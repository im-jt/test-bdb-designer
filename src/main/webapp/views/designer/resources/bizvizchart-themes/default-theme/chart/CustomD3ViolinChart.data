{
	"CustomChart": {
		"Properties": {
			"Object": {
				"componentType": "custom_chart",
				"objectType": "chart",
				"subElement": "Chart",
				"themeType": "default-theme",
				"globalVariableKeyAttribute": "Globalkey",
				"isDataSetAvailable": "true",
				"enableScript": "true",
				"referenceID": "",
				"isValueFieldsAvailable": "false",
				"showContextMenu": "false",
				"shortName": "custom",
				"showLocked": "false",
				"objectName": "Custom_1",
				"unShowHidden": "false",
				"groupings": "",
				"percentheight": "320",
				"width": "643",
				"x": "20",
				"height": "536",
				"y": "10",
				"initialVisibility": "true",
				"percentwidth": "450",
				"objectID": "Obj.784241DDN8439NB566NF0C7N7BBDD306B14F",
				"Chart": {
					"id": "Obj.784241DDN8439NB566NF0C7N7BBDD306B14F",
					"Type": "CustomChart",
					"showGradient": "false",
					"bgGradients": "#f8f8f8",
					"bgAlpha": "1",
					"bgGradientRotation": "0",
					"exportToExcel": "true",
					"exportToCSV": "true",
					"exportToJPEG": "true",
					"exportToPNG": "true",
					"exportToPDF": "true",
					"exportToPPT": "true",
					"exportToPrint": "true",
					"showScreenShotButton": "true",
					"screenShotMode": "ppt",
					"pptServiceURL": "http://bdbizviz.com/PPT/Parser",
					"pptHeading": "Heading",
					"pptSubHeading": "Sub Heading",
					"subHeading": "Sub Heading",
					"scrnShotFileName": "exportDashboard",
					"showTooltip": "true",
					"tooltipBackgroundColor": "#FFFFFF",
					"tooltipBackgroundTransparency": "1",
					"tooltipBorderColor": "#E0DFDF",
					"customTooltipWidth": "auto",
					"tooltipPrecision": "default",
					"tooltipHighlighter": "true",
					"showMaximizeButton": "true",
					"showExcelDownload": "true",
					"showSubTitle": "false",
					"showTitle": "true",
					"GradientColor": "#F5F5F5,#F5F5F5",
					"showLegends": "false",
					"hideLegendOnStart": "true",
					"legendDirection": "horizontal",
					"legendfontSize": "10",
					"legendtextDecoration": "none",
					"legendfontStyle": "normal",
					"legendfontColor": "#000000",
					"legendfontFamily": "BizvizFont",
					"legendfontWeight": "normal",
					"legendbackgroundColor": "#ffffff",
					"legendbackgroundTransparency": "1",
					"showcheckboxwithlegend": "false",
					"showCheckboxSeprate": "false",
					"showBorder": "true",
					"borderColor": "#cccccc",
					"borderRadius": "5",
					"borderThickness": "1",
					"showShadow": "false",
					"shadowColor": "#cccccc",
					"shadowOpacity": "0.3",
					"markerColor": "#F5F5F5",
					"markerTransparency": "0.3",
					"showMarkerLine": true,
					"showVerticalMarkerLine": "false",
					"autoaxisSetup": "true",
					"minimumAxisValue": "-20",
					"maximumAxisValue": "110",
					"baseZero": "true",
					"zeroMarkerLine": "false",
					"zeroMarkerColor": "#be4a47",
					"FixedLabel": "false",
					"Formater": "Currency",
					"Unit": "none",
					"SignPosition": "prefix",
					"Precision": "default",
					"NumberFormatter": "none",
					"SecondaryFormater": "Number",
					"SecondaryUnit": "none",
					"Globalkey": "",
					"enableColorFromDrill": "false",
					"ChartType": "clustered",
					"ChartBase": "plane",
					"barWidth": "70",
							"JSPaths": [{
									"name": "d3",
									"src": "//d3js.org/d3.v3.min.js"
								}, {
									"name": "jquery",
									"src": "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"
								}
							],
							"CSSPaths": [],
							"JSContent": "function makeDistroChart(dataset, xGroup, yValue) {\n\t/*\n\t * dataset = the csv file\n\t * xGroup = the name of the column to group by\n\t * yValue = the column to use as the values for the chart\n\t *\n\t * */\n\n\tvar chart = {};\n\n\tvar colorFunct = d3.scale.category10(); //function () {return 'lightgrey';};\n\n\tfunction formatAsFloat(d) {\n\t\tif (d % 1 !== 0) {\n\t\t\treturn d3.format(\".2f\")(d);\n\t\t} else {\n\t\t\treturn d3.format(\".0f\")(d);\n\t\t}\n\n\t}\n\n\tfunction logFormatNumber(d) {\n\t\tvar x = Math.log(d) / Math.log(10) + 1e-6;\n\t\treturn Math.abs(x - Math.floor(x)) < 0.6 ? formatAsFloat(d) : \"\";\n\t}\n\n\tchart.yFormatter = formatAsFloat;\n\n\tchart.data = dataset;\n\n\t//Data management\n\tchart.xGroup = xGroup;\n\tchart.yValue = yValue;\n\tchart.groupObjs = {}; //The data organized by grouping and sorted as well as any metadata for the groups\n\tchart.objs = {\n\t\tmainDiv: null,\n\t\tchartDiv: null,\n\t\tg: null,\n\t\txAxis: null,\n\t\tyAxis: null\n\t};\n\n\tfunction updateColorFunction(colorOptions) {\n\t\t/*\n\t\t * Takes either a list of colors, a function or an object with the mapping already in place\n\t\t * */\n\t\tif (typeof colorOptions == 'function') {\n\t\t\treturn colorOptions\n\t\t} else if (Array.isArray(colorOptions)) {\n\t\t\t//  If an array is provided, map it to the domain\n\t\t\tvar colorMap = {},\n\t\t\tcColor = 0;\n\t\t\tfor (var cName in chart.groupObjs) {\n\t\t\t\tcolorMap[cName] = colorOptions[cColor];\n\t\t\t\tcColor = (cColor + 1) % colorOptions.length;\n\t\t\t}\n\t\t\treturn function (group) {\n\t\t\t\treturn colorMap[group];\n\t\t\t}\n\t\t} else if (typeof colorOptions == 'object') {\n\t\t\t// if an object is provided, assume it maps to  the colors\n\t\t\treturn function (group) {\n\t\t\t\treturn colorOptions[group];\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction updateGroupWidth(boxWidth) {\n\t\t// Takes the boxWidth size (as percentage of possible width) and returns the actual pixel width to use\n\t\tvar boxSize = {\n\t\t\tleft: null,\n\t\t\tright: null,\n\t\t\tmiddle: null\n\t\t};\n\t\tvar width = chart.xScale.rangeBand() * (boxWidth / 100);\n\t\tvar padding = (chart.xScale.rangeBand() - width) / 2;\n\t\tboxSize.middle = chart.xScale.rangeBand() / 2;\n\t\tboxSize.left = padding;\n\t\tboxSize.right = boxSize.left + width;\n\t\treturn boxSize;\n\t}\n\n\tfunction groupClick(name, metrics) {\nreturn function () {\n         metrics.group= name;\n\t\tbizvizchart.eventCallBack({\n\t\t\ttype: 'click'\n\t\t}, metrics, 0);\n}\n}\n\n\tfunction tooltipHover(name, metrics) {\n\t\tvar tooltipString = \"Group: \" + name;\n\t\ttooltipString += \"<br\\>Max: \" + formatAsFloat(metrics.max, 0.1);\n\t\ttooltipString += \"<br\\>Q3: \" + formatAsFloat(metrics.quartile3);\n\t\ttooltipString += \"<br\\>Median: \" + formatAsFloat(metrics.median);\n\t\ttooltipString += \"<br\\>Q1: \" + formatAsFloat(metrics.quartile1);\n\t\ttooltipString += \"<br\\>Min: \" + formatAsFloat(metrics.min);\n\n\t\treturn function () {\n\t\t\tchart.objs.tooltip.transition().duration(200).style(\"opacity\", 0.9);\n\t\t\tchart.objs.tooltip.html(tooltipString)\n\t\t};\n\t}\n\n\tfunction prepareData() {\n\t\t/*\n\t\t * Takes the dataset that is an array of objects and groups the yValues by xGroups and then sorts it\n\t\t * Returns the groupObj\n\t\t * */\n\n\t\tfunction calcMetrics(values) {\n\n\t\t\tvar metrics = { //These are the original nonâ€“scaled values\n\t\t\t\tmax: null,\n\t\t\t\tupperOuterFence: null,\n\t\t\t\tupperInnerFence: null,\n\t\t\t\tquartile3: null,\n\t\t\t\tmedian: null,\n\t\t\t\tmean: null,\n\t\t\t\tiqr: null,\n\t\t\t\tquartile1: null,\n\t\t\t\tlowerInnerFence: null,\n\t\t\t\tlowerOuterFence: null,\n\t\t\t\tmin: null\n\t\t\t};\n\n\t\t\tmetrics.min = d3.min(values);\n\t\t\tmetrics.quartile1 = d3.quantile(values, 0.25);\n\t\t\tmetrics.median = d3.median(values);\n\t\t\tmetrics.mean = d3.mean(values);\n\t\t\tmetrics.quartile3 = d3.quantile(values, 0.75);\n\t\t\tmetrics.max = d3.max(values);\n\t\t\tmetrics.iqr = metrics.quartile3 - metrics.quartile1;\n\n\t\t\t//The inner fences are the closest value to the IQR without going past it (assumes sorted lists)\n\t\t\tvar LIF = metrics.quartile1 - (1.5 * metrics.iqr);\n\t\t\tvar UIF = metrics.quartile3 + (1.5 * metrics.iqr);\n\t\t\tfor (var i = 0; i <= values.length; i++) {\n\t\t\t\tif (values[i] < LIF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!metrics.lowerInnerFence && values[i] >= LIF) {\n\t\t\t\t\tmetrics.lowerInnerFence = values[i];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (values[i] > UIF) {\n\t\t\t\t\tmetrics.upperInnerFence = values[i - 1];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmetrics.lowerOuterFence = metrics.quartile1 - (3 * metrics.iqr);\n\t\t\tmetrics.upperOuterFence = metrics.quartile3 + (3 * metrics.iqr);\n\t\t\tif (!metrics.lowerInnerFence) {\n\t\t\t\tmetrics.lowerInnerFence = metrics.min;\n\t\t\t}\n\t\t\tif (!metrics.upperInnerFence) {\n\t\t\t\tmetrics.upperInnerFence = metrics.max;\n\t\t\t}\n\t\t\treturn metrics\n\t\t}\n\n\t\tvar current_x = null;\n\t\tvar current_y = null;\n\t\tvar current_row;\n\n\t\t//Group the values\n\t\tfor (current_row = 0; current_row < chart.data.length; current_row++) {\n\t\t\tcurrent_x = chart.data[current_row][chart.xGroup];\n\t\t\tcurrent_y = chart.data[current_row][chart.yValue];\n\t\t\tif (chart.groupObjs.hasOwnProperty(current_x)) {\n\t\t\t\tchart.groupObjs[current_x].values.push(current_y);\n\t\t\t} else {\n\t\t\t\tchart.groupObjs[current_x] = {};\n\t\t\t\tchart.groupObjs[current_x].values = [current_y];\n\t\t\t}\n\t\t}\n\n\t\tvar cName;\n\t\t// Sort them\n\t\tfor (cName in chart.groupObjs) {\n\t\t\tchart.groupObjs[cName].values.sort(d3.ascending);\n\t\t\tchart.groupObjs[cName].metrics = {};\n\t\t\tchart.groupObjs[cName].metrics = calcMetrics(chart.groupObjs[cName].values);\n\n\t\t}\n\t}\n\n\tprepareData();\n\n\tchart.update = function () {\n\n\t\tif (!chart.objs.g) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Update chart size\n\t\tchart.width = parseInt(chart.objs.chartDiv.style(\"width\"), 10) - (chart.margin.left + chart.margin.right);\n\t\tchart.height = parseInt(chart.objs.chartDiv.style(\"height\"), 10) - (chart.margin.top + chart.margin.bottom);\n\t\tchart.xScale.rangeBands([0, chart.width]);\n\t\tchart.yScale.range([chart.height, 0]);\n\n\t\t//Update axes\n\t\tchart.objs.g.select('.x.axis').attr(\"transform\", \"translate(0,\" + chart.height + \")\").call(chart.objs.xAxis)\n\t\t.selectAll(\"text\")\n\t\t.attr(\"y\", 5)\n\t\t.attr(\"x\", -5)\n\t\t.attr(\"transform\", \"rotate(-45)\")\n\t\t.style(\"text-anchor\", \"end\");\n\t\tchart.objs.g.select('.x.axis .label').attr(\"x\", chart.width / 2);\n\t\tchart.objs.g.select('.y.axis').call(chart.objs.yAxis.innerTickSize(-chart.width));\n\t\tchart.objs.g.select('.y.axis .label').attr(\"x\", -chart.height / 2);\n\t\tchart.objs.chartDiv.select('svg').attr(\"width\", chart.width + (chart.margin.left + chart.margin.right)).attr(\"height\", chart.height + (chart.margin.top + chart.margin.bottom));\n\n\t\treturn chart;\n\t};\n\n\tchart.bind = function (selector, chartOptions) {\n\t\t/*\n\t\t * Setup chart and connect it to the correct div\n\t\t *\n\t\t * Selector is the id to attach the chart to\n\t\t * chartOptions = list of chart options\n\t\t *   scale = linear (vs log)\n\t\t *   chartSize\n\t\t *   â€“ chart_width = 800\n\t\t *   â€“ chart_height = 400\n\t\t *   margin = {top: 15, right: 60, bottom: 30, left: 50};\n\t\t *   constrainExtremes True/False, if true max is then the max of the lower fences\n\t\t *   axisLabels = Labels for the chart\n\t\t *\n\t\t */\n\n\t\t//Get base data\n\t\tfunction getBaseData() {\n\t\t\tif (chartOptions && chartOptions.margin) {\n\t\t\t\tchart.margin = margin;\n\t\t\t} else {\n\t\t\t\tchart.margin = {\n\t\t\t\t\ttop: 15,\n\t\t\t\t\tright: 40,\n\t\t\t\t\tbottom: 35,\n\t\t\t\t\tleft: 50\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (chartOptions && chartOptions.chartSize) {\n\t\t\t\tchart.divWidth = chartOptions.chartSize.width;\n\t\t\t\tchart.divHeight = chartOptions.chartSize.height;\n\t\t\t} else {\n\t\t\t\tchart.divWidth = 800;\n\t\t\t\tchart.divHeight = 400;\n\t\t\t}\n\n\t\t\tchart.width = chart.divWidth - chart.margin.left - chart.margin.right;\n\t\t\tchart.height = chart.divHeight - chart.margin.top - chart.margin.bottom;\n\n\t\t\tif (chartOptions && chartOptions.axisLabels) {\n\n\t\t\t\tchart.xAxisLable = chartOptions.axisLabels.xAxis;\n\t\t\t\tchart.yAxisLable = chartOptions.axisLabels.yAxis;\n\t\t\t} else {\n\t\t\t\tchart.xAxisLable = xGroup;\n\t\t\t\tchart.yAxisLable = yValue;\n\t\t\t}\n\t\t\tif (chartOptions && chartOptions.scale === 'log') {\n\t\t\t\tchart.yScale = d3.scale.log();\n\t\t\t\tchart.yFormatter = logFormatNumber;\n\t\t\t} else {\n\t\t\t\tchart.yScale = d3.scale.linear();\n\t\t\t}\n\n\t\t\tif (chartOptions && chartOptions.constrainExtremes === true) {\n\t\t\t\tvar fences = [];\n\t\t\t\tfor (var cName in chart.groupObjs) {\n\t\t\t\t\tfences.push(chart.groupObjs[cName].metrics.lowerInnerFence);\n\t\t\t\t\tfences.push(chart.groupObjs[cName].metrics.upperInnerFence);\n\t\t\t\t}\n\t\t\t\tchart.range = d3.extent(fences);\n\n\t\t\t} else {\n\t\t\t\tchart.range = d3.extent(chart.data, function (d) {\n\t\t\t\t\t\treturn d[chart.yValue];\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Take the options colors argument and update the colors function\n\t\t\tif (chartOptions && chartOptions.colors) {\n\t\t\t\tcolorFunct = updateColorFunction(chartOptions.colors);\n\t\t\t}\n\n\t\t\tchart.yScale.range([chart.height, 0]).domain(chart.range).clamp(true);\n\t\t\t// Get x range\n\t\t\tchart.xScale = d3.scale.ordinal().domain(Object.keys(chart.groupObjs)).rangeBands([0, chart.width]);\n\t\t\t//Build Axes\n\t\t\tchart.objs.yAxis = d3.svg.axis()\n\t\t\t\t.scale(chart.yScale)\n\t\t\t\t.orient(\"left\")\n\t\t\t\t.tickFormat(chart.yFormatter)\n\t\t\t\t.outerTickSize(0)\n\t\t\t\t.innerTickSize(-chart.width + (chart.margin.right + chart.margin.left));\n\t\t\tchart.objs.xAxis = d3.svg.axis().scale(chart.xScale).orient(\"bottom\").tickSize(5);\n\n\t\t}\n\n\t\tgetBaseData();\n\n\t\tchart.objs.mainDiv = d3.select(selector)\n\t\t\t.style(\"max-width\", chart.divWidth + \"px\");\n\t\t// Add all the divs to make it centered and responsive\n\t\tchart.objs.mainDiv.append(\"div\")\n\t\t.attr(\"class\", \"inner-wrapper\")\n\t\t.style(\"padding-bottom\", (chart.divHeight / chart.divWidth) * 100 + \"%\")\n\t\t.append(\"div\").attr(\"class\", \"outer-box\")\n\t\t.append(\"div\").attr(\"class\", \"inner-box\");\n\t\t// Capture the inner div for the chart (where the chart actually is)\n\t\tchart.chartSelector = selector + \" .inner-box\";\n\t\tchart.objs.chartDiv = d3.select(chart.chartSelector);\n\t\td3.select(window).on('resize.' + chart.chartSelector, chart.update);\n\n\t\t// Create the svg\n\t\tchart.objs.g = chart.objs.chartDiv.append(\"svg\")\n\t\t\t.attr(\"class\", \"chart-area\")\n\t\t\t.attr(\"width\", chart.width + (chart.margin.left + chart.margin.right))\n\t\t\t.attr(\"height\", chart.height + (chart.margin.top + chart.margin.bottom))\n\t\t\t.append(\"g\")\n\t\t\t.attr(\"transform\", \"translate(\" + chart.margin.left + \",\" + chart.margin.top + \")\");\n\n\t\tchart.objs.axes = chart.objs.g.append(\"g\").attr(\"class\", \"axis\");\n\t\t// Show axis\n\t\tchart.objs.axes.append(\"g\")\n\t\t.attr(\"class\", \"x axis\")\n\t\t.attr(\"transform\", \"translate(0,\" + chart.height + \")\")\n\t\t.call(chart.objs.xAxis);\n\n\t\tchart.objs.axes.append(\"g\")\n\t\t.attr(\"class\", \"y axis\")\n\t\t.call(chart.objs.yAxis)\n\t\t.append(\"text\")\n\t\t.attr(\"class\", \"label\")\n\t\t.attr(\"transform\", \"rotate(-90)\")\n\t\t.attr(\"y\", -42)\n\t\t.attr(\"x\", -chart.height / 2)\n\t\t.attr(\"dy\", \".71em\")\n\t\t.style(\"text-anchor\", \"middle\")\n\t\t.text(chart.yAxisLable);\n\n\t\t//Add the tooltip div\n\t\tchart.objs.tooltip = chart.objs.mainDiv.append('div').attr('class', 'tooltip');\n\t\t// Add hover tooltip\n\t\tfor (var cName in chart.groupObjs) {\n\t\t\t//Add mouseover\n\t\t\tchart.groupObjs[cName].g = chart.objs.g.append(\"g\").attr(\"class\", \"group\");\n\t\t\tchart.groupObjs[cName].g.on(\"mouseover\", function () {\n\t\t\t\tchart.objs.tooltip.style(\"display\", 'block').style(\"left\", (d3.event.pageX + 10) + \"px\").style(\"top\", (d3.event.pageY + 10) + \"px\");\n\t\t\t}).on(\"mouseout\", function () {\n\t\t\t\tchart.objs.tooltip.style(\"display\", \"none\");\n\t\t\t}).on(\"click\", groupClick(cName, chart.groupObjs[cName].metrics)).on(\"mousemove\", tooltipHover(cName, chart.groupObjs[cName].metrics));\n\t\t}\n\t\tchart.update();\n\n\t\treturn chart;\n\t};\n\n\tchart.renderViolinPlot = function (chartOptions) {\n\t\t/*\n\t\t * Options\n\t\t *  - showArea True/False (default True)\n\t\t *  - showLine True/False (default True)\n\t\t *  - resolution, number of bins\n\t\t *  - boxWidth (wider or not)\n\t\t */\n\t\tchart.violinPlots = {};\n\t\tchart.violinPlots.plots = {};\n\t\tchart.violinPlots.violinOptions = chartOptions;\n\t\tvar vOpts = chart.violinPlots.violinOptions;\n\n\t\t// Violin Calculations\n\t\tchart.violinPlots.calculateNumBins = function (cGroup) {\n\t\t\tvar iqr;\n\t\t\tif (chart.boxPlots) {\n\t\t\t\tiqr = chart.groupObjs[cGroup].metrics.iqr\n\t\t\t} else {\n\t\t\t\tvar quartile1 = d3.quantile(chart.groupObjs[cGroup].values, 0.25);\n\t\t\t\tvar quartile3 = d3.quantile(chart.groupObjs[cGroup].values, 0.75);\n\t\t\t\tiqr = quartile3 - quartile1;\n\t\t\t}\n\t\t\treturn Math.max(Math.round(2 * (iqr / Math.pow(chart.groupObjs[cGroup].values.length, 1 / 3))), 50)\n\t\t};\n\n\t\tfunction prepareViolin() {\n\t\t\t/*\n\t\t\t * Takes the structured data and calculates the box plot numbers\n\t\t\t * */\n\n\t\t\tvar cName;\n\t\t\tfor (cName in chart.groupObjs) {\n\t\t\t\tchart.groupObjs[cName].violin = {};\n\t\t\t\tchart.groupObjs[cName].violin.objs = {};\n\t\t\t\tchart.groupObjs[cName].violin.histogramFunct = d3.layout.histogram().frequency(1);\n\t\t\t}\n\n\t\t}\n\n\t\tprepareViolin();\n\n\t\tchart.violinPlots.change = function (updateOptions) {\n\t\t\t/*\n\t\t\t * Same options as on renderViolin\n\t\t\t */\n\t\t\tif (updateOptions) {\n\t\t\t\tfor (var key in updateOptions) {\n\t\t\t\t\tvOpts[key] = updateOptions[key]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmapObjects(true);\n\t\t\tchart.violinPlots.update()\n\t\t};\n\n\t\tchart.violinPlots.update = function () {\n\t\t\tvar cName,\n\t\t\tcViolinPlot;\n\n\t\t\tfor (cName in chart.groupObjs) {\n\t\t\t\tcViolinPlot = chart.groupObjs[cName].violin;\n\n\t\t\t\tif (vOpts && vOpts.resolution) {\n\t\t\t\t\tcViolinPlot.histogramFunct.bins(vOpts.resolution);\n\t\t\t\t} else {\n\t\t\t\t\tcViolinPlot.histogramFunct.bins(chart.violinPlots.calculateNumBins(cName));\n\t\t\t\t}\n\t\t\t\tcViolinPlot.histogramData = cViolinPlot.histogramFunct(chart.groupObjs[cName].values);\n\n\t\t\t\t// Get the box size\n\t\t\t\tvar groupWidth = {\n\t\t\t\t\tleft: null,\n\t\t\t\t\tright: null,\n\t\t\t\t\tmiddle: null\n\t\t\t\t};\n\t\t\t\tif (vOpts && vOpts.violinWidth) {\n\t\t\t\t\tgroupWidth = updateGroupWidth(vOpts.violinWidth)\n\t\t\t\t} else {\n\t\t\t\t\tgroupWidth = updateGroupWidth(100)\n\t\t\t\t}\n\n\t\t\t\tvar leftBound = chart.xScale(cName) + groupWidth.left;\n\t\t\t\tvar rightBound = chart.xScale(cName) + groupWidth.right;\n\t\t\t\tvar width = (rightBound - leftBound) / 2;\n\n\t\t\t\tvar xV = chart.yScale.copy();\n\t\t\t\tvar yV = d3.scale.linear()\n\t\t\t\t\t.range([width, 0])\n\t\t\t\t\t.domain([0, Math.max(chart.range[1], d3.max(cViolinPlot.histogramData, function (d) {\n\t\t\t\t\t\t\t\t\treturn d.y;\n\t\t\t\t\t\t\t\t}))])\n\t\t\t\t\t.clamp(true);\n\n\t\t\t\tvar area = d3.svg.area()\n\t\t\t\t\t.interpolate('basis')\n\t\t\t\t\t.x(function (d) {\n\t\t\t\t\t\treturn xV(d.x);\n\t\t\t\t\t})\n\t\t\t\t\t.y0(width)\n\t\t\t\t\t.y1(function (d) {\n\t\t\t\t\t\treturn yV(d.y);\n\t\t\t\t\t});\n\n\t\t\t\tvar line = d3.svg.line()\n\t\t\t\t\t.interpolate('basis')\n\t\t\t\t\t.x(function (d) {\n\t\t\t\t\t\treturn xV(d.x);\n\t\t\t\t\t})\n\t\t\t\t\t.y(function (d) {\n\t\t\t\t\t\treturn yV(d.y);\n\t\t\t\t\t});\n\n\t\t\t\tif (cViolinPlot.objs.left.area) {\n\t\t\t\t\tcViolinPlot.objs.left.area\n\t\t\t\t\t.datum(cViolinPlot.histogramData)\n\t\t\t\t\t.attr(\"d\", area);\n\t\t\t\t}\n\n\t\t\t\tif (cViolinPlot.objs.left.line) {\n\t\t\t\t\tcViolinPlot.objs.left.line\n\t\t\t\t\t.datum(cViolinPlot.histogramData)\n\t\t\t\t\t.attr(\"d\", line);\n\t\t\t\t}\n\n\t\t\t\tif (cViolinPlot.objs.right.area) {\n\t\t\t\t\tcViolinPlot.objs.right.area\n\t\t\t\t\t.datum(cViolinPlot.histogramData)\n\t\t\t\t\t.attr(\"d\", area);\n\t\t\t\t}\n\t\t\t\tif (cViolinPlot.objs.right.line) {\n\t\t\t\t\tcViolinPlot.objs.right.line\n\t\t\t\t\t.datum(cViolinPlot.histogramData)\n\t\t\t\t\t.attr(\"d\", line);\n\t\t\t\t}\n\n\t\t\t\tcViolinPlot.objs.left.g.attr(\"transform\", \"rotate(90,0,0)   translate(0,-\" + leftBound + \")  scale(1,-1)\");\n\t\t\t\tcViolinPlot.objs.right.g.attr(\"transform\", \"rotate(90,0,0)  translate(0,-\" + rightBound + \")\");\n\t\t\t}\n\t\t};\n\n\t\tfunction mapObjects(clear) {\n\n\t\t\tvar cName,\n\t\t\tcViolinPlot;\n\n\t\t\tif (vOpts && vOpts.colors) {\n\t\t\t\tchart.violinPlots.color = updateColorFunction(vOpts.colors);\n\t\t\t} else {\n\t\t\t\tchart.violinPlots.color = colorFunct\n\t\t\t}\n\n\t\t\tfor (cName in chart.groupObjs) {\n\t\t\t\tcViolinPlot = chart.groupObjs[cName].violin;\n\n\t\t\t\tif (clear) {\n\t\t\t\t\tcViolinPlot.objs.g.remove()\n\t\t\t\t}\n\n\t\t\t\tcViolinPlot.objs.g = chart.groupObjs[cName].g.append(\"g\").attr(\"class\", \"violin-plot\");\n\t\t\t\tcViolinPlot.objs.left = {\n\t\t\t\t\tarea: null,\n\t\t\t\t\tline: null,\n\t\t\t\t\tg: null\n\t\t\t\t};\n\t\t\t\tcViolinPlot.objs.right = {\n\t\t\t\t\tarea: null,\n\t\t\t\t\tline: null,\n\t\t\t\t\tg: null\n\t\t\t\t};\n\n\t\t\t\tcViolinPlot.objs.left.g = cViolinPlot.objs.g.append(\"g\");\n\t\t\t\tcViolinPlot.objs.right.g = cViolinPlot.objs.g.append(\"g\");\n\n\t\t\t\tif (!vOpts || (vOpts && vOpts.showArea !== false)) {\n\t\t\t\t\tcViolinPlot.objs.left.area = cViolinPlot.objs.left.g.append(\"path\")\n\t\t\t\t\t\t.attr(\"class\", \"area\")\n\t\t\t\t\t\t.style(\"fill\", chart.violinPlots.color(cName));\n\t\t\t\t\tcViolinPlot.objs.right.area = cViolinPlot.objs.right.g.append(\"path\")\n\t\t\t\t\t\t.attr(\"class\", \"area\")\n\t\t\t\t\t\t.style(\"fill\", chart.violinPlots.color(cName));\n\t\t\t\t}\n\n\t\t\t\tif (!vOpts || (vOpts && vOpts.showLine !== false)) {\n\t\t\t\t\tcViolinPlot.objs.left.line = cViolinPlot.objs.left.g.append(\"path\")\n\t\t\t\t\t\t.attr(\"class\", \"line\")\n\t\t\t\t\t\t.attr(\"fill\", 'none')\n\t\t\t\t\t\t.style(\"stroke\", chart.violinPlots.color(cName));\n\t\t\t\t\tcViolinPlot.objs.right.line = cViolinPlot.objs.right.g.append(\"path\")\n\t\t\t\t\t\t.attr(\"class\", \"line\")\n\t\t\t\t\t\t.attr(\"fill\", 'none')\n\t\t\t\t\t\t.style(\"stroke\", chart.violinPlots.color(cName));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tmapObjects();\n\n\t\td3.select(window).on('resize.' + chart.chartSelector + '.violinPlot', chart.violinPlots.update);\n\t\t//Update the divs with the proper values\n\t\tchart.violinPlots.update();\n\t\treturn chart.violinPlots;\n\t};\n\n\tchart.renderBoxPlot = function (chartOptions) {\n\t\tchart.boxPlots = {};\n\t\tchart.boxPlots.chartOptions = chartOptions;\n\t\tvar bOpts = chart.boxPlots.chartOptions;\n\n\t\t/*\n\t\t * options:\n\t\t *   showOutliers: True/False (default True) - this shouldn't  affect the min/max\n\t\t *   showWhiskers: True/False (default True)\n\t\t *   whiskersRatio: (default standard=iqr*1.5), other options, minmax, (future?: std)\n\t\t *   showBox: True/False (default True)\n\t\t *   showMedian: True/False  (default True)\n\t\t *   showMean: True/False (default False)\n\t\t *   outlierScatter: True/False (default False) (not fully implimented)\n\t\t *   boxWidth (not implimented) what percent of the bin should the box take up\n\t\t */\n\n\t\t//Create boxPlots\n\t\tfor (var cName in chart.groupObjs) {\n\t\t\tchart.groupObjs[cName].boxPlot = {};\n\t\t\tchart.groupObjs[cName].boxPlot.objs = {};\n\t\t}\n\t\tfunction calcOutliers(obj, values, metrics) {\n\t\t\t/*\n\t\t\t * Create lists of the outliers for each content group\n\t\t\t */\n\n\t\t\tvar cExtremes = [];\n\t\t\tvar cOutliers = [];\n\t\t\tvar cOut,\n\t\t\tidx;\n\t\t\tfor (idx = 0; idx <= values.length; idx++) {\n\t\t\t\tcOut = {\n\t\t\t\t\tvalue: values[idx]\n\t\t\t\t};\n\n\t\t\t\tif (cOut.value < metrics.lowerInnerFence) {\n\t\t\t\t\tif (cOut.value < metrics.lowerOuterFence) {\n\t\t\t\t\t\tcExtremes.push(cOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcOutliers.push(cOut);\n\t\t\t\t\t}\n\t\t\t\t} else if (cOut.value > metrics.upperInnerFence) {\n\t\t\t\t\tif (cOut.value > metrics.upperOuterFence) {\n\t\t\t\t\t\tcExtremes.push(cOut);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcOutliers.push(cOut);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tobj.outliers = cOutliers;\n\t\t\tobj.extremes = cExtremes;\n\t\t}\n\n\t\tfunction calcAllOutliers() {\n\t\t\tif (!bOpts || (bOpts && bOpts.showOutliers !== false)) {\n\t\t\t\tfor (var cName in chart.groupObjs) {\n\t\t\t\t\tcalcOutliers(chart.groupObjs[cName].boxPlot.objs, chart.groupObjs[cName].values, chart.groupObjs[cName].metrics);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcalcAllOutliers();\n\n\t\tchart.boxPlots.change = function (updateOptions) {\n\t\t\tif (updateOptions) {\n\t\t\t\tfor (var key in updateOptions) {\n\t\t\t\t\tbOpts[key] = updateOptions[key]\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapObjects(true);\n\t\t\tchart.boxPlots.update()\n\t\t};\n\n\t\tchart.boxPlots.update = function () {\n\t\t\tvar cName,\n\t\t\tcBoxPlot;\n\n\t\t\tfor (cName in chart.groupObjs) {\n\t\t\t\tcBoxPlot = chart.groupObjs[cName].boxPlot;\n\n\t\t\t\t// Get the box size\n\t\t\t\tvar groupWidth = {\n\t\t\t\t\tleft: null,\n\t\t\t\t\tright: null,\n\t\t\t\t\tmiddle: null\n\t\t\t\t};\n\t\t\t\tif (bOpts && bOpts.boxWidth) {\n\t\t\t\t\tgroupWidth = updateGroupWidth(bOpts.boxWidth)\n\t\t\t\t} else {\n\t\t\t\t\tgroupWidth = updateGroupWidth(30)\n\t\t\t\t}\n\t\t\t\tvar leftBound = chart.xScale(cName) + groupWidth.left;\n\t\t\t\tvar rightBound = chart.xScale(cName) + groupWidth.right;\n\t\t\t\tvar middle = chart.xScale(cName) + groupWidth.middle;\n\n\t\t\t\tvar sMetrics = {}; //temp var for scaled (plottable) metric values\n\t\t\t\tfor (var attr in chart.groupObjs[cName].metrics) {\n\t\t\t\t\tsMetrics[attr] = null;\n\t\t\t\t\tsMetrics[attr] = chart.yScale(chart.groupObjs[cName].metrics[attr]);\n\t\t\t\t}\n\n\t\t\t\t//// Box\n\t\t\t\tif (cBoxPlot.objs.box) {\n\t\t\t\t\tcBoxPlot.objs.box\n\t\t\t\t\t.attr(\"x\", leftBound)\n\t\t\t\t\t.attr('width', rightBound - leftBound)\n\t\t\t\t\t.attr(\"y\", sMetrics.quartile3)\n\t\t\t\t\t.attr(\"rx\", 1)\n\t\t\t\t\t.attr(\"ry\", 1)\n\t\t\t\t\t.attr(\"height\", -sMetrics.quartile3 + sMetrics.quartile1)\n\t\t\t\t}\n\t\t\t\t//// Lines\n\t\t\t\tif (cBoxPlot.objs.upperWhisker) {\n\t\t\t\t\tcBoxPlot.objs.upperWhisker.fence\n\t\t\t\t\t.attr(\"x1\", leftBound)\n\t\t\t\t\t.attr(\"x2\", rightBound)\n\t\t\t\t\t.attr('y1', sMetrics.upperInnerFence)\n\t\t\t\t\t.attr(\"y2\", sMetrics.upperInnerFence);\n\t\t\t\t\tcBoxPlot.objs.upperWhisker.line\n\t\t\t\t\t.attr(\"x1\", middle)\n\t\t\t\t\t.attr(\"x2\", middle)\n\t\t\t\t\t.attr('y1', sMetrics.quartile3)\n\t\t\t\t\t.attr(\"y2\", sMetrics.upperInnerFence);\n\n\t\t\t\t\tcBoxPlot.objs.lowerWhisker.fence\n\t\t\t\t\t.attr(\"x1\", leftBound)\n\t\t\t\t\t.attr(\"x2\", rightBound)\n\t\t\t\t\t.attr('y1', sMetrics.lowerInnerFence)\n\t\t\t\t\t.attr(\"y2\", sMetrics.lowerInnerFence);\n\t\t\t\t\tcBoxPlot.objs.lowerWhisker.line\n\t\t\t\t\t.attr(\"x1\", middle)\n\t\t\t\t\t.attr(\"x2\", middle)\n\t\t\t\t\t.attr('y1', sMetrics.quartile1)\n\t\t\t\t\t.attr(\"y2\", sMetrics.lowerInnerFence);\n\t\t\t\t}\n\t\t\t\t//// Median\n\t\t\t\tif (cBoxPlot.objs.median) {\n\t\t\t\t\tcBoxPlot.objs.median.line\n\t\t\t\t\t.attr(\"x1\", leftBound)\n\t\t\t\t\t.attr(\"x2\", rightBound)\n\t\t\t\t\t.attr('y1', sMetrics.median)\n\t\t\t\t\t.attr(\"y2\", sMetrics.median);\n\t\t\t\t\tcBoxPlot.objs.median.circle\n\t\t\t\t\t.attr(\"cx\", middle)\n\t\t\t\t\t.attr(\"cy\", sMetrics.median)\n\t\t\t\t}\n\n\t\t\t\t//// Mean\n\t\t\t\tif (cBoxPlot.objs.mean) {\n\t\t\t\t\tcBoxPlot.objs.mean.line\n\t\t\t\t\t.attr(\"x1\", leftBound)\n\t\t\t\t\t.attr(\"x2\", rightBound)\n\t\t\t\t\t.attr('y1', sMetrics.mean)\n\t\t\t\t\t.attr(\"y2\", sMetrics.mean);\n\t\t\t\t\tcBoxPlot.objs.mean.circle\n\t\t\t\t\t.attr(\"cx\", middle)\n\t\t\t\t\t.attr(\"cy\", sMetrics.mean);\n\t\t\t\t}\n\t\t\t\t//// Outliers\n\t\t\t\tvar pt;\n\t\t\t\tif (cBoxPlot.objs.outliers) {\n\t\t\t\t\tfor (pt in cBoxPlot.objs.outliers) {\n\t\t\t\t\t\tcBoxPlot.objs.outliers[pt].point\n\t\t\t\t\t\t.attr(\"cx\", middle /*+scatter()*/)\n\t\t\t\t\t\t.attr(\"cy\", chart.yScale(cBoxPlot.objs.outliers[pt].value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cBoxPlot.objs.extremes) {\n\t\t\t\t\tfor (pt in cBoxPlot.objs.extremes) {\n\t\t\t\t\t\tcBoxPlot.objs.extremes[pt].point\n\t\t\t\t\t\t.attr(\"cx\", middle /*+scatter()*/)\n\t\t\t\t\t\t.attr(\"cy\", chart.yScale(cBoxPlot.objs.extremes[pt].value));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfunction mapObjects(clear) {\n\t\t\t// Map everything to divs\n\t\t\tvar cName,\n\t\t\tcBoxPlot;\n\n\t\t\tif (bOpts && bOpts.colors) {\n\t\t\t\tchart.boxPlots.colorFunct = updateColorFunction(bOpts.colors);\n\t\t\t} else {\n\t\t\t\tchart.boxPlots.colorFunct = colorFunct\n\t\t\t}\n\n\t\t\tfor (cName in chart.groupObjs) {\n\t\t\t\tcBoxPlot = chart.groupObjs[cName].boxPlot;\n\n\t\t\t\tif (clear) {\n\t\t\t\t\tcBoxPlot.objs.g.remove()\n\t\t\t\t}\n\n\t\t\t\tcBoxPlot.objs.g = chart.groupObjs[cName].g.append(\"g\").attr(\"class\", \"box-plot\");\n\n\t\t\t\t//Plot Box (default show)\n\t\t\t\tif (!bOpts || (bOpts && bOpts.showBox !== false)) {\n\t\t\t\t\tcBoxPlot.objs.box = cBoxPlot.objs.g.append(\"rect\")\n\t\t\t\t\t\t.attr(\"class\", \"box\")\n\t\t\t\t\t\t.style(\"fill\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t}\n\n\t\t\t\t//Plot Median (default show)\n\t\t\t\tif (!bOpts || (bOpts && bOpts.showMedian !== false)) {\n\t\t\t\t\tcBoxPlot.objs.median = {\n\t\t\t\t\t\tline: null,\n\t\t\t\t\t\tcircle: null\n\t\t\t\t\t};\n\t\t\t\t\tcBoxPlot.objs.median.line = cBoxPlot.objs.g.append(\"line\")\n\t\t\t\t\t\t.attr(\"class\", \"median\");\n\t\t\t\t\tcBoxPlot.objs.median.circle = cBoxPlot.objs.g.append(\"circle\")\n\t\t\t\t\t\t.attr(\"class\", \"median\")\n\t\t\t\t\t\t.attr('r', 3)\n\t\t\t\t\t\t.style(\"fill\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t}\n\n\t\t\t\t// Plot Mean (default no plot)\n\t\t\t\tif (bOpts && bOpts.showMean) {\n\t\t\t\t\tcBoxPlot.objs.mean = {\n\t\t\t\t\t\tline: null,\n\t\t\t\t\t\tcircle: null\n\t\t\t\t\t};\n\t\t\t\t\tcBoxPlot.objs.mean.line = cBoxPlot.objs.g.append(\"line\")\n\t\t\t\t\t\t.attr(\"class\", \"mean\");\n\t\t\t\t\tcBoxPlot.objs.mean.circle = cBoxPlot.objs.g.append(\"circle\")\n\t\t\t\t\t\t.attr(\"class\", \"mean\")\n\t\t\t\t\t\t.attr('r', 3)\n\t\t\t\t\t\t.style(\"fill\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t}\n\n\t\t\t\t//Plot Whiskers (default show)\n\t\t\t\tif (!bOpts || (bOpts && bOpts.showWhiskers !== false)) {\n\t\t\t\t\tcBoxPlot.objs.upperWhisker = {\n\t\t\t\t\t\tfence: null,\n\t\t\t\t\t\tline: null\n\t\t\t\t\t};\n\t\t\t\t\tcBoxPlot.objs.lowerWhisker = {\n\t\t\t\t\t\tfence: null,\n\t\t\t\t\t\tline: null\n\t\t\t\t\t};\n\t\t\t\t\tcBoxPlot.objs.upperWhisker.fence = cBoxPlot.objs.g.append(\"line\")\n\t\t\t\t\t\t.attr(\"class\", \"upper whisker\")\n\t\t\t\t\t\t.style(\"stroke\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t\tcBoxPlot.objs.upperWhisker.line = cBoxPlot.objs.g.append(\"line\")\n\t\t\t\t\t\t.attr(\"class\", \"upper whisker\")\n\t\t\t\t\t\t.style(\"stroke\", chart.boxPlots.colorFunct(cName));\n\n\t\t\t\t\tcBoxPlot.objs.lowerWhisker.fence = cBoxPlot.objs.g.append(\"line\")\n\t\t\t\t\t\t.attr(\"class\", \"lower whisker\")\n\t\t\t\t\t\t.style(\"stroke\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t\tcBoxPlot.objs.lowerWhisker.line = cBoxPlot.objs.g.append(\"line\")\n\t\t\t\t\t\t.attr(\"class\", \"lower whisker\")\n\t\t\t\t\t\t.style(\"stroke\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t}\n\n\t\t\t\t// Plot outliers (default show)\n\t\t\t\t//var scatter = function() {\n\t\t\t\t//    var range = chartObj.xScale.rangeBand()/3;\n\t\t\t\t//    return Math.floor(Math.random() * range)-range/2;\n\t\t\t\t//}\n\t\t\t\tif (!bOpts || (bOpts && bOpts.showOutliers !== false)) {\n\t\t\t\t\tif (!cBoxPlot.objs.outliers)\n\t\t\t\t\t\tcalcAllOutliers();\n\t\t\t\t\tvar pt;\n\t\t\t\t\tif (cBoxPlot.objs.outliers.length) {\n\t\t\t\t\t\tvar outDiv = cBoxPlot.objs.g.append(\"g\").attr(\"class\", \"boxplot outliers\");\n\t\t\t\t\t\tfor (pt in cBoxPlot.objs.outliers) {\n\t\t\t\t\t\t\tcBoxPlot.objs.outliers[pt].point = outDiv.append(\"circle\")\n\t\t\t\t\t\t\t\t.attr(\"class\", \"outlier\")\n\t\t\t\t\t\t\t\t.attr('r', 2)\n\t\t\t\t\t\t\t\t.style(\"fill\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (cBoxPlot.objs.extremes.length) {\n\t\t\t\t\t\tvar extDiv = cBoxPlot.objs.g.append(\"g\").attr(\"class\", \"boxplot extremes\");\n\t\t\t\t\t\tfor (pt in cBoxPlot.objs.extremes) {\n\t\t\t\t\t\t\tcBoxPlot.objs.extremes[pt].point = extDiv.append(\"circle\")\n\t\t\t\t\t\t\t\t.attr(\"class\", \"extreme\")\n\t\t\t\t\t\t\t\t.attr('r', 2)\n\t\t\t\t\t\t\t\t.style(\"stroke\", chart.boxPlots.colorFunct(cName));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tmapObjects();\n\n\t\td3.select(window).on('resize.' + chart.chartSelector + '.boxPlot', chart.boxPlots.update);\n\t\t//Update the divs with the proper values\n\t\tchart.boxPlots.update();\n\n\t\treturn chart.boxPlots;\n\n\t};\n\n\treturn chart;\n}\n\nvar chart1;\nvar currentColor = 'dark';\nvar currentViolinColor = 'dark';\nfunction drawCustomViolinChart() {\n\n\tvar controlBoxHeight = 120;\n\n\tvar data = bizvizchart.getData();\n\tdata.forEach(function (d) {\n\t\td.value = +d.value;\n\t});\n\n\tchart1 = makeDistroChart(data, 'date', 'value');\n\tchart1.bind(\"#chart-distro1\", {\n\t\tchartSize: {\n\t\t\theight: bizvizchart.getHeight() - controlBoxHeight,\n\t\t\twidth: bizvizchart.getWidth()\n\t\t},\n\t\tconstrainExtremes: false,\n\t\taxisLabels: {\n\t\t\txAxis: 'Years',\n\t\t\tyAxis: 'Values'\n\t\t}\n\t});\n\tchart1.renderViolinPlot({\n\t\tshowArea: true,\n\t\tshowLine: true,\n\t\tviolinWidth: 100,\n\t\tcolors: [\"#86dff9\", \"#08aea8\", \"#f89406\", \"#e0dfdf\", \"#6a3d9a\", \"#33a02c\", \"#e31a1c\"]\n\t});\n\n\tchart1.renderBoxPlot({\n\t\tshowBox: false,\n\t\tshowMean: false,\n\t\tshowMedian: false,\n\t\tshowWhiskers: false,\n\t\tshowOutliers: false,\n\t\tboxWidth: 15\n\t});\n\n}\n\nfunction changeProperties(operation) {\n\tswitch (operation) {\n\tcase \"showBox\":\n\t\tif (chart1.boxPlots.chartOptions.showBox) {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowBox: false\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowBox: true\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"showMean\":\n\t\tif (chart1.boxPlots.chartOptions.showMean) {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowMean: false\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowMean: true\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"showMedian\":\n\t\tif (chart1.boxPlots.chartOptions.showMedian) {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowMedian: false\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowMedian: true\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"showWhiskers\":\n\t\tif (chart1.boxPlots.chartOptions.showWhiskers) {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowWhiskers: false\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowWhiskers: true\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"showOutliers\":\n\t\tif (chart1.boxPlots.chartOptions.showOutliers) {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowOutliers: false\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tshowOutliers: true\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"boxWidth\":\n\t\tif (chart1.boxPlots.chartOptions.boxWidth === 30) {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tboxWidth: 10\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tboxWidth: 30\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"boxColors\":\n\t\tif (currentColor == 'dark') {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tcolors: d3.scale.category10()\n\t\t\t});\n\t\t\tcurrentColor = 'color';\n\t\t} else {\n\t\t\tchart1.boxPlots.change({\n\t\t\t\tcolors: ['#555']\n\t\t\t});\n\t\t\tcurrentColor = 'dark';\n\t\t}\n\t\tbreak;\n\n\tcase \"showArea\":\n\t\tif (chart1.violinPlots.violinOptions.showArea) {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tshowArea: false,\n\t\t\t\tshowLine: false\n\t\t\t});\n\t\t} else {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tshowArea: true,\n\t\t\t\tshowLine: true\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"violinWidth\":\n\t\tif (chart1.violinPlots.violinOptions.violinWidth === 100) {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tviolinWidth: 50\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tviolinWidth: 100\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tcase \"violinColors\":\n\t\tif (currentViolinColor == 'dark') {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tcolors: d3.scale.category10()\n\t\t\t});\n\t\t\tcurrentViolinColor = 'color';\n\t\t} else {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tcolors: ['#555']\n\t\t\t});\n\t\t\tcurrentViolinColor = 'dark';\n\t\t}\n\t\tbreak;\n\tcase \"resolution\":\n\t\tif (chart1.violinPlots.violinOptions.resolution === 75) {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tresolution: null\n\t\t\t})\n\t\t} else {\n\t\t\tchart1.violinPlots.change({\n\t\t\t\tresolution: 75\n\t\t\t})\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}\n\nfunction updateChartControls() {\n\t$(\"#ToggleBox\").attr(\"value\", chart1.boxPlots.chartOptions.showBox);\n\t$(\"#ToggleMean\").attr(\"value\", chart1.boxPlots.chartOptions.showMean);\n\t$(\"#ToggleMedian\").attr(\"value\", chart1.boxPlots.chartOptions.showMedian);\n\t$(\"#ToggleWhiskers\").attr(\"value\", chart1.boxPlots.chartOptions.showWhiskers);\n\t$(\"#ToggleOutliers\").attr(\"value\", chart1.boxPlots.chartOptions.showOutliers);\n\t$(\"#ToggleArea\").attr(\"value\", chart1.violinPlots.violinOptions.showArea);\n}\n\ndrawCustomViolinChart();\nupdateChartControls();",
							"CSSContent": "body{ margin:0px; padding:0px; background: transparent;}/*Primary Chart*/\n\n/*Nested divs for responsiveness*/\n.chart-wrapper {\n    max-width: 800px;  /*Overwritten by the JS*/\n    min-width: 304px;\n    margin-bottom: 8px;\n    background-color: #FAF7F7;\n}\n.chart-wrapper .inner-wrapper {\n    position: relative;\n    padding-bottom: 50%; /*Overwritten by the JS*/\n    width: 100%;\n}\n.chart-wrapper .outer-box {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n}\n.chart-wrapper .inner-box {\n    width: 100%;\n    height: 100%;\n}\n\n.chart-wrapper text {\n  font-family: sans-serif;\n  font-size: 13px;\n}\n\n.chart-wrapper .axis path,\n.chart-wrapper .axis line {\n    fill: none;\n    stroke: #ddd;\n    stroke-width: 1px;\n    shape-rendering: crispEdges;\n}\n\n.chart-wrapper .y.axis .tick line {\n    stroke: lightgrey;\n    opacity: 0.6;\n    stroke-dasharray: 2,1;\n    stroke-width: 1;\n    shape-rendering: crispEdges;\n\n}\n\n.chart-wrapper .x.axis .domain {\n  display: block;\n}\n\n.chart-wrapper div.tooltip {\ndisplay: none;\n    position: absolute;\n    text-align: left;\n    padding: 5px;\n    font: 10px sans-serif;\n    background: #ffffff;\n    border: 1px solid #ccc;\n    border-radius: 5px;\n    pointer-events: none;\n    opacity: 1;\n}\n\n/*Box Plot*/\n.chart-wrapper .box-plot line {\n    stroke-width: 2px;\n}\n.chart-wrapper .box-plot circle {\n    fill: white;\n    stroke: black;\n}\n\n.chart-wrapper .box-plot .median {\n    stroke: black;\n}\n\n.chart-wrapper .box-plot circle.median {\n    /*the script makes the circles the same color as the box, you can override this in the js*/\n    fill: white !important;\n}\n\n.chart-wrapper .box-plot .mean {\n    stroke: white;\n    stroke-dasharray: 2,1;\n    stroke-width: 1px;\n}\n\n@media (max-width:500px){\n    .chart-wrapper .box-plot circle {display: none;}\n}\n\n/*Violin Plot*/\n\n.chart-wrapper .violin-plot .area {\n    shape-rendering: geometricPrecision;\n    opacity: 0.4;\n}\n\n.chart-wrapper .violin-plot .line {\n    fill: none;\n    stroke-width: 1px;\n    shape-rendering: geometricPrecision;\n}\n\n\n/* Non-Chart Styles for demo*/\n.chart-options  {\n    min-width: 200px;\npadding: 2px 4px;\n    font-size: 12px;\n    font-family: sans-serif;\n}\n.chart-options button {\n    margin: 3px;\n    padding: 3px;\n    font-size: 12px;\n}\n@media (max-width:500px){\n    .chart-options p {display: block;}\n}\n\n\n\n\n\n.switch {\n  position: relative;\n  display: inline-block;\n  width: 40px;\n  height: 20px;\n}\n\n.switch input { \n  opacity: 0;\n  width: 0;\n  height: 0;\n}\n\n.slider {\n  position: absolute;\n  cursor: pointer;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background-color: #ccc;\n  -webkit-transition: .4s;\n  transition: .4s;\n}\n\n.slider:before {\n  position: absolute;\n  content: \"\";\n  height: 12px;\n  width: 12px;\n  left: 4px;\n  bottom: 4px;\n  background-color: white;\n  -webkit-transition: .4s;\n  transition: .4s;\n}\n\ninput:checked + .slider {\n  background-color: #2196F3;\n}\n\ninput:focus + .slider {\n  box-shadow: 0 0 1px #2196F3;\n}\n\ninput:checked + .slider:before {\n  -webkit-transform: translateX(18px);\n  -ms-transform: translateX(18px);\n  transform: translateX(18px);\n}\n\n/* Rounded sliders */\n.slider.round {\n  border-radius: 24px;\n}\n\n.slider.round:before {\n  border-radius: 50%;\n}\n\n.checkboxLabel{\ndisplay: inline-grid;\nborder: 1px solid #eee;\n    padding: 2px;\n    width: calc(calc(100% - 180px)/7);\n}\n.chartOptionsCategory{\nwidth: 100px; \nfloat: left;\n    vertical-align: middle;\n}",
							"HTMLContent": "<div class=\"chart-wrapper\" id=\"chart-distro1\"></div>\n\n<!--Sorry about all the inline JS. It is a quick way to show  what options are available-->\n<div class=\"chart-options\">\n    <div class=\"chartOptionsCategory\"><p>Box Options</p></div>\n    <div class=\"checkboxLabel\" id=\"ToggleBox\"><label>Toggle Box</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('showBox')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"ToggleMean\"><label>Toggle Mean</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('showMean')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"ToggleMedian\"><label>Toggle Median</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('showMedian')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"ToggleWhiskers\"><label>Toggle Whiskers</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('showWhiskers')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"ToggleOutliers\"><label>Toggle Outliers</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('showOutliers')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"BoxWidth\"><label>Box Width</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('boxWidth')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"BoxColors\"><label>Box Colors</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('boxColors')\"><span class=\"slider round\"></span></label></div>\n</div>\n\n<div class=\"chart-options\">\n    <div class=\"chartOptionsCategory\"><p>Violin Options</p></div>\n    <div class=\"checkboxLabel\" id=\"ToggleViolin\"><label>Toggle Violin</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('showArea')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"ViolinWidth\"><label>Violin Width</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('violinWidth')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"ViolinColors\"><label>Violin Colors</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('violinColors')\"><span class=\"slider round\"></span></label></div>\n    <div class=\"checkboxLabel\" id=\"ViolinResolution\"><label>Violin Resolution</label><label class=\"switch\"><input type=\"checkbox\"  onchange=\"changeProperties('resolution')\"><span class=\"slider round\"></span></label></div>\n</div>",
					"Title": {
						"FontWeight": "600",
						"Description": "Violin Chart",
						"FontSize": "17",
						"TextDecoration": "none",
						"Align": "left",
						"FontFamily": "BizvizFont",
						"FontColor": "#000000",
						"FontStyle": "normal",
						"showTitle": "true",
						"TitleBarHeight": "40"
					},
					"SubTitle": {
						"FontWeight": "normal",
						"Description": "SubTitle",
						"showSubTitle": "false",
						"FontSize": "15",
						"TextDecoration": "none",
						"Align": "left",
						"FontFamily": "BizvizFont",
						"FontColor": "#808080",
						"FontStyle": "normal"
					}
				}
			}
		},
		"Fields": [{
				"DisplayName": "Year",
				"Type": "Category",
				"visible": "true",
				"PlotRadius": "0",
				"Name": "Year",
				"Color": "#fcdb96",
				"axis": "none",
				"Precision": "0",
				"ChartType": "none"
			},
			{
				"DisplayName": "Expense",
				"Type": "Series",
				"visible": "true",
				"PlotRadius": "0",
				"Name": "Expense",
				"Color": "#fd940b",
				"axis": "none",
				"Precision": "0",
				"ChartType": "none",
				"DataLabelCustomProperties": {
					"showDataLabel": "false",
					"useFieldColor": "false",
					"dataLabelTextAlign": "center",
					"dataLabelFontColor": "#000000",
					"dataLabelRotation": "0",
					"dataLabelFontSize": "14",
					"datalabelFontStyle": "normal",
					"datalabelFontWeight": "normal",
					"datalabelFontFamily": "BizvizFont",
					"datalabelField": "",
					"datalabelPosition": "Top",
					"dataLabelUseComponentFormater": "true",
					"datalabelFormaterUnit": "none",
					"datalabelFormaterPrecision": "default",
					"datalabelFormaterCurrency": "none",
					"datalabelFormaterPosition": "suffix"
				}
			}
		],
		"Data": [{
				"Year": 2016,
				"Expense": 14,
				"Revenue": 22,
				"Profit": 15
			},
			{
				"Year": 2017,
				"Expense": 28,
				"Revenue": 43,
				"Profit": 8
			},
			{
				"Year": 2018,
				"Expense": 31,
				"Revenue": 12,
				"Profit": 4
			}
		]
	}
}