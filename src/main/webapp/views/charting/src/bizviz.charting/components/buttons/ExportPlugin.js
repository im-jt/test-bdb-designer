/**
 * Copyright Â© 2015-2017. Big Data BizViz LLC. All Rights Reserved
 * @File: ExportPlugin.js
 * @description has all the exporting libraries
 **/

function Plugin(component) {
	this.component = "";
	this.m_showexceldownload = "false";
	this.showChartData = "";
	this.m_excelexportext = "xlsx";
	this.m_excelsheetname = "";
	this.m_excelexportextinfo = {"csv": {"ext": ".csv", "seperator": ","}, "xls": {"ext": ".csv", "seperator": ","}, "tsv": {"ext": ".tsv", "seperator": "\t"}};
	this.svgCharts = ["trellis_chart","spider_chart","timeline_chart", "scattered_plot_chart", "bar_chart", "pie_chart", "decisiontree_chart", "decomposition_chart", "heat_map_chart","circumplex_chart", "world_map","group_bar_chart","group_column_chart","mitoplot_chart", "svg_image", "svg_shape", "h_slider", "v_slider", "legend"];
};

Plugin.prototype.initPlugin = function (component) {
	this.component = component;
	this.m_excelexportext = this.component.m_excelexportext;
	this.showChartData = new ShowChartData(this.component);
	this.m_showexceldownload = this.component.m_showexceldownload;
	/* Export filename_dynamically*/
	this.exportFileName = (this.component.m_scrnshotfilename != "") ? this.component.formattedDescription(this.component,this.component.m_scrnshotfilename) : this.component.m_objectname;
	this.m_scrnshotsheetname = (this.component.m_scrnshotsheetname === "") ? this.component.m_objectname: this.component.m_scrnshotsheetname ;
};
/*Plugin.prototype.exportToExcel = function () {
	if (!IsBoolean(this.component.m_isEmptySeries)) {
		this.m_excelsheetname = this.getStringARSC(this.m_scrnshotsheetname);
		if (this.m_excelexportext == 'xls' || this.m_excelexportext == 'csv' || this.m_excelexportext == 'tsv') {
			//added conditions for exporting  csv or tsv
			var fields = [];
			var xlsString = "";
			var columnHeads = this.showChartData.getColumnHeads();
			for (var i = 0; i < columnHeads.columnHeads.length; i++) {
				xlsString = (i == columnHeads.columnNames.length - 1 ) ? xlsString + this.getFormattedExcelHeader(columnHeads.columnHeads[i].title) + "\r\n" : xlsString + (this.getFormattedExcelHeader(columnHeads.columnHeads[i].title) + this.m_excelexportextinfo[this.m_excelexportext].seperator);
				//(i == columnHeads.columnNames.length - 1 ), this condition is for creating new line at end of last data instead of adding separator
			}
			for (var i = 0; i < this.component.getDataProvider().length; i++) {
				for (var j = 0,ser = 0; j < columnHeads.columnNames.length; j++) {
					var data = this.component.getDataProvider()[i][columnHeads.columnNames[j].field];
					data = this.getFormattedData(data);
					if(IsBoolean(this.component.m_enablexcelformatter)){
						//added this for export data with formatters
						if(this.component.m_objecttype == "chart" || this.component.m_objecttype == "funnel") {
							if(_.contains(this.component.m_categoryNames,columnHeads.columnNames[j].field) && this.component.m_componenttype !== "scattered_plot_chart") {
								data = data;
						    } else if(this.component.m_componenttype == "mixed_chart" || this.component.m_componenttype == "timeline_chart") {
						    	data = this.component.getLeftRightAxisFormatterForShowData(this.component.getDataProvider()[i1][columnHeads.columnNames[j].field], ser);
						    	ser++;
						    } else if(this.component.m_componenttype !== "world_map") {
						    	data = this.component.getFormatterForToolTip(data);
							} else {
								data = this.component.getFormatterForToolTip(columnHeads.columnNames[j].field, data);
						    }
						} else {
							data = this.component.getFormattedCellValue(data, columnHeads.columnNames[j].field, j);
						}
					}
					xlsString = (j == columnHeads.columnNames.length - 1 ) ? xlsString + data + "\r\n" : xlsString + (data + this.m_excelexportextinfo[this.m_excelexportext].seperator);
					//(j == columnHeads.columnNames.length - 1 ), this condition is for creating new line at end of last data instead of adding separator
				}
			}
			this.excelRepresentation(xlsString);
		} else {
			var data = [];
			var columns = [];
			var columnHeads = this.showChartData.getColumnHeads();
			for (var i = 0; i < columnHeads.columnHeads.length; i++) {
				columns[i] = this.getFormattedExcelHeader(columnHeads.columnHeads[i].title);
			}
			data.push(columns);
			for (var i1 = 0; i1 < this.component.getDataProvider().length; i1++) {
				var rows = [];
				for (var j = 0,ser = 0; j < columnHeads.columnNames.length; j++) {
					var val = this.component.getDataProvider()[i1][columnHeads.columnNames[j].field];
					val = this.getFormattedData(val);
					if(IsBoolean(this.component.m_enablexcelformatter)){
						if(this.component.m_objecttype == "chart" || this.component.m_objecttype == "funnel") {
							if(_.contains(this.component.m_categoryNames,columnHeads.columnNames[j].field) && this.component.m_componenttype !== "scattered_plot_chart") {
								rows[j] = val;
						    } else if(this.component.m_componenttype == "mixed_chart" || this.component.m_componenttype == "timeline_chart") {
						    	val = this.component.getLeftRightAxisFormatterForShowData(this.component.getDataProvider()[i1][columnHeads.columnNames[j].field], ser);
						    	ser++;
						    } else if(this.component.m_componenttype !== "world_map") {
						    	val = this.component.getFormatterForToolTip(val);
							} else {
						    	val = this.component.getFormatterForToolTip(columnHeads.columnNames[j].field, val);
						    }
						} else {
							val = this.component.getFormattedCellValue(val, columnHeads.columnNames[j].field, j);
						}
					}
					rows[j] = val;
				}
				data.push(rows);
			}
			
			var ws_name = (this.m_excelsheetname) ? this.m_excelsheetname : "Sheet";
			var file_name = (this.exportFileName) ? this.exportFileName : "Dashboard";
			var wb = new Workbook();
			exportToExcelXLSX(data, ws_name, file_name, wb);
			if(IsBoolean(this.component.m_filterdetails)){
				var Cdetail = this.getDetailData();
				if((Cdetail.sheetDetail !== undefined && Cdetail.sheetDetail.length > 0 && Cdetail.sheetDetail[0].length > 0)){
					exportToExcelXLSX(Cdetail.sheetDetail, Cdetail.sheetName, file_name, wb);
				}
			}
			downloadXLSX(wb, file_name);
		}
	}
};*/
Plugin.prototype.exportToExcel = function() {
	if (!IsBoolean(this.component.m_isEmptySeries)) {
		this.m_excelsheetname = this.getStringARSC(this.m_scrnshotsheetname);
		var data = [];
		var columns = [];
		var columnHeads = this.showChartData.getColumnHeads();
		for (var i = 0; i < columnHeads.columnHeads.length; i++) {
			columns[i] = this.getFormattedExcelHeader(columnHeads.columnHeads[i].title);
		}
		data.push(columns);
		for (var i1 = 0; i1 < this.component.getDataProvider().length; i1++) {
			var rows = [];
			for (var j = 0, ser = 0; j < columnHeads.columnNames.length; j++) {
				var val = this.component.getDataProvider()[i1][columnHeads.columnNames[j].field];
				val = this.getFormattedData(val);
				if (IsBoolean(this.component.m_enablexcelformatter)) {
					if (this.component.m_objecttype == "chart" || this.component.m_objecttype == "funnel") {
						if (_.contains(this.component.m_categoryNames, columnHeads.columnNames[j].field) && this.component.m_componenttype !== "scattered_plot_chart") {
							rows[j] = val;
						} else if (this.component.m_componenttype == "mixed_chart" || this.component.m_componenttype == "timeline_chart") {
							val = this.component.getLeftRightAxisFormatterForShowData(this.component.getDataProvider()[i1][columnHeads.columnNames[j].field], ser);
							ser++;
						} else if (this.component.m_componenttype !== "world_map") {
							val = this.component.getFormatterForToolTip(val);
						} else {
							val = this.component.getFormatterForToolTip(columnHeads.columnNames[j].field, val);
						}
					} else {
						val = this.component.getFormattedCellValue(val, columnHeads.columnNames[j].field, j);
					}
				}
				rows[j] = val;
			}
			data.push(rows);
		}
		/**DAS-1137 @desc adding support for aggregation data download in excel */
		var lastRowData = [];
		/*aggregated row data*/
		if (this.showChartData.m_chart.Tabledata !=undefined && this.showChartData.m_chart.Tabledata.length>0) {
		var lastRowindex = this.showChartData.m_chart.Tabledata.findIndex(function(item) {
    	return item.gridHiddenField === 'aggregatedRow';
		});
		var  lastRow = this.showChartData.m_chart.Tabledata[lastRowindex];
		if (lastRow != undefined && lastRow.gridHiddenField === 'aggregatedRow') {
			//console.log('The last row has gridHiddenField as aggregatedrow.');
			var columnHeads= this.showChartData.m_chart.columnHeads;
			for (var j = 0;  j < columnHeads.length - 1; j++) {
			var val = lastRow[columnHeads[j].field];
			val = this.component.getFormattedCellValue(val, columnHeads[j].field, j);
			lastRowData[j] = val;
			}
			} 
			if (lastRowData.length>0) {
			data.push(lastRowData);
			}
		} 
		var ws_name = (this.m_excelsheetname) ? this.m_excelsheetname : "Sheet";
		var file_name = (this.exportFileName) ? this.exportFileName : "Dashboard";
		var wb = new Workbook();
		exportToExcelXLSX(data, ws_name, file_name, wb);
		if (IsBoolean(this.component.m_filterdetails)) {
			var Cdetail = this.getDetailData();
			if ((Cdetail.sheetDetail !== undefined && Cdetail.sheetDetail.length > 0 && Cdetail.sheetDetail[0].length > 0)) {
				exportToExcelXLSX(Cdetail.sheetDetail, Cdetail.sheetName, file_name, wb);
			}
		}
		downloadXLSX(wb, file_name);
	}
};
/**DAS-1012 @desc csv export data not proper */
Plugin.prototype.exportToCSV = function() {
	if (!IsBoolean(this.component.m_isEmptySeries)) {
		this.m_excelsheetname = this.getStringARSC(this.m_scrnshotsheetname);
		var data = [];
		var columns = [];
		var columnHeads = this.showChartData.getColumnHeads();
		for (var i = 0; i < columnHeads.columnHeads.length; i++) {
			columns[i] = this.getFormattedExcelHeader(columnHeads.columnHeads[i].title);
		}
		data.push(columns);
		for (var i1 = 0; i1 < this.component.getDataProvider().length; i1++) {
			var rows = [];
			for (var j = 0, ser = 0; j < columnHeads.columnNames.length; j++) {
				var val = this.component.getDataProvider()[i1][columnHeads.columnNames[j].field];
				val = this.getFormattedData(val);
				if (IsBoolean(this.component.m_enablexcelformatter)) {
					if (this.component.m_objecttype == "chart" || this.component.m_objecttype == "funnel") {
						if (_.contains(this.component.m_categoryNames, columnHeads.columnNames[j].field) && this.component.m_componenttype !== "scattered_plot_chart") {
							rows[j] = val;
						} else if (this.component.m_componenttype == "mixed_chart" || this.component.m_componenttype == "timeline_chart") {
							val = this.component.getLeftRightAxisFormatterForShowData(this.component.getDataProvider()[i1][columnHeads.columnNames[j].field], ser);
							ser++;
						} else if (this.component.m_componenttype !== "world_map") {
							val = this.component.getFormatterForToolTip(val);
						} else {
							val = this.component.getFormatterForToolTip(columnHeads.columnNames[j].field, val);
						}
					} else {
						val = this.component.getFormattedCellValue(val, columnHeads.columnNames[j].field, j);
					}
				}
				rows[j] = val;
			}
			data.push(rows);
		}
		/**DAS-1137 @desc adding support for aggregation data download in csv*/
		var lastRowData = [];
		/*aggregated row data*/
		if (this.showChartData.m_chart.Tabledata !=undefined && this.showChartData.m_chart.Tabledata.length>0) {
		var lastRowindex = this.showChartData.m_chart.Tabledata.findIndex(function(item) {
    	return item.gridHiddenField === 'aggregatedRow';
		});
		var  lastRow = this.showChartData.m_chart.Tabledata[lastRowindex];
		if (lastRow != undefined && lastRow.gridHiddenField === 'aggregatedRow') {
			//console.log('The last row has gridHiddenField as aggregatedrow.');
			var columnHeads= this.showChartData.m_chart.columnHeads;
			for (var j = 0;  j < columnHeads.length - 1; j++) {
			var val = lastRow[columnHeads[j].field];
			val = this.component.getFormattedCellValue(val, columnHeads[j].field, j);
			lastRowData[j] = val;
			}
			} 
			if (lastRowData.length>0) {
			data.push(lastRowData);
			}
		}
		var ws_name = (this.m_excelsheetname) ? this.m_excelsheetname : "Sheet";
		var file_name = (this.exportFileName) ? this.exportFileName : "Dashboard";
		var wb = new Workbook();
		exportToExcelXLSX(data, ws_name, file_name, wb);
		if (IsBoolean(this.component.m_filterdetails)) {
			var Cdetail = this.getDetailData();
			if ((Cdetail.sheetDetail !== undefined && Cdetail.sheetDetail.length > 0 && Cdetail.sheetDetail[0].length > 0)) {
				exportToExcelXLSX(Cdetail.sheetDetail, Cdetail.sheetName, file_name, wb);
			}
		}
		// Get the first sheet (you can also use the sheet name, e.g., workbook.Sheets['Sheet1'])
        var firstSheetName = wb.SheetNames[0];
        var sheet = wb.Sheets[firstSheetName];
		// Generate CSV data from the sheet
        var csvData = XLSX.utils.sheet_to_csv(sheet);
        // Prepend BOM to the CSV content to ensure UTF-8 encoding
        var csvContent = "\uFEFF" + csvData;
        // Create a Blob from the CSV data
        var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
        var filename = this.exportFileName + this.m_excelexportextinfo[this.m_excelexportext].ext;
        if (window.navigator.msSaveBlob) {
                // IE-specific download logic
                window.navigator.msSaveBlob(blob, filename);
            }else{
                // Other modern browsers
                var link = document.createElement('a');
                if (link.download !== undefined) { // check for download attribute support
                    var url = URL.createObjectURL(blob);
                    link.href = url;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url); // clean up
                } else {
                    // Fallback for browsers without download support
                    console.log('Error in dwonload csv.');
                }
			}
	}
};
/**DAS-1012 old csv function */
Plugin.prototype.exportToCSV1 = function() {
	if (!IsBoolean(this.component.m_isEmptySeries)) {
		this.m_excelsheetname = this.getStringARSC(this.m_scrnshotsheetname);
		if (this.m_excelexportext == 'xls' || this.m_excelexportext == 'csv' || this.m_excelexportext == 'tsv') {
			//added conditions for exporting  csv or tsv
			var fields = [];
			var xlsString = "";
			var columnHeads = this.showChartData.getColumnHeads();
			for (var i = 0; i < columnHeads.columnHeads.length; i++) {
				xlsString = (i == columnHeads.columnNames.length - 1) ? xlsString + this.getFormattedExcelHeader(columnHeads.columnHeads[i].title) + "\r\n" : xlsString + (this.getFormattedExcelHeader(columnHeads.columnHeads[i].title) + this.m_excelexportextinfo[this.m_excelexportext].seperator);
				/*(i == columnHeads.columnNames.length - 1 ), this condition is for creating new line at end of last data instead of adding separator*/
			}
			for (var i = 0; i < this.component.getDataProvider().length; i++) {
				for (var j = 0, ser = 0; j < columnHeads.columnNames.length; j++) {
					var data = this.component.getDataProvider()[i][columnHeads.columnNames[j].field];
					data = this.getFormattedData(data);
					if (IsBoolean(this.component.m_enablexcelformatter)) {
						//added this for export data with formatters
						if (this.component.m_objecttype == "chart" || this.component.m_objecttype == "funnel") {
							if (_.contains(this.component.m_categoryNames, columnHeads.columnNames[j].field) && this.component.m_componenttype !== "scattered_plot_chart") {
								data = data;
							} else if (this.component.m_componenttype == "mixed_chart" || this.component.m_componenttype == "timeline_chart") {
								data = this.component.getLeftRightAxisFormatterForShowData(this.component.getDataProvider()[i][columnHeads.columnNames[j].field], ser);
								ser++;
							} else if (this.component.m_componenttype !== "world_map") {
								data = this.component.getFormatterForToolTip(data);
							} else {
								data = this.component.getFormatterForToolTip(columnHeads.columnNames[j].field, data);
							}
						} else {
							data = this.component.getFormattedCellValue(data, columnHeads.columnNames[j].field, j);
						}
					}
					xlsString = (j == columnHeads.columnNames.length - 1) ? xlsString + data + "\r\n" : xlsString + (data + this.m_excelexportextinfo[this.m_excelexportext].seperator);
					/*(j == columnHeads.columnNames.length - 1 ), this condition is for creating new line at end of last data instead of adding separator*/
				}
			}
			this.excelRepresentation(xlsString);
		}
	}
};
Plugin.prototype.getFormattedExcelHeader = function(val) {
	try{
		return ""+val.split("<br>").join("").split("/n").join("").split("\n").join("");
	}catch(e){
		return val;
	}
};

/** CP-930: To switch rows and columns **/
Plugin.prototype.transpose = function (mat) {
    return Object.keys(mat[0]).map(function(c) {
        return mat.map(function(r) { return r[c]; });
    });
}

Plugin.prototype.getDetailData = function () {
	var ConnectionDetail = gvController.dashboard.m_DataProviders.m_dataUrlIdObjMap[this.component.m_datasource];
	var data = [];
	var sheetData1 = [];
	var flMap = {};
	for(var i=0; i<ConnectionDetail.getKeys().length; i++){
		data.push(ConnectionDetail.getClauseData()[(ConnectionDetail.getKeys()[i]).toLowerCase()]);
	}
	sheetData1.push(ConnectionDetail.getKeys());
	sheetData1.push(data);

	var sheetData = this.transpose(sheetData1);	
	
	flMap["sheetDetail"] = sheetData;
	flMap["sheetName"] = this.m_excelsheetname+"Info";
	return flMap;
};
Plugin.prototype.getDetailDataExcelExport = function () {
	var ConnectionDetail = gvController.dashboard.m_DataProviders.m_dataUrlIdObjMap[this.component.m_datasource];
	var data = [];
	var sheetData = [];
	var filterData =[];
	var flMap = {};
	for(var i=0; i<ConnectionDetail.m_availableconditionset.length; i++){
		if(ConnectionDetail.m_availableconditionset[i]["added"]){
			data.push(ConnectionDetail.getClauseData()[(ConnectionDetail.m_availableconditionset[i].displayName).toLowerCase()]);
			filterData.push((ConnectionDetail.m_availableconditionset[i].displayName).toLowerCase());
		}
	}
	sheetData.push(filterData);
	sheetData.push(data);
	flMap["sheetDetail"] = sheetData;
	flMap["sheetName"] = this.m_excelsheetname+"Info";
	return flMap;
};
Plugin.prototype.getFormattedData = function (val) {
	if(val == undefined || val === ""){
		/** return empty for _blank and undefined values **/
		return "";
	}else if(isNaN(val) || val == null){
		/** return same value for string, null, date type values **/
		return val;
	}else{
		/** return number for numeric value with or without single/double quotes **/
		return val*1;
	}
};
Plugin.prototype.excelRepresentation = function (xlsString) {
	var component = this.component;
	var link = document.createElement('a');
	link.setAttribute('id', 'anchor');
	link = document.body.appendChild(link);

	if (isIE = /*@cc_on!@*/
			false || !!document.documentMode) // If Internet Explorer
	{
		var blobObject = new Blob([xlsString], { type: 'text/csv;charset=utf-8;' });
		window.navigator.msSaveBlob(blobObject, this.exportFileName + this.m_excelexportextinfo[this.m_excelexportext].ext)
	} else if (isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0) // If Safari
	{
		var uri = "data:application/...," + encodeURIComponent(xlsString);
		location.replace(uri);
	} else // other browsers chrome, firefox, opera
	{
		var anchorobj = $('#anchor'); //scrnshotfilename
		$(anchorobj)[0]["download"] = component.m_scrnshotfilename + this.m_excelexportextinfo[this.m_excelexportext].ext;
		$(anchorobj)[0]["href"] = 'data:application/...,' + encodeURIComponent(xlsString);
		$(anchorobj)[0].click();
	}
};

Plugin.prototype.exportToJPEG = function () {
	this.exportToScreenShot("image/jpeg", ".jpeg");
};
Plugin.prototype.exportToPNG = function () {
	this.exportToScreenShot("image/png", ".png");
};

Plugin.prototype.exportToScreenShot = function (type, extension) {
	var
	temp = this,
	canvas = temp.component.ctx.canvas,
	fileName = temp.exportFileName;
	if(!IsBoolean(temp.component.chartJson.m_repeaterallexport)) {
		var divSelector = "#draggableDiv" + temp.component.m_objectid;
	} else {
		var compId = temp.component.m_objectid.split("_")[0];
		var divSelector = "#draggableDiv" + compId;
	}
	var divObject = $(divSelector)[0];
//	if( !IsBoolean(temp.component.isMaximized) ){
//		$(divObject).css({
//			'position': 'fixed',
//			'top': "0px",
//			'left': "0px",
//			'height': ($(divObject).get(0).scrollHeight + getScrollBarWidth()) + 'px',
//			'width': ($(divObject).get(0).scrollWidth + getScrollBarWidth()) + 'px'
//		});
//	}
	//remove timeline chart svg rect animation to avoid export issue 
	if ( (temp.svgCharts.indexOf(temp.component.m_componenttype) > -1) && IsBoolean(temp.component.m_enableanimation)) {
		$(divObject).find("svg").find(".timeSeries-stackHighlighter").find("animate").remove();
		$(divObject).find("svg").find(".pointShapeColorAnimation").find("animate").remove();
		for(var i = 1; i<$(divObject).find("svg").find(".pointShapeColorAnimation").length; i= i+2){
			var color =$(divObject).find("svg").find(".pointShapeColorAnimation")[i-1].attributes[1].nodeValue;
			$(divObject).find("svg").find(".pointShapeColorAnimation")[i].setAttribute("stop-color", color);
		}
		$(divObject).find("svg").find(".pointShapeAnimation").find("animate").remove();
	}
	this.removeExportIframe();
	function cb(_canvas){
		img = _canvas.toDataURL(type);
		var contentType = img.split(",")[0];

		contentType = contentType || '';
		var sliceSize = 512;
		var b64Data = img.split(",")[1];
		b64Data = b64Data.replace(/^[^,]+,/, '');
		b64Data = b64Data.replace(/\s/g, '');
		var byteCharacters = window.atob(b64Data);
		var byteArrays = [];

		for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
			var slice = byteCharacters.slice(offset, offset + sliceSize);

			var byteNumbers = new Array(slice.length);
			for (var i = 0; i < slice.length; i++) {
				byteNumbers[i] = slice.charCodeAt(i);
			}

			var byteArray = new Uint8Array(byteNumbers);
			byteArrays.push(byteArray);
		}
		var blob = new Blob(byteArrays, {
				type : contentType
			});
		var fileWithExtension = fileName + extension;
		if (window.saveAs)
			window.saveAs(blob, fileWithExtension);
		else
			window.navigator.msSaveBlob(blob, fileWithExtension);
//		if( !IsBoolean(temp.component.isMaximized) ){
//			$(divObject).css({
//				'position': 'absolute',
//				'top': temp.component.m_top + 'px', 
//				'left': temp.component.m_left + 'px', 
//				'width': temp.component.m_width + 'px', 
//				'height': temp.component.m_height + 'px'
//			});
//		}
		return false;
	}
	if(((isIE = false || !!document.documentMode) || (isFirefox = typeof InstallTrigger !== 'undefined')) && (temp.svgCharts.indexOf(temp.component.m_componenttype) > -1)) {
		var img = replaceSvgWithCanvas(divObject);
		var contentType = img.split(",")[0];

		contentType = contentType || '';
		var sliceSize = 512;
		var b64Data = img.split(",")[1];
		b64Data = b64Data.replace(/^[^,]+,/, '');
		b64Data = b64Data.replace(/\s/g, '');
		var byteCharacters = window.atob(b64Data);
		var byteArrays = [];

		for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
			var slice = byteCharacters.slice(offset, offset + sliceSize);

			var byteNumbers = new Array(slice.length);
			for (var i = 0; i < slice.length; i++) {
				byteNumbers[i] = slice.charCodeAt(i);
			}

			var byteArray = new Uint8Array(byteNumbers);
			byteArrays.push(byteArray);
		}
		var blob = new Blob(byteArrays, {
				type : contentType
			});
		var fileWithExtension = fileName + extension;
		if (window.saveAs)
			window.saveAs(blob, fileWithExtension);
		else
			window.navigator.msSaveBlob(blob, fileWithExtension);
		return false;
	} else {
		/*
		html2canvas(divObject, {
			height: ($(divObject).get(0).scrollHeight),
			width: ($(divObject).get(0).scrollWidth),
			background: "#FFFFFF",
			onrendered : function (_canvas) {
				cb(_canvas);
			}
		});
		*/
		if(!IsBoolean(temp.component.chartJson.m_repeaterallexport)) {
			var reqHeight = ($(divObject).get(0).offsetHeight),
			reqWidth = ($(divObject).get(0).scrollWidth);
		} else {
			var reqHeight = ($(divObject).get(0).scrollHeight + temp.component.m_borderthickness*1),
			reqWidth = ($(divObject).get(0).scrollWidth + temp.component.m_borderthickness*2 + temp.getScrollBarWidth(temp));
		}
		try{
			html2canvas(divObject, {
				height: reqHeight,
				width: reqWidth,
				backgroundColor: temp.component.m_exportdefaultbgcolor,
				logging: IsBoolean(dGlobals.isDevMode)
			}).then(function(canvas){
				cb(canvas);
			});
		}catch(e){
			console.log(e);
		}
	}
};

/** @description method for exporting multiple/selected components in png **/
Plugin.prototype.exportToCustomScreenShot = function (components, compRef) {
	var temp = this;
	var dashboardObj = $("#" + compRef.m_chartContainer[0].id)[0]
	var tempDiv = document.createElement("div");
	tempDiv.id = "temp";
	dashboardObj.append(tempDiv);
	for(var i = 0; i < compRef.m_dashboard.m_widgetsArray.length; i++) {
		if((components).indexOf(compRef.m_dashboard.m_widgetsArray[i].m_referenceid) > -1) {
			var draggableWidgetId = "draggableDiv" + compRef.m_dashboard.m_widgetsArray[i].m_objectid;
			var widgetObject = $("#" + draggableWidgetId);
			tempDiv.append(widgetObject[0]);
		}
	}
	var tempWH = ((compRef.m_dashboard.m_scalingenabled) ? {w: compRef.m_dashboard.getAbsoluteLayout().m_ALWidth, h: compRef.m_dashboard.getAbsoluteLayout().m_ALHeight} : {w: compRef.m_dashboard.m_AbsoluteLayout.m_width, h: compRef.m_dashboard.m_AbsoluteLayout.m_height});
	tempWH.w = tempWH.w*1 + compRef.m_dashboard.getAbsoluteLayout().getBorderThickness()*2;
	tempWH.h = tempWH.h*1 + compRef.m_dashboard.getAbsoluteLayout().getBorderThickness()*2;
	$('#TooltipDivExport' + compRef.m_objectid).remove();
	/* remove timeline chart svg rect animation to avoid export issue */
	$(dashboardObj).find("svg").find(".timeSeries-stackHighlighter").find("animate").remove();
	$(dashboardObj).find("svg").find(".pointShapeColorAnimation").find("animate").remove();
	for(var i = 1; i<$(dashboardObj).find("svg").find(".pointShapeColorAnimation").length; i= i+2){
		var color =$(dashboardObj).find("svg").find(".pointShapeColorAnimation")[i-1].attributes[1].nodeValue;
		$(dashboardObj).find("svg").find(".pointShapeColorAnimation")[i].setAttribute("stop-color", color);
	}
	$(dashboardObj).find("svg").find(".pointShapeAnimation").find("animate").remove();
	this.removeExportIframe();

	var fileName = "Dashboard";
	var type = "image/png";

	if (isIE = false || !!document.documentMode) // If Internet Explorer
		hideBlockUILoader();
	else if (isFirefox = typeof InstallTrigger !== 'undefined') // If Firefox
		hideBlockUILoader();
	else if ((/Edge\/12./i.test(navigator.userAgent))) // IF Edge
		hideBlockUILoader();
	else
		showBlockUILoader(30000);

	var scroll = {};
	scroll.top = $(window).scrollTop();
	scroll.left = $(window).scrollLeft();
	window.scroll(0, 0);

	function cb(_canvas){
		if (isIE = false || !!document.documentMode) // If Internet Explorer
			showBlockUILoader(30000);
		else if (isFirefox = typeof InstallTrigger !== 'undefined') // If Firefox
			showBlockUILoader(30000);
		else if ((/Edge\/12./i.test(navigator.userAgent))) // IF Edge
			showBlockUILoader(30000);

		try {
			var img = _canvas.toDataURL(type);
			var contentType = img.split(",")[0];

			contentType = contentType || '';
			var sliceSize = 512;
			var b64Data = img.split(",")[1];
			b64Data = b64Data.replace(/^[^,]+,/, '');
			b64Data = b64Data.replace(/\s/g, '');
			var byteCharacters = window.atob(b64Data);
			var byteArrays = [];

			for (var offset = 0; offset < byteCharacters.length; offset += sliceSize) {
				var slice = byteCharacters.slice(offset, offset + sliceSize);

				var byteNumbers = new Array(slice.length);
				for (var i = 0; i < slice.length; i++) {
					byteNumbers[i] = slice.charCodeAt(i);
				}

				var byteArray = new Uint8Array(byteNumbers);
				byteArrays.push(byteArray);
			}
			var blob = new Blob(byteArrays, {
				type: contentType
			});
			if (window.saveAs)
				window.saveAs(blob, fileName + ".png");
			else
				window.navigator.msSaveBlob(blob, fileName + ".png");

			$(dashboardObj).css({
				'width': tempWH.w + 'px',
				'height': tempWH.h + 'px'
			});
			var length = tempDiv.children.length;
			for(var j = 0; j < length; j++) {
				dashboardObj.append(tempDiv.children[0]);
			}
			$(tempDiv).remove();
			/** To capture complete dashboard scroll position changed to 0-0 and set back to original **/
			window.scroll(scroll.left, scroll.top);
		} catch (e) {
			console.log(" Export to PNG Failed !");
			$(dashboardObj).css({
				'width': tempWH.w + 'px',
				'height': tempWH.h + 'px'
			});
		}
		hideBlockUILoader();
		return false;
	}
		try{
			html2canvas(tempDiv, {
				height: ($(dashboardObj).get(0).scrollHeight + compRef.m_dashboard.getAbsoluteLayout().getBorderThickness()*2),
				width: ($(dashboardObj).get(0).scrollWidth + compRef.m_dashboard.getAbsoluteLayout().getBorderThickness()*2),
				backgroundColor: temp.m_exportdefaultbgcolor,
				logging: IsBoolean(dGlobals.isDevMode)
			}).then(function(canvas){
				cb(canvas);
			});
		}catch(e){
			console.log(e);
		}
};

/** @description method for group components in export pdf **/
Plugin.prototype.exportToCustomPDF = function(componentsArray, compRef, hiddencomponent) {
    var temp = this;
    var dashboardObj = $("#" + compRef.m_chartContainer[0].id)[0];
    var tempDiv = document.createElement("div");
    tempDiv.id = "temp";
    dashboardObj.append(tempDiv);
    var h, w, dashboardLeft, dashboardTop, hiddenarr = [];
    var fileOrientation = compRef.m_scrnshotorientation;

    $('#TooltipDivExport' + compRef.m_objectid).remove();
    /* remove timeline chart svg rect animation to avoid export issue */
    $(dashboardObj).find("svg").find(".timeSeries-stackHighlighter").find("animate").remove();
    $(dashboardObj).find("svg").find(".pointShapeColorAnimation").find("animate").remove();
    for (var i = 1; i < $(dashboardObj).find("svg").find(".pointShapeColorAnimation").length; i = i + 2) {
        var color = $(dashboardObj).find("svg").find(".pointShapeColorAnimation")[i - 1].attributes[1].nodeValue;
        $(dashboardObj).find("svg").find(".pointShapeColorAnimation")[i].setAttribute("stop-color", color);
    }
    $(dashboardObj).find("svg").find(".pointShapeAnimation").find("animate").remove();
    this.removeExportIframe();
    /*DAS-56 svg rendering support for pdf screenshot*/
	var svgElements = document.body.querySelectorAll('svg');
	/*svgElements.forEach(function(item) {
	    item.setAttribute("width", item.getBoundingClientRect().width);
	    item.setAttribute("height", item.getBoundingClientRect().height);
	    item.style.width = null;
	    item.style.height= null;
	});*/
    
    for (var k = 0; k < compRef.m_dashboard.m_widgetsArray.length; k++) {
        if ((componentsArray[0]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) == 0) {
            var draggableWidgetId = "draggableDiv" + compRef.m_dashboard.m_widgetsArray[k].m_objectid;
            var widgetObject = $("#" + draggableWidgetId);
            h = widgetObject[0].clientHeight;
            w = widgetObject[0].clientWidth;
            if((hiddencomponent != undefined && (hiddencomponent[0]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1)){
				hiddenarr.push(widgetObject[0]);
			}
            dashboardLeft = widgetObject[0].offsetLeft;
            dashboardTop = widgetObject[0].offsetTop;
            tempDiv.append(widgetObject[0]);
        } else if (((componentsArray[0]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1 || (hiddencomponent != undefined && (hiddencomponent[0]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1)) && compRef.m_dashboard.m_widgetsArray[k].m_referenceid.indexOf('custom') < 0) {
            var draggableWidgetId = "draggableDiv" + compRef.m_dashboard.m_widgetsArray[k].m_objectid;
            var widgetObject = $("#" + draggableWidgetId);
            if (hiddencomponent != undefined && (hiddencomponent[0]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1) {
                hiddenarr.push(widgetObject[0]);
                widgetObject.css("display", "block");
                if ((compRef.m_dashboard.m_widgetsArray[k].m_objecttype === "datagrid" || (compRef.m_dashboard.m_widgetsArray[k].m_componenttype === "world_map" && compRef.m_dashboard.m_widgetsArray[k].m_svgtype === "leaflet")) && IsBoolean(compRef.m_dashboard.m_widgetsArray[k].m_isDataSetavailable)) {
                	compRef.m_dashboard.m_widgetsArray[k].draw();
            	}
                tempDiv.append(widgetObject[0]);
                //widgetObject.attr("display", "none");
            } else {
                tempDiv.append(widgetObject[0]);
            }
        }
        /**added conditions to check the first component in array and assign dimensions**/
    }
    /** CP-474: added condition for export pdf issue **/
    if(h == 0 && w == 0){
    	alertPopUpModal({
    		type:'error',
    		message:'Please check first component visibility.',
    		timeout: '3000'
    	});
    	return;
    }
    //var svgElements = $("#temp").find('svg');
    var can = this.replaceSvgWithCanvasForexport(tempDiv, compRef);

    var j = 1;

    var fileName = compRef.m_scrnshotfilename;
    var type = "image/jpeg";

    if (isIE = false || !!document.documentMode) // If Internet Explorer
        hideBlockUILoader();
    else if (isFirefox = typeof InstallTrigger !== 'undefined') // If Firefox
        hideBlockUILoader();
    else if ((/Edge\/12./i.test(navigator.userAgent))) // IF Edge
        hideBlockUILoader();
    else
    	showBlockUILoaderLongExport(compRef.m_loadermessage);

    function cb(canvas) {

        var a = fileOrientation;
        var b = 'pt'; //'mm';
        var c = [canvas.width * 0.75, canvas.height * 0.75]; //[w,h];//"a4";//[dashboardObj.offsetWidth*0.75, ];//dashboardObj.offsetHeight*0.75];//"a4";
        var d = false;
        var doc = new jsPDF(a, b, c, d);
        var imgData = canvas.toDataURL(type);
        var pdfCalcWidth = doc.internal.pageSize.getWidth() - 20;
        var pdfCalcHeight = doc.internal.pageSize.getHeight() - 40;
        doc.addImage(imgData, 'JPEG', 10, 20, pdfCalcWidth, pdfCalcHeight);
        var tempelem = temp.newelements;

        for (var a = 0; a < tempelem.length; a++) {
            for (var b = 0; b < can.length; b++) {
                if (tempelem[a].id == can[b].id) {
                    $(can[b]).remove();
                    $(tempelem[a]).show();
                    break;
                }
            }
        }

        function lastStep() {
            try {
                var pageCount = doc.internal.getNumberOfPages();
                if(compRef.m_showPageNumber){
                	var pgNumColor = hex2rgb(compRef.m_pageNumberFontColor);
                	pgNumColor = pgNumColor.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
                    doc.setTextColor(parseInt(pgNumColor[1]), parseInt(pgNumColor[2]), parseInt(pgNumColor[3]));
                    // For each page, print the page number and the total pages
                    for (var i = 1; i <= pageCount; i++) {
                        // Go to page i
                        doc.setPage(i);
                        //Print Page 1 of 4 for example
                        doc.setFontSize(compRef.m_pageNumberFontSize);
                        doc.text('Page ' + String(i) + ' of ' + String(pageCount), doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, null, null, "right");
                    }
                }

                var data = doc.output();
                var buffer = new ArrayBuffer(data.length);
                var array = new Uint8Array(buffer);
                for (var i = 0, len = data.length; i < len; i++) {
                    array[i] = data.charCodeAt(i);
                }
                var filename = fileName;
                var blob = new Blob([array], {
                    type: "application/pdf",
                    encoding: "raw"
                });
        
                if (window.saveAs) {
                    var filesaver = window.saveAs(blob, filename + ".pdf");
				    hideBlockUILoader();
                } else {
                    window.navigator.msSaveBlob(blob, filename + ".pdf");
                    hideBlockUILoader();
                }


            } catch (e) {
                console.log("Export pdf failed !");
            }
            
        };

        function nextStep() {
            var tempDiv = document.createElement("div");
            tempDiv.id = "temp1";
            dashboardObj.append(tempDiv);

            if (j == componentsArray.length) {
                lastStep();
            } else {
                var hiddenarr1 = [];
                for (var k = 0; k < compRef.m_dashboard.m_widgetsArray.length; k++) {
                    if ((componentsArray[j]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) == 0) {
                        var draggableWidgetId = "draggableDiv" + compRef.m_dashboard.m_widgetsArray[k].m_objectid;
                        var widgetObject = $("#" + draggableWidgetId);
                        h = widgetObject[0].clientHeight;
                        w = widgetObject[0].clientWidth;
                        if((hiddencomponent != undefined && (hiddencomponent[j]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1)){
							hiddenarr1.push(widgetObject[0]);
						}
                        dashboardLeft = widgetObject[0].offsetLeft;
                        dashboardTop = widgetObject[0].offsetTop;
                        tempDiv.append(widgetObject[0]);
                    } else if ((componentsArray[j]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1 || (hiddencomponent != undefined && (hiddencomponent[j]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1)) {
                        var draggableWidgetId = "draggableDiv" + compRef.m_dashboard.m_widgetsArray[k].m_objectid;
                        var widgetObject = $("#" + draggableWidgetId);
                        if (hiddencomponent != undefined && (hiddencomponent[j]).indexOf(compRef.m_dashboard.m_widgetsArray[k].m_referenceid) > -1) {
                            hiddenarr1.push(widgetObject[0]);
                            widgetObject.css("display", "block");
                            if ((compRef.m_dashboard.m_widgetsArray[k].m_objecttype === "datagrid" || (compRef.m_dashboard.m_widgetsArray[k].m_componenttype === "world_map" && compRef.m_dashboard.m_widgetsArray[k].m_svgtype === "leaflet")) && IsBoolean(compRef.m_dashboard.m_widgetsArray[k].m_isDataSetavailable)) {
                            	compRef.m_dashboard.m_widgetsArray[k].draw();
                        	}
                            tempDiv.append(widgetObject[0]);
                            //widgetObject.attr("display", "none");
                        } else {
                            tempDiv.append(widgetObject[0]);
                        }
                        //tempDiv.append(widgetObject[0]);
                    } /**added conditions to check the first component in array and assign dimensions**/
                }
                var can = temp.replaceSvgWithCanvasForexport(tempDiv, compRef);

                function cb1(canvas) {
                    var tempImgData = canvas.toDataURL(type);
                    doc.addPage();
                    try {
                        doc.addImage(tempImgData, 'JPEG', 10, 20, pdfCalcWidth, pdfCalcHeight);
                        var tempelem = temp.newelements;

                        for (var a = 0; a < tempelem.length; a++) {
                            for (var b = 0; b < can.length; b++) {
                                if (tempelem[a].id == can[b].id) {
                                    $(can[b]).remove();
                                    $(tempelem[a]).show();
                                    break;
                                }
                            }
                        }
                    } catch (e) {
                        console.log(e);
                    }
                    j++;
                    var length = tempDiv.children.length;
                    for (var k = 0; k < length; k++) {
                        if (hiddenarr1 != undefined && (hiddenarr1).indexOf(tempDiv.children[0]) > -1) {
                            var val = (hiddenarr1).indexOf(tempDiv.children[0]);
                            var widobj = hiddenarr1[val];
                            //hiddenarr.push(widgetObject);
                            //widgetObject.css("display", "none");
                            //tempDiv.append(widgetObject[0]);
                            $(widobj).css("display", "none");
                        }
                        dashboardObj.append(tempDiv.children[0]);
                    }
                    $(tempDiv).remove();
                    nextStep();

                }

                try {
                	/**Added settimeout to export hidden datagrid compoenets without header cuts**/
                	setTimeout(function() {
                		html2canvas(tempDiv, {
                            height: h,
                            width: w,
                            x: dashboardLeft + dashboardObj.offsetLeft,
                            y: dashboardTop,
                            logging: IsBoolean(dGlobals.isDevMode)
                        }).then(function(canvas) {
                            cb1(canvas);
                        });
                	},250);
                } catch (e) {
                    console.log(e);
                }
            }
        };

        var length = tempDiv.children.length;
        for (var k = 0; k < length; k++) {
            if (hiddenarr != undefined && (hiddenarr).indexOf(tempDiv.children[0]) > -1) {
                var val = (hiddenarr).indexOf(tempDiv.children[0]);
                var widobj = hiddenarr[val];
                //hiddenarr.push(widgetObject);
                //widgetObject.css("display", "none");
                //tempDiv.append(widgetObject[0]);
                $(widobj).css("display", "none");
            }
            dashboardObj.append(tempDiv.children[0]);
        }
        $(tempDiv).remove();

        if (j < componentsArray.length) {
            /**added this condition to check for array of group components added in script**/
            nextStep();
        } else {
            lastStep();
        }
    }
    try {
    	/**Added settimeout to export hidden datagrid compoenets without header cuts**/
    	setTimeout(function() {
    		html2canvas(tempDiv, {
           	 	height: h,
                width: w,
                x: dashboardLeft + dashboardObj.offsetLeft,
                y: dashboardTop,
                logging: IsBoolean(dGlobals.isDevMode)
           }).then(function(canvas) {
               cb(canvas);
           });
    	}, 250);
    } catch (e) {
        console.log(e);
    }
};

/** @description method will return right scrollbarwidth according to browser, can be overridden using script for componenet png export to remove scrollwidth **/
Plugin.prototype.getScrollBarWidth = function (temp) {
	if(temp.component.chartJson.m_repeaterscrollwidth == undefined) {
		return getScrollBarWidth();
	} else {
		return temp.component.chartJson.m_repeaterscrollwidth;
	}
};
Plugin.prototype.getExportPPTServieURL = function () {
	var url = base_url + req_url.designer.dashboardPPTService;
	if (url)
		return url;
	else
		return '//www.bdbizviz.com/BizVizEP/Parser';
};
Plugin.prototype.createExportIframe = function () {
	this.removeExportIframe();
	var iframe = document.createElement("iframe");
	document.body.appendChild(iframe);
	iframe.setAttribute('id', "exportIframe");
	iframe.style.display = "none";
	iframe.style.visibility = "hidden";
	iframe.style.width = "1px";
	iframe.style.height = "1px";
	return iframe;
};

/** @description Has to delete the iFrame from DOM, Otherwise all the previous event will be associated with it.
 * And on every click of exportPPT button, previous PPT's will also be exported */
Plugin.prototype.removeExportIframe = function () {
	$("#exportIframe").remove();
};
Plugin.prototype.exportToPPT = function () {
	var
	temp = this,
	canvas = temp.component.ctx.canvas,
	divSelector = "#draggableDiv" + temp.component.m_objectid,
	divObject = $(divSelector)[0],
	fileName = temp.exportFileName,
	pptHeading = temp.component.m_pptheading,
	pptSubHeading = temp.component.m_pptsubheading,
	imageData = null,
	arr = [];
//	if( !IsBoolean(temp.component.isMaximized) ){
//		$(divObject).css({
//			'position': 'fixed',
//			'top': "0px",
//			'left': "0px",
//			'height': ($(divObject).get(0).scrollHeight + getScrollBarWidth()) + 'px',
//			'width': ($(divObject).get(0).scrollWidth + getScrollBarWidth()) + 'px'
//		});
//	}
	//remove timeline chart svg rect animation to avoid export issue 
	if ( (temp.svgCharts.indexOf(temp.component.m_componenttype) > -1) && IsBoolean(temp.component.m_enableanimation)) {
		$(divObject).find("svg").find(".timeSeries-stackHighlighter").find("animate").remove();
		$(divObject).find("svg").find(".pointShapeColorAnimation").find("animate").remove();
		for(var i = 1; i<$(divObject).find("svg").find(".pointShapeColorAnimation").length; i= i+2){
			var color =$(divObject).find("svg").find(".pointShapeColorAnimation")[i-1].attributes[1].nodeValue;
			$(divObject).find("svg").find(".pointShapeColorAnimation")[i].setAttribute("stop-color", color);
		}
		$(divObject).find("svg").find(".pointShapeAnimation").find("animate").remove();
	}
	this.removeExportIframe();
	function cb(_canvas){
		imageData = _canvas.toDataURL("");
		arr = imageData.split(",");
		$.ajax({
			url : temp.getExportPPTServieURL(),
			data : {

				"image" : arr[1],
				"name" : fileName,
				"heading" : pptHeading ? pptHeading : " ",
				"subheading" : pptSubHeading ? pptSubHeading : " "
			},
			headers: {
				authtoken: parent.BIZVIZ.SDK.getAuthInfo().authToken,
				spacekey: parent.BIZVIZ.SDK.getAuthInfo().user.spaceKey,
				userid: parent.BIZVIZ.SDK.getAuthInfo().user.id
			},
			type : "POST",
			crossDomain : true,
			cache : false,
			success : function (_data) {
				var re = new RegExp("\<column>(.*?)\</column>");
				var matchedString = _data.match(re);
				var iframe = temp.createExportIframe();
				if(matchedString && matchedString[1]){
					var src =  matchedString[1].substr( matchedString[1].indexOf("://")+1);
					iframe.setAttribute('src', src);
					hideBlockUILoader();
				}else{
					alertPopUpModal({ type: "error", message: "Error in PPT export", timeout: '3000' });
				}
//				if( !IsBoolean(temp.component.isMaximized) ){
//					$(divObject).css({
//						'position': 'absolute',
//						'top': temp.component.m_top + 'px', 
//						'left': temp.component.m_left + 'px', 
//						'width': temp.component.m_width + 'px', 
//						'height': temp.component.m_height + 'px'
//					});
//				}
			},
			error : function () {
				alertPopUpModal({ type: "error", message: "Error in PPT export", timeout: '3000' });
//				if( !IsBoolean(temp.component.isMaximized) ){
//					$(divObject).css({
//						'position': 'absolute',
//						'top': temp.component.m_top + 'px', 
//						'left': temp.component.m_left + 'px', 
//						'width': temp.component.m_width + 'px', 
//						'height': temp.component.m_height + 'px'
//					});
//				}
			}
		});
		return false;
	};
	if(((isIE = false || !!document.documentMode) || (isFirefox = typeof InstallTrigger !== 'undefined')) && (temp.svgCharts.indexOf(temp.component.m_componenttype) > -1)) {
		imageData = replaceSvgWithCanvas(divObject);
		arr = imageData.split(",");
		$.ajax({
			url : temp.getExportPPTServieURL(),
			data : {

				"image" : arr[1],
				"name" : fileName,
				"heading" : pptHeading ? pptHeading : " ",
				"subheading" : pptSubHeading ? pptSubHeading : " "
			},
			headers: {
				authtoken: parent.BIZVIZ.SDK.getAuthInfo().authToken,
				spacekey: parent.BIZVIZ.SDK.getAuthInfo().user.spaceKey,
				userid: parent.BIZVIZ.SDK.getAuthInfo().user.id
			},
			type : "POST",
			crossDomain : true,
			cache : false,
			success : function (_data) {
				var re = new RegExp("\<column>(.*?)\</column>");
				var matchedString = _data.match(re);
				var iframe = temp.createExportIframe();
				if(matchedString && matchedString[1]){
					var src =  matchedString[1].substr( matchedString[1].indexOf("://")+1);
					iframe.setAttribute('src', src);
					hideBlockUILoader();
				}else{
					alertPopUpModal({ type: "error", message: "Error in PPT export", timeout: '3000' });
				}
			},
			error : function () {
				alertPopUpModal({ type: "error", message: "Error in PPT export", timeout: '3000' });
			}
		});
		return false;
	} else {
		/*
		html2canvas(divObject, {
			height: ($(divObject).get(0).scrollHeight),
			width: ($(divObject).get(0).scrollWidth),
			background: "#FFFFFF",
			onrendered : function (_canvas) {
				cb(_canvas);
			}
		});
		*/
		try{
			html2canvas(divObject, {
				height: ($(divObject).get(0).scrollHeight),
				width: ($(divObject).get(0).scrollWidth),
				backgroundColor: temp.component.m_exportdefaultbgcolor,
				logging: IsBoolean(dGlobals.isDevMode)
			}).then(function(canvas){
				cb(canvas);
			});
		}catch(e){
			console.log(e);
		}
	}
};

Plugin.prototype.exportToPDF = function() {
    var temp = this;
    /*@decsription added below variables for color changes in heading and sub heading of chart data */
    var hcolor = hex2rgb(temp.component.m_pdfheadingcolor);
    hcolor = pSBC(1 - temp.component.m_pdfheadingopacity, hcolor, false, false);
    hColor = hcolor.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    var shColor = hex2rgb(temp.component.m_pdfsubheadingcolor);
    shColor = pSBC(1 - temp.component.m_pdfsubheadingopacity, shColor, false, false);
    shColor = shColor.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    var hfColor = hex2rgb(temp.component.m_pdfhfontcolor);
    hfColor = hfColor.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    var shfColor = hex2rgb(temp.component.m_pdfshfontcolor);
    shfColor = shfColor.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
	var sl = $("#WatermarkDiv").scrollLeft();
	var st = $("#WatermarkDiv").scrollTop();
	 if (this.component.m_componenttype == 'decomposition_chart') {
       var coordinates = {
           "height": $("#" + this.component.chartSvg).height(),
           "width": $("#" + this.component.chartSvg).width()
       }
       $("#" + this.component.chartSvg).css("width", this.component.m_width);
       $("#" + this.component.chartSvg).css("height", this.component.m_height);
   }
    if (!IsBoolean(this.component.m_exporttopdfgrid.exportastable)) {
        var
            divSelector = "#draggableDiv" + temp.component.m_objectid,
            divObject = $(divSelector)[0],
            fileName = temp.exportFileName,
            pdfngrid = temp.component.m_exporttopdfngrid,
            heading = temp.component.m_pptheading,
            subHeading = temp.component.m_pptsubheading,
            //with and height is converted to mm unit
            width = temp.component.m_width * 0.264583333,
            height = temp.component.m_height * 0.264583333;

        if (width > 200) {
            width = 200;
        }

        /*DAS-56*/
        /*get legend data*/
        var legendObject = '',
            h = 0,
            w = 0,
            dashboardLeft = 0,
            dashboardTop = 0;
        if (temp.component.m_associatedlegendid) {

            var dashboardObj = $("#" + temp.component.m_chartContainer[0].id)[0];
            /*if legend is associated with chart*/
            var divObject1 = divObject;
            var divObject = document.createElement("div");
            divObject.id = "temp";
            dashboardObj.append(divObject);
            /*get chart top and left*/
            var componentLeft1 = divObject1.offsetLeft;
            var componentTop1 = divObject1.offsetTop;
            
            var legendComponent = "#draggableDiv" + temp.component.m_associatedlegendid;
            legendObject = $(legendComponent)[0];
            /*append associated legend component to div*/
            divObject.append(legendObject);
            h = legendObject.clientHeight;
            w = legendObject.clientWidth;

            var componentLeft2 = legendObject.offsetLeft;
            var componentTop2 = legendObject.offsetTop;
            
            /*get lowest left and top from chart and legend component*/
            dashboardLeft = (componentLeft1 < componentLeft2) ? componentLeft1 : componentLeft2;
            dashboardTop = (componentTop1 < componentTop2) ? componentTop1 : componentTop2;
            /*set legend width to zero if legend is at top or bottom*/
            if (componentLeft2 + w < componentLeft1 || componentLeft2 > componentLeft1 + width) {
                //do nothing
            } else {
                w = 10
            };
            /*when legend at left side of chart*/
            if (componentLeft2 < componentLeft1 && componentTop2 > componentTop1) {
                w += componentLeft1 - componentLeft2 + w;
            }
            /*check if legend at top then set margin height for canvas*/
            if (componentTop2 < componentTop1) {
                //h+=componentTop1-componentTop2+h;
            }
            divObject.append(divObject1);
        }
        /*append chart component to div*/
        //divObject.append(divObject1);
        //$(divObject).empty();
        //divObject.append(tempDiv);

        //	if( !IsBoolean(temp.component.isMaximized) ){
        //		$(divObject).css({
        //			'position': 'fixed',
        //			'top': "0px",
        //			'left': "0px",
        //			'height': ($(divObject).get(0).scrollHeight + getScrollBarWidth()) + 'px',
        //			'width': ($(divObject).get(0).scrollWidth + getScrollBarWidth()) + 'px'
        //		});
        //	}
        //remove timeline chart svg rect animation to avoid export issue 
        if ((temp.svgCharts.indexOf(temp.component.m_componenttype) > -1) && IsBoolean(temp.component.m_enableanimation)) {
            $(divObject).find("svg").find(".timeSeries-stackHighlighter").find("animate").remove();
            $(divObject).find("svg").find(".pointShapeColorAnimation").find("animate").remove();
            for (var i = 1; i < $(divObject).find("svg").find(".pointShapeColorAnimation").length; i = i + 2) {
                var color = $(divObject).find("svg").find(".pointShapeColorAnimation")[i - 1].attributes[1].nodeValue;
                $(divObject).find("svg").find(".pointShapeColorAnimation")[i].setAttribute("stop-color", color);
            }
            $(divObject).find("svg").find(".pointShapeAnimation").find("animate").remove();
        }
        this.removeExportIframe();
        var can = this.replaceSvgWithCanvasForexport(divObject);

        onrenderedHandler = function(_canvas) {
            var
                data = null,
                buffer = null,
                array = null,
                blob = null;
            if (!IsBoolean(pdfngrid)) {
                doc = new jsPDF();
            } else {
                doc.insertPage(1);
            } //added above conditions for checking to export as both pdf n grid or not
            var imageData = _canvas.toDataURL("image/jpeg");
            doc.setProperties({
                title: 'Export Component',
                subject: 'Export Component to PDF',
                keywords: 'BDB, Big Data BizViz, BizViz Technlogies Pvt. Ltd.',
                creator: 'www.bizviz.com'
            });

            var pageWidth = doc.internal.pageSize.getWidth() - 20;

            if (heading !== "") {
                doc.setDrawColor(220, 220, 220);
                doc.setFillColor(parseInt(hColor[1]), parseInt(hColor[2]), parseInt(hColor[3]));
                doc.setTextColor(parseInt(hfColor[1]), parseInt(hfColor[2]), parseInt(hfColor[3]));
                //added color values from variables instead of static
                doc.rect(10, 20, pageWidth, 10, 'F');
                doc.line(10, 20, (pageWidth + 10), 20);
                doc.setFontSize(15);
                doc.text(12, 27, heading);
            }

            if (subHeading !== "") {
                doc.setFillColor(parseInt(shColor[1]), parseInt(shColor[2]), parseInt(shColor[3]));
                doc.setTextColor(parseInt(shfColor[1]), parseInt(shfColor[2]), parseInt(shfColor[3]));
                //added color values from variables instead of static
                doc.rect(10, 30, pageWidth, 8, 'F');
                doc.line(10, 38, (pageWidth + 10), 38);
                doc.setFontSize(10);
                doc.text(12, 35, subHeading);
            }

            if (heading !== "" || subHeading !== "") {
                doc.addImage(imageData, "JPEG", 10, 40, width - 10, height);
            } else {
                doc.addImage(imageData, "JPEG", 10, 15, width - 10, height);
            }
            var tempelem = temp.newelements;

            for (var a = 0; a < tempelem.length; a++) {
                for (var b = 0; b < can.length; b++) {
                    if (tempelem[a].id == can[b].id) {
                        $(can[b]).remove();
                        $(tempelem[a]).show();
                        break;
                    }
                }
            }

            var pageCount = doc.internal.getNumberOfPages();

            // For each page, print the page number and the total pages
            for (var i = 1; i <= pageCount; i++) {
                // Go to page i
                doc.setPage(i);
                //Print Page 1 of 4 for example
                doc.text('Page ' + String(i) + ' of ' + String(pageCount), doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, null, null, "right");
            }

            data = doc.output();
            buffer = new ArrayBuffer(data.length);
            array = new Uint8Array(buffer);
            for (var i = 0, l = data.length; i < l; i++) {
                array[i] = data.charCodeAt(i);
            }
            blob = new Blob([array], {
                type: "application/pdf",
                encoding: "raw"
            });
            if (window.saveAs)
                window.saveAs(blob, fileName + ".pdf");
            else
                window.navigator.msSaveBlob(blob, fileName + ".pdf");

            //		if( !IsBoolean(temp.component.isMaximized) ){
            //			$(divObject).css({
            //				'position': 'absolute',
            //				'top': temp.component.m_top + 'px', 
            //				'left': temp.component.m_left + 'px', 
            //				'width': temp.component.m_width + 'px', 
            //				'height': temp.component.m_height + 'px'
            //			});
            //		}
            //saveAs( blob, fileName );
            if (temp.component.m_componenttype == 'decomposition_chart') {
                $("#" + temp.component.chartSvg).css("width", coordinates.width);
                $("#" + temp.component.chartSvg).css("height", coordinates.height);
            }
        };
        if (((isIE = false || !!document.documentMode) || (isFirefox = typeof InstallTrigger !== 'undefined')) && (temp.svgCharts.indexOf(temp.component.m_componenttype) > -1)) {
            var
                data = null,
                buffer = null,
                array = null,
                blob = null,
                doc = new jsPDF(),
                imageData = replaceSvgWithCanvas(divObject);
            doc.setProperties({
                title: 'Export Component',
                subject: 'Export Component to PDF',
                keywords: 'BizViz Technlogies Pvt. Ltd.',
                creator: 'www.bdbizviz.com'
            });

            if (heading !== "") {
                doc.setDrawColor(220, 220, 220);
                doc.setFillColor(parseInt(hColor[1]), parseInt(hColor[2]), parseInt(hColor[3]));
                doc.setTextColor(parseInt(hfColor[1]), parseInt(hfColor[2]), parseInt(hfColor[3]));
                //added color values from variables instead of static
                doc.rect(10, 20, 190, 10, 'F');
                doc.line(10, 20, (190 + 10), 20);
                doc.setFontSize(15);
                doc.text(12, 27, heading);
            }

            if (subHeading !== "") {
                doc.setFillColor(parseInt(shColor[1]), parseInt(shColor[2]), parseInt(shColor[3]));
                doc.setTextColor(parseInt(shfColor[1]), parseInt(shfColor[2]), parseInt(shfColor[3]));
                //added color values from variables instead of static
                doc.rect(10, 30, 190, 8, 'F');
                doc.line(10, 38, (190 + 10), 38);
                doc.setFontSize(10);
                doc.text(12, 35, subHeading);
            }

            if (heading !== "" || subHeading !== "") {
                doc.addImage(imageData, "JPEG", 10, 40, width, height);
            } else {
                doc.addImage(imageData, "JPEG", 10, 15, width, height);
            }

            var pageCount = doc.internal.getNumberOfPages();

            // For each page, print the page number and the total pages
            for (var i = 1; i <= pageCount; i++) {
                // Go to page i
                doc.setPage(i);
                //Print Page 1 of 4 for example
                doc.text('Page ' + String(i) + ' of ' + String(pageCount), doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, null, null, "right");
            }

            data = doc.output();
            buffer = new ArrayBuffer(data.length);
            array = new Uint8Array(buffer);
            for (var i = 0, l = data.length; i < l; i++) {
                array[i] = data.charCodeAt(i);
            }
            blob = new Blob([array], {
                type: "application/pdf",
                encoding: "raw"
            });
            if (window.saveAs)
                window.saveAs(blob, fileName + ".pdf");
            else
                window.navigator.msSaveBlob(blob, fileName + ".pdf");
            //saveAs( blob, fileName );
        } else {
            /*
            html2canvas(divObject, {
            	height: ($(divObject).get(0).scrollHeight),
            	width: ($(divObject).get(0).scrollWidth),
            	background: "#FFFFFF",
            	onrendered : onrenderedHandler
            });
            */
            try {
                if (h != 0) {
                    html2canvas(divObject, {
                        height: ($(divObject1).get(0).scrollHeight) + h,
                        width: ($(divObject1).get(0).scrollWidth) + w,
                        backgroundColor: temp.component.m_exportdefaultbgcolor,
                        x: (dashboardLeft + dashboardObj.offsetLeft - sl),
                        y: (dashboardTop - st),
                        logging: IsBoolean(dGlobals.isDevMode)
                    }).then(function(canvas) {
                        onrenderedHandler(canvas);
                    });
                } else {
                    html2canvas(divObject, {
                        height: ($(divObject).get(0).scrollHeight),
                        width: ($(divObject).get(0).scrollWidth),
                        backgroundColor: temp.component.m_exportdefaultbgcolor,
                        logging: IsBoolean(dGlobals.isDevMode)
                    }).then(function(canvas) {
                        onrenderedHandler(canvas);
                    });

                }
            } catch (e) {
                console.log(e);
            }
        }
    }
    if (IsBoolean(this.component.m_exporttopdfgrid.exportastable) || IsBoolean(this.component.m_exporttopdfngrid)) {
        var
            fileName = temp.exportFileName,
            heading = temp.component.m_pptheading,
            subHeading = temp.component.m_pptsubheading,
            pdfngrid = temp.component.m_exporttopdfngrid,
            rowdata = [],
            columns = [],
            columnHeads = [],
            allColumnHeads = this.showChartData.getColumnHeads(),
            headKeys = ['title', 'dataKey'],
            alertColorRow = [],
            textAlign = [];
        for (var i = 0; i < allColumnHeads.columnHeads.length; i++) {
            var map = {};
            if ((this.component.m_objecttype == "datagrid" || this.component.m_objecttype == "scorecard") || (this.component.m_objecttype == "chart" || this.component.m_objecttype == "funnel")) {
                for (var j = 0; j < headKeys.length; j++) {
                    map[headKeys[j]] = headKeys[j] == 'title' ? allColumnHeads.columnHeads[i].title : allColumnHeads.columnHeads[i].field;
                }
                columnHeads.push(map);
            }
        } /*Changes done for supporting all charts exports */
        for (var i1 = 0; i1 < this.component.getDataProvider().length; i1++) {
            var rows = {};
            var alertColors = {};
            var align = {};
            for (var j = 0, k = 0; j < allColumnHeads.columnNames.length; j++) {
                var val = this.component.getDataProvider()[i1][allColumnHeads.columnNames[j].field];
                if ((this.component.m_objecttype == "datagrid" || this.component.m_objecttype == "scorecard") && (IsBoolean(this.component.m_seriesVisibleArr[allColumnHeads.columnNames[j].field]))) {
                    align[k] = ((this.component.m_objecttype == "scorecard") || (this.component.m_datagridtype == "DynamicDatagrid")) ? this.component.m_textAlignArr[allColumnHeads.columnNames[j].field] : this.component.m_textAlignArr[k];
                    rows[columnHeads[k].dataKey] = (val !== "") ? this.component.getFormattedCellValue(val, columnHeads[k].dataKey, k) : val;
                    if (this.component.getAlertObj()[allColumnHeads.columnNames[j].field] != undefined) {
                        if (IsBoolean(this.component.getAlertObj()[allColumnHeads.columnNames[j].field].getDynamicRange()) && this.component.m_datagridtype != "DynamicDatagrid") {
                            var color = this.component.getAlertObj()[allColumnHeads.columnNames[j].field].getCellBackGroundColor(allColumnHeads.columnNames[j].field, j, val, rows, i1);
                            var colorUpdated = (color[0] != "#") ? rgb2hex(color) : color;
                            alertColors[k] = colorUpdated;
                        } else {
                            var compareColName = this.component.getAlertObj()[allColumnHeads.columnNames[j].field].m_comparecolumn;
                            var comapreColData = this.component.getDataProvider()[i1][compareColName];
                            var tempObj = this.component.getAlertObj()[allColumnHeads.columnNames[j].field].drawGridAlerts(comapreColData, val, j);
                            alertColors[k] = tempObj.colorCode;
                        }
                    }
                    k++;
                } else if ((this.component.m_objecttype == "chart") || (this.component.m_objecttype == "funnel")) {
                    // && (IsBoolean(this.component.m_seriesVisibleArr[allColumnHeads.columnNames[j].field]) || IsBoolean(this.component.m_categoryVisibleArr[allColumnHeads.columnNames[j].field]))
                    /* Added below block to check whether the component is circumplex and groupbar chart,
                    	because they have subcategory names which are converted to NaN when getFormaterForToolTip is called*/
                    switch (this.component.m_componenttype) {
                        case "circumplex_chart":
                        case "group_bar_chart":
                            if (_.contains(this.component.m_categoryNames, allColumnHeads.columnNames[j].field) || _.contains(this.component.m_subCategoryNames, allColumnHeads.columnNames[j].field)) {
                                rows[columnHeads[k].dataKey] = val;
                            } else {
                                rows[columnHeads[k].dataKey] = (val !== "") ? this.component.getFormatterForToolTip(val) : val;
                            }
                            break;
                        case "project_timeline_chart":
                        case "trellis_chart":
                            rows[columnHeads[k].dataKey] = val;
                            break;
                        default:
                            if (_.contains(this.component.m_categoryNames, allColumnHeads.columnNames[j].field)) {
                                rows[columnHeads[k].dataKey] = val;
                            } else {
                                rows[columnHeads[k].dataKey] = (val !== "") ? this.component.getFormatterForToolTip(val) : val;
                            }
                            break;
                    }
                    k++;
                }
            }
            rowdata.push(rows);
            alertColorRow.push(alertColors);
            textAlign.push(align);
        }
        var doc = new jsPDF(temp.component.m_exporttopdfgrid.orientation, 'mm');
        /** DAS-1022 @desc adding arial font base64 to support currency symbol in pdf */
        var customfont ='AAEAAAAZAQAABACQRFNJR7d+U2oADdwwAAAa3EdERUaxP7OhAAxLJAAAAzRHUE9Tg8boRAAMTlgAASD4R1NVQv4PFEsADW9QAABsWkpTVEZtKmkGAA3brAAAAB5MVFNIexA4xgAARKwAABCRT1MvMhQyXYQAAAIYAAAAYFBDTFT9ez5DAAxK7AAAADZWRE1YUJJq9QAAVUAAABGUY21hcH7INSsAAfRcAAAmamN2dCCtv9+OAAIyqAAABm5mcGdtOKUWKwACGsgAAAuwZ2FzcAAZACEADErcAAAAEGdseWYu4fkXAAJ7UAAJjhBoZG14wjxZ4QAAZtQAAY2IaGVhZOZkPEQAAAGcAAAANmhoZWESMxlWAAAB1AAAACRobXR4tA2jEgAAAngAAEI0a2VybjdhOTYADAlgAAAVYGxvY2FT/X2sAAI5GAAAQjhtYXhwFoMJrwAAAfgAAAAgbWV0YQXNzMMADdvMAAAAYm5hbWU100zCAAwewAAAK/pwb3N0/yoAlgAMSrwAAAAgcHJlcKGy6OoAAiZ4AAAMLwABAAAABuZm/ZugkV8PPPUIGwgAAAAAAKLjJyoAAAAA0Z3j/fqv/WcQAAhRAAAACQABAAEAAAAAAAEAAAc+/k4AQxAA+q/6ehAAAAEAAAAAAAAAAAAAAAAAABCNAAEAABCNArUAPADKAAcAAgAQAEAAhgAABRcF7AAFAAIAAwOIAZAABQAIBZoFMwAAARsFmgUzAAAD0QBmAhIIBQILBgQCAgICAgTgAC7/wAB4QwAAAAkAAAAAVE1DIABAACD//AXT/lEBMwc+AbJAAAH///8AAAQmBbsAAAAgABUGAAEAAAAAAAI5AAACOQAAAjkAsALXAF4EcwAVBHMASQcdAHcFVgBYAYcAWgKqAHwCqgB8Ax0AQASsAHICOQCqAqoAQQI5ALoCOQAABHMAVQRzAN8EcwA8BHMAVgRzABoEcwBVBHMATQRzAGEEcwBTBHMAVQI5ALkCOQCqBKwAcASsAHIErABwBHMAWggfAG8FVv/9BVYAlgXHAGYFxwCeBVYAogTjAKgGOQBtBccApAI5AL8EAAA3BVYAlgRzAJYGqgCYBccAnAY5AGMFVgCeBjkAWAXHAKEFVgBcBOMAMAXHAKEFVgAJB40AGQVWAAkFVgAGBOMAKQI5AIsCOQAAAjkAJwPBADYEc//hAqoAWQRzAEoEcwCGBAAAUARzAEYEcwBLAjkAEwRzAEIEcwCHAccAiAHH/6IEAACIAccAgwaqAIcEcwCHBHMARARzAIcEcwBIAqoAhQQAAD8COQAkBHMAgwQAABoFxwAGBAAADwQAACEEAAAoAqwAOQIUALwCrAAvBKwAVwVW//0FVv/9BccAaAVWAKIFxwCcBjkAYwXHAKEEcwBKBHMASgRzAEoEcwBKBHMASgRzAEoEAABQBHMASwRzAEsEcwBLBHMASwI5AL0COQAjAjn/5QI5AAkEcwCHBHMARARzAEQEcwBEBHMARARzAEQEcwCDBHMAgwRzAIMEcwCDBHMASQMzAIAEcwBrBHMAGwRzAFECzQBtBEwAAQTjAJkF5QADBeUAAwgAAOECqgDeAqoAPQRkAE4IAAABBjkAUwW0AJoEZABOBGQATQRkAE0Ec//9BJwAoAP0ADgFtAB6BpYAoQRkAAACMQAAAvYALwLsAC0GJQB/Bx0ARATjAIEE4wCeAqoA6ASsAHIEZABUBHMALgRkADME5QAaBHMAhgRzAIwIAADvBVb//QVW//0GOQBjCAAAgQeNAFIEc//8CAAAAAKqAFMCqgBHAccAgAHHAGwEZABOA/QALwQAACEFVgAGAVb+OQRz/+QCqgBcAqoAXAQAABcEAAAXBHMASQI5ALkBxwBsAqoARwgAACUFVv/9BVYAogVW//0FVgCiBVYAogI5AI0COf/gAjkABAI5ABUGOQBjBjkAYwY5AGMFxwChBccAoQXHAKECOQDGAqoAGQKqAAYCqgAdAqoALgKqAOUCqgCiAqoAawKqADoCqgBLAqoAKARzAAABxwADBVYAXAQAAD8E4wApBAAAKAIUALwFx//9BHMASQVWAAYEAAAhBVYAngRzAIcErAByBKwAoQKqAGsCqgAZAqoAIQasAGsGrABrBqwAIQRzAAAGOQBtBHMAQgI5ALEFVgBcBAAAPwXHAGYEAABQBccAZgQAAFAEcwBGBGv/4QKqAO4FVv/9BHMASgVW//0EcwBKBccAngTrAEcFx//9BVYAogRzAEsFVgCiBHMASwRzAJYBxwBCBHMAlgJVAIgEcwCWAqwAgwXHAJwEcwCHBccAnARzAIcGOQBjBHMARAXHAKECqgCFBccAoQKqADwFVgBcBAAAPwTjADACOQAkBOMAMAMAACMFxwChBHMAgwXHAKEEcwCDBOMAKQQAACgE4wApBAAAKARoAKQGOQBgBmIAVQSgAEgEdABIA5EAYgTwAEQDKQAuBTAASARr/+EEAACwAusAUgjAADMIAABPBAAAmQgAAE8EAACZCAAATwQAAJgEAACYB9UBagXAAJ4EqwByBNUAnQSsAHEE1QIiBNUBBQWr/+kFAAHJBasCfgWr/+kFqwJ+Bav/6QWrAn4Fq//pBav/6QWr/+kFq//pBav/6QWrAcAFqwJ+BasBwAWrAcAFq//pBav/6QWr/+kFqwJ+BasBwAWrAcAFq//pBav/6QWr/+kFqwJ+BasBwAWrAcAFq//pBav/6QWr/+kFq//pBav/6QWr/+kFq//pBav/6QWr/+kFq//pBav/6QWr/+kFq//pBav/6QWr/+kFq//pBasC1gWrAGYFq//qBdX//wTVAJIIAAAAB+sBMAfrASAH6wEwB+sBIATVALIE1QCABNUAKggrAZgIawG4B1UAEAYAAPQGAABvBEAAOgVAADcEwAA/BBUAQAQAACUGAABVBeEAvwONAIgE1f/ZAYAAgALVAIAHFQBhApYADwTVAJIC1gCDAtYAgwTVALIC1gBwBVb//QRzAEoFxwBmBAAAUAXHAGYEAABQBVYAogRzAEsFVgCiBHMASwVWAKIEcwBLBjkAbQRzAEIGOQBtBHMAQgY5AG0EcwBCBccApARzAIcFxwAfBHMABgI5/84COf/OAjn/5AI5/+QCOf/2Ajn/9QI5AEsBxwAZBAAANwHH/6IFVgCWBAAAiAQAAIYEcwCWAccAagXHAJwEcwCHBckApQRzAIsGOQBjBHMARAY5AGMEcwBEBccAoQKqAGoFVgBcBAAAPwTjADACOQAMBccAoQRzAIMFxwChBHMAgwXHAKEEcwCDBccAoQRzAIMHjQAZBccABgVWAAYEAAAhAccAiQVW//0EcwBKCAAAAQcdAEQGOQBTBOMAgQI5ALkHjQAZBccABgeNABkFxwAGB40AGQXHAAYFVgAGBAAAIQHHAIoCqv/hBHMAGwTNAFoGrABrBqwAIgasACIGrABKAqoA4gKqAGsCqgDeAqr/6gVX//8GRv+nBrT/qAMS/6gGMv+nBtj/pwYF/6cBx/94BVb//QVWAJYFWP/+BVYAogTjACkFxwCkAjkAvwVWAJYFWAALBqoAmAXHAJwFMwBt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ArMAXwKzAF8CswBfArMAOAKzADgCswBJArMASQPpAEoD6QBKA+kASgPpAEoD6QBKA+kASgPpAEoD6QBKA+kASgPpAEoD6QBKA+kASgPpAEoD6QBKA+kASgPpAEoGkgA+BpIAPgQ//7oEP/+6BpIAPgaSAD4EP/+6BD//ugaSAD4GkgA+BD//ugQ//7oIyQA+CMkAPgbF/7oGxf+6CMkAPgjJAD4Gxf+6BsX/ugSn/7oEp/+6BFoAKgOaADYENf+6Ayf/ugZPACcGTwAnBk8AJwIk/7oCGv+6Bk8AJwZPACcCJP+6Ahr/ugZPACcGTwAnAiT/ugIa/7oGTwAnBk8AJwIk/7oCGv+6Bk8AJwZPACcCJP+6Ahr/ugSnAEYEpwBGBKcARgSnAEYJPgAyCT4AMgdA/7oHQP+6Bn8AFAd2ABQDJ/+6BB7/ugTPAC0EzwAtAyf/ugMn/7oEzwAtBM8ALQMn/7oDJ/+6BM8ALQTPAC0DJ/+6Ayf/ugZ/ABQHdgAUAyf/ugQe/7oGfwAUB3YAFAMn/7oEHv+6Bn8AFAd2ABQDJ/+6BB7/ugZ/ABQHdgAUAyf/ugQe/7oGfwAUB3YAFAMn/7oEHv+6BA0ARwQNAEcBqP+6Aaj/ugQNAEcEDQBHAaj/ugGo/7oEDQBHBA0ARwGo/7oBqP+6BA0ARwQNAEcBqP+6Aaj/ugQ1AEUENQBFAfT/ugH0/7oENQBFBDUARQQ1AEUENQBFBDUARQQ1AEUB9P+6AfT/ugQ1AEUENQBFBIEANgQ1ADYEPf+6BD3/ugJCADYDAP/3AxoAGgMaABoDGgAaA3UAMgN1ADIDdQAyA3UAMgN1ADIDdQAyA3UAMgN1ADIDdQAyA3UAMgN1ADIDdQAyA3UAMgN1ADIDdQAyA3UAMgUb/7oEtf+6BRsAMgS1ACQB9P+6AfT/ugN1ADIDdQAyBRsAMgS1ACQB9P+6AfT/ugUbADIEtQAkBn8ARQZ/AEUGfwBFBn8ARQGoACgAAP4pAAD+ogAA/vMAAP8dAAD/EgAA/5IAAP5+CPwAMgitADIAAP+IAAD/rwAA/z8AAP9kAAD+fgAA/zYBjQAAAvb//QAA/oIAAP8QBM0AMgAA/1gAAP9YAAD/ZAaSAD4GkgA+BD//ugQ//7oIyQA+CMkAPgbF/7oGxf+6BFoAKgOaADYENf+6Ayf/ugNNAHkCtAAjAkIANgH0/7oCkP+6AfQALwH0ADsB9AASAfQAsQH0AG0GfwAUB3YAFAH5AJsAAP7gArwAAAPyAJsEWv/1BM7/9QRaAFMEzgBKBFoAUwTOAEoEWgBTBM4ASgRaAFMEzgBKBFoAUwTOAEoEWgBTBM4ASgQ1AHEENQCtBFoADwTOAA8EcwAUBhEAFAVAAKcEcwCGBUAACgRzAAoFxwBRBccAZgQAAFAFx//9BnoAFAVAAEoEcwBGBHQASAVWAG4E1QBTBOP/xAY5AG0E/gAPBwwAhwHHAIMCOQAfBVYAlgQAAIgBxwAVBAAAGAcgAKQFx/+4BHMAiwY5AGAG8gBjBVcARAYJABQEcwCGBVYAngVWAGsEAABPBPIAlAMLAEQCOQAkBOMAFAI5ACQE4wAwBfsAYQXHAKEGLgAQBAAAIQTjACkEAAAoBOMAKQTjADEEXABEBFwAPwRzADwEcwBVA6sAMgPlACQEcwCHAhQAvANOALwErAByAjkAsAqqAJ4JxwCeCGQARgh/AJYGqgCWA5wAgwnHAJwHjgCcBisAhwRzAFUFVv/9BHMASgAA/v4FVv/9BHMASggAAAEHHQBEBjkAbQRzABoGOQBtBHMAQgVWAJYEAACIBjkAYwRzAEQGOQBjBHMARATjACkEXABMAcf/ogqqAJ4JxwCeCGQARgY5AG0EcwBCCEYApATyAJ4FxwCcBHMAhwVW//0EcwBKBVb//QRzAEoFVgCiBHMASwVWAKIEcwBLAjn/igI5/2QCOQAEAjn/9gY5AGMEcwBEBjkAYwRzAEQFxwChAqr/zAXHAKECqgBoBccAoQRzAHYFxwChBHMAgwVWAFwEAAA/BOMAMAI5ACQEXABRA34AEwXHAKQEcwCHBaYApATWAF4EhgBeBOMAKQQAACgFVv/9BHMASgVWAKIEcwBLBjkAYwRzAEQAAP79BjkAYwRzAEQGOQBjBHMARAY5AGMEcwBEBVYABgQAACEEcwBXBHMASARzAIYEcwCGBAAAEwQAAFAEcwBGBHMARgRzAFUF6QBVA6sASQOrADIFDQAyBA8ARAI5/7kEcwBCBHMAQgR4AFAEAgAZBO8AGQRzAIsEcwCHBHMAhwHHABkBxwBXAtkARAKeAAACbgAUAccAgwSTAIMGqgCEBqoAhAaqAIcEc/+mBHMAiwRsAIcEcwBEBlMARAY/AFcEZgBEAqr/5AKq/+QCqv/kAqoAhQKqAIUCqgCFAqr/5ARVAIoEVQCKBAAAPwHH/6ICFP+5Acf/cgLLAAACOQAPAjkAJARzABkEjABUBGAAiAQAABoFxwAGBAAAGAQoABkEAAAoBFQAKARcAEwEXAB5BAAAJAQAAFAEAAAkBAAAUAY5AGMEQACIBA8ASQR4AFAEawCIAy4AAAQAAAgDOwCIBHMASAQAACQEAABQB7cARgdAAEYICwBGBbMAJANvACQFwAAkBhwAEwVKAIMFDwCDA+IAHgQ4AGMDEQBkAxEAZAFG/84B6wBkAesAAAHrAAAC6gBkA9kAAAKRAAABhwBaAtcAXgHHAIABxwBsAccAigKqAPsCqgD7AsoAMgLKADIErABwBKwAcASsAGUErABlAqoBIQKqAN4CqgBZAqoBIQKqAB0CqgBZAqoA3gI5ALYCOQC2AqoA+wKqAPsCqgCmAqoApgKqAKYCqgAdAqr/4gKq//sClAAAAUIAZAK4ADICoAAAAsoAMgMQAJYDEACWAxAAlgMQAJYDEACWAqoAYgKqAGICqgAoAqoAHQKqAEcEVwCWBFcAlgRXAJYEVwCWBFcAQwRXAEMEVwBDBFcAQwRXAEMDEABDBFcALwRXAC8EVwAvBFcALwRXAC8DEAAvBFcAJQRXACUEVwAlBFcAJQRXACUDEAAvBFcAGgRXABoEVwAaBFcAGgRXABoDEAAaBFcAQgRXAEIEVwBCBFcAQgRXAEIDEABCBFcAlgRXAJYEVwCWBFcAlgRXAEIEVwBCBFcAQgRXAEIEVwBCAxAAQgRXAC8EVwAvBFcALwRXAC8EVwAvAxAALwRXAC8EVwAvBFcALwRXAC8EVwAvAxAALwRXACYEVwAmBFcAJgRXACYEVwAmAxAAJgRXAEIEVwBCBFcAQgRXAEIEVwBCAxAAQgRXAJYEVwCWBFcAlgRXAJYEVwBCBFcAQgRXAEIEVwBCBFcAQgMQAEIEVwAmBFcAJgRXACYEVwAmBFcAJgMQACYEVwAjBFcAIwRXACMEVwAjBFcAIwMQACMEVwAvBFcALwRXAC8EVwAvBFcALwMQAC8EVwBLBFcASwRXAEsEVwBLBFcASwMQAEsEVwCWBFcAlgRXAJYEVwCWBFcAQgRXAEIEVwBCBFcAQgRXAEIDEABCBFcAGgRXABoEVwAaBFcAGgRXABoDEAAaBFcAJARXACQEVwAkBFcAJARXACQDEAAkBFcALwRXAC8EVwAvBFcALwRXAC8DEAAvBFcATgRXAE4EVwBOBFcATgRXAE4DEABOBFcAlgRXAJYEVwCWBFcAlgAA/sEAAP7GAAD9rAAA/tgAAP+SAAD+6QAA/0wAAP6gAAD+xAAA/84AAP9mAAD+oAAA/tgAAP7YAAD/lwAA/5gAAP+ZAAD/9AAA/0IAAP9CAAD/RAAA/18AAP6HAAD/7AAA/6YAAP9RAAD/UQAA/1EAAP7JAAD/HAAAAAAAAP7pAAD/TAAA/5MAAP8qAAD/VgAA/84AAP6HAAD+uwAA/sQAAP7EAAD+2AAA/tgAAP6zAAD+yQAA/a0AAP7IAAD+swAA/skAAP2tAAD+FgAA/uYAAP+mAAD+hwAA/0QAAP66AAD/IwAA/5oAAP2sAAD+iAAAAAAAAP6wAAD/mAAA/pMAAP+mAAD+hwAA/hwAAP9mAAD/RAAA/rAAAP6wAAD+sAAA/wMAAP9SAAD9HwAA/1MAAP9TAAD/UwAA/rUAAP61AAD/wwAA/q4AAP7cAAD+xwAA/sgAAP7cAAD+HgAA/0IAAP9RAAD+twAA/rACqgDeAqoAWQKqAPoEmgBwBGAAAAYuABQHqgAABi4AFAR7AEwGPwBXBM8ARAY5AGMEcwBEBccAcAQAAFAE4wCoAzsAiAT/AAAEPAAyBg0ACgSdAEIHIACkBqoAhAVlAGMEcwCLBWQApAQAAAoFVgBrBVYAawTgAAUExQAZBeUAXwRuAEQDtgAUA0cAKATPAEQElQBbBAAAUAHH/6IGOQBgA4kATQOJAFAFVgCiBcAAoQRzAEsEeACHCrQAbQT+ABAGOQAUBOcAFAeZAL8FtQCIBVgAAQQAAAYHLgC/BZAAiAahAHgFewB6CG0AvwbwAIgE1QBmA6sAHwZfADkFggBIBjkAYARzAEQGbQAJBQwAGgZtAAkFDAAaCJgAYwcsAEQGqgAgBOYAHAmHAG0G0ABQAAD+Nwq0AG0E/gAQBccAZgQAAFAEBwAUAAD+pgAA/rwAAP+YAAD/mAAA/CsAAPxMBcAAoQR4AIcFQAAEBCsAFAVWAJ4EcwCHBV0ApARkAIgE1QBOA6sAMgSpAAQDgAAABe8AKQRJACgHCQCkBS8AiAkYAKAG9gCIBgYAPgQrACMFxwBmBAAAUATjADADqgAmB2cAMQWHACYFVQBXBCsARQbkAAoFVAAKBuQACgVUAAoCOQC/B2MABwVa//sFVwChBGgAhgVAABIEqwAYBccApARrAIgFxwCkBGsAiAVVAFcEKwBFBqoAmAWAAIwCqgAuBVb//QRzAEoFVv/9BHMASggAAAEHHQBEBVYAogRzAEsGBQBjBHMAVQdjAAcFWv/7BNUATgOrADIE1QBOBFwATAXAAKEEeACHBcAAoQR4AIcGOQBjBHMARAY5AGAEcwBEBcAASgQVACsFFQAKBAAAIQUVAAoEAAAhBRUACgQAACEFVQBXBCsARQcVAKgFwACLBUAASgRzAEYHvwBKBwMARgemAGYGhgBTBU0AZgQTAFMHwwASB0cAGAhGAKQHBwCIBjkAbQR4AFAF+QAwBVMAJgAA/0MAAP8pAAD/agAA/6wAAP9ZAAD/VgAA/3MAAP7XAAD+XAAAAF4AAP9WAAD/VgAAAFAAAP8LAAD+VQAA/0MAAP9cAAD/dQAA/2QAAP9WAAD/CwAA/4oAAP9WAAD/QwAA/0MAAP9kAAD/dQAAAFAAAP3dAAD/dQAA/60AAP7+AAD+/gAA/t8AAP7fAAD/WAAA/yAAAP7+BVb//QRzAEoFVgCWBHMAhgVWAJYEcwCGBVYAlgRzAIYFxwBmBAAAUAXHAJ4EcwBGBccAngRzAEYFxwCeBHMARgXHAJ4EcwBGBccAngRzAEYFVgCiBHMASwVWAKIEcwBLBVYAogRzAEsFVgCiBHMASwVWAKIEcwBLBOMAqAI5ABMGOQBtBHMAQgXHAKQEcwCHBccApARzAIcFxwCkBHMAhwXHAJMEcwBoBccApARzAIcCOf/fAcf/kgI5ACACOQAGBVYAlgQAAIgFVgCWBAAAiAVWAJYEAACIBHMAlgHHAH4EcwCWAcf/uQRzAJYBx/+lBHMAlgHH/6MGqgCYBqoAhwaqAJgGqgCHBqoAmAaqAIcFxwCcBHMAhwXHAJwEcwCHBccAnARzAIcFxwCcBHMAhwY5AGMEcwBEBjkAYwRzAEQGOQBjBHMARAY5AGMEcwBEBVYAngRzAIcFVgCeBHMAhwXHAKECqgCFBccAoQKqAIUFxwChAqoAXgXHAKECqgAmBVYAXAQAAD8FVgBcBAAAPwVWAFwEAAA/BVYAXAQAAD8FVgBcBAAAPwTjADACOQAkBOMAMAI5ACQE4wAwAjn//wTjADACOQAOBccAoQRzAIMFxwChBHMAgwXHAKEEcwCDBccAoQRzAIMFxwChBHMAgwVWAAkEAAAaBVYACQQAABoHjQAZBccABgeNABkFxwAGBVYACQQAAA8FVgAJBAAADwVWAAYEAAAhBOMAKQQAACgE4wApBAAAKATjACkEAAAoBHMAhwI5AAMFxwAGBAAAIQRzAEoBxwCJBKAASASgAEgEoABIBKAASASgAEgEoABIBKAASASgAEgFVv/9BVb//QaCABMGggATBoIAEwaCABMGggBWBoIAVgORAGIDkQBiA5EAYgORAGIDkQBiA5EAYgYeAAAGHgAAB2wAAAdsAAAHbAAAB2wAAARzAIsEcwCLBHMAiwRzAIsEcwCLBHMAiwRzAIsEcwCLBo8AAAaPAAAIHwAACB8AAAgfAAAIHwAACB//8wgf//MBxwCBAccAgQHH/5sBx/+bAcf/6wHH/+sBx/+iAcf/ogMBAAADAQAABJEAAASRAAAEkQAABJEAAASR//MEkf/zBHMARARzAEQEcwBEBHMARARzAEQEcwBEBp0AAAadAAAILQAACC0AAAfJAAAHyQAABGAAiARgAIgEYACIBGAAiARgAIgEYACIBGAAiARgAIgGggAAB64AAAgSAAAHrgAGBj8AVwY/AFcGPwBXBj8AVwY/AFcGPwBXBj8AVwY/AFcGXwAABl8AAAfvAAAH7wAAB4sAAAeLAAAHi///B4v//wSgAEgEoABIA5EAYgORAGIEcwCLBHMAiwHH/+YBxwBoBHMARARzAEQEYACIBGAAiAY/AFcGPwBXBKAASASgAEgEoABIBKAASASgAEgEoABIBKAASASgAEgFVv/9BVb//QaCABMGggATBoIAEwaCABMGggBWBoIAVgRzAIsEcwCLBHMAiwRzAIsEcwCLBHMAiwRzAIsEcwCLBo8AAAaPAAAIHwAACB8AAAgfAAAIHwAACB//8wgf//MGPwBXBj8AVwY/AFcGPwBXBj8AVwY/AFcGPwBXBj8AVwZfAAAGXwAAB+8AAAfvAAAHiwAAB4sAAAeL//8Hi///BKAASASgAEgEoABIBKAASASgAEgEoABIBKAASAVW//0FVv/9BVb//QVW//0FVv/9AqoA5QKqAP0CqgDlAqoABgKqAAYEcwCLBHMAiwRzAIsEcwCLBHMAiwaCAAAGggAABvMAAAbzAAAFxwCkAqoAEwKqABMCqgAGAcf/uwHH/6sBx//KAcf/ygHH/5MBx/+TAjkAGgI5//UDZQAAA2UAAAKqABMCqgATAqoABgRgAIgEYACIBGAAiARgAIgEjQCDBI0AgwRgAIgEYACIBVYABgVWAAYG5gAABxgAAAYeAAACqv/qAqr/6gKqAFkGPwBXBj8AVwY/AFcGPwBXBj8AVwdlAAAGnQAABycAAAZfAAAF+wBhAqoA3gKqAOUEcwANBccAZgXHAGYGqgCHBccAJAlQAKEHjQAZBVYAHwTjADAIAAApBAAAMATBAGYAAP9TAAD/UwAA/1MAAP9TAccAGQHH/6IEKwAFBVYAEQV0AEYCy/+jBXoAhwLw/8gFfwAKBX8ACgKqAIQCqgCEAqoAyQKqAMkCqgCgAqoAWQKq/68CqgA6AqoABgI5ALkCqgCpAqoAqQKqAKkCqgCpAy4AHgMuAB4CqgA6AAD/cwAA/6UAAP7YAAD/IwAA/3IAAP9yAAD+5wAA/6UAAP9TAAD/UwAA/1MFVgCeBHMAhwP4ABkF+wAZBx0ARARAABkEAABQBGkAhwRpABkD6wCHA6sAMgHHAIgDYQBBBAAAiAM2ABAFgACMBHgAhwRzAEQEAAATBN4ARATeAEQE3gANB40AUAOoAEQEcwBEBHMARAQrAIQEVQAfBFUAHwOqACYEYACIBMYARAXeAEQExgBEBAAAGgXHAAYEAAAoA6sAMgNrAD8E2wAfAusAiAQAABoEVQCIBCsAhAW0AHoEqwAYA6AAAAVPAAADUQAyA1H/0QOYADIDSAAyA0gAMgP4ADIDbgAyAVYAaQKEAC0DZgAyAtAAMgQVADIDcQAyA28AMgQYADIDDwAyA1kAMgOcADIDdgAxA28AMgT7AAAC+gAyAvoAMgMEADIEzAAyAwUAZAMFADIC+QAyAvkAMgKMADICjAAyAwQAMgFCAGQCtgBkBJUAZAMPAGQDBQAyAtUAMgMFADIDBQAyAwYAZAHCADIDDwBkA0IAMgSVAGQCkgAAAyAAAAMVAGQCkgAAAwYAMgOFADICvwAAAUIAZAHrAGQDDwBkApIAAAMVAGQCkgAAAwkAMgOFADICvwAAB30ARgpmAEYDgwBGCi8ARgVB/7oB6QA8BFoAEQAA/w0AAP81AAD+zgAA/rcAAP7JAAD/zwAA/08AAP+eAAD+ygKzAF8CswBfA+kASgPpAEoDmv+6Ayf/ugOa/7oDJ/+6Ba0AaQU9AC0F/QCWBNwAUATgADwF9gCbBT8AKAZQACgErAByAAAAAAAAAAAAAAAABHP//AKqAFMC1f/OAaj/ugGo/7oBqP+6Aaj/ugZYABUJxQBHBAAAAAgAAAAEAAAACAAAAAKrAAACAAAAAVUAAARzAAACOQAAAZoAAACrAAAAAAAABeUAAwXHAGYGqgCYBYAAjAdEAIMHGABGBxgASAVW//0FxwBmBAAAFARzAAoE4wAwBAAATwQAACgEpQAdAAABAgAA/0IAAP6/AAD/OgAA/1MEjQAKBccAUQXHAGYFxwBRBFUAoQLrAIgAAP9DAAD/rAAA/6wC0gCWAAAAAAIa/7oCUAAeAAD/OgAA/1sAAP9fAAD/fgAA/5QAAP9KAAD+nAW1ADoFtQA6AfT/lgH0/5YFtQA6BbUAOgH0/7oB9P+6BbUAOgW1ADoB9P+6AfT/ugW1ADoFtQA6AfT/ugH0/7oFtQA6BbUAOgH0/7oB9P+6BbUAOgW1ADoB9P+6AfT/ugW1ADoFtQA6AfT/ugH0/7oEgQA2BDUANgQ9/7oEPf+6BIEANgQ1ADYEPf+6BD3/ugKzADICswAyArMAXwKzAF8D6QBKA+kASgaSAD4GkgA+BD//ugQ//7oEWgAqA5oANgQ1/7oDJ/+6BFoAKgOaADYENf+6Ayf/ugRaACoDmgA2BDX/ugMn/7oGTwAnBk8AJwIk/7oCGv+6Bk8AJwZPACcCJP+6Ahr/ugZ/ABQHdgAUAyf/ugQe/7oGfwAUB3YAFAMn/7oEHv+6Bn8AFAd2ABQDJ/+6BB7/ugK0ACMCtAAjAyf/ugMn/7oCtAAjArQAIwMn/7oDJ/+6BDUARQQ1AEUB9P+6AfT/ugQ1AEUENQBFAfT/ugH0/7oENQBFBDUARQH0/7oB9P+6BA0ARwQNAEcBqP+6Aaj/ugPpAEoD6QBKA+kASgPpAEoGkgA+BpIAPgQ//7oEP/+6BHP/kwRzAEYCOf+/Bqr/1QRz/7cEc/+RAqr/pAKq/6QEAP//Ajn/uQQAACgEcwCJAwsAZAR0AEgGSQAkAccAGQHHABkEcwAeBGAAHgSMAAoEcwCGBHMARgI5ABMFtABCBAAAiAHH//wGqgCHBHMAiwRzAIcCqv/7BAAAPwMY/6IEAAAaBAAADwQAACgEcwBKBHMASARzAEYEcwBLA6sASQOrADIFNABVAccAiAQAABMBx/+iBHMAgwRcAEwDBABkAtUAMgLJADMC/AAyAowAMgHVADIB1QAAAwQAMgMRAGQBQgAZAUIAZAFCAGQBQgAZAioAAAFCAGQBQgAJAjMAZASTAGQEkwBkAw//yQMPAGQDDgBkAwUAMgMAADICuAAyAUL/ygHCADIDDwAdAxoAMgMGAGQC1ABkApIAAALeADIC3gAyAt4AMgL0ADIC6gAyAAD+vAAA/rwAAP9zAAD+qQI5ALkC+gAyAvkAMgMFADICoAAAAvkAMgY5AG0FVv/9BHMADwXHAGYCqgBBBKAASASgAEgEoABIBKAASASgAEgEoABIBKAASASgAEgBx/+bAcf/qwHH/5sBx/+rAcf/mwHH/7sBx/+bAcf/uwRgAIgEYACIBGAAiARgAIgEYACIBGAAiARgAIgEYACIAcf/qwHH/6sBx/+7Acf/uwRgAIgEYACIBGAAiARgAIgEWgBTBM4ASgOgABMFVgARBccAKQVYAAsFVgCiBHMASwQAADMBx/+iBeYAYwRzAEgFxwAAAqoADwVWAAYEAAAhBAAAEwQAAFAEAAATAccAgwRV//0C6wABBVYACQQAAA8FVgAJBAAADwTVAFMDqwBJBUAAEgSrABgAAP7GAAD+1AAA/sYAAP7UAAD+XwAA/l8AAP9yAAD/cwAA/ucHiwAKA+sATAQAABMEcwAKAccAFQRz//QFVgARBccAoQRzABkCOf+LBccApARzAIcFVgCWBAAAiATjACkEAAAoBAAAOwSeAKQDZwCIBTAASAAA/1MAAP+8AAD+/gAA/v4AAP6kAAD+pAHHAIgFyQClBccAnAXJAKUAAP7NAAD/SAAA/skAAP7OAAD+xQAA/tAAAP7RAAD+7gAA/tYAAP7cAAD92QY5AFgEcwBIB40AGQXHAAYFnwCkAAD+uQXcAGMExgAJCEwAGQa6AAYCOQC5A4AAcgGHAFoBhwBaBAAAmQQAAJkCOQCwAjkAsAI5ALACqgAZAAAARgAAADsAAAAxAAAAVgAAAEQAAABWAAAASgAAAEkE4wAwBHMAUARzAFwDEgA/BFAASARGAD0EcwAxBFAAPQR9AGIEJwA/BHMAVgR5AFQEcwBVAxkAOwRzADwEcwBWBHMAMgRzAFUEfgBiBC8ASwRzAFMEewBVBcUAagXTAGMF+ACmCUoApgX4AJwDAgA7BUEApAY5AGAEcgBGAccAiQP4AIcCCgCJBHMATgJQAA4EeACFBHMAXARzAFwDAgA7AgoAiQHHAIgEcQAABIkAmATDAFwE5wCYBG8AmAQIAJgFLwBcBPAAmAHqAJgDcwApBIkAmAO8AJgFxwCYBOwAmAUxAFwEbQCYBTEAXATbAJgEbQBKBBAAKQTdAJEEaAAIBlkAHgRvAAgEbAAIBA4AHwaRAAAGqgBcA7wAOAUxADEEbwCYBOcAFATDAJAEcQAABHEAAARxAAAEcQAABHEAAARxAAAEwwBcBG8AmARvAJgEbwCYBG8AmAHq//QB6gCOAer/tgHq/9oE7ACYBTEAXAUxAFwFMQBcBTEAXAUxAFwE3QCRBN0AkQTdAJEE3QCRBGwACARxAAAEcQAABHEAAATDAFwEwwBcBMMAXATDAFwE5wCYBOcAFARvAJgEbwCYBG8AmARvAJgEbwCYBS8AXAUvAFwFLwBcBS8AXATwAJgE8gAuAer/lgHq/70B6v/UAeoAPgHqAIcFQwCYA3MAKQSJAJgDvACYA7wAmAO8AJgDvACYBOwAmATsAJgE7ACYBPUAmAUxAFwFMQBcBTEAXATbAJgE2wCYBNsAmARtAEoEbQBKBG0ASgRtAEoEbQBKBBAAKQQQACkEEAApBA4AKQTdAJEE3QCRBN0AkQTdAJEE3QCRBN0AkQZZAB4GWQAeBlkAHgZZAB4EbAAIBGwACARsAAgEDgAfBA4AHwQOAB8EcQAABpEAAAUxADEEcQAABIkAmAOuAJgEcQAABG8AmAQOAB8E8ACYBTEAXAHqAJgEiQCYBFoAAgXHAJgE7ACYBC8ATAUxAFwE5gCYBG0AmAQlAGoEEAApBGwACAVGAEwEbwAIBUMATAUxAFIEcQAABG8AmATwAJgB6gCOBTEAXARsAAgFMQBSAer/2gRsAAgEbwCYBa8AKQOuAJgExwBcBG0ASgHqAJgB6v/aA3MAKQb0AA8GtgCYBdoAKQQWAJgEYwAjBOYAmARxAAAEhgCYBIkAmAOuAJgEaQAPBG8AmAZUACMEHwBGBOUAmATlAJgEFgCYBGkADwXHAJgE8ACYBTEAXATmAJgEbQCYBMMAXAQQACkEYwAjBQ0ATARvAAgE3ACYBH0ATAYoAJgGHgCYBXwAPAXnAJgEVQCYBMYARgavAJgE2wASAyMAmAKqACICqgBrAqoAGQKqACECqgAXAqoAIgKqAC4CqgBJAqoAKgKqADMCqgAuAqoAMwKqACIFxQBqBcUAagXFAGoFxQBqBcUAagXFAGoFxQBqBcUAagXFAGoFxQBqBcUAagXTAGMF0wBjBdMAYwXTAGMF0wBjBdMAYwXTAGMF0wBjBdMAYwXTAGMF0wBjBfgApgX4AKYF+ACmBfgApgX4AJwF+ACcBfgAnAX4AJwF+ACcBfgAnAX4AJwF+ACcBfgAnAMCADsDAgA7AwIAOwMCADsDAgAyAwIAOwMCADsDAgA7AwIAOwQW/6wDAgA7AwIAOwMCADsCCgCJAgoATgJpAIkCpQCJAgoABwMCADsDAgA7AwIAOwMCADsDAgAyAwIAOwMCADsDAgA7BUEApARyAEYEcgBGBHIARgRyAEYEcgBGBHIARgRyAEYEcgBGBHIARgHH/6cD+ACHAgoAiQIKAE4CaQCJAqUAiQIKAAcCUAAOAlAADgMAAA4CUAAOBHgAhQR4AIUEeACFBHgAhQSgAFcCqgAXAqoAIgKqAEkCqgAqBO4AFQTtAJ0E7QCdBgsAGgTVAIUF4wCFAiYAmQImAIkCJgAsAiYAHgImAGMCJgAwAiYAGwImAB0CJgAdAiYAKQImAB4CJgAmAiYAHQImAAgCJgAoDJYARg4MAEYAAP+6DtIARgAA/1sAAP+RAAD/twAA/5sEgQA2BDUANgQ9/7oEPf+6BIEANgQ1ADYEPf+6BD3/ugaSAD4GkgA+BD//ugQ//7oD6QBKA+kASgSBADYENQA2BD3/ugQ9/7oBqP/DAdb/XwGo/+kB1v+FBRsAMgS1ACQB9P+6AfT/ugUbADIEtQAkAfT/ugH0/7oFGwAyBLUAJAH0/7oB9P+6A3UAMgN1ADIDdQAyA3UAMgZ/AEUGfwBFBn8ARQZ/AEUEgQA2BDUANgQ9/7oEPf+6BpIAPgaSAD4EP/+6BD//ugaSAD4GkgA+BD//ugQ//7oEzwAtBM8ALQMn/7oDJ/+6BLT/4AUA/+AElv/oBOT/6AdcADIF2gAyBw4AMgUTADkLtwAAAAD+LAAA//wAAABrAAAAcwAAAGsFGwAyBLUAJAH0/7oB9P+6Bn8AFAd2ABQDJ/+6BB7/ugZ/ABQHdgAUAyf/ugQe/7oFGwAy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AQEBAQEsHQEyLCwsLCwsKAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBASwsAQEsLAEBLCwBASwsAQEsLAEBLCwBASwsAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBKSkpKSkpKSkpKSkpKSkpKSkpAQEBAQEBAQEBAQEBAQEBASsrERErKxERKysREQEBAQEBAQEBMjIjAQEBAQEBHQEBAR0BAQEdAQEBHQEBAR0BMjIyMgEBAQEJAQEjAQEBAQEBAQEBAQEBCQEBIwkBASMJAQEjCQEBIwkBASMBAQEBAQEBAQEBAQEBAQEBAQEsLAEBAQEBASwsAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBASwsAQEBASwsAQEJCQkJAQEBAQEBAQEFAQEBAQEBATIBAQEBAQEBKysREQEBAQEjAQEBAQEBLCgsLCwsLAkB9wEUwiMBIwEjASMBIwEjASMBAQEjAQEBJAEBAS4uAS4BAQEtARkcAQUWAQEBAQEBAS4BARQBAQEBAQEBLwEcARwDLgwBHAEcHAEBAQEBJwEaAQGrAQEBCRYqAS4BASUmASUmAQEBARJTAV0BAQEBHAEBAQEBElMBAS43JSYlJgwnDCc+/z7/EiQSJC4BLgEuNy43ASua/gEJLjcBAQEcASUmAQESJAESJBIkEiSVxAEBAQEBAQEBAQEBCwEBAQFTEgEBAQEBAQEBAQEBARYWFgEBAQEBER8BAQEBAQEBJSUBARoBAQEBAQEBAS4BAQENAQEBAQEBASQBEjcBARsBAQEBAQEpAQElICMBEx8fAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBGgEBAQEBAQEBAQEBATAwMDAwMDAwMAEwMDAwMAEwMDAwMAEwMDAwMAEwMDAwMAEwMDAwMDAwMDABMDAwMDABMDAwMDABMDAwMDABMDAwMDABMDAwMDAwMDAwATAwMDAwATAwMDAwATAwMDAwATAwMDAwATAwMDAwMDAwMAEwMDAwMAEwMDAwMAEwMDAwMAEwMDAwMAEwMDAwAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBDA0MAREBAQEuARwbDQEoDgEWAQEYAQEBAQEBAQ8BATEL3wEBAQwMJzcBBQEBCwEBAQEBARwBMhkBAQEBAQErASsBARYpAQEBAQUuAQEBAQEBAQEBEgEBAQEtARkBBwEBKwEcARwBAS4BHA0BAQEBAQEBAT4YKAEBAQEuFC4UAQEWAQElJiUmAQEMJwEBGCgZCxkBDDcMNxIkAQEBMTHEMcQxxBwBMQEBIxEBARQBARIBAQEBEgMBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQElJgE1ATUBNS4LLiMuIy4jLiMuIwwnDCcMJwwnAQEcZRJTLjcuNy43LjcuNz45Pv8BXQFdAV0BOQE5ATkBOXWydbJ1si43LjcuNy43EiQSJBIkEiQcNRw1LgEuAS4BLgEBKwErASsBKwErmhKaEpoSmhIuNy43LjcuNy43H8YfxoWkhaRN1U3VlcQcYxxjHGM3EqTEJjkLCwsLCwsLCyUlAQEBAQEBJiYmJiYmAQEICAgIKSkpKSkpKSkaGiIiIiIiIt3d3d3d3d3dAQEBAQEBAQEkJCQkJCQbGwEBAQEpKSkpKSkpKQEBAQEqKioqKioqKgEBAQEBAQEBCwsmJikp3d0kJCkpKioLCwsLCwsLCyUlAQEBAQEBKSkpKSkpKSkaGiIiIiIiIioqKioqKioqAQEBAQEBAQELCwsLCwsLJSUlJSUBAQEBASkpKSkpAQEBAS4BAQHd3d3d3d0+PgEBAQEBKSkpKSQkKSmVlSkBAQEBASoqKioqARsBAQ8BAQEuLhYuBAoBHAEBAQEBAQEBAQEBIgEBAQkJAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAgMBAQsoKAELAQEBARY3JAEBAQEKAQEBASUlFCkgASDGpGMBAQ8mATcBATcBAQEBCwEBAgEBARUcMSwBKxIBKgEBAQEBAQEyMgEBAQEBAQExEjIZMjIqGhIBMSsBMSsqAREBARIrMSsBAREBJAEqAQEjAQEBAQEBAQEBKSkBAQEBAQEBAQMBAQERAQEBAQEBARkBAQEBAQEBAQEBAQEuAQEBAQEBLhYBAQEBAS4BARwBAQEBAQEBAR4uLi4lJgEBAQEBARQBAQEBAQEBAQEsLAEBLCwBASwsAQEsLAEBLCwBASwsAQEsLAEBAQEBAQEBKSkpKQEBKysRESMBAQEjAQEBIwEBAQEBHQEBAR0BCQEBIwkBASMJAQEjAQEBAQEBAQEBASwsAQEsLAEBLCwBAQEBAQEBASsrEREBAQEWAQEBAQEBAQEvLTIBAQEBAQEBAQEBARYBAQEBAQEBAQEBAQEBAQEBAQEBAQEZAQUBGRkBHwEBAQEZAQEVAQESEgEyARoBGhIBKiorAQEBAQEBAQEBAQEBMgEBAQEBLgELCwsLCwsLC93d3d3d3d3dKSkpKSkpKSnd3d3dKSkpKSMBAQEuEAEBAQEpAS4BAQEBCwE5JSYBAQEBGQEBAQEBAQEBAQEBAQEBAQEBAQEuAQEuAQEBHAEBAQEBAQEBAQEBOQEuAQEBAQEBAQEBAQEBElOFpAEBLCABFwEBAQEBAQEBAQEBAQEBAQEBARwBAQEBAQEBARsBAQEBAQEBAQkBAQEBAQMBAwEBAQEBAgEBFBIBAQEBOQEBFgEvARwSAQEBAS4BMAEwDwEBJgEvLwEBARYBMC8BFgEBAQEBARYvLy8vAQEBAQEwMDAwMCYmJiYBAQEBFhYWFgEBLy8vLy8cHBwcEgEBAQEBARQBAQEBAQEBAQEBMDAwDw8PAQEBAQEBAQEBJiYmJiYmLy8vLwEBAQEBAQEBMAEBGgEvARIwAQEjLgEBMCkBAQEvAS8UMAEvEgEwATABAS8UGiUBAQEBAQEBLwEpAQEBGigvDQEBAS8oLhIwKQEWAQEBLwEBAQEBFiUgAQ8BAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEDAwMDAwMDAwMDAwMDAQEBAQEBAQEBLwEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQIBAQEBARQUARQSEhISAQEBAQEsAQEBGQEBAQEBAQEBAQEBAQEBAQEBAQESAQEBAQEBAQEBAQEBKysREQEBAQEBAQEBAQEBASwsAQEsLAEBLCwBAQEBCQkJCQEBAQErKxERKysREQEBAQEBAQEBAQEBAQEBAQEBAQEBLCwJAQEjCQEBIwEBLCwBASwsAQEsLAEBARwNDAEBASQBAQExAQEBAQEBAQ4BAS4lAS8BAS0uMiItAQEWASwBAQEBASsBHP8jAQEBEgEBAQEBAQEBAQEBAQEBAQEBAQEBLCwsLCwBLAEREQEBARsbAQEBAQEBAQEBAScBAScBASwsAQEBATIyMjIBAR0BMjIdAQEBAQEBAQEBAQEsLAEBLCwBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEjAQEMAQEWAQEBAQEBAQEBAQEBATIBAQEBAQEBFS0BFQEvJy0tAQEBLgEBAQEBAQENGhUGAQEBFQEBDwEBASwBAQEBAQEBASUKAQEHAQEBAQEBARoBMAEBAQESARoBAQEBCgEBAQEEAQEBBAEBAQEBAQEBARkZARkxAQEBAQEBLCwnKSkBAQEBCQEBIwEiAQEBHC4UASUBAQEBAQEBAQEBJgEAAAAAAAADAAMBAQEBAQUDAwECAQEAGAXsC8AA+Aj/AAgACP/+AAkACf/9AAoACv/9AAsAC//9AAwADP/9AA0ADf/9AA4ADf/9AA8ADv/9ABAAD//9ABEAD//8ABIAEf/8ABMAEv/8ABQAE//8ABUAE//7ABYAFP/7ABcAFf/7ABgAFf/6ABkAF//7ABoAGf/6ABsAGv/6ABwAGv/6AB0AG//6AB4AHP/5AB8AHP/5ACAAHf/5ACEAH//5ACIAIP/5ACMAIP/4ACQAIf/4ACUAIv/4ACYAIv/3ACcAI//3ACgAJP/3ACkAJv/3ACoAJv/3ACsAJ//2ACwAKP/2AC0AKP/2AC4AKv/2AC8AK//2ADAALf/2ADEALf/1ADIALv/1ADMAL//1ADQAMP/0ADUAMP/0ADYAMf/0ADcAM//0ADgANP/zADkANP/zADoANf/zADsANf/zADwANv/zAD0AN//zAD4AOP/zAD8AOf/yAEAAOv/yAEEAO//yAEIAPP/yAEMAPP/xAEQAPf/xAEUAPv/xAEYAP//wAEcAQP/wAEgAQf/wAEkAQv/wAEoAQv/wAEsAQ//wAEwARP/wAE0ARv/vAE4ARv/vAE8AR//vAFAASP/vAFEASf/uAFIASf/uAFMASv/uAFQAS//tAFUATf/tAFYATf/tAFcATv/tAFgAT//sAFkAUP/sAFoAUP/tAFsAUf/sAFwAU//sAF0AVP/sAF4AVP/sAF8AVf/rAGAAVv/rAGEAV//rAGIAV//qAGMAWf/qAGQAWv/qAGUAW//qAGYAXP/pAGcAXP/pAGgAXf/pAGkAXv/oAGoAYP/pAGsAYP/pAGwAYf/pAG0AYv/oAG4AY//oAG8AY//oAHAAZP/nAHEAZf/nAHIAZ//nAHMAZ//nAHQAaP/mAHUAaf/mAHYAav/mAHcAav/lAHgAa//lAHkAbf/lAHoAbv/lAHsAbv/lAHwAb//lAH0AcP/lAH4Acf/kAH8Acf/kAIAAc//kAIEAdP/kAIIAdf/jAIMAdv/jAIQAdv/jAIUAd//iAIYAeP/iAIcAef/iAIgAev/iAIkAe//hAIoAfP/hAIsAff/iAIwAff/hAI0Afv/hAI4Af//hAI8Agf/hAJAAgf/gAJEAgv/gAJIAg//gAJMAhP/fAJQAhP/fAJUAhf/fAJYAh//fAJcAiP/gAJgAiP/fAJkAif/fAJoAiv/eAJsAi//eAJwAjP/eAJ0AjP/eAJ4Ajv/eAJ8Aj//eAKAAkP/eAKEAkP/dAKIAkf/dAKMAkv/dAKQAk//dAKUAlP/cAKYAlf/bAKcAlv/bAKgAl//bAKkAl//bAKoAmP/bAKsAmf/bAKwAm//bAK0Am//bAK4AnP/bAK8Anf/bALAAnv/bALEAnv/aALIAn//aALMAoP/aALQAov/ZALUAo//YALYAo//YALcApP/YALgApf/YALkApv/YALoApv/YALsAqP/YALwAqf/XAL0Aqv/XAL4Aqv/XAL8Aq//XAMAArP/XAMEArf/XAMIArv/XAMMAr//WAMQAsP/WAMUAsf/VAMYAsf/VAMcAsv/VAMgAs//UAMkAtP/UAMoAtf/UAMsAtv/UAMwAt//UAM0AuP/UAM4Auf/UAM8Auf/UANAAuv/UANEAvP/UANIAvf/TANMAvf/SANQAvv/SANUAv//SANYAwP/RANcAwP/RANgAwv/RANkAw//RANoAxP/RANsAxP/RANwAxf/RAN0Axv/RAN4Ax//QAN8Ax//QAOAAyf/PAOEAyv/PAOIAy//PAOMAy//PAOQAzP/PAOUAzf/PAOYAzv/PAOcA0P/OAOgA0P/OAOkA0f/OAOoA0v/NAOsA0//NAOwA0//NAO0A1P/NAO4A1v/MAO8A1//MAPAA1//MAPEA2P/MAPIA2f/MAPMA2v/MAPQA2v/MAPUA3P/LAPYA3f/LAPcA3v/LAPgA3v/KAPkA3//KAPoA4P/KAPsA4f/KAPwA4f/KAP0A4//JAP4A5P/JAP8A5f/JAPgI/wAIAAj//gAJAAn//QAKAAr//QALAAv//QAMAAz//QANAA3//QAOAA3//QAPAA7//QAQAA///QARAA///AASABH//AATABL//AAUABP//AAVABP/+wAWABT/+wAXABX/+wAYABX/+gAZABf/+wAaABn/+gAbABr/+gAcABr/+gAdABv/+gAeABz/+QAfABz/+QAgAB3/+QAhAB//+QAiACD/+QAjACD/+AAkACH/+AAlACL/+AAmACL/9wAnACP/9wAoACT/9wApACb/9wAqACb/9wArACf/9gAsACj/9gAtACj/9gAuACr/9gAvACv/9gAwAC3/9gAxAC3/9QAyAC7/9QAzAC//9QA0ADD/9AA1ADD/9AA2ADH/9AA3ADP/9AA4ADT/8wA5ADT/8wA6ADX/8wA7ADX/8wA8ADb/8wA9ADf/8wA+ADj/8wA/ADn/8gBAADr/8gBBADv/8gBCADz/8QBDADz/8QBEAD3/8QBFAD7/8QBGAD//8ABHAED/8ABIAEH/8ABJAEL/8ABKAEL/8ABLAEP/8ABMAET/8ABNAEb/7wBOAEb/7wBPAEf/7wBQAEj/7wBRAEn/7gBSAEn/7gBTAEr/7gBUAEv/7QBVAE3/7QBWAE3/7QBXAE7/7QBYAE//7ABZAFD/7ABaAFD/7QBbAFH/7ABcAFP/7ABdAFT/7ABeAFT/7ABfAFX/6wBgAFb/6wBhAFf/6wBiAFf/6wBjAFn/6gBkAFr/6gBlAFv/6gBmAFz/6QBnAFz/6QBoAF3/6QBpAF7/6QBqAGD/6QBrAGD/6QBsAGH/6QBtAGL/6QBuAGP/6ABvAGP/6ABwAGT/6ABxAGX/5wByAGf/5wBzAGf/5wB0AGj/5wB1AGn/5gB2AGr/5gB3AGr/5gB4AGv/5QB5AG3/5QB6AG7/5QB7AG7/5QB8AG//5QB9AHD/5AB+AHH/5AB/AHL/5ACAAHP/5ACBAHT/4wCCAHX/4wCDAHb/4wCEAHb/4wCFAHf/4wCGAHj/4wCHAHn/4gCIAHr/4gCJAHv/4gCKAHz/4gCLAH3/4gCMAH3/4gCNAH7/4gCOAH//4gCPAIH/4QCQAIH/4QCRAIL/4ACSAIP/4ACTAIT/4ACUAIT/4ACVAIX/4ACWAIf/3wCXAIj/4ACYAIj/3wCZAIn/3wCaAIr/3gCbAIv/3gCcAIz/3gCdAIz/3gCeAI7/3gCfAI//3gCgAJD/3gChAJD/3QCiAJH/3QCjAJL/3QCkAJP/3QClAJT/3ACmAJX/2wCnAJb/2wCoAJf/2wCpAJf/2wCqAJj/2wCrAJn/2wCsAJv/2wCtAJv/2wCuAJz/2wCvAJ3/2wCwAJ7/2wCxAJ7/2gCyAJ//2gCzAKD/2QC0AKL/2QC1AKP/2AC2AKP/2AC3AKT/2AC4AKX/2AC5AKb/2AC6AKb/2AC7AKj/2AC8AKn/1wC9AKr/1wC+AKr/1wC/AKv/1wDAAKz/1wDBAK3/1wDCAK7/1wDDAK//1gDEALD/1gDFALH/1QDGALH/1QDHALL/1ADIALP/1ADJALT/1ADKALX/1ADLALb/1ADMALf/1ADNALj/1ADOALn/1ADPALn/1ADQALr/1ADRALz/1ADSAL3/0wDTAL3/0gDUAL7/0gDVAL//0gDWAMD/0QDXAMD/0QDYAML/0QDZAMP/0QDaAMT/0QDbAMT/0QDcAMX/0QDdAMb/0QDeAMf/0ADfAMf/0ADgAMn/zwDhAMr/zwDiAMv/zwDjAMv/zwDkAMz/zwDlAM3/zwDmAM7/zwDnAND/zgDoAND/zgDpANH/zgDqANL/zQDrANP/zQDsANP/zQDtANT/zQDuANb/zADvANf/zADwANf/zADxANj/zADyANn/zADzANr/zAD0ANr/zAD1ANz/ywD2AN3/ywD3AN7/ywD4AN7/ygD5AN//ygD6AOD/ygD7AOH/ygD8AOH/ygD9AOP/yQD+AOT/yQD/AOX/yQD4CP8ACAAI//4ACQAJ//0ACgAK//0ACwAL//0ADAAM//0ADQAN//0ADgAN//0ADwAO//0AEAAP//0AEQAP//wAEgAR//wAEwAS//wAFAAT//wAFQAT//sAFgAU//sAFwAV//sAGAAV//oAGQAX//sAGgAZ//oAGwAa//oAHAAa//oAHQAb//oAHgAc//kAHwAc//kAIAAd//kAIQAf//kAIgAg//kAIwAg//gAJAAh//gAJQAi//gAJgAi//cAJwAj//cAKAAk//cAKQAm//cAKgAm//cAKwAn//YALAAo//YALQAo//YALgAq//YALwAr//YAMAAt//YAMQAt//UAMgAu//UAMwAv//UANAAw//QANQAw//QANgAx//QANwAz//QAOAA0//MAOQA0//MAOgA1//MAOwA1//MAPAA2//MAPQA3//MAPgA4//MAPwA5//IAQAA6//IAQQA7//IAQgA8//IAQwA8//EARAA9//EARQA+//EARgA///AARwBA//AASABB//AASQBC//AASgBC//AASwBD//AATABE//AATQBG/+8ATgBG/+8ATwBH/+8AUABI/+8AUQBJ/+4AUgBJ/+4AUwBK/+4AVABL/+0AVQBN/+0AVgBN/+0AVwBO/+0AWABP/+wAWQBQ/+wAWgBQ/+0AWwBR/+wAXABT/+wAXQBU/+wAXgBU/+wAXwBV/+sAYABW/+sAYQBX/+sAYgBX/+sAYwBZ/+oAZABa/+oAZQBb/+oAZgBc/+kAZwBc/+kAaABd/+kAaQBe/+kAagBg/+kAawBg/+kAbABh/+kAbQBi/+kAbgBj/+gAbwBj/+gAcABk/+gAcQBl/+cAcgBn/+cAcwBn/+cAdABo/+cAdQBp/+YAdgBq/+YAdwBq/+YAeABr/+UAeQBt/+UAegBu/+UAewBu/+UAfABv/+UAfQBw/+QAfgBx/+QAfwBy/+QAgABz/+QAgQB0/+QAggB1/+MAgwB2/+MAhAB2/+MAhQB3/+MAhgB4/+MAhwB5/+IAiAB6/+IAiQB7/+IAigB8/+IAiwB9/+IAjAB9/+IAjQB+/+IAjgB//+IAjwCB/+EAkACB/+EAkQCC/+AAkgCD/+AAkwCE/+AAlACE/+AAlQCF/+AAlgCH/98AlwCI/+AAmACI/98AmQCJ/98AmgCK/94AmwCL/94AnACM/94AnQCM/94AngCO/94AnwCP/94AoACQ/94AoQCQ/90AogCR/90AowCS/90ApACT/90ApQCU/9wApgCV/9sApwCW/9sAqACX/9sAqQCX/9sAqgCY/9sAqwCZ/9sArACb/9sArQCb/9sArgCc/9sArwCd/9sAsACe/9sAsQCe/9oAsgCf/9oAswCg/9kAtACi/9kAtQCj/9gAtgCj/9gAtwCk/9gAuACl/9gAuQCm/9gAugCm/9gAuwCo/9gAvACp/9cAvQCq/9cAvgCq/9cAvwCr/9cAwACs/9cAwQCt/9cAwgCu/9cAwwCv/9YAxACw/9YAxQCx/9UAxgCx/9UAxwCy/9QAyACz/9QAyQC0/9QAygC1/9QAywC2/9QAzAC3/9QAzQC4/9QAzgC5/9QAzwC5/9QA0AC6/9QA0QC8/9QA0gC9/9MA0wC9/9IA1AC+/9IA1QC//9IA1gDA/9EA1wDA/9EA2ADC/9EA2QDD/9EA2gDE/9EA2wDE/9EA3ADF/9EA3QDG/9EA3gDH/9AA3wDI/9AA4ADJ/88A4QDK/88A4gDL/88A4wDL/88A5ADM/88A5QDN/88A5gDO/88A5wDQ/84A6ADQ/84A6QDR/84A6gDS/80A6wDT/80A7ADT/80A7QDU/80A7gDW/8wA7wDX/8wA8ADX/8wA8QDY/8wA8gDZ/8wA8wDa/8wA9ADa/8wA9QDc/8sA9gDd/8sA9wDe/8sA+ADe/8oA+QDf/8oA+gDg/8oA+wDh/8oA/ADh/8oA/QDj/8kA/gDk/8kA/wDl/8kAAAAYAAAQkAsWCAADAwIEBgYKBwIEBAQGAwQDAwYGBgYGBgYGBgYDAwYGBgYLCAcHBwYGCAcCBQcGCAcIBggHBwYHCAoHCAcDAwMFBgQGBgYGBgQGBgICBQIIBgYGBgQGAwYGCgYGBgQCBAYICAcGBwgHBgYGBgYGBgYGBgYCAgICBgYGBgYGBgYGBgYEBgYGBAYHCAgLBAQGCwgIBgYGBgYGBwkGAwQFCAoGBgIGBwYHBgYGCwgICAsKBgsEBAICBgUGCAIGBAQGBgYDAgQLCAYIBgYCAgICCAgIBwcHAgQEBAQEBAQEBAQGAgcGBwYCCAYIBgcGBgYEBAQKCQoGCAYCBwYHBgcGBgYECAYIBgcHCAYGBgYGAgYEBgQHBgcGCAYHBAcEBwYGAwYEBwYHBgcGBwYGCAgGBgUHBAcGBgQMCwYLBgsGBgsIBgcGBwcIBwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgHCwsLCwsHBwcLDAoICAYHBwYGCAgFBwIECgQHBAQHBAgGBwYHBgYGBgYGBggGCAYIBgcGCQYCAgICAgICAgUCBwUGBgIHBggGCAYIBgcEBwYGBAcGBwYHBgcGCgoIBgIIBgsKCAYDCgoKCgoKCAYCBAYGCgoKCgQEBAQICQkFCQoIAggHCAYHBwIHCAgHBwgHBgcGCAcICAIIBgUGAgYGBgUGBgIGBgYGBQYGBQYFCAgCBgYGCAYKBgcHAgIFDAsJBwcHCAcHBggGDAcJCQcHCAcIBwYHBgcIBwcGCgoICQcICwgGBgcEBgYIBQYGBQYIBgYGBgYGBggGBgYICAcIBgYIBgYGBAYGAgICCgkGBQYGBQULDQkAAAAAAAAAAAAAAAAABAADAAADBgYFBgcDAwcHAwYFBQcHAwUHBgYGBgYGBgkHBgYGAwUJAwYGBQUHCQkJCQYGBgYFBgcDBQcDBgUFBwUHBgYGBgYJBwMGBQYGAAAAAAQEBAUCAAAAAAAAAAAGBgYGBgYGBgYGBgQGCAgDCAYGBggICAgIAAgICAgICAgIBwgICAgIAwMICAgIBgYGBgUFCQoEBgkKBAYHBgQICAgICAgICAgICAgICAgAAAAAAAgIAAAAAAAAAAAAAAAAAAAAAAcLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAQECAcFAgMCAwUFAgMHBgMDAgMICAMDAwQICAMDCAgDAwYGBgYGBgYGBgYGBgQEBAQFBQUFCQkGBgkJBgYMDAkJDAwJCQYGBgYGBgYGBgUGBAYFBgQJCQMDBgYDAwcHBAQGBgICBAQEBAYGAwMDBAUEBQUHBgcGAwMGBwYHBgcGBwgIAAAICAgAAAgIAAAICAgAAAAAAAAIAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQICAgICAgICAgICAgICAgICAgICAgICAgBCxYJBwkHAAAAAAAAAAAAAAAAAAAAAAYJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCAYIBggGCAYIBggGCAYIBggGCAYIBggGBgYGBgYGBgYGBgYGBgYGBgICAgIIBggGCAYIBggGCAYIBgkHCQcJBwkHCQcHBgcGCQcJBwkHCQcJBwgGCAYIBggGAgIIBgcGBwYHBgcGBwYAAAAABgQKBwYFBgUIBgYGBgYHBgcGBwYIBgkGCAMDAwYDAwMDAwMDAAAEBAAAAAACAwIDAgMCAwUFBQUHBggIAwMICAMDCAgDAwgIAwMICAMDCAgDAwgIAwMGBgYGBgYGBgYGBgYGBgYGBgYGBgYGBgYEBAQEBAQEBAQEBAQEBAQEBAQFBQUFBQUFBQUFBQUFBQUFCQkGBgkJBgYJCQYGDAwJCQwMCQkGBgYFBgQJCQkDAwkJAwMJCQMDCQkDAwkJAwMGBgYGDQ0KCgkKBAYHBwQEBwcEBAcHBAQJCgQGCQoEBgkKBAYJCgQGCQoEBgYGAgIGBgICBgYCAgYGAgIGBgMDBgYGBgYGAwMGBgYGBgYDBAQEBAUFBQUFBQUFBQUFBQUFBQUHBgcGAwMFBQcGAwMHBgkJCQkCAAAAAAAAAAwMAAAAAAAAAgQAAAcAAAAJCQYGDAwJCQYFBgQFBAMDBAMDAwMDCQoDAAQGBgcGBwYHBgcGBwYHBgcGBgYHBggHBgcGCAgGCAkHBgYHBwcJBwoCAwcGAgYKCAYJCgcIBgcHBgcEAwcDBwgICQYHBgcHBgYGBgUFBgMFBgIPDQwMCQUNCggGCAYACAYLCgkGCAYHBQgGCAYHBgIPDQwIBgsHBwYIBggGBgYGBgICAgIIBggGBwQHBAcGBwYHBgYDBgUHBggHBgcGCAYHBggGAAgGCAYIBggGBgYGBgYGBgYGCAUFBwYDBgYGBgcGBgYCAgQEAwIGCQkJBgYGBgkJBgQEBAQEBAQGBgYCAwIEAwMGBgYGCAYGBgYGBgYGBgYJBwYGBgQGBAYGBgsKCwgFCAgHBwUGBAQCAwMDBAUEAgQCAgIEBAQEBgYGBgQEBAQEBAQDAwQEBAQEBAQEBAIEBAQEBAQEBAQEBAQEBgYGBgYGBgYGBAYGBgYGBAYGBgYGBAYGBgYGBAYGBgYGBAYGBgYGBgYGBgQGBgYGBgQGBgYGBgQGBgYGBgQGBgYGBgQGBgYGBgYGBgYEBgYGBgYEBgYGBgYEBgYGBgYEBgYGBgYEBgYGBgYGBgYGBAYGBgYGBAYGBgYGBAYGBgYGBAYGBgYGBAYGBgYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBgYJCwkGCQcJBggGBwQHBggGCgkHBgcGBwcHBwgGBQUHBgYCCQUFBgkGBg8HCQcKCAcGCggJCAwKBwUJCAkGCQcJBwwKCQcNCQAPBwgGBgAAAAAAAAgGBwYHBgcGBwUGBQgGCgcNCggGCAYHBQoIBwYJBwkHAgwIBwYHBggGCAYHBgkIBAgGCAYLCgYGCAYMCAcFBwYJBgkGCAYJBggGBwYHBgcGBgYJCAcGCwoLCQcGCwoLCgkGCAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgGBwYHBgcGBwYHBgcGBwYHBgcGBgYGBgYGBgYHBgYECAYHBgcGBwYHBgcGAgICAgcFBwUHBQYCBgIGAgYCCAgICAgIBwYHBgcGBwYIBggGCAYIBgYGBgYHBAcEBwQHBAcGBwYHBgcGBwYGAwYDBgMGAwcGBwYHBgcGBwYIBggGCgoKCgcGBwYIBgcGBwYHBgYDCgYGAgYGBgYGBgYGCAgJCQkJCQkFBQUFBQUICAoKCgoGBgYGBgYGBgkJCwsLCwsLAgICAgICAgIEBAYGBgYGBgYGBgYGBgkJCwsLCwYGBgYGBgYGCQsLCwgICAgICAgICQkLCwoKCgoGBgUFBgYCAgYGBgYICAYGBgYGBgYGCAgJCQkJCQkGBgYGBgYGBgkJCwsLCwsLCAgICAgICAgJCQsLCgoKCgYGBgYGBgYICAgICAQEBAQEBgYGBgYJCQoKBwQEBAICAgICAgICBQUEBAQGBgYGBgYGBggICQoIBAQECAgICAgKCQoJCAQEBggICQgNCgcHCwYHAAAAAAICBgcIBAgECAgEBAQEBAQEBAQDBAQEBAQEBAAAAAAAAAAAAAAABwYFCAoGBgYGBQUCBQYECAYGBgcHBwoFBgYGBgYGBgcIBwYKBgUFBwQGBgYIBgUHBQUFBQUFBQIDBQQGBQUGBAUFBQUHBAQEBwQEBAQEBAQCBAYEBAQEBAQCBAQGBAQEBAQFBAIDBAQEBAQFBAoOBQ4HAwYAAAAAAAAAAAAEBAUFBQQFBAgHCAcHCAcJBgAAAAYEBAICAgIJDQYLBgsEAwIGAwIBAAgHCQgKCgoHCAYGBwYGBgAAAAAABggICAYEAAAABAADAwAAAAAAAAAICAMDCAgDAwgIAwMICAMDCAgDAwgIAwMICAMDBgYGBgYGBgYEBAQEBQUJCQYGBgUGBAYFBgQGBQYECQkDAwkJAwMJCgQGCQoEBgkKBAYEBAQEBAQEBAYGAwMGBgMDBgYDAwYGAgIFBQUFCQkGBgYGAwkGBgQEBgMGBgQGCQICBgYGBgYDCAYCCQYGBAYEBgYGBgYGBgUFBwIGAgYGBAQEBAQDAwQEAgICAgMCAgMGBgQEBAQEBAICBAQEBAQEBAQEBAAAAAADBAQEBAQJBwYIBAYGBgYGBgYGAgICAgICAgIGBgYGBgYGBgICAgIGBgYGBgcFBwgIBwYGAggGCAQHBgYGBgIGBAcGBwYHBQcGAAAAAAAAAAAACgUGBgIGBwgGAwgGBwYHBgYGBQcAAAAAAAACCAgIAAAAAAAAAAAAAAAIBgoKCAAIBwsJAwUCAgYGAwMDBAAAAAAAAAAABwYGBAYGBgYGBgYGBgQGBgYGBgYGBggICA0IBAcJBgIFAwYDBgYGBAMCBgYHBwYGBwcDBQYFCAcHBgcHBgYHBgkGBgYJCQUHBgcHBgYGBgYGBwYGBgYDAwMDBwcHBwcHBwcHBwYGBgYHBwcHBwcGBgYGBgcHBwcHBwMDAwMDBwUGBQUFBQcHBwcHBwcHBwcGBgYGBgYGBgYHBwcHBwcJCQkJBgYGBgYGBgkHBgYFBgYGBwcDBgYIBwYHBwYGBgYHBgcHBgYHAwcGBwMGBggFBwYDAwUKCQgGBgcGBgYFBgYJBgcHBgYIBwcHBgcGBgcGBwYICAgIBgcJBwQEBAQEBAQEBAQEBAQECAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgEBAQEBAQEBAQGBAQEAwMDBAMEBAQEBAQEBAcGBgYGBgYGBgYCBQMDAwQDAwMEAwYGBgYGBAQEBAcHBwgHCAMDAwMDAwMDAwMDAwMDAxETABQAAAAABgYGBgYGBgYJCQYGBQUGBgYGAgMCAwcGAwMHBgMDBwYDAwUFBQUJCQkJBgYGBgkJBgYJCQYGBwcEBAYHBgcKCAoHEAAAAAAABwYDAwkKBAYJCgQGBwYDAwcGAwMHBgMDAAYFBwUJBgcGDgYHCwgJCAsJBwYMCgwJCAYIBgMDBggEBwYHBgkHCAgEBgUCBAcHAgkQCw8UAgICAwICAgIDAgICAgICAgICAgIDAwMDAwMDAgQEBgQEBgYHBwcHBwcHBwYGBQYGBQgIAwMGBgYGBgYGBgkJAwMGBgMDBgYCAgQEBAQHBgMDBwYDAwUFBQUFBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYHAAUGBwcAAAQEBgYGBgYGBgYGBgQEAwIACQgICAgICAcICQgHBgoICAcICAgICAgICAgJCAgICAcHBwYICAkIAwICAgMDBgkGBgYGBgUGBwYGAgkGBgYGBgYGAgYFBgQJBgYGBgkGBgQJBgYICAMECwsIDAwMDA8GCwAACAgDAwIEBAwMCQkJCgQGAwIFBQAFCAYPDAcGBwYJCQYICAYICQAMGAkAAwMDBAcHCwgCBAQFBwMEAwMHBwcHBwcHBwcHAwMHBwcHDAcICQkIBwkJAwYIBwkJCQgJCQgHCQcLBwcHAwMDBQcEBwcGBwcDBwcDAwYDCwcHBwcEBwMHBQkFBQUEAwQHBwcJCAkJCQcHBwcHBwYHBwcHAwMDAwcHBwcHBwcHBwcHBQcHBwQGCAkJDAQEBwwJCQcHBwcHBgkKBwMEBAkLBwcDBwcHBwcHBwwHBwkMCwcMBAQDAwcGBQcCBwQEBgYHAwMECwcIBwgIAwMDAwkJCQkJCQMEBAQEBAQEBAQEBwMIBwcFAwkHBwUIBwcHBAQECgoKBwkHAwgHCQYJBgcHBAcHBwcJBwkIBwgHBwMHBAcECQcJBwkHCQQJBAgHBwMHBQkHCQcHBQcFBwkJBwcFBwUIBwYEDQwGDAYMBgYMCQcHBwcHCQgJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJBwwMDAwMBwcHDA0LCQkGCAcGBgkJBQcCBAsEBwQEBwQHBwkGCQYIBwgHCAcJBwkHCQcJBwkHAwMDAwMDAwMGAwgGBwcDCQcJBwkHCQcJBAgHBwMJBwkHCQcJBwsJBwUDBwcMCwkHAwsJCwkLCQcFAwQHBwoKCgoEBAQEBwkKBAkJCQMHCAcIBwkDCAcJCQgJCQgHBwcHCQkDBwcFBwMHBwUFBwcDBwUHBQUHBwYHBgkJAwcHBwkICgcJCAMDBg0MCgcICQcICAcICAsHCQkHCAkJCQkICQcICQcJCAsLCgoICQwJBwcGBAcHCQYHBwYHCQcHBwcGBQUJBQcGCQkICQcGCQcHBwQGBwMDAwsKBwYFBwYFDA0IAAAAAAAAAAAAAAAAAAUAAwAAAwcHBQYHAwUHBwMGBgYHBwMEBwYHBwYGBwYICAYGBgMFCQMGBgYGBggICAgHBwcHBQYHAwUHAwYGBgcEBwcHBgcGCAgDBwYHBwAAAAAEBAQFAgAAAAAAAAAABgYGBgYGBgYGBgYEBgkJAwkGBgYJCQkJCQAJCQkJCQkJCQgJCQkJCQMDCQkJCQcGBgYGBgoLBQYKCwUGCAcFCQkJCQkJCQkJCQkJCQkJAAAAAAAJCQAAAAAAAAAAAAAAAAAAAAAHDAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkEBAkHBQIDAgMFBQIDCAcDAwIDCQkDAwMFCQkDAwkJAwMHBgYGBwYGBgcGBgYEBAQEBgYGBgoKBgYKCgYGDQ0KCg0NCgoHBwcHBwcHBwcFBgUHBQYFCQkDAwcHAwMHBwUFBgYCAgQEBQUGBgMDAwUFBQUFCAcIBwMDBwcHBwcHBwcJCQAACQkJAAAJCQAACQkJAAAAAAAACQAACQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJBAQECQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJAgwYCggKCAAAAAAAAAAAAAAAAAAAAAAGCgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwgHCAcIBwgHCAcIBwgHCAcDAwMDCQcJBwkHCQcJBwkHCQcKCAoICggKCAoICQcJBwoICggKCAoICggHBQcFBwUHBwMDCQcJBwkHCQcJBwkHAAAAAAcECwgHBQcFCQcHBgcGCAYIBggHCQcJBwkDAwMHAwMDAwMDAwAABAQAAAAAAgMCAwIDAgMFBQUFCAcJCQMDCQkDAwkJAwMJCQMDCQkDAwkJAwMJCQMDBwYGBgcGBgYHBgYGBwYGBgcGBgYHBgYGBAQEBAQEBAQEBAQEBAQEBAQEBgYGBgYGBgYGBgYGBgYGBgoKBgYKCgYGCgoGBg0NCgoNDQoKBwcHBQYFCQkJAwMJCQMDCQkDAwkJAwMJCQMDBwcHBw4OCwsKCwUGBwcFBQcHBQUHBwUFCgsFBgoLBQYKCwUGCgsFBgoLBQYGBgICBgYCAgYGAgIGBgICBgYDAwYGBgYGBgMDBgYHBgYGAwUFBQUFBQUFBQUFBQUFBQUFBQUFCAcIBwMDBQUIBwMDCAcKCgoKAgAAAAAAAAANDQAAAAAAAAIEAAAHAAAACgoGBg0NCgoHBQYFBQQDAwQDAwMDAwoLAwAEBgcHBwcHBwcHBwcHBwcHBgYHBwcJCAcIBwkJBgkKCAcHCAcHCQcLAwMIBgMGCwkHCQoICQcICAYHBQMHAwcJCQkGBwYHBwcHBwcGBgcDBQcDEA8NDQoFDwsJBwcHAAcHDAsJBwkHCAYJBwkHBwcDEA8NCQcMBwkHBwcHBwgHCAcDAwMDCQcJBwkECQQJBwkHCAcHAwcFCQcIBwcHBgcHCAcJBwAJBwkHCQcHBQcHBwcGBgcHBwkGBggGAwcHBwYHBwcHAwMEBAQDBwoKCgcHBwcJCQcEBAQEBAQEBwcGAwMDBAMDBwcHBgkGBgYHBwcGBgYGCQYGBwcFBgUHBgYMCwwJBQkJCAgGBgUFAgMDAwQGBAIEAwMDBAQEBAcHBwcEBAQEBAQEAwMEBAQEBAQEBAQCBAQEBQUFBQUEBAQEBAcHBwcHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcHBwcHBQcHBwcHBQcHBwcHBQcHBwcHBQcHBwcHBQcHBwcHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwUHBwcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAcHCQwJBwkHCQcJBgcFCAYJBwsKCAcIBggIBwcJBwYFBwcGAwkFBQgJBwcQBwkHCwkIBgsICggNCgcGCggJBwoICggNCwoHDgoAEAcJBgYAAAAAAAAJBwgGCAcIBwcGBwUJBgsIDgoJBgkGBwYLCAgGCggKCAMLCQgHCAcJBwkHCAYKCAQHBwcHDAsIBwkHCwkHBgcHCQcJBwkHCQcJBggFCAUIBQgGCgkIBwwLCwoIBgwLDAsJBwkIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBwgHCAcIBwkGCQcJBwkHCQcJBwgHCAcIBwgHCAcHAwkHCQcJBwkHCQcJBwMDAwMIBggGCAYHAwcDBwMHAwkLCQsJCwkHCQcJBwkHCQcJBwkHCQcIBwgHCQQJBAkECQQIBwgHCAcIBwgHBwMHAwcDBwMJBwkHCQcJBwkHBwUHBQsJCwkHBQcFBwUHBQcFBwUHAwkFBwMHBwcHBwcHBwcHCgoKCgoKBQUFBQUFCQkLCwsLBwcHBwcHBwcKCgwMDAwMDAMDAwMDAwMDBQUHBwcHBwcHBwcHBwcKCgwMDAwHBwcHBwcHBwoMDAwJCQkJCQkJCQoKDAwLCwsLBwcFBQcHAwMHBwcHCQkHBwcHBwcHBwcHCgoKCgoKBwcHBwcHBwcKCgwMDAwMDAkJCQkJCQkJCgoMDAsLCwsHBwcHBwcHBwcHBwcEBAQEBAcHBwcHCgoKCgkEBAQDAwMDAwMDAwUFBAQEBwcHBwcHBwcHBwoLCQQEBAkJCQkJCwoLCgkEBAcJCQoJDgsIBwwGBwAAAAADAwYICAQIBAgIBAQEBAQEBAQEAwQEBAQFBQQAAAAAAAAAAAAAAAgHBgkLBgYHBwYGAwUGBQkHBwYHBwcLBQcHBgcHBQcHCQcFCQUGBQcEBgcGCQcFCAUFBQUFBgUCBAUEBgUFBgUFBQUFBwQEBQcFBQQEBAQFAgQHBQUEBQUFAwUFBwQFBQQFBQQCAwUEBQQFBQQLEAUPCAMHAAAAAAAAAAAABAQGBgUFBQUJCAkHBwkICQcAAAAHBAQCAgICCg8GDAYMBAMCBwMCAQAJCQoICwsLCAkGBwcGBgcAAAAAAAcJCQkHBAAAAAQAAwMAAAAAAAAACQkDAwkJAwMJCQMDCQkDAwkJAwMJCQMDCQkDAwcGBgYHBgYGBAQEBAYGCgoGBgcFBgUHBQYFBwUGBQkJAwMJCQMDCgsFBgoLBQYKCwUGBAQFBQQEBQUGBgMDBgYDAwYGAwMGBgICBgYGBgoKBgYHBwMKBwcEBAYDBgcFBwkDAwcHBwcHAwkGAwoHBwQGBQYGBgcHBwcGBggDBgMHBwUEBAQEAwMFBQICAgIDAgIDBwcFBQUFBQQCAwUFBQQEBAQEBAQAAAAAAwQEBQQECQgHCQQHBwcHBwcHBwMDAwMDAwMDBwcHBwcHBwcDAwMDBwcHBwcHBQgJBwgHBgMJBwkECAYGBgYDBwQIBggGBwYIBwAAAAAAAAAAAAsGBgcDBwgJBwMJBwgGBwYGBwUIAAAAAAAAAwkJCQAAAAAAAAAAAAAACQcLCQgACQcMCgMFAgIGBgMDAwQAAAAAAAAAAAcHBwUGBgcGBwYHBwcFBwcHBwcGBwcJCQkOCQUICQcDBgMHAwcHBwUDAwcHBwcHBggHAwUHBgkHCAcIBwcGBwcKBwcGCgoGCAcHBwcHBwcHBwcHBwcHAwMDAwcICAgICAcHBwcHBwcHBwcHBwcHBwcHBwcICAgIBwcDAwMDAwgFBwYGBgYHBwcHCAgIBwcHBwcHBwcGBgYGBwcHBwcHCgoKCgcHBwYGBgcKCAcHBgcHBgcIAwcHCQcGCAcHBgYHCAcICAcHBwMIBwgDBwcJBgcHAwMFCgoJBgcHBwcHBgcHCgYHBwYHCQcIBwcHBgcIBwcHCQkICQcHCgcFBAQEBAQEBAQEBAQEBAkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJBQUFBQUFBQUFBgUFBQMDBAQDBQUFBQUFBQUIBwcHBwcHBwcHAwYDAwQEAwMDBQMHBwcHBwQEBAQHBwcJBwkDAwMDAwMDAwMDAwMDAwMTFQAWAAAAAAcGBgYHBgYGCgoGBgYGBwYGBgIDAgMIBwMDCAcDAwgHAwMFBQUFCgoKCgcGBgYKCgYGCgoGBgcHBQUHCAcHCwkLCBIAAAAAAAgHAwMKCwUGCgsFBggHAwMIBwMDCAcDAwAHBgcGCQcIBxAHCAwJCQkLCggGDQsOCgkHCAcDAwcJBQcHCAcKCAkIBAcGAgQIBwMJEQwRFgICAgMCAgICAwICAgICAgICAgICAwMDAwMDAwIEBAcEBAYGCAgICAgICAgHBwYHBwYJCQMDBwYGBgcHBwcJCQMDBwcDAwYGAgIEBAUFCAcDAwgHAwMGBgUFBQUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHBwAFBgcIAAAEBAYGBgYGBgYGBgcEBQMCAAoJCQkJCQkHCQoJCAYLCQgHCAkICQkJCAkICgkJCQgICAgGCQgJCQMDAgIDAwYKBwcHBwcGBwgHBwMKBwcHBgcHBwMHBQcECgYHBwcKBwcFCgcHCQkDBAwMCQ0NDQ0RBwwAAAkJAwMCBAQNDQoKCgsFBgMCBgYABgkHEA0IBwgHCgkGCQkGCQoADRoKAAQEAwUHBwwJAgQEBQgEBAQEBwcHBwcHBwcHBwQECAgIBw0JCQkJCQgKCQMGCQcLCQoJCgkJBwkJDQcJBwQEBAUHBAcHBwcHAwcHAwMHAwsHBwcHBAcEBwUJBwcHBAMECAkJCQkJCgkHBwcHBwcHBwcHBwMDAwMHBwcHBwcHBwcHBwUHBwcFBwkKCg0EBAcNCgkHBwcHBwYJCwcDBAUKDAcIAwgIBwcIBwcNCQkKDQwHDQQEAwMHBgcJAgcEBAcHBwQDBA4JCQkJCQMDAwMKCgoJCQkDBAQEBAQEBAQEBAcDCQcHBwMJBwkHCQcICAQEBAsLCwcKBwMJBwkHCQcHBwQJBwkHCQgJCQcJBwcDBwQHBAkHCQcKBwkECQQJBwcEBwUJBwkHBwcHBwcKCQgHBggFCAcHBQ8NBw0HDQcHDQkICAgICAkICQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCQgNDQ0NDQgICA0ODAoKBwkIBwcKCgYIAgUMBQgFBQgFCQcJBwkHCQcJBwkHCgcKBwoHCQcJBwMDAwMDAwMDBgMJBwcHAwkHCQcKBwoHCQQJBwgECQcJBwkHCQcNCQkHAwkHDQwKBwMNCQ0JDQkJBwMEBwgLCwsLBAQEBAkKCwUKCwoDCQkJCQcJAwkJCwkICgkJCAcJBwkKAwkIBgcDBwcHBgcHAwcHBwUGBwcGBwcJCQMHBwcJCQsHCQkDAwYODQsICAkJCQkHCQkLCAkJCAkLCQoJCQkHCAsHCgkLCwoLCAkNCQcHBwUIBwkGBwcGBwkHBwcHBwUHCQcHBwsMCAkHBwoHBwcFBwcDAwMMCwcGBwcGBQ0OCQAAAAAAAAAAAAAAAAAFAAMAAAQHBwUHCAMFCAgDBwYGCAgDBQcHBwcGBgcHCQgGBgYDBQkDBwcGBgcJCQkJBwcHBwUHCAQFCAQHBgYIBQcHBwYHBwkIAwcGBwcAAAAABAQFBQMAAAAAAAAAAAcHBwcHBwcHBwcHBAcKCgQKBwcHCgoKCgoACgoKCgoKCgoICgoKCQkDAwoKCgoHBwcHBgYLDAUHCwwFBwgIBQoKCgoKCgoKCgoKCgoKCgAAAAAACgoAAAAAAAAAAAAAAAAAAAAABw0KCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKBAQKCAUDAwMDBgYDAwgIAwMDAwkJAwMEBQkJAwMJCQMDBwcHBwcHBwcHBwcHBAQEBAYGBgYLCwcHCwsHBw4OCwsODgsLCAgICAgICAgHBgcFBwYHBQoKAwMICAMDCAgFBQcHAwMEBAUFBwcDAwQFBgUGBggICAgDAwcIBwgHCAcICgoAAAoKCgAACgoAAAoKCgAAAAAAAAoAAAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgQEBAoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgINGgsJCwkAAAAAAAAAAAAAAAAAAAAABwsLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMJBwkHCQcJBwkHCQcJBwkHCQcJBwkHCQcJBwkHCQcJBwkHCQcJBwkHAwMDAwoHCgcKBwoHCgcKBwoHCwkLCQsJCwkLCQkHCQcLCQsJCwkLCQsJCQcJBwkHCQcDAwoHCQcJBwkHCQcJBwAAAAAHBQwJCAYIBgkHBwcHBwkHCQcJBwoHCgcJAwMDCAMDAwMDAwQAAAQEAAAAAAMDAwMDAwMDBgYGBggICQkDAwkJAwMJCQMDCQkDAwkJAwMJCQMDCQkDAwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwQEBAQEBAQEBAQEBAQEBAQEBAYGBgYGBgYGBgYGBgYGBgYLCwcHCwsHBwsLBwcODgsLDg4LCwgIBwYHBQoKCgMDCgoDAwoKAwMKCgMDCgoDAwgICAgPDwwMCwwFBwgIBQUICAUFCAgFBQsMBQcLDAUHCwwFBwsMBQcLDAUHBwcDAwcHAwMHBwMDBwcDAwcHAwMHBwcHBwcDAwcHBwcHBwQFBQUFBgYGBgYGBgYGBgYGBgYGBggICAgDAwYGCAgDAwgICwsLCwMAAAAAAAAADw4AAAAAAAADBQAACAAAAAsLBwcODgsLBwYHBQUEBAMEAwMDAwMLDAMABAYHCAcIBwgHCAcIBwgHCAcHBwgHCgkHCQcJCQcJCwkHBwkICAoICwMECQcDBwwJBwoLCQoHCQkHCAUECAQICgkKBwgHCAgHBwcHBgYHAwUIAxEQDg4LBhAMCgcJBwAJBw0MCgcKBwkHCgcKBwgHAxEQDgoHDQgJBwkHCQcJBwkHAwMDAwoHCgcJBAkECQcJBwkHBwMHBgkHCQgHCAcJBwkHCgcACgcKBwoHCQcHBwcHBwcHBwcKBgYIBwQHBwcHCAcHBwMDBQQEAwcLCwsHBwcHCgoHBAQEBAQEBAcHBwMDAwUEBAcHBwcJBwcHBwcHBwcHBwoHBwcHBQcFBwcHDQwNCQYJCgkIBgcFBQIDAwMFBgQCBQMDAwQEBQUICAgIBAQEBAQEBAQEBAQEBAQEBAQEAgQEBQUFBQUFBAQEBAQHBwcHBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcHBwcHBQcHBwcHBQcHBwcHBQcHBwcHBQcHBwcHBQcHBwcHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwUHBwcHBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwcFBwcHBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQHBwoMCgcKCAoHCQcIBQgHCggMCwkHCQcJCQgICgcGBQgHBwMKBgYJCQcHEQgKCAwJCQcMCQsJDgsIBgoJCgcKCAoIDgwLCA8LABEICQcHAAAAAAAACQcJBwkHCQcIBggGCgcLCA8LCgcJBwgGDAkJBwsJCwkDCwkJBwkICQcJBwkHCwkECQcJBw0MCQcKBwsJCAYIBwkHCQcKBwoHCQcIBwgHCAcJBwsJCQcNCwwLCQcNDA0LCgcKCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQcJBwkHCQcJBwkHCQcJBwkHCQcJBwkHCQcJBwkHCAMKBwkHCQcJBwkHCQcDAwMDCQcJBwkHBwMHAwcDBwMLCwsLCwsJBwkHCQcJBwoHCgcKBwoHCQcJBwkECQQJBAkECQcJBwkHCQcJBwcEBwQHBAcECQcJBwkHCQcJBwkFCQUNCQ0JBwcHBwkHBwcHBwcHBwQJBwcDCAgICAgICAgJCQsLCwsLCwYGBgYGBgoKDAwMDAcHBwcHBwcHCwsNDQ0NDQ0DAwMDAwMDAwUFBwcHBwcHBwcHBwcHCwsNDQ0NBwcHBwcHBwcLDA0MCQkJCQkJCQkKCg0NDAwMDAgIBgYHBwMDBwcHBwkJCAgICAgICAgJCQsLCwsLCwcHBwcHBwcHCwsNDQ0NDQ0JCQkJCQkJCQoKDQ0MDAwMCAgICAgICAkJCQkJBAQEBAQHBwcHBwsLCwsJBAQEAwMDAwMDAwMGBgQEBAcHBwcHBwcHCQkLDAoEBAQJCQkJCQwLDAoKBAQHCQkLCQ8MCQgNBwgAAAAAAwMHCQkFCQUJCQQEBAQEBAQEBAQEBAQEBQUEAAAAAAAAAAAAAAAJBwYKDAcHBwcGBgMFBwUJBwcHCAgIDAYHBwcHBwUHCAoIBQkHBgYIBQcHBwkHBgkFBQYFBQYGAgQGBQcGBgcFBQYGBggFBQUIBQUFBQQEBQIEBwUFBQUFBQMFBQcEBQUEBQYEAgMFBAUEBQYEDBEGEQkDBwAAAAAAAAAAAAQEBgYGBQYFCQkKCAgKCQoIAAAABwQFAwMDAwoQBw0HDQQDAgcEAwEACgkLCQwMDAkJBwcIBwcIAAAAAAAHCQkJBwUAAAAFAAMEAAAAAAAAAAkJAwMJCQMDCQkDAwkJAwMJCQMDCQkDAwkJAwMHBwcHBwcHBwQEBAQGBgsLBwcHBgcFBwYHBQcGBwUKCgMDCgoDAwsMBQcLDAUHCwwFBwQEBQUEBAUFBwcDAwcHAwMHBwMDBwcDAwYGBgYLCwcHBwcECwcHBAQHBAcHBQcKAwMHBwcHBwQJBwMLBwcEBwUHBwcHBwcHBgYIAwcDBwcFBQUFBAMDBQUCAgICBAICBAcHBQUFBQUEAgMFBQUFBAUFBQUFAAAAAAQFBQUEBQoJBwkECAgICAgICAgDAwMDAwMDAwcHBwcHBwcHAwMDAwcHBwcHCAYJCQkJBwcDCgcJBAkHBwcHAwcFCQcJBwgGCQgAAAAAAAAAAAAMBgcHAwcJCQcECQcJBwgHBwgGCAAAAAAAAAMJCQkAAAAAAAAAAAAAAAoHDQkJAAoIDQsEBgICBwcEBAQEAAAAAAAAAAAIBwcFBwcHBwcHBwcHBQcHBwcHBwcHCQkKDwoFCQoHAwYDBwQHBwcFAwMHBwgIBwcICAMGBwYJCAgHCAgHBwgHCgcHBwsLBggHCAgHBwcHBwcIBwcHBwMDAwMICAgICAgICAgIBwcHBwgICAgICAcHBwcHCAgICAgIAwMDAwMJBgcGBgYGCAgICAgICAgICAcHBwcHBwcHBwgICAgICAoKCgoHBwcHBwcHCwgHBwYHBwcICAMHBwkIBwgIBwcHBwkHCQgHBwgDCAcIAwcHCQYIBwMDBgsLCgcHCAcHBwYHBwoHCAgHBwkICAgHCAcHCAcIBwoKCQoHCAsIBQQEBAQEBAQEBAQEBAQJCQkJCQkJCQkJCQkJCQkJCQkJCQkJCgoKCgoKCgoKCgoKCgUFBQUFBQUFBQcFBQUDAwQEAwUFBQUFBQUFCQcHBwcHBwcHBwMGAwMEBAMEBAUEBwcHBwgEBAQECAgICggKAwMDAwMDAwMDAwMDAwMDFBcAGAAAAAAHBwcHBwcHBwsLBwcGBgcHBwcDAwMDCAgDAwgIAwMICAMDBgYGBgsLCwsHBwcHCwsHBwsLBwcICAUFCAgHCAwKCwgTAAAAAAAICAMDCwwFBwsMBQcICAMDCAgDAwgIAwMACAYIBgkICQcRBwkMCgoJDAsJBw4MDwsJBwkHBAQHCgUIBwkHCwkKCQQHBgIECQgDChINEhgDAwMDAwMDAwQDAwMDAwMDAwMDAwMDAwMDBAMDBAQHBQUHBwgICAgICAgIBwcGBwcGCQkDAwcHBwcICAgICgoDAwgIAwMHBwMDBAQFBQgIAwMICAMDBgYGBgYGAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwgABQcICAAABAQHBwcHBwcHBwcIBAUEAgAKCgkJCQkJCAkKCQkHDAoJCAkJCQoJCQkJCQoKCgkJCQkJBwoJCgoEAwIDAwMHCwcICAcHBgcJCAcDCwcHBwcHBwcDBwYHBQsHBwcHCwcHBQsHBwoJBAQNDQkODg4OEgcNAAAJCQMDAgQEDg4LCwsMBQcEAwYGAAYJBxEOCQcJCAsKBwoKBwoKAA8eCwAEBAUFCAgNCgMFBQYJBAUEBAgICAgICAgICAgEBAkJCQgPCQoLCwoJCwoDBwoICwoMCgwLCgkKCQ8JCQgEBAQFCAUICAgICAQICAMDBwMNCAgICAUIBAgHCwcHCAUDBQkJCQsKCgwKCAgICAgICAgICAgDAwMDCAgICAgICAgICAgGCAgIBQgJCwsPBQUIDwwLCAgICAgHCwwIBAUFDA0ICQUJCQgICQgIDwkJDA8OCA8FBQMDCAcHCQMIBQUICAgEAwUOCQoJCgoDAwMDDAwMCgoKAwUEBQUFBQUFBQUIAwoICAgDCwgJBwoICQkFBQUNDQ0ICwgDCggLCAsICAgFCQgJCAsJCwoICggIAwgECAUKCAoIDAgLBQsFCggJBAkGCggKCAgICAgIDAsJCAcJBQoICAURDwgPCA8ICA8LCQkJCQkLCQsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsJDw8PDw8JCQkPEA4LCwgKCQgICwsHCQMFDQUJBQUJBQkICwgLCAoICggKCAsICwgLCAoICggDAwMDAwMDAwcDCgcICAMKCAsIDAgMCAsFCggJBAoICggKCAoIDwsJBwMJCA8NDAgDDwsPCw8LCQcDBQgJDQ0NDQUFBQUJDA0GDAwLAwkKCgoICgMKCwsKCgwKCgkJCQkLCwMJCQcIAwgJBwcICAMIBwgHBwgIBwgICwwDCAgIDAoNCAsKAwMHEA8NCQoLCQoKCAoKDgkLCwkKCwoMCgoLCQoLCQsJDg8MDQoLDwsICQgFCQgJBwgIBwgKCAgICAgHBwsHCQgLCwkLCAgLCAgIBQgIAwMDDgwIBwcIBwYPEAoAAAAAAAAAAAAAAAAABgADAAAECAgGCAkDBgkJAwgHBwkJAwUJCAkIBwcICAoKBgYGBAYMAwgIBwcICgoKCggICAgGCAkEBgkECAcHCQUJCQgHCAgKCgMIBwgJAAAAAAUFBQYDAAAAAAAAAAAICAgICAgICAgICAUICwsECwgICAsLCwsLAAsLCwsLCwsLCgsLCwsLBAQLCwsLCAgICAcHDA4GCAwOBggKCQYLCwsLCwsLCwsLCwsLCwsAAAAAAAsLAAAAAAAAAAAAAAAAAAAAAAgPCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwUFCwkGAwMDAwYGAwMKCQQEAwMLCwQEBAYLCwQECwsEBAgICAgICAgICAgICAUFBQUHBwcHDAwICAwMCAgQEA0NEBANDQkJCQkJCQkJCAcIBggHCAYMDAQECQkEBAkJBgYICAMDBQUGBggIBAQEBgcGBgYKCQoJBAQICQgJCAkICQsLAAALCwsAAAsLAAALCwsAAAAAAAALAAALCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsFBQULCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsCDx4NCg0KAAAAAAAAAAAAAAAAAAAAAAgNDQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADCQgJCAkICQgJCAkICQgJCAkICQgJCAkICggKCAoICggKCAoICggKCAMDAwMMCAwIDAgMCAwIDAgMCA0KDQoNCg0KDQoKCAoIDQoNCg0KDQoNCgkHCQcJBwkIAwMMCAoICggKCAoICggAAAAACAUOCgkHCQcLCAgICAgKCAoICggLCAwICwQEBAkEBAQEBAQEAAAFBQAAAAADAwMDAwMDAwYGBgYKCQsLBAQLCwQECwsEBAsLBAQLCwQECwsEBAsLBAQICAgICAgICAgICAgICAgICAgICAgICAgFBQUFBQUFBQUFBQUFBQUFBQUHBwcHBwcHBwcHBwcHBwcHDAwICAwMCAgMDAgIEBANDRAQDQ0JCQgHCAYMDAwEBAwMBAQMDAQEDAwEBAwMBAQJCQkJEREODgwOBggJCQYGCQkGBgkJBgYMDgYIDA4GCAwOBggMDgYIDA4GCAgIAwMICAMDCAgDAwgIAwMICAQECAgICAgIBAQICAgICAgEBgYGBgYGBgYGBgYGBgYGBgYGBgYKCQoJBAQGBgoJBAQKCQwMDAwDAAAAAAAAABEQAAAAAAAAAwYAAAkAAAAMDAgIEBANDQgHCAYGBQQEBQQEBAQEDA4DAAUGCAkICQgJCAkICQgJCAkICAgJCAsKCAoICwsICwwKCAgKCQkMCQ0DBAoIAwgNCwgMDQoLCAoKCAkGBAkECQsLDAgJCAkJCAgICAcHCAQGCQUUEhAQDQcSDgwICQgACQgPDQwICwgKBwwIDAgJCAMUEhALCBAJCggJCAkICggKCAMDAwMMCAwICwULBQoICggKCAkECAcKCAsJCAkICQgKCAwIAAwIDAgMCAkHCAgICAgICAgICwcHCQgECAgICAkICAgDAwUFBQMJDQ0NCAgICAwMCAUFBQUFBQUICAgDBAMFBAQICQgICwgICAgICAgICAgMCAgICAYIBggICA4ODwsGCwsKCQcIBgYCBAQEBQcFAwUDAwMFBQUFCQkJCQUFBQUFBQUEBAUFBQUFBQUFBQIFBQUGBgYGBgUFBQUFCAgICAgICAgIBggICAgIBggICAgIBggICAgIBggICAgIBggICAgICAgICAYICAgICAYICAgICAYICAgICAYICAgICAYICAgICAgICAgGCAgICAgGCAgICAgGCAgICAgGCAgICAgGCAgICAgICAgIBggICAgIBggICAgIBggICAgIBggICAgIBggICAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQUFCQgMDgwIDAkMCAsICQYJCAsJDQ0KCAoICgoJCQsIBwYJCQgDDAcHCgsICBQJDAkOCwoIDQoMChANCQcMCgwIDAkMCRANDQkSDQAUCQsICAAAAAAAAAsICggKCAoICQcJBwsIDQoRDQsICwgJBw4KCggNCg0KAw4JCggKCQsICwgKCA0KBQkICQgPDQoICwgOCQkHCQgLCAsIDAgMCAsICgcKBwoHCQgNCwoIDw0ODAoIDw4QDQwICwoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkICggKCAoICwgLCAsICwgLCAsICggKCAoICggKCAkECwgKCAoICggKCAoIAwMDAwoHCgcKBwgDCAMIAwgDCw0LDQsNCggKCAoICggMCAwIDAgMCAoICggLBQsFCwULBQoICggKCAoICggJBAkECQQJBAoICggKCAoICggJBwkHDwsPCwkHCQcJBwgICAgICAgECwcIAwkJCQkJCQkJCQkMDAwMDAwHBwcHBwcLCw4ODg4ICAgICAgICAwMDw8PDw8PAwMDAwMDAwMGBgkJCQkJCQgICAgICAwMDw8PDwgICAgICAgIDA4PDgwMDAwMDAwMDAwPDw4ODg4JCQcHCAgDAwgICAgMDAkJCQkJCQkJCQkMDAwMDAwICAgICAgICAwMDw8PDw8PDAwMDAwMDAwMDA8PDg4ODgkJCQkJCQkJCQkJCQUFBQUFCAgICAgMDA0NCgUFBQMDAwMDAwMDBgYFBQUICAgICAgICAkJDQ0LBQUFDAwMDAwODA0MCwUFCAsLDQsRDgoJDwgJAAAAAAMDCAoKBQoGCgoFBQUFBQUFBQUEBQUFBQYGBQAAAAAAAAAAAAAACggHCw0ICAgIBwcDBggGCggICAkJCQ4HCAgICAgHCAkLCQcLCAcGCQUICAgLCAcKBgYHBgYHBgMFBgUIBgYIBgYHBgYJBgYGCQYGBgYFBQYCBQkGBgUGBgYDBgYJBQYGBQYHBQIEBgUGBQYHBQ4UBxMKBAgAAAAAAAAAAAAFBQcHBwYHBgsKCwkJCwoMCQAAAAgFBQMDAwMMEggPCA8FBAMIBAMBAAsLDQoODQ0KCwgICQgICQAAAAAACQsLCwgFAAAABQAEBAAAAAAAAAALCwQECwsEBAsLBAQLCwQECwsEBAsLBAQLCwQECAgICAgICAgFBQUFBwcMDAgICAcIBggHCAYIBwgGDAwEBAwMBAQMDgYIDA4GCAwOBggFBQYGBQUGBggIBAQICAQECAgEBAgIAwMHBwcHDAwICAgIBA0ICAUFCAQICAYIDAMDCAgJCAgECwgDDQgIBQgGCAgICAgICAcHCgMIAwgIBgUFBgUDAwYGAgICAgQCAgQJCQYGBgYGBQIDBgYGBQUFBQUGBQAAAAAEBgYGBQYMCggLBQkJCQkJCQkJAwMDAwMDAwMICAgICAgICAMDAwMICAgICAkHCgsLCggIAwsICwUKCAgICAMIBQoICggJBwoJAAAAAAAAAAAADgcICAMICgsIBAsICggJCAgJBgoAAAAAAAADCwsLAAAAAAAAAAAAAAAMCA8LCwALCRANBAcDAwgIBAQEBQAAAAAAAAAACQgIBggICAgICAgICAYICAgICAgICAsLCxELBgoMCAMHBAgECAgIBgQDCAkJCQgICgkEBgkHCwkKCAoJCAgJCAwICAgMDQcKCAkJCAgICAgICQgICAgEBAQECQoKCgoKCQkJCQgICAgJCQkJCQkICAgICAoKCgoJCQQEBAQECgYJBwcHBwkJCQkKCgoJCQkICAgICAgICAgJCQkJCQkMDAwMCAgICAgICAwKCAkHCAgICQoECQgLCQgKCQgICAgKCAoKCAgJBAoICgQICAsHCQgEBAYNDQsICAkICAkHCAgMCAkJCAgLCQoJCAkICAkICQgMCwoLCAkNCQYFBQUFBQUFBQUFBQUFCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsGBgYGBgYGBgYIBgYGBAQFBQQGBgYGBgYGBgoICAgICAgICAgDBwQEBQUEBAQGBAgICAgJBQUFBQkJCQsJCwQEBAQEBAQEBAQEBAQEBBgaABwAAAAACAgICAgICAgMDAgIBwcICAgIAwMDAwoJBAQKCQQECgkEBAYGBgYMDAwMCAgICAwMCAgMDAgICQkGBgkJCQkOCw0KFgAAAAAACgkEBAwOBggMDgYICgkEBAoJBAQKCQQEAAkHCQcLCQoIFAgKDgsMCw4NCggQDRENCwgLCAQECAwGCQgKCQ0KCwoFCAcCBQoJAwwVEBUcAwMDAwMDAwMEAwMDAwMDAwMDAwMEBAQEBAQEAwUFCAUFCAgKCgoKCgoKCggIBwgIBwsLBAQICAgICQkJCQwMBAQJCQQECAgDAwUFBgYKCQQECgkEBAcHBgYGBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgJAAYICQoAAAUFCAgICAgICAgICQUGBAMADAsLCwsLCwkLDAsKCA4MCgkLCwsLCwsLCwoMCwsLCgoKCggLCgwLBAMDAwQDCAwICQkICAcICgkIAw0ICAgICAgIAwgHCAUMCAgICAwICAYMCAgLCwQFDw8LERERERUIDwAACwsEBAMFBRAQDQ0MDgYIBAMHBwAHCwgUEAoICgkMDAgLCwgLDAAQIAwABAQFBgkJDgsDBQUGCQQFBAQJCQkJCQkJCQkJBAQJCQkJEAsLDAwLCgwLAwgLCQ0LDAsMCwsJCwsPCwkJBAQEBwkFCQkICQkECQgEAwgDDQgJCQkFCAQIBwsHBwcFAwUJCwsMCwsMCwkJCQkJCQgJCQkJAwMDAwgJCQkJCQgICAgJBgkJCQYJCQwMEAUFCRAMCwkJCQkJCAsNCQQFBQwOCQoFCQkJCQkJCRALCwwRDwkQBQUEBAkIBwkDCQUFCAgJBAQFEQsLCwsLAwMDAwwMDAsLCwMFBAUFBQUFBQUFCQMLCAkHAwwJCQcLCQkJBQUFDQ0NCQwJAwsIDAgMCAkJBQsJCwkMCgwLCQsJCQMJBAkFCwgLCAwJCwULBQsICQQJBgsICwgJBwkHCQwLCQkHCgUKCQgGEhAIEAgQCAgQDAkKCQoKCwoLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsMChAQEBAQCgoKEBEPDAwJCwoICAwMBwoDBg4FCgYGCgYLCQwIDAgLCQsJCwkMCQwJDAkLCAsIAwMDAwMDAwQIAwsICAkDCwgMCQwJDAkLBQsICgQLCAsICwgLCA8LCQcDCwkQDgwJAw8LDwsPCwkHBAUJCg0NDQ0FBQUFCw0NBgwMDAMLCwsLCQsDCwsNCwoMCwsKCQkLCwwDCQkHCAMICQgHCAkDCAgJBwcJCQgICAsNAwgJCA0LDgkMCwMDCBEQDQkKDAsLCwkLCw4KDAwJCw0LDAsLDAkKCwsMCg0ODQ4LDBAMCQkJBgkJCgcICAcICwgJCAkIBwcNBwkICwsKDAkIDAkJCAYICAQDAw8NCAcHCAgHEBELAAAAAAAAAAAAAAAAAAYAAwAABAkJBggKAwYKCQMIBwcKCgMGCQgJCQcICQgLCgYGBgQHDAMICAcHCQsLCwsJCQkJBggKBQcJBQgHBwoGCQkJCAkICwoDCQcJCQAAAAAFBQYHAwAAAAAAAAAACAgICAgICAgICAgFCAwMBQwICAgMDAwMDAAMDAwMDAwMDAoMDAwLCwQEDAwMDAkICAgICA0PBggNDwYICgkGDAwMDAwMDAwMDAwMDAwMAAAAAAAMDAAAAAAAAAAAAAAAAAAAAAAJEAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwFBQwKBwMEAwQHBwMECgkEBAMECwsEBAUGCwsEBAsLBAQJCAgICQgICAkICAgFBQUFCAgICA0NCQkNDQkJEhIODhISDg4JCQkJCQkJCQkHCAYJBwgGDQ0EBAkJBAQKCgYGCAgDAwUFBgYICAQEBQYHBgcHCgkKCQQECQoJCgkKCQoMDAAADAwMAAAMDAAADAwMAAAAAAAADAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMBQUFDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAhAgDgsOCwAAAAAAAAAAAAAAAAAAAAAIDQ0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAsJCwkLCQsJCwkLCQsJCwkLCQsJCwkLCQsJCwkLCQsJCwkLCQsJCwkDBAMEDAkMCQwJDAkMCQwJDAkOCw4LDgsOCw4LCwgLCA4LDgsOCw4LDgsJBwkHCQcLCQMEDAkLCAsICwgLCAsIAAAAAAkGDwsJBwkHDAkJCAkICwgLCAsIDAkMCQsEBAQJBAQEBAQEBAAABQUAAAAAAwQDBAMEAwQHBwcHCgkLCwQECwsEBAsLBAQLCwQECwsEBAsLBAQLCwQECQgICAkICAgJCAgICQgICAkICAgJCAgIBQUFBQUFBQUFBQUFBQUFBQUFCAgICAgICAgICAgICAgICA0NCQkNDQkJDQ0JCRISDg4SEg4OCQkJBwgGDQ0NBAQNDQQEDQ0EBA0NBAQNDQQECQkJCRISDw8NDwYICgoGBgoKBgYKCgYGDQ8GCA0PBggNDwYIDQ8GCA0PBggICAMDCAgDAwgIAwMICAMDCAgEBAgICAgICAQECAgJCAgIBQYGBgYHBwcHBwcHBwcHBwcHBwcHCgkKCQQEBwcKCQQECgkNDQ0NAwAAAAAAAAASEQAAAAAAAAMGAAAKAAAADQ0JCRISDg4JBwgGBwUFBAUEBAQEBA0PAwAFBgkKCQoJCgkKCQoJCgkKCAgJCgkMCwkLCQwMCAwNCwkJCwoKDAoOBAQLCAQIDgwJDA4LDAkLCwgKBgQKBAoMDAwICggKCgkJCQkHCAkEBwkFFRQREQ0HFA8MCQsJAAsJEA4MCQwJCwgMCQwJCgkEFRQRDAkRCgsICwkLCQsJCwkDAwMDDAkMCQsFCwULCAsICwgJBAkHCwgLCgkKCAsJCwkMCQAMCQwJDAkJBwkJCQkICAkJCQwHBwoIBAkJCQgKCQkJBAQGBQUECQ0NDQkJCQkNDQkFBQUFBQUFCQkIBAQEBgQECQkJCAwICAgJCQkICAgIDAkICQgGCAYJCAgPDxALBwwMCwoICAYGAwQEBAYIBQMGBAQEBQUGBgkJCQkFBQUFBQUFBAQFBQUFBQUFBQUDBQUGBgYGBgYFBQUFBQkJCQkJCQkJCQYJCQkJCQYJCQkJCQYJCQkJCQYJCQkJCQYJCQkJCQkJCQkGCQkJCQkGCQkJCQkGCQkJCQkGCQkJCQkGCQkJCQkJCQkJBgkJCQkJBgkJCQkJBgkJCQkJBgkJCQkJBgkJCQkJCQkJCQYJCQkJCQYJCQkJCQYJCQkJCQYJCQkJCQYJCQkJAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUFBQkJDA8MCQ0KDAkMCAoGCggMCQ4NCwkLCAsLCgoMCQcHCgkIAwwHBwsMCQgVCgwKDwsLCA4LDQsRDgoHDQsMCQ0KDQoRDg0KEw4AFQoMCAgAAAAAAAAMCQsICwkLCQoHCQcMCQ4KEg4MCAwICgcPCwsIDgsOCwMOCgsJCwkMCQwJCwgNCwULCQsJEA4LCQwJDgoKBwoJDAgMCAwJDAkMCAoHCgcKBwoIDgwLCRAODw0LCBAPEQ4MCQwLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALCQsJCwkLCQwIDAkMCQwJDAkMCQsJCwkLCQsJCwkKBAwJCwgLCAsICwgLCAMEAwMLCAsICwgJAwkDCQMJAw0NDQ0NDQsICwgLCAsIDAkMCQwJDAkLCQsJCwULBQsFCwULCAsICwgLCAsICQQJBAkECQQLCAsICwgLCAsICwcLBw8LDwsLBwsHCQcJBwkHCQcIBAsHCQMJCQkJCQkJCQsLDQ0NDQ0NBwcHBwcHDAwPDw8PCAgICAgICAgNDRAQEBAQEAMDAwMDAwMDBgYJCQkJCQkJCQkJCQkNDRAQEBAICAgICAgICA0PEA8NDQ0NDQ0NDQ0NEBAPDw8PCQkHBwgIAwMJCQgIDQ0JCQkJCQkJCQsLDQ0NDQ0NCAgICAgICAgNDRAQEBAQEA0NDQ0NDQ0NDQ0QEA8PDw8JCQkJCQkJCwsLCwsFBQUFBQgICAgIDQ0ODgsFBQUDAwMDAwMDAwcHBQUFCAgICAkJCAgJCQ4ODAUFBQ0NDQ0NDw0ODQwFBQkMDA0MEw8LChAICgAAAAAEBAgLCwYLBgsLBQUFBQUFBQUFBAUFBQUGBgUAAAAAAAAAAAAAAAsJCAwOCQgJCQgHBAcIBgsICQgKCgoPBwkJCAkJBwgKDAoHCwcHBwoGCAgICwgHCwcHBwcHCAcDBQcGCAcHCAYHBwcHCgYGBgoGBgYGBQUGAwUJBgYGBgYGBAYHCQUGBgUGBwYDBAYFBgUGBwYPFQcUCwQJAAAAAAAAAAAABQUICAcGBwYLCgwKCgwLDQkAAAAJBQYDAwMDDRQIEAgQBQQDCQQDAQAMDA0LDw4OCwwICQoICAkAAAAAAAkMDAwJBgAAAAYABAUAAAAAAAAACwsEBAsLBAQLCwQECwsEBAsLBAQLCwQECwsEBAkICAgJCAgIBQUFBQgIDQ0JCQkHCAYJBwgGCQcIBg0NBAQNDQQEDQ8GCA0PBggNDwYIBQUGBgUFBgYICAQECAgEBAgIBAQICAMDCAgICA0NCQkJCQQNCQkFBQgECAkGCQ0EBAkJCQkJBAsIBA0JCQUIBggICAkJCQkHBwoECAQJCQYGBgYFBAQGBgMDAwMEAwMECQkGBgYGBgUDBAYGBgYFBgYGBgYAAAAABAYGBgUGDAsJDAUJCQkJCQkJCQMDAwMDAwMDCAgICAgICAgDAwMDCAgICAkKBwsMCwsJCAQMCQwFCwgICAgDCQYLCAsICgcLCQAAAAAAAAAAAA8ICAkECQsMCQQMCQsICggICQcKAAAAAAAABAwMDAAAAAAAAAAAAAAADAkPCwsADAoRDQQHAwMICAQEBAUAAAAAAAAAAAoJCQYJCQkJCQgJCQkGCQkJCQkICQkMDAwTDAYLDAkECAQJBQkJCQYEBAkJCgoJCAoKBAcJBwwKCgkKCgkICgkNCQkIDQ0HCgkKCgkJCQkJCQoJCQkJBAQEBAoKCgoKCgoKCgoJCQkJCgoKCgoKCQkJCQkKCgoKCgoEBAQEBAsHCQcHBwcKCgoKCgoKCgoKCQkJCQkICAgICgoKCgoKDQ0NDQkJCQgICAkNCgkJBwkJCAoKBAkJDAoICgoJCAgJCwkLCgkJCgQKCQoECQkLBwoJBAQHDg0MCAkKCQkJBwkJDQgKCggJDAoKCgkKCAkKCQoJDAwLDAkKDQoGBQUFBQUFBQUFBQUFBQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMBgYGBgYGBgYGCAYGBgQEBQUEBgYGBgYGBgYLCQkJCQkJCQkJBAgEBAUFBAUFBgUJCQkJCQUFBQUKCgoMCgwEBAQEBAQEBAQEBAQEBAQZHAAeAAAAAAkICAgJCAgIDQ0JCQgICQgICAMEAwQKCQQECgkEBAoJBAQHBwcHDQ0NDQkICAgNDQkJDQ0JCQoKBgYJCgkKDwwOChcAAAAAAAoJBAQNDwYIDQ8GCAoJBAQKCQQECgkEBAAJCAoHDAkLCRUJCw8MDQsPDgsIEQ4SDgwJCwkEBAkMBgkJCwkNCwwLBQkIAwULCgMMFxEWHgMDAwQDAwMDBQMDAwMDAwMDAwMDBAQEBAQEBAMGBgkGBggICgoKCgoKCgoJCQgJCQgLCwQECQgICAkJCQkNDQQECQkEBAgIAwMFBQYGCgkEBAoJBAQHBwcHBwcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJCgAGCAoKAAAFBQkICQgJCAkJCAkFBgQDAA0MDAsLDAsKDA0LCwgPDAsKCwsLDAsLCwwLDQwMDAsLCwsIDAsNDAQEAwMEBAgNCQkJCQkICQsJCQQNCQkJCAkJCQQJBwkGDQgJCQkNCQkGDQkJDAsEBRAQDBISEhIWCRAAAAsLBAQDBQUSEg4ODQ8GCAUDCAgACAwJFRELCQsJDQ0JDAwJDA0AESINAAUFBQYJCQ8LAwYGBwoFBgUFCQkJCQkJCQkJCQUFCgoKCRELCwwMCwoMCwUJCwkNCwwLDAsLCQsLEQsLCQUFBQcJBgkJCQkJBQkJBAMIAw0JCQkJBggECQcLBwkIBgUGCgsLDAsLDAsJCQkJCQkJCQkJCQUFBQUJCQkJCQkJCQkJCQcJCQkGCQoNDREGBgkRDQwJCQkJCQgMDgkEBQUNDwkKBQoKCQkLCQkRCwsMERAJEQYGBAQJCAkLAwkGBgkJCQUEBhELCwsLCwUFBQUMDAwLCwsFBgQGBgYGBgYGBgkDCwgJCAUMCQsJCwkKCgYGBg4ODgkMCQULCAwJDAkKCQYLCQsJDAoMCwkLCQkDCQQJBgsJCwkMCQsGCwYLCAkECQYLCQsJCQgJCAkMDQoJCAsGCwkJBhMRCREJEQkJEQwKCgoKCgwLDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAoREREREQoKChESEA0NCQsKCQkNDQgKAwYPBgoGBgoGCwkMCQwJCwkLCQsJDAkMCQwJCwkLCQUFBQUFBQUECQMLCAgJAwsJDAkMCQwJCwYLCAoECwkLCQsJCwkRCwsJBAsJEQ8NCQQRCxELEQsLCQQGCQoODg4OBgYGBgsNDQYNDg0DCwsLCwkLBQsLDQsLDAsLCwkLCw0NBQsKCAkDCQoJCAkJAwgJCQcICQkICQkLDQMJCQkNCw8JDAsFBQkSEQ8KCwsLCwsJDAsPCgwMCgoNCwwLCwwJCw0LDQoPDw0OCgwQDAkJCQYKCQsICQkHCgsJCQkJCQgJDQcKCQ4OCwwJCQ0JCQkGCQgEBQMPDgkHCQkIBxESDAAAAAAAAAAAAAAAAAAHAAMAAAUKCQcJCgMHCgoDCQgICgoDBgoJCgkICAkJDAsHBwcEBwwDCQkICAkMDAwMCgoKCQcJCgUHCgUJCAgKBgoKCQgJCQwLAwkICQoAAAAABQUGBwQAAAAAAAAAAAkJCQkJCQkJCQkJBQkNDQUNCQkJDQ0NDQ0ADQ0NDQ0NDQ0LDQ0NDAwEBA0NDQ0KCQkJCAgOEAcJDhAHCQsKBg0NDQ0NDQ0NDQ0NDQ0NDQAAAAAADQ0AAAAAAAAAAAAAAAAAAAAACRENDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NBQUNCgcEBAQEBwcEBAsKBAQEBAwMBAQFBgwMBAQMDAQECgkJCQoJCQkKCQkJBgYGBggICAgODgkJDg4JCRMTDg4TEw4OCgoKCgoKCgoJCAkHCQgJBw0NBQQKCgUECgoHBwkJBAQGBgcHCQkEBAUGCAcHBwsKCwoEBAkKCQoJCgkKDQ0AAA0NDQAADQ0AAA0NDQAAAAAAAA0AAA0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQUFBQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQIRIg8LDwsAAAAAAAAAAAAAAAAAAAAACQ4OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQLCQsJCwkLCQsJCwkLCQsJCwkLCQsJCwkLCQsJCwkLCQsJCwkLCQsJBQQFBAwJDAkMCQwJDAkMCQwJDwsPCw8LDwsPCwsJCwkPCw8LDwsPCw8LCwkLCQsJCwkFBAwJCwkLCQsJCwkLCQAAAAAJBhALCgcKBwwJCQkJCQsJCwkLCQ0JDQkMBAUECgQEBAQEBAUAAAYGAAAAAAQEBAQEBAQEBwcHBwsKDAwEBAwMBAQMDAQEDAwEBAwMBAQMDAQEDAwEBAoJCQkKCQkJCgkJCQoJCQkKCQkJCgkJCQYGBgYGBgYGBgYGBgYGBgYGBggICAgICAgICAgICAgICAgODgkJDg4JCQ4OCQkTEw4OExMODgoKCQgJBw0NDQUEDQ0FBA0NBQQNDQUEDQ0FBAoKCgoUFA8PDhAHCQoKBwcKCgcHCgoHBw4QBwkOEAcJDhAHCQ4QBwkOEAcJCQkEBAkJBAQJCQQECQkEBAkJBAQJCQkJCQkEBAkJCgkJCQUGBwcHBwcHBwcHBwcHBwcHBwcHBwsKCwoEBAcHCwoEBAsKDg4ODgQAAAAAAAAAExIAAAAAAAADBgAACgAAAA4OCQkTEw4OCQgJBwcGBQQFBAQEBAQOEAMABgcJCgkKCQoJCgkKCQoJCgkJCQoJDQsJCwkMDAkMDgsJCQsKCg0LDwQFCwkECQ8MCQ0PCw0JCwsJCwYFCgUKDQwNCQoJCgoJCQkJCAgJBAcKBRcVEhIOCBUQDQkLCQALCREPDQkMCQsIDAkMCQoJBBcVEgwJEgsLCQsJCwkLCQsJBQUFBQwJDAkLBgsGCwkLCQsICQQJBwsJDAoKCgkLCQsJDAkADAkMCQwJCwkJCQkJCQkJCQkNCAgLCQUJCQoJCgkJCQQEBgYFBAoODg4JCQkJDQ0JBgYGBgYGBgkJCQQEBAYFBQkKCQkMCQkJCQkJCQkJCQ0JCQoJBwkHCQkJEA8RDAcMDQsLCAkHBwMEBAQGCAUDBgQEBAYGBgYKCgoKBgYGBgYGBgUFBgYGBgYGBgYFAwYGBgcHBwcHBgYGBgYJCQkJCQkJCQkHCQkJCQkHCQkJCQkHCQkJCQkHCQkJCQkHCQkJCQkJCQkJBwkJCQkJBwkJCQkJBwkJCQkJBwkJCQkJBwkJCQkJCQkJCQcJCQkJCQcJCQkJCQcJCQkJCQcJCQkJCQcJCQkJCQkJCQkHCQkJCQkHCQkJCQkHCQkJCQkHCQkJCQkHCQkJCQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGBgYKCQ0QDQoNCg0JDAkKBwsJDQoPDgsJCwkLCwoKDQkIBwoKCQMNCAgLDAkJFwsNChAMCwkPDA4MEg8KCA4MDQkOCw4LEg8OChQOABcLDAkJAAAAAAAADAoLCQsJCwkKCAoHDQkPCxMPDQkMCQoIEAwLCQ8LDwsFDwsLCQsKDAkMCQsJDgwGCwkLCREPCwkNCQ8LCggKCQwJDAkMCQ0JDAkLCQsJCwkKCQ4MCwkQDxAOCwkRDxIPDQoNCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwkLCQsJCwkMCQwJDAkMCQwJDAkLCQsJCwkLCQsJCgUMCQsJCwkLCQsJCwkFBAUFCwgLCAsICQMJAwkDCQMNDQ0NDQ0LCQsJCwkLCQwJDAkMCQwJCwkLCQsGCwYLBgsGCwgLCAsICwgLCAkECQQJBAkECwkLCQsJCwkLCQsHCwcRCxELCwcLBwsJCQgJCAkICQQLCQkECgoKCgoKCgoLCw4ODg4ODggICAgICA0NEBAQEAkJCQkJCQkJDg4REREREREDAwMDAwMDAwYGCgoKCgoKCQkJCQkJDg4RERERCQkJCQkJCQkOEBEQDQ0NDQ0NDQ0ODhEREBAQEAoKCAgJCQMDCQkJCQ0NCgoKCgoKCgoLCw4ODg4ODgkJCQkJCQkJDg4RERERERENDQ0NDQ0NDQ4OEREQEBAQCgoKCgoKCgsLCwsLBgYGBgYJCQkJCQ4ODw8LBgYGAwMDAwMDBQUHBwYGBgkJCQkJCQkJCwsPDw0GBgYNDQ0NDRAODw4NBgYJDAwODBQQCwoRCQoAAAAABAQJCwwGDAYMDAYGBgYGBgYGBgUGBgYGBwcGAAAAAAAAAAAAAAALCQgNDwkJCQkICAQHCQcLCQkJCgoKEAgJCQkJCQgJCgwKBwsICAcKBgkJCQwKCAsHBwgHBwgHAwUHBgkHBwkHBwgHBwsGBgYKBgYGBgUFBgMGCgcGBgYGBgQHBwoFBwcFBgcGAwQHBQcFBgcGEBYHFgsECQAAAAAAAAAAAAYGCAgIBwgHDAsNCgoNCw0KAAAACQYGBAQEBA0VCREJEQYEAwkFAwEADQwODA8PDwsMCQkKCQkKAAAAAAAKDAwMCQYAAAAGAAQFAAAAAAAAAAwMBAQMDAQEDAwEBAwMBAQMDAQEDAwEBAwMBAQKCQkJCgkJCQYGBgYICA4OCQkJCAkHCQgJBwkICQcNDQUEDQ0FBA4QBwkOEAcJDhAHCQYGBwcGBgcHCQkEBAkJBAQJCQQECQkEBAgICAgODgkJCQkFDgkJBgYJBQkJBgkNBAQJCQoJCQUMCQQOCQkGCQcJCQkJCQkJCAgLBAkECQkGBgYGBQQEBgcDAwMDBQMDBQoKBwcGBgYGAwQHBwYGBQYGBgYGAAAAAAUGBgYGBg0LCQwGCgoKCgoKCgoDAwMDAwMDAwkJCQkJCQkJAwMDAwkJCQkJCggLDAsLCQkEDQkMBgsJCQkJAwkGCwkLCQoICwoAAAAAAAAAAAAQCAkJBAkLDAkFDAkLCQoJCQoHCwAAAAAAAAQMDAwAAAAAAAAAAAAAAAwJEQsMAAwKEg4FBwMDCQkFBQUGAAAAAAAAAAAKCQkHCQkJCQoJCQoJBwkJCQkKCQkKDAwNFA0GCw0JBAgECQUKCQkGBAQJCgoKCQkLCwQHCggMCgsJCwoJCQoJDQkJCQ4OCAsJCgoJCQkJCQkKCQkJCQQEBAQKCwsLCwsKCgoKCQkJCQoKCgoKCgkJCQkJCwsLCwsLBAQEBAQLBwoICAgICgoKCwsLCwoKCgkJCQkJCQkJCQoKCgoKCg0NDQ0JCQkJCQkJDgsJCggJCQkLCwQKCQwKCQsKCQkJCQsJCwsJCQsECwkLBAkJDAgKCQQEBw8ODAkJCgkKCggJCQ0JCgoJCQwLCwoJCgkJCwkKCg0NDA0JCg4KBwYGBgYGBgYGBgYGBgYMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQ0NDQ0NDQ0NDQ0NDQYGBgYGBgYGBgkGBgYEBAUGBAYGBgYGBgYGCwkJCQkJCQkJCQQIBAQFBgQFBQYFCgoKCgoGBgYGCgoKDQoNBQUFBQUFBQUFBQUFBQUFGx4AIAAAAAAKCQkJCgkJCQ4OCQkICAoJCQkEBAQECwoEBAsKBAQLCgQEBwcHBw4ODg4KCQkJDg4JCQ4OCQkKCgcHCgsKChAMDwsZAAAAAAALCgQEDhAHCQ4QBwkLCgQECwoEBAsKBAQACggKCAwKCwkWCQsQDQ0MEA8LCRIPEw4MCQwJBQUJDQcKCQsKDgsMDAYJCAMFCwoFDRgSFyAEBAQEBAQEBAUEBAQEBAQEBAQEBAQEBAQEBQQDBgYJBgYJCQsLCwsLCwsLCgoICgoIDAwEBAoJCQkKCgoKDQ0FBAoKBQQJCQQEBgYHBwsKBAQLCgQECAgHBwcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQoABwkKCwAABQUJCQkJCQkJCQkKBQcFAwANDQwMDAwMCgwODAsJEA0MCgwMDA0MDAwMDA0NDQwMCwwMCQ0MDQ0FBAMDBQQJDgkKCgkJCAkLCgkEDgkJCQkJCgkECQgJBg4JCgkJDgkJBw4JCQ0MBQYREQwTExMTGAkRAAAMDAQEAwYGExMODg4QBwkFAwgIAAkMCRcSCwoLCg4NCQ0NCQ0OABMmDgAFBQYHCwsRDQQGBgcLBQYFBQsLCwsLCwsLCwsFBQsLCwsTDQ0ODg0MDw0GCg0LDw0PDQ8ODQwNDRMNDAwFBQUHCwYKCwoLCwYLCgQECQQQCgsLCwYKBQoJDQkJCQYGBgsNDQ4NDQ8NCgoKCgoKCgsLCwsGBgYGCgsLCwsLCgoKCgsICwsLBwoMDg4TBgYKEw8OCgoKCwsJDhAKBAcHDxELDAYLCwsKDAsLEw0NDxMSCxMHBwQECgkJDAMLBgYKCgsFBAcRDQ0NDQ0GBgYGDw8PDQ0NBgYFBgYGBgYGBgYLBA0KDAkGDgsMCQ0LCwsGBgYQEBALDwsGDQoOCg4KCwsGDQoNCg4MDg0LDQsLBAsGCwYNCg0KDwsOBg4GDQoMBQwHDQoNCgwJDAkKDw4LCwgMCAwLCgcVEwoTChMKChMOCwsLCwsNDA0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ4LExMTExMLCwsTFBEODgoMCwoKDg4ICwQHEQYLBwcLBw0KDgoOCg0LDQsNCw8LDwsPCw0KDQoGBgYGBgYGBAoEDQkKCwQNCg4LDwsPCw4GDQoMBQ0KDQoNCg0KEw0MCQQNChMRDwsGEw0TDRMNDAkEBgsLEBAQEAYGBgYNDw8HDxAPBA0NDQ0MDQYNDQ8NDA8NDQwMDA0ODgYMCwgKBAoLCggKCwQKCQsJCQsLCQoKDhAECgsKEA0QCg4NBgYKFBMPCwwODQwNCg0NEgsODgsMDw0PDQ0ODAwODQ4NEREPEQ0OEw4KCwoHCwsOCQoKCAoNCgsJCwoICRAJCwoODgwOCwoOCgsKBwoKBAYEEQ8KCAkKCQgTFA0AAAAAAAAAAAAAAAAABwAEAAAFCwoICgsEBwsLBAoJCQsLBAcLCgsKCQkKCg0MCQkJBAgQBAoKCQkKDQ0NDQsLCwoICgsFCAsFCgkJCwcLCwoJCgoNDAQKCQoLAAAAAAYGBwgEAAAAAAAAAAAKCgoKCgoKCgoKCgYKDg4FDgoKCg4ODg4OAA4ODg4ODg4ODA4ODg4OBQUODg4OCwoKCgkJDxIHCg8SBwoMCwcODg4ODg4ODg4ODg4ODg4AAAAAAA4OAAAAAAAAAAAAAAAAAAAAAAsTDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODgYGDgwIBAQEBAgIBAQMCwUFBAQODgUFBQcODgUFDg4FBQsKCgoLCgoKCwoKCgYGBgYJCQkJEBAKChAQCgoVFRAQFRUQEAsLCwsLCwsLCgkKBwoJCgcPDwUFCwsFBQsLBwcKCgQEBgYHBwoKBQUFBwkHCAgMCwwLBQUKCwoLCgsKCw4OAAAODg4AAA4OAAAODg4AAAAAAAAOAAAODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4GBgYODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4CEyYQDBANAAAAAAAAAAAAAAAAAAAAAAoQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEDQoNCg0KDQoNCg0KDQoNCg0KDQoNCg0KDQsNCw0LDQsNCw0LDQsNCwYEBgQPCw8LDwsPCw8LDwsPCxAMEAwQDBAMEAwNCg0KEA0QDRANEA0QDQwJDAkMCQ0KBgQPCw0KDQoNCg0KDQoAAAAACgcSDQsICwgOCwsKCwoNCg0KDQoOCw8LDgUFBQsFBQUFBQUFAAAGBgAAAAAEBAQEBAQEBAgICAgMCw4OBQUODgUFDg4FBQ4OBQUODgUFDg4FBQ4OBQULCgoKCwoKCgsKCgoLCgoKCwoKCgsKCgoGBgYGBgYGBgYGBgYGBgYGBgYJCQkJCQkJCQkJCQkJCQkJEBAKChAQCgoQEAoKFRUQEBUVEBALCwoJCgcPDw8FBQ8PBQUPDwUFDw8FBQ8PBQULCwsLFhYREQ8SBwoLCwcHCwsHBwsLBwcPEgcKDxIHCg8SBwoPEgcKDxIHCgoKBAQKCgQECgoEBAoKBAQKCgUFCgoKCgoKBQUKCgsKCgoFBwcHBwgICAgICAgICAgICAgICAgMCwwLBQUICAwLBQUMCw8PDw8EAAAAAAAAABUVAAAAAAAABAcAAAsAAAAQEAoKFRUQEAoJCgcIBgUFBgUFBQUFDxIEAAcJCgsKCwoLCgsKCwoLCgsKCgoLCw4MCwwLDg4KDg8MCwsNCwwPDBEEBQ0KBAoRDgsPEQ0OCw0NCgwHBQwFDA4ODwoMCgwMCgoLCwkJCwUICwYZFxQUEAkXEg8LDQoADQoTEQ8LDwsNCQ8LDwsMCgQZFxQPCxQMDQoNCg0KDQsNCwYGBgYPCw8LDgYOBg0KDQoNCgwGCggNCg0LCwwKDQoNCw8LAA8LDwsPCwwJCwsLCwoKCwsLDgkJDAoFCwsLCgwLCwsEBAcGBgQLEBAQCwsLCw8PCgYGBgYGBgYKCgoEBQQHBQULCwoKDgoKCgoKCgoKCgoPCgoLCggKCAsKChIREw4IDg8NDAkKBwcDBQUFBwkGBAcEBAQGBgcHCwsLCwYGBgYGBgYFBQYGBgYGBgYGBgMGBgcHBwcHBwYGBgYGCgoKCgoKCgoKBwoKCgoKBwoKCgoKBwoKCgoKBwoKCgoKBwoKCgoKCgoKCgcKCgoKCgcKCgoKCgcKCgoKCgcKCgoKCgcKCgoKCgoKCgoHCgoKCgoHCgoKCgoHCgoKCgoHCgoKCgoHCgoKCgoKCgoKBwoKCgoKBwoKCgoKBwoKCgoKBwoKCgoKBwoKCgoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgYGCwoPEg8LDwsPCw4KDAgMCg4LERANCw0KDQ0MCw4LCQgLCwoEDwgIDQ4LChkMDwwSDg0KEQ0QDRQQCwkPDQ8LDwwPDBQREAwXEAAZDA4KCgAAAAAAAA4LDAoNCw0KCwkLCA4KEQwWEQ4KDgoMCRINDQoQDRANBhIODQoMCw4LDgsNChANBg0KDQoTEQ0LDgsSDgsJCwoOCg4KDwsPCw4KDAkMCQwJDQoRDgwLEhESEA0KEhEUEQ8LDg0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0KDQsNCw0LDgoOCw4LDgsOCw4LDQsNCw0LDQsNCwwGDwsNCg0KDQoNCg0KBgQGBg0JDQkNCQsECwQLBAsEDxAPEA8QDQoNCg0KDQoPCw8LDwsPCw0LDQsOBg4GDgYOBg0KDQoNCg0KDQoMBQwFDAUMBQ0KDQoNCg0KDQoNCQ0JEw0TDQ0JDQkMCQwJDAkMCQoFDQkKBAsLCwsLCwsLDQ0PDw8PDw8ICAgICAgPDxISEhIKCgoKCgoKChAQExMTExMTBAQEBAQEBAQHBwsLCwsLCwsLCwsLCxAQExMSEgoKCgoKCgoKDxITEhAQEBAQEBAQDw8TExISEhILCwgICgoEBAsLCgoQEAsLCwsLCwsLDQ0PDw8PDw8KCgoKCgoKChAQExMTExMTEBAQEBAQEBAPDxMTEhISEgsLCwsLCwsNDQ0NDQYGBgYGCgoKCgoPDxERDQYGBgQEBAQEBAYGCAgGBgYKCgoKCwsKCgwMEBEPBgYGEBAQEBASEBEPDgYGCw4OEA4WEg0MEwoLAAAAAAQECg0NBw0HDQ0GBgYGBgYGBgYFBgYGBggIBgAAAAAAAAAAAAAADQsJDhEKCgoKCQkECAoIDQoLCgwMDBIJCwsKCgoICgsOCwkNCQkIDAcKCQoOCgkNCAgJCAgJCAMGCAcKCAgKBwgJCAgMBwcHCwcHBwcGBgcDBgsHBwcHBwcEBwgLBgcHBgcIBwMFBwYHBgcIBxIZCBgMBQoAAAAAAAAAAAAGBgkJCQcJBw0MDgwMDgwPCwAAAAsGBwQEBAQPFwoTChMGBQMLBQQCAA4OEA0RERENDgoLDAoKCwAAAAAACw4ODgoHAAAABwAFBgAAAAAAAAAODgUFDg4FBQ4OBQUODgUFDg4FBQ4OBQUODgUFCwoKCgsKCgoGBgYGCQkQEAoKCgkKBwoJCgcKCQoHDw8FBQ8PBQUPEgcKDxIHCg8SBwoGBgcHBgYHBwoKBQUKCgUFCgoFBQoKBAQJCQkJEBAKCgsLBRALCwYGCgUKCwcLDwQECwoLCwsFDgoEEAsLBgoHCgoKCwsLCwkJDAQKBAsKBwcHBwYEBAcHAwMDAwUDAwULCwcHBwcHBgMEBwcHBwYHBwcHBwAAAAAFBwcHBgcPDQsOBgsLCwsLCwsLBAQEBAQEBAQKCgoKCgoKCgQEBAQKCgoKCgsJDQ4NDQsKBA4LDgYNCgoKCgQKBw0KDQoLCQwLAAAAAAAAAAAAEgkKCwQLDQ4LBQ4LDQoMCgoLCAwAAAAAAAAEDg4OAAAAAAAAAAAAAAAPCxMNDQAOCxQQBQgEBAoKBQUFBgAAAAAAAAAADAsLBwoKCwoLCgsLCwcLCwsLCwoLCw4ODhYOBwwPCwQJBQsGCwsLBwUECwsLDAsKDAwFCAsJDgwMCwwMCwoMCg8LCwoQEAkMCwwLCwsLCwsLCwsLCwsFBQUFDAwMDAwMDAwMDAsLCwsLCwsLDAwLCwsLCwwMDAwMDAUFBQUFDQgLCQkJCQwMDAwMDAwMDAwLCwsLCwoKCgoMDAwMDAwPDw8PCwsLCgoKCxAMCwsJCwsKDAwFCwoODAoMDAsKCgsNCw0MCwsMBQwLDAULCw4JCwsFBQgREA4KCgwLCwsJCgsPCgwMCgoODAwMCwsKCgwLDAsPDw0OCgsQDAcGBgYGBgYGBgYGBgYGDg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4HBwcHBwcHBwcKBwcHBQUGBgUHBwcHBwcHBwwLCwsLCwsLCwsECQUFBgYFBgYHBgsLCwsLBgYGBgwMDA4LDgUFBQUFBQUFBQUFBQUFBR4hACMAAAAACwoKCgsKCgoQEAoKCQkLCgoKBAQEBAwLBQUMCwUFDAsFBQgICAgPDw8PCwoKChAQCgoQEAoKCwsHBwsMCwwRDhEMHAAAAAAADAsFBQ8SBwoPEgcKDAsFBQwLBQUMCwUFAAsJDAkOCw0LGQsNEg4PDhIQDQoUERYQDgoNCwUFCw8ICwsNCxANDg0GCwkDBg0MBg8bFBojBAQEBAQEBAQGBAQEBAQEBAQEBAQFBQUFBQUFBAcHCwcHCgoMDAwMDAwMDAsLCQsLCQ4OBQULCgoKCwsLCw8PBQULCwUFCgoEBAYGBwcMCwUFDAsFBQkJCAgICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoLAAgKCwwAAAYGCgoKCgoKCgoKCwYHBQQADw4ODg4ODQsODw4NChIPDQwNDg0ODg0NDg0PDg8ODQ0NDQoODQ8OBQQDBAUEChAKCwsLCgkKDQsKBBAKCwoKCwsKBAsJCgcQCgsKChAKCwcQCgsODgUGExMOFRUVFRoLEwAADg4FBQMGBhUVEBAPEgcKBQQJCQAKDgsZFA0LDAsQDwoODgoODwAVKhAABgYGBwwMEw4EBwcIDAYHBgYMDAwMDAwMDAwMBgYMDAwMFQ0ODw8ODRAOBgsODBEOEA4QDw4MDg0VDg4NBgYGCAwHDAsLCwwGCwsFBAoEEAsMCwsHCwYLCw8KCwkHBgcMDQ0PDg4QDgwMDAwMDAsMDAwMBgYGBgsMDAwMDAsLCwsMCAwMDAcLDQ8PFQcHDBUQDwwMDAwLCg8RDAYHCBATDA0GDAwMDA0MDBUNDRAVFAwVBwcFBQwKCw4EDAcHCwsMBgUHFQ0ODQ4OBgYGBhAQEA4ODgYHBwcHBwcHBwcHDAQOCw0JBg8MDgsODAwMBwcHEhISDBALBg4LDwsPCwwMBw0MDQwPDQ8ODA4MDAQMBgwHDgsOCxAMDwcPBw4LDAYMCA4LDgsNCQ0JDBAQDAwJDQgODAsIFxULFQsVCwsVDwwNDA0NDw0PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDRUVFRUVDQ0NFRYTEBALDgwLCxAPCQ0EBxMHDQcHDQcNDA8LDwsODA4MDgwQCxALEAwOCw4LBgYGBgYGBgULBA4KCgwEDgsPDBAMEAwPBw4LDQYOCw4LDgsOCxUPDgsFDQwVExAMBhUPFQ8VDw4LBQcMDRISEhIHBwcHDRARCBAREAQNDg4ODQ4GDg4RDg4QDg4NDA4OEhAGDgwJCwQKDAoJCwwECgsLCwkMDAoKCw4QBAoMChAOEgsPDgYGCxYVEgwNDw0ODgsODhMNDw8MDhEOEA4ODwwNEA4QDhIUERMODxUPDAwLCAwMDgoLCwkLDQsMCgsLCgsRCgwLEBANDwsLEAsMDAgLCwUGBBMRDAkLCwoJFRcOAAAAAAAAAAAAAAAAAAgABgAABgwLCAsNBggNDAYLCgoNDQYHDAsMCwoKDAsPDgsLCwUJEgYLCwoKCw8PDw8MDAwLCAsNBgkMBgsKCg0HDAwLCgwLDw4GCwoLDAAAAAAHBwcJBAAAAAAAAAAACwsLCwsLCwsLCwsHCxAQBhALCwsQEBAQEAAQEBAQEBAQEA0QEBAPDwUFEBAQEAwLCwsKChEUCAsRFAgLDQwIEBAQEBAQEBAQEBAQEBAQAAAAAAAQEAAAAAAAAAAAAAAAAAAAAAAMFRAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAHBxANCQQFBAUJCQQFDQwFBQQFDw8FBQYIDw8FBQ8PBQUMCwsLDAsLCwwLCwsHBwcHCgoKChERCwsREQsLFxcSEhcXEhIMDAwMDAwMDAsJCwgLCQsIEREGBgwMBgYNDQgICwsEBAcHCAgLCwUFBggJCAkJDQwNDAUFCw0LDQsNCw0QEAAAEBAQAAAQEAAAEBAQAAAAAAAAEAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBwcHEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAxUqEg4SDgAAAAAAAAAAAAAAAAAAAAALEhIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ0MDQwNDA0MDQwNDA0MDQwNDA0MDQwNDA4MDgwODA4MDgwODA4MDgwGBQYFEAwQDBAMEAwQDBAMEAwSDhIOEg4SDhIODgsOCxIOEg4SDhIOEg4OCw4LDgsNDAYFEAwOCw4LDgsOCw4LAAAAAAsIEw4MCQwJDwwMCwwLDgsOCw4LEAwQDA8FBgYMBQUFBQUFBgAABwcAAAAABAUEBQQFBAUJCQkJDQwPDwUFDw8FBQ8PBQUPDwUFDw8FBQ8PBQUPDwUFDAsLCwwLCwsMCwsLDAsLCwwLCwsMCwsLBwcHBwcHBwcHBwcHBwcHBwcHCgoKCgoKCgoKCgoKCgoKChERCwsREQsLERELCxcXEhIXFxISDAwLCQsIERERBgYREQYGEREGBhERBgYREQYGDAwMDBgYExMRFAgLDQ0ICA0NCAgNDQgIERQICxEUCAsRFAgLERQICxEUCAsLCwQECwsEBAsLBAQLCwQECwsFBQsLCwsLCwUFCwsMCwsLBggICAgJCQkJCQkJCQkJCQkJCQkJDQwNDAUFCQkNDAUFDQwRERERBAAAAAAAAAAYFwAAAAAAAAQIAAANAAAAERELCxcXEhILCQsICQcGBQcFBQUFBREUBgAHCwsNCw0LDQsNCw0LDQsNCwsLDQwQDgwODA8PCw8RDgwMDg0NEA0TBQYOCwULEw8MEBIOEAwODgsNCAYNBg0QDxALDQsNDQsLDAwKCgwFCQwGHBoWFhIJGhQQDA0MAA0MFRMQDBALDgoQDBAMDQsFHBoWEAsWDQ4LDQwNDA4MDgwGBgYGEAwQDA8HDwcOCw4LDgsMBgsJDgsPDQwNCw0MDgwQDAAQDBAMEAwOCwwMDAwLCwwMDBAKCg0LBgwLDAsNDAwMBQUHBwYFDBISEgwMDAwREAwHBwcHBwcHCwsLBQUFBwYGDAwLCw8LCwsLCwsLCwsLEAsLDAsICwgMCwsUExUPCQ8QDg0KCwgIAwUFBQgKBwQHBQUFBwcHBwwMDAwHBwcHBwcHBgYHBwcHBwcHBwcDBwcHCAgICAgHBwcHBwsLCwsLCwsLCwgLCwsLCwgLCwsLCwgLCwsLCwgLCwsLCwgLCwsLCwsLCwsICwsLCwsICwsLCwsICwsLCwsICwsLCwsICwsLCwsLCwsLCAsLCwsLCAsLCwsLCAsLCwsLCAsLCwsLCAsLCwsLCwsLCwgLCwsLCwgLCwsLCwgLCwsLCwgLCwsLCwgLCwsLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcHBwwLEBQQDBANEAwPCw0IDQsQDBMSDgwOCw4ODQ0PDAoJDQwLBBAJCQ4PDAscDRANFA8OCxMPEQ4WEg0KEQ4QDBENEQ0XExINGRIAHA0PCwsAAAAAAAAPDA4LDgwODA0KDAkQCxIOGBIQCw8LDQoTDw4LEg4SDgYTDg4MDgwPDA8MDgsSDgcNDA0MFRMODBAMEw4NCg0LDwsPCxAMEAwPCw0LDQsNCw4LEw8OCxQSFBEOCxQTFhIQDBAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANDA4LDgsOCw8LDwsPCw8LDwsPCw4MDgwODA4MDgwNBhALDgsOCw4LDgsOCwYFBgYOCg4KDgoMBAwEDAQMBBEQERAREA4LDgsOCw4LEAwQDBAMEAwOCw4LDwcPBw8HDwcOCw4LDgsOCw4LDAYMBgwGDAYOCw4LDgsOCw4LDQsNCxUPFQ8OCg4KDgsNCQ0JDQkLBg8LDAUMDAwMDAwMDA0NERERERERCQkJCQkJEBATExMTCwsLCwsLCwsRERUVFRUVFQQEBAQEBAQECAgMDAwMDAwMDAwMDAwRERUVFBQKCgoKCgoKChEUFRQQEBAQEBAQEBERFRUUFBQUDAwJCQsLBAQMDAoKEBAMDAwMDAwMDA0NERERERERCwsLCwsLCwsRERUVFRUVFRAQEBAQEBAQEREVFRQUFBQMDAwMDAwMDQ0NDQ0HBwcHBwsLCwsLERESEg4HBwcEBAQEBAQGBgkJBwcHCgoKCgwMCgoODhITEAcHBxAQEBAQExETERAHBwwPDxIPGBQODRULDAAAAAAFBQsODgcOCA4OBwcHBwcHBwcHBgcHBwcICAcAAAAAAAAAAAAAAA4MChATCwsMDAoKBQkLCA0LDAsNDQ0UCgwMCwsLCgoNDw0LDwkKCQ0ICwoLDwsKDgkJCQkJCgkEBwkHCwkJCwgJCQkJDQgICA0ICAgIBwcIAwcMCAgHCAgIBQgJDAcICAcICQcDBQgHCAcICQcUGwkbDgULAAAAAAAAAAAABwcKCgkICQgPDhANDRAOEQwAAAAMBwcEBAQEERoLFQsVBwUEDAYEAgAPDxIOExMTDg8LDA0LCwwAAAAAAAwPDw8LCAAAAAcABgYAAAAAAAAADw8FBQ8PBQUPDwUFDw8FBQ8PBQUPDwUFDw8FBQwLCwsMCwsLBwcHBwoKERELCwsJCwgLCQsICwkLCBERBgYREQYGERQICxEUCAsRFAgLBwcICAcHCAgLCwUFCwsFBQsLBQULCwQECgoKChERCwsMDAYSDAwHBwsGCwwIDBEFBQwLDAwMBg8LBRIMDAcLCAsLCwwMDAwKCg4FCwUMCwgHBwgHBQUICAMDAwMGAwMGDAwICAgICAcDBQgICAcHCAgICAgAAAAABggICAcIEA4MDwcMDAwMDAwMDAQEBAQEBAQECgoKCgoKCgoEBAQECgoKCgsNCg4PDg4MCwUPDA8HDgsLCwsECwgOCw4LDQoODAAAAAAAAAAAABQKCwwFDA4PDAYPDA4LDQsLDAkOAAAAAAAABQ8PDwAAAAAAAAAAAAAAEAsVDw8ADw0WEgYJBAQLCwYGBgcAAAAAAAAAAA0MDAgLCwwLDAsMDAwIDAwMDAwLDAwPDxAYEAgOEAwFCgUMBgwMDAgFBQwMDQ0MCw4NBQkMCg8NDgwODQwLDQwRDAwLERIKDgwNDQwMDAwMDA0MDAwMBQUFBQ0ODg4ODg0NDQ0MDAwMDQ0NDQ0NDAwMDAwODg4ODQ0FBQUFBQ4JDAoKCgoNDQ0NDg4ODQ0NDAwMDAwLCwsLDQ0NDQ0NEREREQwMDAsLCwwRDgwMCgwMCw0OBQwLDw0LDg0MCwsMDgwODgwMDQUODA4FDAwPCg0MBQUJEhIPCwwNDAwMCgwMEQsNDQsMDw0ODQwNCwwNDA0MEBAOEAsNEg0IBwcHBwcHBwcHBwcHBw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8QEBAQEBAQEBAQEBAQCAgICAgICAgICwgICAUFBgcFCAgICAgICAgODAwMDAwMDAwMBQoFBQYHBQYGCAYMDAwMDAcHBwcNDQ0QDQ8GBgYGBgYGBgYGBgYGBgYhJQAnAAAAAAwLCwsMCwsLERELCwoKDAsLCwQFBAUNDAUFDQwFBQ0MBQUJCQkJEREREQwLCwsREQsLERELCw0NCAgMDQwNEw8TDR8AAAAAAA0MBQURFAgLERQICw0MBQUNDAUFDQwFBQAMCg0KDwwODBsMDhQQEQ8UEg4LFhMYEg8LDwwGBgwQCAwMDgwSDg8PBwwKAwcODQYQHhYdJwQEBAUEBAQEBgQEBAQEBAQEBAQEBQUFBQUGBQQHBwwICAsLDQ0NDQ0NDQ0MDAoMDAoPDwUFDAsLCwwMDAwREQYGDAwGBgsLBAQHBwgIDQwFBQ0MBQUKCgkJCQkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALDQAICw0OAAAHBwsLCwsLCwsLCwwHCAYEABEQDw8PDw8NDxEPDgsTEA8NDw8PEA8PDw8PERAQDw8ODg4LEA4QEAYFBAQGBQsRDAwMDAwKDA4MDAUSCwwMCwwMDAUMCgwHEQsMDAwRDAwIEQwMEA8GBxUVDxcXFxcdDBUAAA8PBQUEBwcXFxISERQICwYECgoACw8MHBYODA4MERELEBALEBEAGDASAAcHCAkNDRUQBQgICQ4HCAcHDQ0NDQ0NDQ0NDQcHDg4ODRgPEBEREA8TEQYMEA0TERMQExEQDhEPFw8QDwcHBwwNCA0ODA4NBw4OBQYMBhQODQ4OCAwHDgsRCwwMCAYIDg8PERARExENDQ0NDQ0MDQ0NDQYGBgYODQ0NDQ0ODg4ODQoNDQ0IDQ8SEhgICA0YExENDQ0NDgwRFA0GCQkSFQ8PCA4NDQ0PDQ0YDw8TGBcNGAgIBQUNDAwQBA0ICAwMDQcFCBoPEA8QEAYGBgYTExMREREGCAgICAgICAgICA0GEAwPDAYRDRAMEA0ODggICBQUFA0TDgYQDBEMEQwNDQgPDQ8NEQ8REA0QDQ0GDQcNCBEOEQ4TDREIEQgQDA4HDgkRDhEODwwPDA0TEg4NCw8JEA0MCRoYDBgMGAwMGBEODw4PDxEPEREREREREREREREREREREREREREREREREREREREREREREREREREREREREREREg8YGBgYGA8PDxkZFhISDRAODAwSEgsPBQkVCA8JCQ8JDw0RDBEMEA0QDRANEw4TDhMNEQ4RDgYGBgYGBgYFDAYQDAwNBhEOEQ0TDRMNEQgQDA8HEQ4RDhEOEQ4XERAMBQ8NGBUTDwYXERcRFxEQDAUIDQ4UFBQUCAgICA8TFAkTFBIGDxAQEA8RBhAQExEQExEQDw4QDxMSBhAOCw4GDg4LCw4NBgwMDgsLDQ4MDg0SEgYODQ4SEBUNERAGBgwZGBYODxEPEBANEBAWDxERDhATERMREBEODxIPEhAWFxMVEBEYEQ0ODQkODRALDQ0LDhENDQ0ODAsMFAsODRMUDxENDBINDQ4JDAwFBgYWFA4LDA0MChgaEQAAAAAAAAAAAAAAAAAJAAYAAAcODQoMDgYJDg4GDAsLDg4GCA4NDg0LCw0MEQ8MDAwGChUGDAwLCw0RERERDg4ODQoMDgcKDgcMCwsOCA4ODQsNDBEPBg0LDQ4AAAAACAgJCgUAAAAAAAAAAA0NDQ0NDQ0NDQ0NCA0SEgcSDQ0NEhISEhIAEhISEhISEhIPEhISEREGBhISEhIODQ0NDAwTFgkMExYJDA8OCRISEhISEhISEhISEhISEgAAAAAAEhIAAAAAAAAAAAAAAAAAAAAADRgSEhISEhISEhISEhISEhISEhISEhISEhISEhISCAgSDwoFBgUGCgoFBg8OBgYFBhERBgYHCRERBgYREQYGDg0NDQ4NDQ0ODQ0NCAgICAwMDAwUFA0NFBQNDRoaFBQaGhQUDg4ODg4ODg4NCw0JDQsNCRMTBgYODgYGDg4JCQwMBQUICAkJDQ0GBgcJCwkKCg8ODw4GBg0ODQ4NDg0OEhIAABISEgAAEhIAABISEgAAAAAAABIAABISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEhISEggICBISEhISEhISEhISEhISEhISEhISEhISEgMYMBUQFRAAAAAAAAAAAAAAAAAAAAAADBQUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUPDQ8NDw0PDQ8NDw0PDQ8NDw0PDQ8NDw0QDRANEA0QDRANEA0QDRANBgUGBRMNEw0TDRMNEw0TDRMNFRAVEBUQFRAVEBEOEQ4VEBUQFRAVEBUQEAwQDBAMDw0GBRMNEQ4RDhEOEQ4RDgAAAAANCRYQDgsOCxENDQwNDBAMEA0QDhINEw0RBgYGDgYGBgYGBgYAAAgIAAAAAAUGBQYFBgUGCgoKCg8OEREGBhERBgYREQYGEREGBhERBgYREQYGEREGBg4NDQ0ODQ0NDg0NDQ4NDQ0ODQ0NDg0NDQgICAgICAgICAgICAgICAgICAwMDAwMDAwMDAwMDAwMDAwUFA0NFBQNDRQUDQ0aGhQUGhoUFA4ODQsNCRMTEwYGExMGBhMTBgYTEwYGExMGBg4ODg4cHBYWExYJDA4OCQkODgkJDg4JCRMWCQwTFgkMExYJDBMWCQwTFgkMDAwFBQwMBQUMDAUFDAwFBQ0NBgYNDQ0NDQ0GBg0NDg0NDQcJCQkJCgoKCgoKCgoKCgoKCgoKCg8ODw4GBgoKDw4GBg8OExMTEwUAAAAAAAAAGxoAAAAAAAAFCQAADgAAABQUDQ0aGhQUDQsNCQoIBwYIBgYGBgYTFgYACAwNDg0ODQ4NDg0ODQ4NDg0NDQ4NEhANEA0REQwRExANDRAPDxMPFQUHEAwFDBURDRMVEBINEBAMDwkHDwcPEhETDA8MDw8NDQ0NCwwNBgoOCCAdGRkUCx0XEw0PDQAPDRgVEw0TDhAMEw0TDQ8NBSAdGRMOGQ8RDg8NDw0QDRANBgYGBhMNEw0RCBEIEQ4RDhAMDgcNChEOEQ8ODwwPDRANEw0AEw0TDRMNEAwNDQ0NDAwNDQ0SCwsPDAcNDg0MDw0NDQUFCQgHBQ4UFBQNDQ0NExMNCAgICAgICA0NDAUGBQgHBw0ODQwRDAwMDQ0NDAwMDBMNDA0NCgwKDQwMFxYYEQoREhAPDA0JCQQGBgYJDAgFCQUFBQgICAgODg4OCAgICAgICAcHCAgICAgICAgIBAgICAkJCQkJCAgICAgNDQ0NDQ0NDQ0JDQ0NDQ0JDQ0NDQ0JDQ0NDQ0JDQ0NDQ0JDQ0NDQ0NDQ0NCQ0NDQ0NCQ0NDQ0NCQ0NDQ0NCQ0NDQ0NCQ0NDQ0NDQ0NDQkNDQ0NDQkNDQ0NDQkNDQ0NDQkNDQ0NDQkNDQ0NDQ0NDQ0JDQ0NDQ0JDQ0NDQ0JDQ0NDQ0JDQ0NDQ0JDQ0NDQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAICAgODRMXEw0TDhMNEQwPCg8NEg4VFBANEAwQEA8OEg0LCg4ODAYTCwsQEQ0NIA8TDxcREAwWERQQGRUPCxMREw0TDxMPGhYUDx0UACAPEQwMAAAAAAAAEQ0QDRANEA0PCw4LEg0VEBsVEg0RDA8LFhEQDRUQFRAGFhAQDRAOEQ0RDRANFBEIDw0PDRgVEA0SDRYQDwsPDRENEQ0TDRMNEQwPDA8MDwwQDRUREA4XFRcUEAwXFhkVEw0SEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADw0QDhAOEA4RDBEOEQ4RDhEOEQ4QDRANEA0QDRANDwcTDhEOEQ4RDhEOEQ4GBQYGEAwQDBAMDQYNBg0GDQYTFBMUExQRDhEOEQ4RDhMNEw0TDRMNEA4QDhEIEQgRCBEIEAwQDBAMEAwQDA4HDgcOBw4HEQ4RDhEOEQ4RDg8LDwsXERcRDwsPCxAMDwwPDA8MDgcRDA0FDg4ODg4ODg4PDxQUFBQUFAsLCwsLCxISFhYWFg4ODg4ODg4OFBQYGBgYGBgGBgYGBgYGBgkJDg4ODg4ODQ0NDQ0NFBQZGRcXDg4ODg4ODg4UFxgXEhISEhISEhITExgYFxcXFw4OCwsODgYGDQ0ODhISDg4ODg4ODg4PDxQUFBQUFA4ODg4ODg4OFBQYGBgYGBgSEhISEhISEhMTGBgXFxcXDg4ODg4ODg8PDw8PCAgICAgODg4ODhQUFRURCAgIBgYGBgYGBgYKCggICA4ODg4ODg4OEBAVFRIICAgSEhISEhYUFRMSCAgNEREUERwXEA8YDA4AAAAABQUNEBAIEAkQEAgICAgICAgICAcICAgICgoIAAAAAAAAAAAAAAAQDQwSFQ0MDQ0MCwUKDAoRDQ0MDw8PFwsNDQ0NDQsODhIOCxEMCwoPCQwNDREOCxAKCgsKCgwKBAgKCAwKCgwJCgsKCg8JCQkOCQkJCQgICQQIDgkJCQkJCQUJCg4ICQkICQsIBAYJCAkICQsIFh8LHxAGDQAAAAAAAAAAAAgIDAwLCQsJERASDw8SEBMOAAAADQgJBQUFBRMdDBgMGAgGBA0HBQIAEhEUERYVFRARDA0PDAwOAAAAAAAOERERDQkAAAAIAAYHAAAAAAAAABERBgYREQYGEREGBhERBgYREQYGEREGBhERBgYODQ0NDg0NDQgICAgMDBQUDQ0NCw0JDQsNCQ0LDQkTEwYGExMGBhMWCQwTFgkMExYJDAgICQkICAkJDQ0GBg0NBgYNDQYGDAwFBQwMDAwUFA0NDQ0HFA0NCAgMBwwNCQ0TBQUNDQ4NDQcRDAUUDQ0IDAkMDAwNDQ0NCwsQBQwFDQ0JCQgJCAYGCQkEBAQEBwQEBw4OCQkJCQkIBAUJCQkICAkJCQkJAAAAAAcJCQkICRMQDREIDg4ODg4ODg4GBgYGBgYGBg4ODg4ODg4OBgYGBg4ODg4NDgsQERAQDQwFEg0RCBAMDAwMBg0JEAwQDA8LEA4AAAAAAAAAAAAXDAwNBQ0QEQ0HEQ0QDA8MDA4KEAAAAAAAAAUREREAAAAAAAAAAAAAABMOFxERABIOGRQHCwUFDAwHBwcIAAAAAAAAAAAPDQ0JDQ0NDQ0MDQ0NCQ0NDQ0NDQ0NERESHBIJEBMNBQwGDQcNDQ0JBgUNDg4PDQwQDwYKDgsRDxANEA8NDA8NEw0NDBQUCxANDw4NDQ0NDQ0ODQ0NDQYGBgYPEBAQEBAPDw8PDQ0NDQ4ODg4PDw0NDQ0NEBAQEA8PBgYGBgYQCg4LCwsLDw8PDxAQEA8PDw0NDQ0NDAwMDA8PDw8PDxMTExMNDQ0MDAwNFBANDgsNDQwPEAYODREPDRAPDQwMDRANEBANDQ8GEA0QBg0NEQsODQYGChUUEgwNDw0ODgsN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ERISDxASCA0TCysnIiIbDiceGRIVEQAVESAcGRIZERUQGREZERQRBysnIhkRIRQXEhURFREVERURCQkJCRkRGREXCxcLFxIXEhUQEwkRDhcSFxMSFBAVERUSGREAGREZERkRFQ8SEhISEBASEhIYDw8UEAkSERIQFBISEgcHCwoKBxIbGxsSEhISGRkSCwsLCwsLCxEREAcIBwsJCRISEhAXEBEQEREREBAQEBkQEBISDRANEhAQHx0gFw4XGBUUEBEMDAUICAgMDwoGCwcHBwsLCwsTExMTCwsLCwsLCwkJCwsLCwsLCwsKBQsLCwwMDAwMCwsLCwsREREREREREREMEREREREMEREREREMEREREREMEREREREMERERERERERERDBERERERDBERERERDBERERERDBERERERDBEREREREREREQwREREREQwREREREQwREREREQwREREREQwREREREREREREMEREREREMEREREREMEREREREMEREREREMEREREQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALCwsSEhkfGRIZExkSFxAUDRQRGBIdGxYSFhAVFRQTGBIPDRMSEAcZDg4VFxESKxQZFB4XFRAdFhsWIhwTDxkWGRIaFBoUIh0bFCYbACsUFxAQAAAAAAAAFxIVERUSFRITDxMOGBEcFSQcGBEXEBQPHhYVERwVHBUJHhYVEhUTFxIXEhURGxYLFREVESAcFREYEh4WEw8TERcSFxIZERkSFxAUDxQPFA8VERwXFREfHB8aFRAfHSEcGRIYFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFREVERURFREXEBcRFxEXERcRFxEVERURFREVERUSFAoZERcSFxIXEhcSFxIJBwkJFRAVEBUQEgcSBxIHEgcbGxsbGxsXEhcSFxIXEhkRGREZERkRFREVERcLFwsXCxcLFRAVEBUQFRAVEBMJEwkTCRMJFxIXEhcSFxIXEhUPFQ8gFyAXFQ4VDhUPFA8UDxQPEgkXDxEHExMTExMTExMVFRoaGhoaGg4ODg4ODhgYHh4eHhISEhISEhISGhogICAgICAH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AZgBmQGaAZsA/QD+AQYBBwEIAP8BnAGdAZ4BnwGgAaEBCQEKAQsBDAGiAaMA9gD3AaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMA+ADVAYoBiwG0AbUBtgG3AbgBDQEOAbkBugEPARABEQESAOAA4QETARQBuwG8ARUBFgGMAb0BvgG/AcABwQHCARcBGACvALABGQEaAcMBxAEbARwBHQEeAcUBxgD5APoA4gDjAR8BIAEhASIBxwHIAckBygHLAcwBzQHOASMBJAElASYBzwHQAdEB0gHTAdQAugEnASgBKQEqAOQA5QHVBooGiwaMBo0GjgaPBpAGkQaSBpMGlAaVBpYGlwaYBSQGmQaaAKYGmwacBp0GngafBqAGoQaiBqMGpAalBqYGpwRqBGsGqAapBqoGqwasBq0GrgavBrAGsQayBrMGtARsBG0GtQa2BrcGuAa5BroGuwa8Br0Gvga/BsAGwQbCBsMGxAbFBsYGxwbIBskGygbLBswGzQbOBs8G0AT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBtEG0gbTBtUG1gbXBtgG2QbaBtsG3AbdBt4G3wbgBuEG4gbjBuQG5QbmBucG6AbpBuoG6wbsBu0G7gHWAdcB2AHZAdoB2wsSBxAHEQcSBxMHFAcVBxYHFwcYBxkHGwccBx0HHgcfByAHIQciCxMLFAsVCw8L3wvgC+EL4gvjC+QL5QvmC+cL6Az1DPYM9wz4DPkM+gz7DPwM/Qz+DP8NAA0BDQIHIwckByUHJgcnBygHKQcqBysFJQsWCxcHgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQDWAN8HlgDYB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpADZANoA2wDeANcA3QelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7ULGAsZCxoLGwscCx0LHgsfCyALIQsiCyMLJAslCyYLJwsoBJIEkwhCBHoIQwhECEUIRghHBHQISAhJCEoISwhMCE0ITghPCFAIUQhSCFMIVAhVCFYIVwhYCFkIWghbCFwIXQheCF8IYASVCykLKgsrCywLLQsuCy8LMAvpC+oL6wvsC+0LMQsyCzMIjQiOCI8IkAiRCJIIkwiUCJUIlgiXCJgImQiaCJsInA9AD0EPQg9DCJ0Ing9ED0UInw0DDQQNBQAeEHwB7wHwAfEB3AHyAfMB9AH2AfcB+AH5AfoBKwH7AfwB/QH+ASwB/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoBLQILAgwCDQIOAg8CEAIRAhICEwIUAS4CFQIWAS8BMAIXAhgCGQIaAhsCHAIdAh4CHwIgAowCIQIiATEBMgIjATMCJAIlAiYCJwIoAikCKgIrD0YLNAs1C9sL3AvdC+4L7wvwC/EIxwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwjICMkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUIygKGAocIywjMCM0IzgjPCNAI0QjSCNMI1AjVCNYI1wjYCNkI2gjbCNwI3QjeCN8I4AjhCOII4wjkCOUI5gjnCOgI6gjrCOwI7QjuCO8I8AjxCPINQgjzCPQI9Qj2CPcI+Aj5CPoCiAKJBRAFEQj7CPwFEgUTCP0I/gUUBRUFFgUXCP8JAAkBCQIFGAUZCQMJBAkFCQYJBwkICQkJCgkLCQwFGgUbBRwFHQUeBR8JDQkOCQ8JEAUgBSEFIgUjCREJEgkTCRQJFQkWCRcJGAkZCRoJGwkcCR0JHgkfCSAJIQkiCSMNBgklCSYJJwkoCSkJKgkrCSwFJAUlCS0JLgkvCTAJMQkyCTMJNAk1CTYJNwk4CTkJOgUmBScJOwk8CT0JPgk/CUAJQQlCCUMJRAlFCUYL8gvzCUcJSA0HDQgNCQ0KDQsNDAlJCUoJSwlMCU0JTglPCVAJUQlSCVMJVAlVCVYJVwlYDQ0NDg0PDRAPSw9MD00PTg9PD1ANQw1EDUUNRg9RD1IPUw9UD1UPVg9XD1gPWQ9aEH0QfhB/EIAQgRCCEIMQhAlZCVoJWwlcCV0JXglfCWAJYQliCWMJZAllCWYJZwloCWkL9AlqCWsJbAltCW4JbwlwCXEJcglzCXQJdQl2Ao0CjgKPApACkQKSApMClAKVApYL9QKXApgCmQKaApsCnAKdAp4Cnwl3C/YL9wv4C6ELogujC6QPSBBmDsMOxA7FDsYOxwv5AuwLpgulC6cLqAupC6oLqwusBTMPIg8jDyQPJQ8mAu0QZQv6Au4PJwLvA4EDgwOFA4cDiQONA48DkwOVA5kDnQOhA6UDqQOrA60DrwOxA7UDuQO9A8EDxQPJA80PKw8vDzMPNw87AvAD0QPVA9kD3QPhA+UD6QPtA+8D8QLxAvIC8wL0AvUC9gL3AvgFOAU5BToLrQuuC68L+wv8C/0L/gv/DAAPPwL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBBAAAwUFKAUsBTsFPAU+BUAFOQVCBUQFRgVIBUoFTgVSBVYFWgMfBV4FYgVmBWoFbgVyBXYDJwV6BX4FgAWCBYQFhgWIBYoFjAWOBZAFkgWUBZYFmAWaBZwDKwWeBaAFpAWoBawFsAW0BbYFugW7Bb8FwwXHBcsFzwXRAy0F0wXXBdsF3wXjAzEF5wXrBe8F8wX3BfsF/wYDBgcGCwYPBhEGEwYXA+sGGQYdBh8GIAYhBiIGJAYmBigGKgYsBi4GMAM1BjIGNAY4BjoGPgZABkIGRAMIBkUGRgZHBkgGSQZKBksGTAZNBk4GTwZQBlEGUgZTBlQGVQZWBlcGWAZZBloQBAZbC7ELswL5AvoC+wL8AwoDCwMMAwADAQMCBlwGYAZkBmgGaQu1DAIMBgwKDA4MEgwWDBoMHgwiDCYMKAwqDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMagxsDt8O4w7nDusO7Q7xDvMO9Q75Dv0PAQ8DDwUPBw8JDw0PEQ8VD6YQaA+qD64Psg+2D7oPvg/CD8YPyg/MD84QbBBtEG8QcxB3EHkP0A/RD9IP0w/UD9UP1g/XD9gP2Q/aD9sP3A/dD94P3w/gD+EP4g/jD+QP5Q/mD+cP6A/pD+oQewveDRgNGQHdAd4B3wHgAeEB4gn/CgAKAQoCCgMKBAoFCgYKBwoICgkKCgoLCgwKDQoOCg8KEAoRChIKEwoUD1sPXA1HD10B4wHkBPYE9wT4BPkE+gT7D14PXw9gD2EPYg9jChUKFgoXChgKGQoaChsKHAodCh4KHwogCiEKIgojCiQKJQomCicKKAopCioLzgvPC9AL0QvSC9ML1AvVC9YL1wvYC9kC6ALpAuoC6wvFALEAsgKKBsUBNAC1ALYAwwHlALMAtADEC8YAggDBAIcDTgNPA1IDUANRC9cAxQGNAY4LxwE1D0cB5gNVA1YDVwNYA1MDVA5mDr4Ovw5kDsAOwQ5lCv4K/wsAAPUB5wsBCwIBNwsDCwQCwAR+ALwLBQsGCwcLEAsRDM4MzwzQDNEPSQ9KDV8NYA+T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BsMGxAbFBsYGxwbIBskGygbLBswGzQbOBs8G0AT8BP0E/gT/BQAFAQUCBQMFBAUFBQYFBwUIBQkFCgULBtEG0gbTBtUG1gbXBtgG2QbaBtsG3AbdBt4G3wbgBuEG4gbjBuQG5QbmBucG6AbpBuoG6wbsBu0G7gHWAdcB2AHZAdoB2wsSBxAHEQcSBxMHFAcVBxYHFwcYBxkHGwccBx0HHgcfByAHIQciCxMLFAsVCw8L3wvgC+EL4gvjC+QL5QvmC+cL6Az1DPYM9wz4DPkM+gz7DPwM/Qz+DP8NAA0BDQIHIwckByUHJgcnBygHKQcqBysFJQsWCxcHgAeBB4IHgweEB4UHhgeHB4gHiQeKB4sHjAeNB44HjweQB5EHkgeTB5QHlQDWAN8HlgDYB5cHmAeZB5oHmwecB50HngefB6AHoQeiB6MHpADZANoA2wDeANcA3QelB6YHpweoB6kHqgerB6wHrQeuB68HsAexB7IHswe0B7ULGAsZCxoLGwscCx0LHgsfCyALIQsiCyMLJAslCyYLJwsoBJIEkwhCBHoIQwhECEUIRghHBHQISAhJCEoISwhMCE0ITghPCFAIUQhSCFMIVAhVCFYIVwhYCFkIWghbCFwIXQheCF8IYASVCykLKgsrCywLLQsuCy8LMAvpC+oL6wvsC+0LMQsyCzMIjQiOCI8IkAiRCJIIkwiUCJUIlgiXCJgImQiaCJsInA9AD0EPQg9DCJ0Ing9ED0UInw0DDQQNBQAeEHwB7wHwAfEB3AHyAfMB9AH2AfcB+AH5AfoBKwH7AfwB/QH+ASwB/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoBLQILAgwCDQIOAg8CEAIRAhICEwIUAS4CFQIWAS8BMAIXAhgCGQIaAhsCHAIdAh4CHwIgAowCIQIiATEBMgIjATMCJAIlAiYCJwIoAikCKgIrD0YLNAs1C9sL3AvdC+4L7wvwC/EIxwIsAi0CLgIvAjACMQIyAjMCNAI1AjYCNwjICMkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUIygKGAocIywjMCM0IzgjPCNAI0QjSCNMI1AjVCNYI1wjYCNkI2gjbCNwI3QjeCN8I4AjhCOII4wjkCOUI5gjnCOgI6gjrCOwI7QjuCO8I8AjxCPINQgjzCPQI9Qj2CPcI+Aj5CPoCiAKJBRAFEQj7CPwFEgUTCP0I/gUUBRUFFgUXCP8JAAkBCQIFGAUZCQMJBAkFCQYJBwkICQkJCgkLCQwFGgUbBRwFHQUeBR8JDQkOCQ8JEAUgBSEFIgUjCREJEgkTCRQJFQkWCRcJGAkZCRoJGwkcCR0JHgkfCSAJIQkiCSMNBgklCSYJJwkoCSkJKgkrCSwFJAUlCS0JLgkvCTAJMQkyCTMJNAk1CTYJNwk4CTkJOgUmBScJOwk8CT0JPgk/CUAJQQlCCUMJRAlFCUYL8gvzCUcJSA0HDQgNCQ0KDQsNDAlJCUoJSwlMCU0JTglPCVAJUQlSCVMJVAlVCVYJVwlYDQ0NDg0PDRAPSw9MD00PTg9PD1ANQw1EDUUNRg9RD1IPUw9UD1UPVg9XD1gPWQ9aEH0QfhB/EIAQgRCCEIMQhAlZCVoJWwlcCV0JXglfCWAJYQliCWMJZAllCWYJZwloCWkL9AlqCWsJbAltCW4JbwlwCXEJcglzCXQJdQl2Ao0CjgKPApACkQKSApMClAKVApYL9QKXApgCmQKaApsCnAKdAp4Cnwl3C/YL9wv4C6ELogujC6QPSBBmDsMOxA7FDsYOxwv5AuwLpgulC6cLqAupC6oLqwusBTMPIg8jDyQPJQ8mAu0QZQv6Au4PJwLvA4EDgwOFA4cDiQONA48DkwOVA5kDnQOhA6UDqQOrA60DrwOxA7UDuQO9A8EDxQPJA80PKw8vDzMPNw87AvAD0QPVA9kD3QPhA+UD6QPtA+8D8QLxAvIC8wL0AvUC9gL3AvgFOAU5BToLrQuuC68L+wv8C/0L/gv/DAAPPwL5AvoC+wL8Av0C/gL/AwADAQMCAwMDBBAAAwUFKAUsBTsFPAU+BUAFOQVCBUQFRgVIBUoFTgVSBVYFWgMfBV4FYgVmBWoFbgVyBXYDJwV6BX4FgAWCBYQFhgWIBYoFjAWOBZAFkgWUBZYFmAWaBZwDKwWeBaAFpAWoBawFsAW0BbYFugW7Bb8FwwXHBcsFzwXRAy0F0wXXBdsF3wXjAzEF5wXrBe8F8wX3BfsF/wYDBgcGCwYPBhEGEwYXA+sGGQYdBh8GIAYhBiIGJAYmBigGKgYsBi4GMAM1BjIGNAY4BjoGPgZABkIGRAMIBkUGRgZHBkgGSQZKBksGTAZNBk4GTwZQBlEGUgZTBlQGVQZWBlcGWAZZBloQBAZbC7ELswL5AvoC+wL8AwoDCwMMAwADAQMCBlwGYAZkBmgGaQu1DAIMBgwKDA4MEgwWDBoMHgwiDCYMKAwqDCwMMAw0DDgMPAxADEQMSAxMDFAMVAxYDFwMYAxkDGgMagxsDt8O4w7nDusO7Q7xDvMO9Q75Dv0PAQ8DDwUPBw8JDw0PEQ8VD6YQaA+qD64Psg+2D7oPvg/CD8YPyg/MD84QbBBtEG8QcxB3EHkP0A/RD9IP0w/UD9UP1g/XD9gP2Q/aD9sP3A/dD94P3w/gD+EP4g/jD+QP5Q/mD+cP6A/pD+oQewveDRgNGQHdAd4B3wHgAeEB4gn/CgAKAQoCCgMKBAoFCgYKBwoICgkKCgoLCgwKDQoOCg8KEAoRChIKEwoUD1sPXA1HD10B4wHkBPYE9wT4BPkE+gT7D14PXw9gD2EPYg9jChUKFgoXChgKGQoaChsKHAodCh4KHwogCiEKIgojCiQKJQomCicKKAopCioLzgvPC9AL0QvSC9ML1AvVC9YL1wvYC9kC6ALpAuoC6wvFALEAsgKKBsUBNAC1ALYAwwHlALMAtADEC8YAggDBAIcDTgNPA1IDUANRC9cAxQGNAY4LxwE1D0cB5gNVA1YDVwNYA1MDVA5mDr4Ovw5kDsAOwQ5lCv4K/wsAAPUB5wsBCwIBNwsDCwQCwAR+ALwLBQsGCwcLEAsRDM4MzwzQDNEPSQ9KDV8NYA+TEIUQhhBkEIwCiwvaAJkA7QDCAKUAkgE/AI8BQQF2AZEBkgGTAXcAuAF8CwkNHQ0eDR8NIA0hDSINIw0kDSUNJg0nDSgNKQ1JD2QPZQ9mDUoNSw1MDSoNKw0sDS0PZw9oD2kPag9rD2wPbQ9uDS4NLw0wDTENUQ1SDVMNVA1VDTINMw1WDU0NTg1PDVAQhwC/AMAQiBCJEIoQiwZ0BnUGdwLGC7kLugu7C7wLvQu+C78LwAvBAscCyALJAsoCywLMAs0CzgLPAtAC0QLSAtMC3gLfAuAC4QLiAuMC5ALlAuYC5wU8BT0FUgVTBVQFVQMfAyADIQMiBWIFYwVkBWUFTgVPBVAFUQVeBV8FYAVhBUoFSwVMBU0FwwXEBcUFxgXLBcwFzQXOBXIFcwV0BXUFbgVvBXAFcQMnAygDKQMqBXoFewV8BX0FiAWJBYYFhwWKBYsFfgV/AysDLAWQBZEDLQMuAy8DMAMxAzIDMwM0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AAEpFAABKUQAASl0AAErlgABK+QAASwcAAEsTAABLIAAASymAAEszAABLRAAAS78AAEwpgABMMwAATDyAAExNgABMWYAATGWAAEx7AABMu4AATQaAAE0ZAABNJwAATT2AAE1NAABNWgAATWYAAE11AABNhQAATZSAAE2jgABNtAAATcGAAE3QgABN4IAATeoAAE3zAABOBwAATmsAAE6AgABOjYAATqEAAE60AABOxIAATtKAAE7gAABO8gAATyEAAE+TgABQFgAAUIGAAFELAABRcIAAUdyAAFIcAABSj4AAUq8AAFK5AABS6IAAU60AAFO9AABTzQAAU90AAFPsgABUBAAAVBuAAFQ3AABUPwAAVHmAAFStAABUuoAAVNMAAFTlgABU+AAAVP8AAFUGAABVDgAAVRYAAFUeAABVJgAAVS+AAFU5AABVQoAAVUwAAFVYAABVYgAAVWwAAFV3AABVggAAVY8AAFWZgABVpIAAVbIAAFW8gABVx4AAVdUAAFXfgABV6gAAVfcAAFYDAABWEAAAViEAAFYtAABWOgAAVkqAAFZXgABWZAAAVnSAAFaBgABWjYAAVp4AAFavAABWwIAAVteAAFbegABW5YAAVuyAAFbzgABW+oAAV1YAAFgBAABYnQAAWKQAAFiqgABYsYAAWLiAAFi/gABYxoAAWN2AAFjsAABZBoAAWTkAAFlhAABZloAAWbaAAFnYgABZ9IAAWhoAAFoxgABaQwAAWlqAAFpzAABao4AAWtMAAFreAABa+YAAWwqAAFt0AABbwQAAW9EAAFvYAABb4wAAW/EAAFwEAABcFAAAXCEAAFwtAABcOQAAXEUAAFxWAABcYgAAXG4AAFx+AABcigAAXJYAAFyiAABcsgAAXL4AAFzKAABc1gAAXN+AAF1ygABdfoAAXYqAAF3vAABeaIAAXnSAAF6AAABejAAAXpeAAF6jgABerwAAXrgAAF7BAABezQAAXzUAAF8+gABfSAAAX7eAAF/BAABfygAAX9OAAF/dAABgQgAAYLUAAGDDAABg0wAAYOIAAGDuAABg94AAYQCAAGEMgABhGIAAYV8AAGHKgABh1oAAYeUAAGH1AABiAQAAYg0AAGIdgABiJwAAYjCAAGJAgABiUIAAYlyAAGJsgABiroAAYs6AAGMHgABjE4AAYx+AAGMrgABjN4AAY0sAAGNXgABjZAAAY3AAAGN8AABjjYAAY5oAAGOmAABjs4AAY9WAAGPmAABkdIAAZL8AAGU0gABl1oAAZoWAAGb5gABnFwAAZzmAAGc9gABnZ4AAZ/KAAGhLAABosYAAaPOAAGlegABp8AAAaooAAGrPAABq0wAAatcAAGsjgABrJ4AAayuAAGsvgABrM4AAazeAAGuJgABrjYAAa5GAAGu6gABrvoAAa/mAAGv9gABsSwAAbE8AAGxTAABsVwAAbLsAAG1AAABtUIAAbV4AAG1rgABtd4AAbYOAAG2YgABtooAAbhKAAG5sAABuzAAAby6AAG+bgABvuQAAcCMAAHBxAABwdQAAcHkAAHDpgABw7YAAcVCAAHG3gAByC4AAcmkAAHLVgABzU4AAc2OAAHNxgABzfwAAc4iAAHOUgABzngAAdA8AAHQbAAB0eAAAdHwAAHSAAAB0kIAAdJSAAHULAAB1goAAdfOAAHX9gAB2CYAAdmkAAHZtAAB2xoAAdsqAAHb3gAB3WwAAd18AAHgJgAB4e4AAeOsAAHj3AAB5YIAAebiAAHm8gAB5wIAAecSAAHoCAAB6BgAAegoAAHoOAAB6WQAAesmAAHrNgAB7IAAAe3iAAHvVgAB8RIAAfJeAAH0FgAB9U4AAfWEAAH39gAB+JYAAfimAAH6ZgAB/DoAAfzWAAH+hgAB/pYAAgFIAAIDCAACBKQAAgTUAAIGogACCE4AAgowAAILhAACC5QAAgzgAAIM8AACDQAAAg3aAAIN6gACEBQAAhAkAAIRfAACErIAAhSAAAIWXgACF9AAAhlwAAIa3gACGzAAAh1IAAIe9AACHzIAAiEaAAIhPgACIroAAiLKAAIi2gACIxIAAiMiAAIk7gACJogAAigsAAIoUAACKIAAAioQAAIq4AACK7oAAiv2AAIt5gACLv4AAi+MAAIwsgACMWAAAjI0AAIyfAACMvQAAjO0AAIz2gACNBwAAjRwAAI1TAACNZYAAjXIAAI18AACNhYAAjZKAAI2jgACNtIAAjcQAAI4TgACOQYAAjomAAI6nAACO2oAAju8AAI8TgACPP4AAj3yAAI+RgACPtwAAj+aAAJAhAACQTYAAkJWAAJCqAACQ1IAAkSIAAJFYAACRkYAAkdMAAJIMgACSRQAAkoIAAJKpgACS6wAAkymAAJNHgACTZYAAk4MAAJOQgACTp4AAk9mAAJPfgACT5YAAk+uAAJPxAACT+AAAlCgAAJQuAACUNAAAlDoAAJRAAACURgAAlEwAAJS0AACUuYAAlL8AAJTEgACUyoAAlPGAAJUwAACVNgAAlV8AAJVkgACVagAAlW+AAJV1gACVe4AAleGAAJY7AACWkwAAlpkAAJafAACWpIAAlwEAAJcHAACXDQAAlxMAAJcZAACXHwAAl2sAAJd1AACXxAAAl+gAAJgSgACYMwAAmGIAAJioAACY64AAmPiAAJkaAACZcQAAmZGAAJmjAACZ5YAAmfeAAJo4gACaV4AAmm2AAJqOgACayQAAmw6AAJtNgACbeAAAm7QAAJvrAACcJAAAnF4AAJyKAACcqAAAnT+AAJ1KAACdVIAAnYKAAJ2NAACd3YAAnh8AAJ5ZgACeZAAAnm6AAJ55AACeg4AAno4AAJ6WAACeoIAAnqsAAJ61gACewAAAnsqAAJ7VAACe34AAnuoAAJ73AACfAYAAnwwAAJ8WgACfHIAAnyKAAJ8oAACfLYAAnzgAAJ9CgACfTQAAn1eAAJ9dgACfY4AAn2mAAJ9vgACfdYAAn3uAAJ/NAACgQAAAoIGAAKDhgAChSYAAodKAAKIpAACioYAAovKAAKM+AACjeYAAo4QAAKOOgACjmQAAo6OAAKOuAACjuIAAo8MAAKPNgACj2AAAo+KAAKPtAACj94AApAIAAKQMgACkFwAApB0AAKQlgACkK4AApKWAAKSsAACktoAApMEAAKTNAACk2QAApO0AAKUBAAClEQAApS2AAKVCgAClWgAApW+AAKV9AACljYAApZ8AAKWxgAClvYAApcuAAKXXgACmPIAApw4AAKcYgACnIwAApy2AAKc4AACnQoAAp00AAKdXgACnYgAAp2yAAKd3AACngYAAp4wAAKeWgACnoQAAp6uAAKe2AACnwIAAp8sAAKfVgACn4AAAp+qAAKf1AACn/4AAqAoAAKgUgACoHwAAqCmAAKg0AACodIAAqHoAAKiEgACoioAAqI6AAKiZgACopIAAqKoAAKivgACpGQAAqR8AAKkkgACpKgAAqTAAAKk2AACpPAAAqUIAAKlmAACpiYAAqY+AAKmVgACpmwAAqaCAAKmmgACprIAAqbKAAKm4gACpvoAAqcSAAKnKgACp0IAAqdaAAKncgACp4oAAqeiAAKnugACp9IAAqjQAAKqKgACqrYAAqrGAAKq3gACqvYAAqsOAAKrJgACq8IAAqvSAAKr6gACrAIAAqzaAAKs6gACrQIAAq0aAAKu4AACrvAAArBIAAKwWAACsHAAArCIAAKwoAACsLgAArIiAAKyMgACsyIAArMyAAKzSgACs2IAArN6AAKzkgACtNIAArTiAAK08gACtQIAArUaAAK1MgACtUoAArViAAK2tAACuAIAArjQAAK5tAACucwAArnkAAK5/AACuhQAArosAAK6RAACulwAArp0AAK6jAACuqQAArq8AAK7wgACvcAAAr3QAAK94AACvfAAAr86AAK/SgACwAIAAsASAALBIAACwTAAAsIcAALCLAACwkQAAsJcAALCdAACwowAAsKcAALCrAACxCAAAsVMAALGRgACxlYAAsZmAALGdgACxo4AAshIAALIXgACyHQAAsieAALIyAACyN4AAsj0AALJDAACySIAAsryAALMqAACzNIAAsz8AALNDAACzRwAAs1GAALNcAACzZoAAs2qAALNugACzeQAAs4OAALOHgACzi4AAs5YAALOggACzqwAAs7EAALO5AACzv4AAs8gAALPMAACz0gAAs9yAALPggACz5IAAs+8AALP5gAC0BAAAtA6AALQZAAC0I4AAtC4AALQ4gAC0QwAAtE2AALRYAAC0YoAAtG0AALR3gAC0ggAAtIyAALSXAAC0oYAAtKwAALS2gAC0wQAAtMuAALTWAAC04IAAtOsAALT1gAC1AAAAtQqAALUVAAC1H4AAtSoAALU0gAC1PwAAtUmAALVUAAC1XoAAtWkAALVzgAC1fgAAtYiAALWTAAC1nYAAtagAALWygAC1vQAAtceAALXSAAC13IAAtecAALXxgAC1/AAAtgaAALYRAAC2G4AAtkOAALZUgAC2cgAAtnyAALaHAAC2kYAAtpwAALamgAC2sQAAtruAALbGAAC20IAAttsAALblgAC28AAAtvqAALcFAAC3D4AAtxoAALckgAC3LwAAtzmAALdEAAC3ToAAt1kAALdjgAC3bgAAt3sAALeIAAC3lQAAt/mAALhggAC4x4AAuSqAALk8AAC5TYAAuWkAALmAAAC5lIAAubCAALnmgAC6GYAAuk+AALqCgAC6qoAAuvEAALseAAC7PoAAu1UAALtlAAC7rIAAu/8AALxlAAC8fAAAvJOAALyqgAC8wYAAvO6AAL0cAAC9RwAAvXIAAL2dAAC9ywAAvfkAAL4nAAC+K4AAvjAAAL40gAC+OQAAvj2AAL5ZAAC+dIAAvqKAAL6nAAC+q4AAvrAAAL60AAC+uIAAvr0AAL7BgAC+xgAAvsqAAL7PAAC++oAAvyWAAL9RAAC/fAAAv6IAAL+wgAC/uwAAv8WAAL/agAC/7wAAwA4AAMAggADAP4AAwFSAAMB1gADAigAAwKeAAMC9gADA1wAAwOyAAMEDAADBIoAAwTWAAMFNAADBZgAAwXmAAMGNAADBowAAwbUAAMG/gADBywAAwdSAAMHhgADB7YAAwfmAAMIOAADCKYAAwj8AAMJcAADCcQAAwo4AAMKfgADCuYAAwssAAMLiAADC7gAAwvyAAMMGAADDEgAAwxuAAMMlAADDMYAAwz2AAMNSAADDa4AAw4EAAMOagADDr4AAw8sAAMPbgADD84AAxAQAAMQXAADEJYAAxDSAAMRDAADEUgAAxF8AAMRrgADEd4AAxIOAAMSOAADEl4AAxKIAAMStgADEuAAAxMsAAMTcAADE6YAAxPiAAMUFgADFEQAAxSCAAMUsgADFOwAAxUWAAMVRAADFWoAAxWQAAMVvAADFhgAAxZIAAMWeAADFqgAAxbgAAMXFAADF0IAAxdyAAMXogADF9IAAxgCAAMYNgADGIwAAxjAAAMZIAADGVQAAxmsAAMZ4AADGjwAAxraAAMbqAADHMgAAx2QAAMeIAADHrYAAyCiAAMingADJBYAAyWSAAMnPAADKO4AAynWAAMrDAADLAQAAy0WAAMuNAADL2oAAzDUAAMyQgADM9gAAzVUAAM2ZAADNnQAAzegAAM43AADOfIAAzt2AAM8UAADPMYAAz18AAM+IgADP5IAAz/KAANARAADQQYAA0HAAANCKAADQy4AA0RkAANFMAADRo4AA0cIAANHggADR/wAA0i2AANJagADScYAA0ogAANKaAADStgAA0tUAANLngADS9gAA0weAANMYgADTLQAA00GAANNiAADTgoAA05MAANOjAADTsIAA074AANPJgADT1QAA0+IAANPvAADT/4AA1BAAANQfAADULgAA1DyAANRLAADUUwAA1FsAANRjAADUawAA1HmAANSIAADUmIAA1KkAANS5gADUygAA1N2AANTxAADVAYAA1RIAANUiAADVMgAA1UCAANVPAADVYgAA1XUAANWEgADVlIAA1aYAANW3gADVxoAA1dwAANXrAADV+gAA1goAANYaAADWKQAA1jgAANZIAADWWAAA1mkAANZ6AADWjwAA1rKAANbDAADW04AA1u2AANcHgADXFAAA1yCAANcugADXPIAA12IAANeHgADXmgAA16yAANe7gADXyoAA1+AAANf1gADYCAAA2BqAANgwgADYRoAA2FaAANhmgADYdIAA2IKAANiVAADYp4AA2LcAANjGgADY1wAA2OeAANj8gADZEYAA2SMAANk0gADZRgAA2VeAANltAADZgoAA2ZgAANmtgADZwIAA2dOAANnmgADZ+YAA2haAANozgADaUIAA2m2AANp9AADajIAA2pwAANqrgADauwAA2sqAANrbgADa7IAA2v+AANsSgADbKoAA2z2AANtNAADbYIAA26SAANu4gADbzIAA29qAANvogADb8IAA2/iAANwVgADcLoAA3D8AANxPgADcZQAA3HiAANyLgADcnoAA3K6AANy+gADc0IAA3OKAANz9gADdFAAA3SIAAN0oAADdOAAA3T4AAN1yAADdsQAA3eEAAN4cgADeMgAA3keAAN5cAADecQAA3ooAAN6jAADeuIAA3s4AAN7rgADfCQAA3xmAAN8qAADfOoAA30sAAN9bgADfbAAA34GAAN+XAADfq4AA38CAAN/igADgAwAA4CsAAOBTgADgYwAA4HKAAOCCAADgkQAA4KCAAOCwAADgv4AA4M6AAOEHgADhQoAA4YgAAOHPAADiAYAA4jQAAOJygADisQAA4vCAAOMwAADjd4AA478AAOQIgADkUgAA5JKAAOTTAADk94AA5RwAAOUrgADlOwAA5UMAAOVLAADlUoAA5VoAAOWeAADlogAA5bQAAOXGAADlzgAA5dYAAOXeAADl5gAA5faAAOYHAADmDwAA5hcAAOYfAADmJwAA5kUAAOZLAADmbwAA5oAAAOaQAADmsIAA5tEAAOcnAADnKwAA5z6AAOdSAADnYQAA53AAAOeBgADnkwAA56aAAOe6AADnzgAA5+IAAOf5AADoEAAA6G2AAOjHgADo1YAA6OQAAOjrgADo8wAA6QeAAOkcAADpMIAA6UYAAOlVAADpZAAA6XmAAOmOgADp3IAA6gSAAOoYAADqKAAA6jaAAOqcAADrPQAA62gAAOvNgADsJQAA7FiAAOzCAADtVwAA7eUAAO4CAADuHwAA7kQAAO6NAADulgAA7rKAAO71gADvOYAA732AAO/BAADwIoAA8C8AAPBXgADwYYAA8HoAAPCSgADwqwAA8MOAAPDLgADw04AA8NuAAPDjgADw64AA8POAAPD7gADxA4AA8VqAAPGvgADxs4AA8eMAAPIwgADySAAA8o4AAPLxgADzGwAA82yAAPN8AADzi4AA85GAAPOmgADzsIAA88cAAPPgAADz8gAA9AqAAPQigAD0PwAA9F4AAPR9AAD0nYAA9MCAAPTjgAD1BgAA9SYAAPU0gAD1Q4AA9ZyAAPXPAAD12wAA9ecAAPY1AAD2iQAA9o0AAPbIgAD2/YAA9zuAAPd5AAD32YAA+DAAAPg0AAD4egAA+KUAAPj1gAD5SwAA+WIAAPm5gAD53QAA+kaAAPqjAAD66AAA+vYAAPsPAAD7ewAA+9WAAPvuAAD8SAAA/ImAAPy3AAD84gAA/SwAAP1ngAD9n4AA/e+AAP46gAD+gQAA/t0AAP87gAD/P4AA/3eAAP+1AAD/4QABACAAAQBLAAEAjYABAMiAAQD6gAEBQ4ABAYSAAQHQAAECH4ABAnqAAQLIAAEDLQABA5cAAQPVAAEEGgABBGaAAQSjAAEEsQABBMaAAQTyAAEE9gABBQ6AAQUlgAEFPwABBVIAAQViAAEFcAABBXsAAQWGgAEFlQABBeKAAQXvgAEGEIABBj4AAQZKAAEGawABBncAAQaFAAEG6wABB04AAQdggAEHbwABB4SAAQeXgAEHoQABB6qAAQe7AAEHy4ABB9wAAQfoAAEH9gABCAOAAQgRAAEIIYABCC2AAQg5gAEIdwABCLgAAQjFAAEI0wABCOSAAQjxgAEI/YABCQuAAQkYgAEJJYABCTGAAQk9gAEJSwABCViAAQlkgAEJcIABCX2AAQmKgAEJloABCaKAAQmxAAEJvgABCcqAAQnXAAEJ5AABCfEAAQn9AAEKCQABChSAAQogAAEKbIABCtcAAQskAAELcQABC30AAQuLgAELsgABDAyAAQxjgAEMlIABDNmAAQzlgAEM8oABDTCAAQ2cgAENsoABDdEAAQ4gAAEOL4ABDkwAAQ5YAAEOZAABDnKAAQ6UgAEOoIABDqyAAQ8RAAEPY4ABD6aAAQ/qAAEQNQABEIqAARDhgAEROYABEYgAARHkgAESPIABEkCAARKuAAES+AABEx6AAROAgAEThIABE8OAARQlAAEUewABFKeAARTbgAEVHoABFUkAARVcgAEVcIABFZyAARXGAAEV5QABFjkAARZ2AAEWs4ABFvaAARcsgAEXYwABF4gAARfMgAEYMIABGHgAARi1gAEY4AABGQqAARk9AAEZZwABGZyAARm7gAEZ0wABGiuAARp4gAEa34ABGxAAARtQAAEbhoABG9YAARwBAAEcM4ABHG+AARyjAAEc2gABHSUAAR1zAAEdrwABHdaAAR4TAAEebwABHsGAAR9cgAEfkQABH74AAR/xgAEgLoABIH4AASCCAAEgzwABIROAASEXgAEhWoABIaaAASG7gAEiGIABImKAASKngAEjFAABI5kAASQ+AAEkrIABJPeAASVvgAEl4AABJkSAASZ3gAEm3oABJvwAAScngAEnXoABJ4GAASeqAAEn0oABKAuAAShZgAEo8IABKUKAASlGgAEpSoABKWMAASl6gAEpkwABKbqAASnggAEqIYABKl0AASphAAEqZQABKouAASqyAAEqwQABKuAAASr9AAErEoABKx+AAStBAAErZAABK4IAASuZgAErwAABK+SAASwEgAEsJQABLEoAASxXAAEsb4ABLJwAAS0NgAEtG4ABLZKAAS3XgAEt24ABLekAAS36AAEuCwABLhwAAS4pgAEuNgABLkaAAS5tgAEugwABLqyAAS7KgAEu7AABLwgAAS8ggAEvQgABL1oAAS90gAEvkYABL62AAS/FAAEv7oABMBSAATAvgAEwU4ABMGsAATCGgAEwsIABMNuAATEBAAExG4ABMTwAATFVAAExgAABMa4AATHZAAEx/IABMhOAATIugAEyRAABMmSAATKEAAEypYABMsiAATLfAAEy+gABMxYAATMyAAEzTgABM28AATOTAAEzrIABM8sAATPqAAE0CAABNDGAATRYgAE0fIABNJQAATS7gAE02oABNP8AATUngAE1UgABNXgAATWPAAE1pIABNb6AATXoAAE2EgABNkSAATZuAAE2hoABNpyAATa0gAE22AABNvmAATcdAAE3NQABN04AATdogAE3goABN5yAATe8AAE33gABOAMAATgeAAE4OAABOFEAATh7AAE4qYABONUAATj4gAE5EAABOSsAATlHAAE5cIABOZsAATnLgAE59AABOg0AAToxAAE6TYABOnGAATqRAAE6sAABOssAATrugAE7BYABOx0AATs+gAE7XYABO3eAATuQgAE7pYABO8EAATvbAAE7+oABPBgAATw2gAE8VoABPG2AATyHAAE8oAABPMgAATzwgAE9HgABPUoAAT1hAAE9fwABPZaAAT25AAE93wABPgMAAT4cgAE+NAABPleAAT50AAE+mQABPr8AAT7bAAE+9wABPxUAAT8sgAE/RIABP2MAAT95gAE/kYABP6gAAT+/AAE/2QABP/yAAUAKAAFAGAABQDsAAUBFgAFAVgABQHsAAUC2gAFA2oABQOgAAUD8AAFBGIABQUOAAUFoAAFBfgABQZSAAUGqgAFBwQABQeIAAUIDgAFCLIABQlaAAUJmAAFCggABQqcAAULNAAFC8oABQx0AAUMpgAFDPYABQ1KAAUNkAAFDjQABQ6+AAUPRAAFD6QABQ/oAAUQNgAFENYABRFmAAUSBgAFEqwABRNSAAUUFgAFFEgABRRyAAUU+AAFFagABRXaAAUWAgAFFtAABRcuAAUXyAAFGBYABRh8AAUZJAAFGZIABRn4AAUahAAFGvYABRtsAAUcIAAFHHoABRzqAAUdJgAFHXgABR3+AAUeXgAFHwIABR/iAAUhCgAFIpoABSL2AAUjTAAFJnIABScMAAUnaAAFJ7AABSkeAAUqcAAFKrYABSvEAAUsXAAFLWoABS50AAUvFgAFL/4ABTCQAAUxLAAFMh4ABTMeAAUzmgAFNCAABTRoAAU1mAAFNtQABTe4AAU4CAAFODwABTkqAAU6UgAFO+wABT0cAAU+MgAFPvYABUASAAVAgAAFQRQABUJmAAVDHAAFRIYABUW2AAVG6AAFSBQABUjAAAVJhgAFSlgABUuyAAVNMgAFTmIABU9+AAVROAAFUooABVN2AAVUUgAFVRQABVaOAAVX3gAFV+4ABVf+AAVYDgAFWMYABVl8AAVZuAAFWe4ABVomAAVaXAAFW/AABV4EAAVe7gAFYAQABWF8AAVi6gAFY6QABWRmAAVlSgAFZkQABWfiAAVpNgAFayQABWzqAAVuxgAFcF4ABXFGAAVyIgAFc2oABXTsAAV11AAFdu4ABXcwAAV3egAFeNgABXpWAAV7yAAFfMAABX6gAAWAYAAFgOQABYEUAAWBYAAFgigABYL4AAWEjAAFhRQABYV8AAWFzgAFhiAABYfSAAWKAgAFizgABY0aAAWN9gAFjxAABZC8AAWSyAAFk8oABZS2AAWWqAAFmLAABZocAAWboAAFnQAABZ5uAAWe/AAFn4wABaCmAAWhsgAFo1oABaS0AAWmpAAFqG4ABakCAAWpngAFqjQABaq8AAWrogAFrHoABa4UAAWvpgAFsTQABbJYAAWyaAAFspgABbLIAAW0QgAFteQABbaOAAW3cAAFuDAABbjaAAW5dAAFulYABbsUAAW78AAFvboABb70AAW/gAAFv7AABb/gAAXAFAAFwEgABcBYAAXAaAAFwJgABcDIAAXA/AAFwTAABcFkAAXBmAAFwcwABcIAAAXDegAFw4oABcO6AAXD6gAFxCIABcRWAAXEigAFxL4ABcTyAAXFJgAFxVoABcWSAAXFyAAFxfgABcY4AAXGcAAFxrgABcb+AAXHMgAFx2YABcegAAXH2AAFyHgABciIAAXJ2gAFy6IABc1IAAXO8gAF0D4ABdFUAAXSYgAF03gABdRyAAXVWgAF1nwABdd4AAXYUAAF2UAABdn8AAXasAAF23gABdv2AAXckgAF3M4ABd0yAAXeOgAF3ngABd8mAAXfkgAF384ABeAMAAXgfgAF4WoABeHqAAXiagAF4qoABeNYAAXjmAAF5AoABeSiAAXk3gAF5VgABeWwAAXmagAF5qYABebkAAXn4gAF6HQABei2AAXp1AAF6v4ABezgAAXuogAF79gABfEGAAXyBgAF8i4ABfJWAAXyjAAF8r4ABfLqAAXzEgAF8zoABfNoAAXzxgAF9DQABfRsAAX0pAAF9NQABfT6AAX1LgAF9WQABfWKAAX1sAAF9d4ABfYMAAX2OAAF9q4ABfbWAAX3OAAF914ABfeEAAX3qgAF99AABfgAAAX4MAAF+GAABfiaAAX4ygAF+QAABfkwAAX5YgAF+YgABfmuAAX54gAF+hgABfpIAAX6eAAF+p4ABfrEAAX66gAF+xgABftMAAX70gAF/BYABfxQAAX8hAAF/MgABf0CAAX9PAAF/WIABf2MAAX92AAF/hoABf5AAAX+bgAF/pQABf66AAX++gAF/ywABf9cAAX/jAAF/7IABf/YAAYACAAGADgABgBeAAYAhAAGAKoABgDQAAYA9gAGARwABgFEAAYBzAAGAfYABgJqAAYCkgAGAwgABgMwAAYDkgAGA8QABgP2AAYEJgAGBF4ABgSQAAYEvgAGBPgABgUgAAYFgAAGBcIABgXyAAYGHgAGBk4ABgZ+AAYGpgAGBs4ABgb2AAYHWAAGB4AABgfeAAYIIgAGCGYABgiWAAYIzAAGCPIABgkaAAYJQAAGCWgABgmOAAYJtgAGCd4ABgoIAAYKLgAGClQABgp6AAYKrAAGCtQABgtaAAYLhAAGC+4ABgweAAYMTgAGDHQABgyaAAYM8gAGDSIABg1eAAYNiAAGDbgABg3oAAYOHAAGDlAABg6AAAYOwAAGDvoABg9CAAYPaAAGD44ABg+0AAYP2gAGEAAABhBAAAYQgAAGELwABhDsAAYRHAAGEUwABhF8AAYRtAAGEewABhIsAAYSbAAGEqYABhLgAAYTHAAGE1oABhOkAAYT7gAGFDQABhR6AAYUvAAGFP4ABhUuAAYVXgAGFZIABhXGAAYWAAAGFjoABhaGAAYW0gAGFyoABheCAAYX2gAGGDgABhhoAAYYmAAGGM4ABhkEAAYZOgAGGXYABhmqAAYZ3gAGGjIABhqGAAYa2gAGGy4ABhuCAAYb1gAGHC4ABhyGAAYctAAGHOIABh0UAAYdRgAGHYwABh3SAAYeBAAGHjYABh6IAAYe4AAGHyQABh9oAAYfrAAGH/AABiBEAAYgmAAGIMgABiD4AAYhLgAGIWQABiGiAAYh6AAGIjwABiKGAAYi2AAGIyoABiOKAAYj6gAGJBoABiRMAAYkhgAGJMAABiUSAAYlZgAGJbAABiX4AAYmOgAGJqQABibyAAYnPgAGJ3AABieiAAYn1gAGKAoABihAAAYodgAGKLQABijqAAYpHAAGKVgABimuAAYqBAAGKmIABirAAAYrFgAGK2wABiugAAYr0AAGLBQABixKAAYsegAGLL4ABiz8AAYtNAAGLWwABi2iAAYt3gAGLg4ABi5KAAYuigAGLtAABi8aAAYvZgAGL7IABjAIAAYwXgAGMKwABjD6AAYxSAAGMZgABjH0AAYyUAAGMqgABjMAAAYzVAAGM6gABjPqAAY0LAAGNHQABjS8AAY1BAAGNVIABjWWAAY12gAGNkAABjamAAY3DAAGN3IABjfYAAY4PgAGOKgABjkSAAY5WgAGOaIABjnqAAY6MgAGOn4ABjrKAAY7HgAGO2oABjuuAAY7/AAGPGQABjzMAAY9PAAGPawABj4UAAY+fAAGPrwABj76AAY/RAAGP24ABj+0AAY/7AAGQDoABkBqAAZAmgAGQNYABkEKAAZBMAAGQYQABkHCAAZCFgAGQvwABkQkAAZEZgAGRIwABkTiAAZFEgAGRVQABkWcAAZF6gAGRjQABkaEAAZGqgAGR5IABkh2AAZJyAAGSfYABkokAAZKuAAGSz4ABktsAAZL9gAGTCYABkxWAAZMpAAGTPIABk3WAAZOsgAGT/YABlAmAAZQVgAGUOwABlF0AAZRpAAGUdQABlIEAAZSlAAGUsQABlL0AAZTRgAGU44ABlPkAAZUegAGVRIABlWGAAZV2AAGVgIABlZYAAZWjAAGVtYABlcOAAZXXgAGV5wABlfoAAZYDgAGWIoABljcAAZZ7gAGW/gABl2sAAZfLgAGYKAABmNCAAZmEgAGZ9IABmkYAAZrcgAGbLQABm7KAAZvHAAGb2wABm/CAAZwGAAGcHoABnEcAAZzagAGdQ4ABncaAAZ4NgAGeeoABntsAAZ8LAAGfQ4ABn12AAZ92AAGfk4ABn62AAZ/YgAGf9IABoBiAAaBdgAGgjoABoKGAAaDHAAGg8gABoRsAAaFFgAGhWAABoWiAAaGGAAGhoAABocQAAaHvgAGiCgABoiMAAaI8gAGiawABopCAAaKoAAGisoABor0AAaLBAAGixQABovWAAaM2gAGjuQABpA6AAaQSgAGkPoABpHeAAaSPgAGkk4ABpKqAAaTCAAGlCgABpUWAAaVJgAGlTYABpVGAAaVVgAGljwABpc8AAaZFAAGmtAABpvWAAacUAAGnMoABp18AAadjAAGnpoABp6qAAaeugAGn3wABqCwAAahnAAGoawABqG8AAahzAAGozIABqSeAAalygAGpdoABqXqAAal+gAGpgoABqbsAAam/AAGqF4ABqloAAaqZgAGq54ABqxwAAas7gAGrWwABq6MAAavCAAGr1QABq/gAAaw9AAGsUgABrKKAAazSgAGtBYABrUMAAa2FgAGtsgABrguAAa4lAAGuVgABrtaAAa86AAGvmYABr+WAAbCSAAGw4oABsS4AAbGMAAGx6gABskoAAbKtgAGzGgABszWAAbOOgAGz3IABtB2AAbRrAAG0t4ABtOuAAbUfgAG1doABta0AAbXVAAG2FgABtmCAAbagAAG3AAABt1qAAbeqAAG4CAABuFsAAbiTgAG4rYABuNYAAbj+AAG5PYABuZeAAbnmAAG6SwABup2AAbrWgAG68IABuzIAAbtaAAG7iYABu7UAAbvFAAG8MAABvGSAAbyWAAG84AABvUgAAb2LAAG9oQABvgcAAb4qgAG+LwABvjsAAb5HAAG+VQABvmMAAb5wgAG+f4ABvo0AAb6cAAG+94ABvwoAAb8wgAG/VoABv3UAAb+WAAG/r4ABv9qAAb/tgAHAGgABwDOAAcBOgAHAXIABwGwAAcCJAAHAx4ABwQ8AAcFPgAHBYAABwX+AAcGbAAHBnwABwaMAAcGnAAHBqwABwa8AAcGzAAHBtwABwbsAAcG/AAHBwwABwccAAcHHAAHCKAABwiwAAcJigAHClAABwuGAAcNfAAHD34ABxF6AAcTsAAHFbAABxYcAAcXLgAHGMAABxoYAAcaygAHGw4ABxusAAcc3AAHHSwABx3CAAce/gAHHw4AByDEAAch+AAHIkgAByKeAAci9gAHIzgAByN4AAcj/gAHJD4AByUwAAclvgAHJfQAByZuAAcm5gAHJzYAByhCAAcpOAAHKeIAByoMAAcqNgAHKmAAByqKAAcqqgAHKsoAByroAAcrBgAHK1AAByuaAAcr2gAHLBoAByw6AAcsWgAHLHgAByyWAAcs8AAHLUoABy1oAActhgAHLcoABy4OAAcuUgAHLpYABy7qAAcvPgAHL4oABy/WAAcwFAAHMFgABzCoAAcw+AAHMVIABzGwAAcx2gAHMgQABzKeAAczOAAHM3wABzPAAAc01gAHNOYABzUuAAc1dgAHNcgABzYaAAc2hAAHNtgABzckAAc3ggAHOAwABzhwAAc4tAAHOP4ABzlmAAc5sAAHOfAABzo4AAc6dAAHOrAABzrsAAc7JgAHO2gABzuqAAc76gAHPCoABzx0AAc8vgAHPRQABz1sAAc9ugAHPggABz5KAAc+mAAHPtoABz8kAAc/ZgAHP6oAB0AGAAdAYgAHQK4AB0D6AAdBRAAHQY4AB0HMAAdCCgAHQioAB0JKAAdCaAAHQoYAB0MgAAdDugAHRI4AB0ViAAdFggAHRaIAB0XCAAdF4gAHR0AAB0dQAAdIOgAHSEoAB0iA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AAh4jgAIeVgACHmIAAh6YAAIenAACHqAAAh6sgAIesIACHuiAAh8XAAIfPAACH0gAAh9UAAIfbAACH3AAAh+WgAIfmoACH56AAh/KAAIfzgACIDuAAiCBAAIgqoACILaAAiEAgAIhIIACISSAAiEogAIhLIACIT8AAiFDAAIhRwACIUsAAiF4AAIhugACIb4AAiHYgAIh94ACIg6AAiIrAAIiT4ACInsAAiKegAIi1oACIw+AAiNCgAIjV4ACI18AAiNmAAIjbQACI3QAAiN7gAIjgoACI4oAAiORAAIjmQACI6CAAiOoAAIjr4ACI7cAAiPDAAIjzwACI9sAAiPnAAIj9AACJAEAAiQNAAIkGQACJCKAAiQ4AAIkPAACJEgAAiRUAAIkYAACJG0AAiR5AAIkhQACJJEAAiSagAIkpoACJKqAAiS3gAIkw4ACJM+AAiTZAAIk5QACJPEAAiT9AAIlCgACJRYAAiUiAAIlLgACJTsAAiVIAAIlUYACJV2AAiVpgAIldYACJYKAAiWOgAIlmoACJaQAAiWwAAIltAACJcAAAiXNAAIl0QACJd4AAiXqAAIl8wACJf4AAiYHgAImNQACJkEAAiZNAAImWQACJmYAAiZyAAImfgACJoeAAiaTgAImnQACJqkAAia1AAImwQACJs0AAibaAAIm5wACJvMAAib/AAInCIACJyGAAicrAAInNwACJ0AAAidLAAInVIACJ1iAAidhgAInaoACJ3WAAieSAAInngACJ6oAAie3AAInwwACKCoAAigxgAIoOIACKD+AAihHgAIo3IACKSwAAil5gAIp7wACKi6AAip7gAIqkQACKrIAAirhgAIrF4ACK0MAAitmgAIrmAACK7aAAivcAAIsBYACLDaAAixnAAIsjwACLMaAAiz3AAItEQACLWmAAi12AAItpYACLdyAAi4EAAIuMoACLmCAAi5ugAIufIACLo0AAi6dgAIutYACLtIAAi7tAAIvCAACLxuAAi8vAAIvQ4ACL1gAAi9rgAIvfwACL4sAAi+XAAIvowACL68AAi+6gAIvxYACL9CAAi/cAAIv5wACL/IAAi/5gAIwAQACMAwAAjAXAAIwHoACMCYAAjAzAAIwRwACMGAAAjB5AAIwhIACMJAAAjCbAAIwpgACMLEAAjC8gAIwx4ACMNMAAjDeAAIw6QACMPi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+X19AfN8fAHyfX0HSH19fX19fH19fX19fH19fX19fXx8fHx8fX19fX19fH19fX19fH19fX19fXx8fHx8fX19fX19fH19fX19ADz/6v4IBcEHSAADAAcACwAPABMAFwAbAB8AIwAnACsALwAzADcAOwA/AEMARwBLAE8AUwBXAFsAXwBjAGcAawBvAHMAdwB7AH8AgwCHAIsAjwCTAJcAmwCfAKMApwCrAK8AswC3ALsAvwDDAMcAywDPANMA1wDbAN8A4wDnAOsA7wACMTATMxUjNzMVIzczFSM3MxUjNzMVIzczFSMFMxUjNzMVIzczFSM3MxUjNzMVIzczFSMFMxUjNzMVIzczFSM3MxUjNzMVIzczFSMFMxUjNzMVIzczFSM3MxUjNzMVIzczFSMFMxUjNzMVIzczFSM3MxUjNzMVIzczFSMFMxUjJTMVIzczFSM3MxUjNzMVIyUzFSMFMxUjJzMVIyczFSMnMxUjJzMVIyczFSMHMxUjNzMVIzczFSM3MxUjNzMVIzczFSMXMxUjJzMVIyczFSMnMxUjJzMVIyczFSMHMxUjNzMVIzczFSM3MxUjNzMVIzczFSNnfHz5fHz5fX35fX36fHz5fHz6pX19+X19+X19+nx8+X19+X19+598fPl8fPl9ffl9ffp8fPl8fPqlfX35fX35fX36fHz5fX35fX37n3x8+Xx8+X19+X19+nx8+Xx8+qV9fQHyfX36fHz5fX35fX38G319BGJ8fPl8fPp9ffl9ffl8fPl8fH19ffl9ffl9ffp8fPl9ffl9fX18fPl8fPp9ffl9ffl8fPl8fH19ffl9ffl9ffp8fPl9ffl9fQdIfX19fX19fX19fX18fX19fX19fX19fX18fX19fX19fX19fX19fHx8fHx8fHx8fHx9fX19fX19fX19fX18fX19fX19fX19fX18fX19fX19fX19fX19fHx8fHx8fHx8fHx9fX19fX19fX19fX18fX19fX19fX19fX0AAC7///2MBdYHSAA9AEEARQBJAE0AUQBVAFkAXQBhAGUAaQBtAHEAdQB5AH0AgQCFAIkAjQCRAJUAmQCdAKEApQCpAK0AsQC1ALkAvQDBAMUAyQDNANEA1QDZAN0A4QDlAOkA7QDxAAABESMVMxEjFTMRIxUzESMVMxUhETM1IxEzNSMRMzUjETM1IxEzNTMV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BAD8IAPA/EAFAPsAIATAAAACAQAAAAUABQAAAwAHAAAhESERJSERIQEABAD8IAPA/EAFAPsAIATAAAACAQAAAAUABQAAAwAHAAAhESERJSERIQEABAD8IAPA/EAFAPsAIATAAP//AEYE1wGxB1gCJgL3AAAAJwL0AAAAjwAHAvQAAAEnAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAH/ugElBRsB0wADABi9AAIC7wABAusAAALwsQUBLxDkAD/tMTABITUhBRv6nwVhASWuAAACAQAAAAUABQAAAwAHAAAhESERJSERIQEABAD8IAPA/EAFAPsAIATAAAACAQAAAAUABQAAAwAHAAAhESERJSERIQEABAD8IAPA/EAFAPsAIATAAAACAQAAAAUABQAAAwAHAAAhESERJSERIQEABAD8IAPA/EAFAPsAIATAAP//ADr+mQW1A8ACJgUoAAAABwUwAhUAAP//ADr+mQW1A8ACJgUoAAAABwUwAhUAAP///7r+mQH0A6YCJgUpAAAABgUwAAD///+6/pkB9AOmAiYFKQAAAAYFMAAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA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/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEA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BQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAAAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAA//8ARgTXAbEGuQImAvcAAAAHAvQABwCI//8ARgTXAbEHWAImAvcAAAAnAvQAAACPAAcC9AAAASf//wBGBNgBsQbTAicC9wAAALoABwL2AAYFA///AEYE2QGxBzsCJwL3AAABIgAnAvYABgWAAAcC9gAGBQT//wBABNkBsQcuABYDSgAA//8AMQTXAdAHdQImAvcAAAAHAvL/6wEbAAIBAAAABQAFAAADAAcAACERIRElIREhAQAEAPwgA8D8QAUA+wAgBMAA//8ARv/VAZwApAAWAvYAAP//AEb+9gGcAFsAFgLzAAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgEAAAAFAAUAAAMABwAAIREhESUhESEBAAQA/CADwPxABQD7ACAEwAAAAgDKARgByQW3ABIAHgA+uQAQAvK3B0AJCjQHBxy8Au4AFgLsAAYC8bQHBxMZALgC7bINDRO5Au0AGS/tMy/tERI5L+0AP/0yLys/MTABFAcG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NSsrKzUA//8ASv67BBwFwgImAEQAAAAnANYA3gAAAQcEfQLIAAAAQ0AwAx9AAQBAQS83QQKfOgEgOjA6cDqAOgSQOqA6sDrgOvA6BTpALjI0ADo9HBxBAgE+uQIiACkAKwErK11xcjUrXTUA/////QAABVkHKwImACQAAAAnBHsCqwAAAQcEcQPfAAAANLEDI7j/wLNBQjQjuP/AQBg5Nf8jASMWE0grAgARGwECQQIgQBktNCAALys1ASs1K3ErKzX//wBK/+gEHAcjAiYARAAAACcA2QD1AAABBwSTA0gAAAA3QAwDYEhwSAIASFtIAki4/+BAFA8RNEhDGEgrAs88ATwcA2grAgE8uQIiACkAKwErXTUrK11xNQD////9AAAFWQcrAiYAJAAAACcEewKrAAABBwRuA7EAAABctgIgQBktNCAALys1AbEGAkNUWEAOA1QjIxYWQQIAHx8BAkErNSs1G0AbAyNAODk0I0ApMTQjQAkRNEAjbyPfI+8jBCMCuP/1QAlIKwIAERsBAkErNStxKysrNVn//wBK/+gEHAcjAiYARAAAACcA2QD1AAABBwSSA1wAAAAqtwMPSVBJAklDuP/yQA5IKwLPPAE8HANoKwIBPLkCIgApACsBK101K101/////QAABVkHLAImACQAAAAnBHsCqwAAAQcEdQPUAAAAO0AJA7A2wDbQNgM2uP/AsyoyNDa4/8BAFyEoNAA2NQECQQIAERsBAkECIEAZLTQgAC8rNQErNSsrK3I1AP//AEr/6AQcBywCJgBEAAAAJwDZAPUAAAEHBHQDXAAAAEJAMANQWmBakFqgWgQAWhBaMFpwWoBaBQBagFrAWtBaBABaWRwcQQLPPAE8HANoKwIBPLkCIgApACsBK101K11xcjX////9AAAFWQcrAiYAJAAAACcEewKrAAABBwSfBVAAAAAsQB8DzyPfI+8jAy8jAQAjLQECQQIAERsBAkECIEAZLTQgAC8rNQErNStdcTX//wBK/+gEHAbyAiYARAAAACcA2QD1AAABBwR6BJwAAAArsQNGuP/AQBUKDDQARlA/OUECzzwBPBwDaCsCATy5AiIAKQArAStdNSsrNQD////9/rsFWQZmAiYAJAAAACcEewKrAAABBwR9AzQAAAA1sQMkuP/AszU8NCS4/8CyEhc0uP/sQBMkJQcEQQIA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uQIhACkAKwErXXE1//8ARP/oBQAFwgImBGsAAAEHAEMA3gAAACFAEwJfLm8uAiAuMC4CLiUASCsCAS25AiIAKQArAStdcTUA//8AY//nBqwHRQImBGoAAAEHBHQEOAAZABpAEwJQQQF/QZBBsEHAQQQAQUAlJUEBK11xNf//AET/6AUABg0CJgRrAAABBwSFAyoAAAAYQBECAEEBkEHAQdBBAwBBQCUlQQErXXE1//8AY//nBqwG+wImBGoAAAEHANcBywFRABZACgIALTklJUECAS25AiEAKQArASs1//8ARP/oBQAFqgImBGsAAAEHANcA4AAAABZACgIALTklJUECAS25AiIAKQArASs1//8AY/67BqwF1AImBGoAAAEHBH0DrAAAABBACgIALgEALi8dHUEBK3E1//8ARP67BQAEQAImBGsAAAEHBH0CxgAAAAu2AgAuLx0dQQErNQD//wCh/rsFIgW6AiYAOAAAAQcEfQNwAAAAEEAKAU8WAQAWFxEGQQErcTX//wCD/rsD4AQmAiYAWAAAAQcEfQKoAAAAFEAOAVAaYBpwGgMAGhsMFUEBK101//8Aof/nBSIHLAImADgAAAEHBHQD6AAAABBACgHQHwEAHyUMAEEBK101//8Ag//oA+AGDQImAFgAAAEHBIUDGwAAADJAHAFQLZAtoC2wLQQALRAtUC1gLXAtkC2gLbAtCC24/8BACRcaNAAtLAsWQQErK11xNf//AKH/5waCBywCJgRsAAABBwCNAYgBagApsQEnuP/AQBQ5NXAnAS8nXyePJwMnGhdIKwEBJrkCIQApACsBK11yKzUA//8Ag//oBR0FwgImBG0AAAEHAI0A5wAAABtADgFPKJAoAigZPEgrAQEluQIiACkAKwErcTUA//8Aof/nBoIHLAImBGwAAAEHAEMBhQFqACFAEgF/KQFvKQGfKQEpGgBIKwEBJ7kCIQApACsBK11xcjUA//8Ag//oBR0FwgImBG0AAAEHAEMA3gAAABlADAHgJgEmGQxIKwEBJrkCIgApACsBK3E1AP//AKH/5waCBywCJgRsAAABBwR0A+gAAAAUQA4BLzCAMNAwAwAwNhQfQQErXTX//wCD/+gFHQYNAiYEbQAAAQcEhQMbAAAAJLEBObj/wEAQFhgGVVA5oDkCkDmgOQI5Gbj/57FIKwErXXErNf//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txgXBQVBAQEYuQIiACkAKwErXTX////9AAAFWQcsAjYAJAAAARcITQJYAWoAK7IDAhS4/8CzKjI0FLj/wEANBwg0KBQPAQJBAgMCFLkCIQApACsBKysrNTUA//8ASv/oBBwFwgI2AEQAAAEXCE0B9AAAABlADAMCFD04HBxBAgMCPbkCIgApACsBKzU1AP////0AAAVZByICNgAkAAABFwhPApkBagAWQAoCABQQAQJBAgEVuQIhACkAKwErNf//AEr/6AQcBbgCNgBEAAABFwhPAkQAAAAetQJQPWA9Arj//Lc9ORwcQQIBPbkCIgApACsBK3E1//8AogAABOgHLAI2ACgAAAEXCE0CagFqABlADAIBABEMAQJBAQICEbkCIQApACsBKzU1AP//AEv/6AQeBcICNgBIAAABFwhNAfQAAAAZQAwDAiEjHgoKQQIDAiK5AiIAKQArASs1NQD//wCiAAAE6AciAjYAKAAAARcITwK8AWoAFkAKAQASDAECQQEBErkCIQApACsBKzX//wBL/+gEHgW4AjYASAAAARcITwI6AAAAFkAKAgAkHgoKQQIBJLkCIgApACsBKzX///+KAAACSwcsAjYALAAAARcITQDqAWoAHLECAbj/zkAJCQQBAkEBAgIJuQIhACkAKwErNTX///9kAAACJQXCAjYA1QAAARcITQDEAAAAHLECAbj/9EAJCQQBAkEBAgIJuQIiACkAKwErNTX//wAEAAACUwciAjYALAAAARcITwEsAWoAFkAKAQAKBAECQQEBCrkCIQApACsBKzX////2AAACRQW4AjYA1QAAARcITwEeAAAAFkAKAQAKBAECQQEBCbkCIgApACsBKzX//wBj/+cF3QcsAjYAMgAAARcITQK8AWoAGUAMAwIAIRwDA0ECAwIguQIhACkAKwErNTUA//8ARP/oBCcFwgI2AFIAAAEXCE0B4AAAABlADAMCEh8aBARBAgMCH7kCIgApACsBKzU1AP//AGP/5wXdByICNgAyAAABFwhPAyABagAWQAoCACIcAwNBAgEhuQIhACkAKwErNf//AET/6AQnBbgCNgBSAAABFwhPAkQAAAAWQAoCACAaBARBAgEfuQIiACkAKwErNf//AKEAAAWtBywCNgA1AAABFwhNAlgBagAgtAMCACgBuP/VQAkoIwEGQQIDAii5AiEA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AAABFwhuAjAAAAAUtQIAIBAgArj/37QgIQELQQErXTX//wBm/lsFdgcsAjYAJgAAADcA3AGUAAABFwCNAZwBagA7swJQNwG4//VAHDc3DAxBAQAwIDBPMAMvMH8wjzADMAQASCsCATe4AiG1KQEBHwgpACsrAStdcTUrXTUA//8AUP5vA+0FwgI2AEYAAAA3ANwAwwAUARcAjQC0AAAATLkAAv/ztjQ0CwtBARy4/8BAGhQUBlUfHC8cAhAcAe8c/xwCEBwwHH8cAxwLuP+YtEgrAgE0uAIitSkBARwIKQArKwErXV1xcis1KzX//wCeAAAFWgb0AjYAJwAAARcA2gFeAWoAHrECHrj/wEALCDUbHiECAkECAR65AiEAKQArASsrNf//AEb/6APfBboCNgBHAAABFwDaAJYAAAAeQBECEB5QHmAeAzIeIQcOQQIBHrkCIgApACsBK101//8Anv67BVoFugI2ACcAAAEXBH0DUgAAABWxAh+4/8BACQgLNAEfIA8PQQErKzUA//8ARv67A98FugI2AEcAAAEXBH0CvAAAAAu2AhQfIAMDQQErNQD//wCe/tYFWgW6AjYAJwAAARcIbgKUAAAAGbYCECDwIAIguP/Atwc1ACAhERFBASsrXTUA//8ARv7WA98FugI2AEcAAAEXCG4CCwAAABxAFAIgQB4gNJ8gzyACnyABACAhAwNBAStdcSs1//8Anv49BVoFugI2ACcAAAEXCGMCtAAAAAu2AgApKg8PQQErNQD//wBG/j0D3wW6AjYARwAAARcIYwIdAAAAC7YCFikqAwNBASs1AP//AJ7+aQVaBboCNgAnAAABFwhqArwAAAATsQIjuP/Atwg1CSMkDw9BASsrNQD//wBG/mkD3wW6AjYARwAAARcIagIIAAAAFLUCI0AICjS4//W0IyQDA0EBKys1//8AogAABOgHMwI2ACgAAAEXCXgCvAAAABJACwIBIBEBABEQAQJBAStdNTX//wBL/+gEHgbqAjYASAAAADcA2ADmAAABFwBDAOUBKABUtgMjQBcZNCO4/8CzDhE0I7j/wLIICTS4/+pAJCMjHiFBAgAeIQoKQQMfIwEfI18jkCOgI7AjBSNACQw0IwIBHrkCIgApACsvK11yNQErNSsrKys1//8AogAABOgHMwI2ACgAAAEXCXkCvAAAAA23AgEA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KzU1ASs1KzU1AP//AAkAAAVGBxoCNgA5AAABFwDXAVgBcAAWQAoBAAsXAQlBAQEauQIhACkAKwErNf//ABoAAAPoBaoCNgBZAAABFwDXAKkAAAAWQAoBAAsXAQlBAQEauQIiACkAKwErNf//AAn+uwVGBboCNgA5AAABFwR9AzwAAAALtgEADA0ACkEBKzUA//8AGv67A+gEJgI2AFkAAAEXBH0CnAAAAAu2AQAMDQAKQQErNQD//wAZAAAHdgb0AjYAOgAAARcA2gJ2AWoAPkArARnAa4Q0GYBhajQZgFFfNBlASFA0GUA0QjQZQC4wNJ8ZAQAZHAgJQQEBGbkCIQApACsBK3IrKysrKys1//8ABgAABbcFigI2AFoAAAEXANoBkAAAABZACgEAExYHCEEBARO5AiIAKQArASs1//8AGf67B3YFugI2ADoAAAEXBH0EYgAAACJAGQEZQF1nNBlAND40GUAuMDSfGQEAGRwICUEBK3IrKys1//8ABv67BbcEJgI2AFoAAAEXBH0DcAAAABBACgFPFAEAFBUSD0EBK3E1//8ACQAABUkG9AI2ADsAAAEXANoBaQFqABZACgEAFBcCCkEBARS5AiEAKQArASs1//8ADwAAA/EFigI2AFsAAAEXANoAqgAAABZACgEAERQDCUEBARG5AiIAKQArASs1//8ACQAABUkHLQI2ADsAAAEXAI4BaQFqABlADAIBABQbAwlBAQICFLkCIQApACsBKzU1AP//AA8AAAPxBcMCNgBbAAABFwCOAKoAAAAZQAwCAQASFwIKQQECAhS5AiIAKQArASs1NQD//wAGAAAFRgb0AjYAPAAAARcA2gFoAWoAFkAKAQANEAIKQQEBDbkCIQApACsBKzX//wAh/lED7gWKAjYAXAAAARcA2gCzAAAAJkAYAQAbEBswGwPAG9Ab4BsDABseCxNBAQEbuQIiACkAKwErXXE1//8AKQAABLAHLAI2AD0AAAEXANYBQQFqACBAEwEADzAPUA9gDwQADxIGB0EBAQ+5AiEAKQArAStdNf//ACgAAAPUBcICNgBdAAABFwDWAK0AAAAtsQERuP/AQBgHCTQPEQFAEXARgBGQEQQAERQGB0EBARG5AiIAKQArAStdcis1AP//ACn+uwSwBboCNgA9AAABFwR9AwMAAAALtgEADg8ADEEBKzUA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QA8INQADEANAA1ADBEADAQMBLnFdKzUrXSsrNTUrNQD//wAA/mkHKwXTADcCDQGQAAAANgrg7QABFwiCBIgAAABNQAoDADAvAwtBAgEeuP/AsxMVNB64/8BAEgcINDAeQB5wHgOHHh4DA0EAA7j/wEAPCDUAAxADQANQAwRAAwEDAS5xXSs1K10rKzU1KzUA//////5pBysGuQA3Ag0BkAAAADYK1PkAARcIggSIAAAARkAKAwBAPwMLQQIBPrj/wLMPEjQ+u//AAAgANf+7tj4+AwNBAAO4/8BADwg1AAMQA0ADUAMEQAMBAwEucV0rNSsrKzU1KzX//////mkHKwa5ADcCDQGQAAAANgrh+QABFwiCBIgAAABGQAoDAEA/AwtBAgE5uP/Asw8SNDm7/8AACAA1/662OTkDA0EAA7j/wEAPCDUAAxADQANQAwRAAwEDAS5xXSs1KysrNTUrNf//AEj/6ARTBbgCNgEuAAABFwDZAMgAAAAmQBcCLygBnygBECggKHAoAzIoIg0BQQIBJbkCIgApACsBK11xcjX//wBI/+gEUwVfAjYBLgAAARcA2ADIAAAAJEAVAi8hAZ8hARAhcCECMiEkDQFBAgEhuQIiACkAKwErXXFyNf//AEj+aQRTBcICNgEuAAAANwBDAMcAAAEXCIICHAAAACdAFwOfJgEAJiUKCkECnyIBACIiEBBBAgEiuQIiACkAKwErXTUrXTUA//8ASP5pBFMEPgI2AS4AAAEXCIICHAAAABBACgKfIgEAIiEKCkEBK101//8ASP5pBFMFwgI2AS4AAAA3AI0AlAAAARcIggIcAAAAI0AUA58mAQAmJQoKQQIAJCQQEEECASS5AiIAKQArASs1K101AP//AEj/6ARTBaoCNgEuAAABFwDXAMgAAAAeQBACLyEBbyEBMiEtDQFBAgEwuQIiACkAKwErXXI1//8ASP5pBFMFqgI2AS4AAAA3ANcAyAAAARcIggIcAAAAK0AaA586AQA6OQoKQQIvIQFvIQEyIS0NAUECATC5AiIAKQArAStdcjUrXTUA/////QAABVkHIgI2ACQAAAEXANkBVAFqABZACgIAFhABAkECARO5AiEAKQArASs1/////QAABVkGyQI2ACQAAAEXANgBTAFqABZACgIADxIBAkECAQ+5AiEAKQArASs1/////QAA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AQEAUAAWQAoBAAwPAgNBAQEMuQMsACkAKwErNf//AJgAAAQjBhECJg2NAAABBwDWAQMATwAWQAoBAA4RAgNBAQEOuQMsACkAKwErNf//AJgAAAQjBcYCJg2NAAABBwCOAQcAAwAZQAwCAQAMEwIDQQECAgy5AywAKQArASs1NQD////0AAABbAYRAiYNkQAAAQYAQ5tPABZACgEABQQCA0EBAQW5AywAKQArASs1//8AjgAAAf8GEgImDZEAAAEGAI2wUAAWQAoBAAQHAgNBAQEEuQMsACkAKwErNf///7YAAAIvBhICJg2RAAABBgDWnVAAFkAKAQAGCQIDQQEBBbkDLAApACsBKzX////aAAACCwXGAiYNkQAAAQYAjp0DABlADAIBAAQLAgNBAQICBLkDLAApACsBKzU1AP//AJgAAARUBeECJg2WAAABBwDXAUAANwAWQAoBAAwYBgtBAQEMuQMsACkAKwErNf//AFz/7gTVBhICJg2XAAABBwBDASYAUAAWQAoCACkoAABBAgEpuQMsACkAKwErNf//AFz/7gTVBhECJg2XAAABBwCNAU8ATwAWQAoCACgrAABBAgEouQMsACkAKwErNf//AFz/7gTVBhECJg2XAAABBwDWAT8ATwAWQAoCACotAABBAgEpuQMsACkAKwErNf//AFz/7gTVBeACJg2XAAABBwDXAUQANgAWQAoCACg0AABBAgEouQMsACkAKwErNf//AFz/7gTVBccCJg2XAAABBwCOAUIABAAZQAwDAgAoLwAAQQIDAii5AywAKQArASs1NQD//wCR/+4ETgYRAiYNnQAAAQcAQwEUAE8AFkAKAQAhIA8fQQEBIbkDLAApACsBKzX//wCR/+4ETgYSAiYNnQAAAQcAjQEWAFAAFkAKAQAgIw8fQQEBILkDLAApACsBKzX//wCR/+4ETgYSAiYNnQAAAQcA1gEXAFAAFkAKAQAiJQ8fQQEBIrkDLAApACsBKzX//wCR/+4ETgXHAiYNnQAAAQcAjgEXAAQAGUAMAgEAICcPH0EBAgIguQMsACkAKwErNTUA//8ACAAABGQGEQImDaEAAAEHAI0A7wBPABZACgEADxIFAEEBAQ+5AywAKQArASs1//8AAAAABHEFrgImDYkAAAEHANgA1wBPABZACgIAFhkGB0ECARa5AywAKQArASs1//8AAAAABHEF/AImDYkAAAEHANkA1gBEABZACgIAHRcGB0ECARq5AywAKQArASs1//8AAP5SBHEEcQImDYkAAAEHAN4C0wAAAAu2AgAqFgEAQQErNQD//wBc/+4EfQYRAiYNiwAAAQcAjQFHAE8AFkAKAQAlKA8PQQEBJbkDLAApACsBKzX//wBc/+4EfQYRAiYNiwAAAQcA3wEsAE8AFkAKAQAqJw8PQQEBKbkDLAApACsBKzX//wBc/+4EfQYSAiYNiwAAAQcA1gEtAFAAFkAKAQAnKg8PQQEBJ7kDLAApACsBKzX//wBc/+4EfQXZAiYNiwAAAQcA2gE0AE8AFkAKAQAlKA8PQQEBJbkDLAApACsBKzX//wCYAAAEiQYRAiYNjAAAAQcA3wDWAE8AFkAKAgAbGAAPQQIBGrkDLAApACsBKzX//wAUAAAEiQRxAgINqAAA//8AmAAABCMFrgImDY0AAAEHANgA9ABPABZACgEADA8CA0EBAQy5AywAKQArASs1//8AmAAABCMF/AImDY0AAAEHANkBAgBEABZACgEAEw0CA0EBARC5AywAKQArASs1//8AmAAABCMF2gImDY0AAAEHANoBGgBQABZACgEADA8CA0EBAQy5AywAKQArASs1//8AmP5SBCMEcQImDY0AAAEHAN4ChQAAAAu2AQAVFQAAQQErNQD//wCYAAAEIwYSAiYNjQAAAQcA3wD6AFAAFkAKAQARDgIDQQEBELkDLAApACsBKzX//wBc/+4EuAX8AiYNjwAAAQcA2QFYAEQAFkAKAQApIwwMQQEBJrkDLAApACsBKzX//wBc/+4EuAYSAiYNjwAAAQcA1gFbAFAAFkAKAQAkJwwMQQEBJLkDLAApACsBKzX//wBc/lsEuASDAiYNjwAAAQcB7gFxAAAAC7YBACIxAgJBASs1AP//AFz/7gS4BdkCJg2PAAABBwDaAWYATwAWQAoBACIlDAxBAQEiuQMsACkAKwErNf//AJgAAARYBhICJg2QAAABBwDWASQAUAAWQAoBAA4RBgtBAQEOuQMsACkAKwErNQACAC4AAAS/BHEAEwAXAFFAJwcJBRcMAyUFERATJRQNEAIgAgICEAkNKxMGFgMrIBTAFAIUFAQOC7gDKrIBBAoAP8Q/xBI5L13t3sTE/cTEAS9dxMT9xM0v/cTEENTNMTAhIxEhESMRIzUzNTMVITUzFTMVIwc1IRUEWLj9srpqaroCTrhnZ7j9sgIK/fYDQJSdnZ2dlJaWlgD///+WAAACNAXgAiYNkQAAAQYA15A2ABZACgEABBACA0EBAQS5AywAKQArASs1////vQAAAi0FrgImDZEAAAEGANigTwAWQAoBAAQHAgNBAQEEuQMsACkAKwErNf///9QAAAIjBf0CJg2RAAABBgDZpkUAFkAKAQALBQIDQQEBCLkDLAApACsBKzX//wA+/lIBkQRxAiYNkQAAAQYA3vMAAAu2AQAYBAEAQQErNQD//wCHAAABZgXZAiYNkQAAAQYA2qJPABZACgEABAcCA0EBAQS5AywAKQArASs1//8AmP/uBLMEcQAmDZEAAAEHDZIB0AAAAAu2AacMDAAAQQErNQD//wAp/+4DxQYRAiYNkgAAAQcA1gEzAE8AFkAKAQAVGBESQQEBFbkDLAApACsBKzX//wCY/lsEhQRxAiYNkwAAAQcB7gEPAAAAC7YBAAwRBAFBASs1AP//AJgAAAOJBhICJg2UAAABBgCN21AAFkAKAQAGCQIDQQEBBrkDLAApACsBKzX//wCY/lsDiQRxAiYNlAAAAQcB7gC/AAAAC7YBAAYLAQBBASs1AP//AJgAAAOJBHECJg2UAAABBwAPAZ8DowALtgEABwcDBUEBKzUA//8AmAAAA4kEcQImDZQAAAEHANoBNv1WAAu2AQAGCQMFQQErNQD//wCYAAAEVAYRAiYNlgAAAQcAjQEkAE8AFkAKAQAMDwYLQQEBDLkDLAApACsBKzX//wCY/lsEVARxAiYNlgAAAQcB7gEzAAAAC7YBABYRBQBBASs1AP//AJgAAARUBhECJg2WAAABBwDfAQwATwAWQAoBABEOBgtBAQEQuQMsACkAKwErNQABAJj/7QR6BIQAKABdQDZJHgFIGgFmDwFXDwFmCQFXCQFIAwEMJAAdEB0CHR0oKhUUJgEBJiUoKAoVGBwUEQsfHAIHBwG4AyoAPzMvM+0/M+0yPwEv7TIvEMYyERI5L13tMTBdXV1dXV1dEzMVPgMzMh4CFRQOAiMiJic3FhYzMj4CNRAhIg4CBwYVESOYuitWWFwxaqd0PTloklo/cSpTH0ImLU05IP7LMllLNw8dugRxfSo3IQ5KkNaLmeOWSiMdixMZMWundgGpFyo7JEmZ/ZQA//8AXP/uBNUFrgImDZcAAAEHANgBQwBPABZACgIAKCsAAEECASi5AywAKQArASs1//8AXP/uBNUF/QImDZcAAAEHANkBQwBFABZACgIALykAAEECASy5AywAKQArASs1//8AXP/uBNUGEQImDZcAAAEHAN0BTgBPABlADAMCACgvAABBAgMCKLkDLAApACsBKzU1AP//AJgAAATJBhECJg2aAAABBwCNAP8ATwAWQAoCACEkCxxBAgEhuQMsACkAKwErNf//AJj+WwTJBHECJg2aAAABBwHuAUQAAAALtgIAISYJAUEBKzUA//8AmAAABMkGEQImDZoAAAEHAN8A9ABPABZACgIAJiMLHEECASW5AywAKQArASs1//8ASv/uBBkGEgImDZsAAAEHAI0A/wBQABZACgEAPD82NkEBATy5AywAKQArASs1//8ASv/uBBkGEQImDZsAAAEHANYA4ABPABZACgEAPkE2NkEBAT65AywAKQArASs1//8ASv5bBBkEgwImDZsAAAEHANwA9wAAAAu2AQBOThcXQQErNQD//wBK/+4EGQYSAiYNmwAAAQcA3wDQAFAAFkAKAQBBPjY2QQEBQLkDLAApACsBKzX//wBK/dkEGQSDAiYNmwAAAQcB7QDlAAAAC7YBAD0+FxdBASs1AP//ACn+WwPnBHECJg2cAAABBwDcALQAAAALtgEACQoDAkEBKzUA//8AKf3ZA+cEcQImDZwAAAEHAe0ArgAAAAu2AQAJCgMCQQErNQD//wApAAAD5wYRAiYNnAAAAQcA3wCjAE8AFkAKAQANCgQBQQEBDLkDLAApACsBKzUAAQApAAAD5wRxAA8AMkAUBQQAAiUNCwoICwIrBQgIBgEMKw64AyqxBgoAPz/9xBE5L8T9xAEvzcTM/c7NxDEwASERIRUhESMRITUhESE1IQPn/nsBBP78uP77AQX+fwO+A9H+jZT+NgHKlAFzoP//AJH/7gROBeACJg2dAAABBwDXARkANgAWQAoBACAsDx9BAQEguQMsACkAKwErNf//AJH/7gROBa4CJg2dAAABBwDYARkATwAWQAoBACAjDx9BAQEguQMsACkAKwErNf//AJH/7gROBfwCJg2dAAABBwDZARkARAAWQAoBACchDx9BAQEkuQMsACkAKwErNf//AJH/7gROBmcCJg2d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/90FbQcsAiYNdQAAAQcA1gGWAWoAFkAKAgBKTSYmQQIBSrkCIQApACsBKzX//wBq/90FbQcUAiYNdQAAAQcA1wGWAWoAFkAKAgBIVCYmQQIBSLkCIQApACsBKzX//wBq/90FbQctAiYNdQAAAQcAjgGWAWoAGUAMAwIASE8mJkECAwJIuQIhACkAKwErNTUA//8Aav/dBW0HfwImDXUAAAEHANsBlgGSABlADAMCAEhOJiZBAgMCUbkCIQApACsBKzU1AP//AGr/3QVtBskCJg11AAABBwDYAZYBagAWQAoCAEhLJiZBAgFIuQIhACkAKwErNf//AGr/3QVtByICJg11AAABBwDZAZYBagAWQAoCAE9JJiZBAgFMuQIhACkAKwErNf//AGr+UgVtBdMCJg11AAABBwDeA7sAAAALtgIAXEgBAEEBKzUA//8Aav/dBW0HxQImDXUAAAAnANsBnQEJAQcAjQGxAgMAM0AhBABgYFRUQQMCAEhOJiZBBM9gAb9gAa9gAQ9gAWADAlcDAD81NS9dXV1dNQErNTUrNQD//wBq/90FbQXTAgYNdQAA//8AY//nBW8HLAImDXYAAAEHAEMBdQFqABZACgIAKSgPD0ECASm5AiEAKQArASs1//8AY//nBW8HLAImDXYAAAEHAI0BugFqABZACgIAKCsPD0ECASi5AiEAKQArASs1//8AY//nBW8HLAImDXYAAAEHANYBlgFqABZACgIAKi0PD0ECASq5AiEAKQArASs1//8AY//nBW8HLQImDXYAAAEHAI4BlgFqABlADAMCACgvDw9BAgMCKLkCIQApACsBKzU1AP//AGP/5wVvBskCJg12AAABBwDYAZYBagAWQAoCACgrDw9BAgEouQIhACkAKwErNf//AGP/5wVvByICJg12AAABBwDZAZYBagAWQAoCAC8pDw9BAgEsuQIhACkAKwErNf//AGP/5wVvBvQCJg12AAABBwDaAZYBagAWQAoCACgrDw9BAgEouQIhACkAKwErNf//AGP+UgVvBdMCJg12AAABBwDeAmEAAAALtgIAKysFBUEBKzUA//8AY//nBW8HLAImDXYAAAEHAN8BlgFqABZACgIALSoPD0ECASy5AiEAKQArASs1//8AY//nBW8F0wIGDXYAAP//AGP/5wVvBy0CJg12AAABBwCOAZYBagAZQAwDAgAoLw8PQQIDAii5AiEAKQArASs1NQD//wCmAAAFXAcUAiYNdwAAAQcA1wGnAWoAFkAKAQAdKQ4bQQEBHbkCIQApACsBKzX//wCmAAAFXAcsAiYNdwAAAQcAjQG9AWoAFkAKAQAdHw4bQQEBHbkCIQApACsBKzX//wCm/lsFXAXTAiYNdwAAAQcB7gG5AAAAC7YBACciDRxBASs1AP//AKYAAAVcBywCJg13AAABBwDfAaoBagAWQAoBACIfDhtBAQEhuQIhACkAKwErNf//AJz/5wVSBywCJg15AAABBwBDAZYBagAWQAoBAB4dHA1BAQEeuQIhACkAKwErNf//AJz/5wVSBywCJg15AAABBwCNAboBagAWQAoBAB0gHA1BAQEduQIhACkAKwErNf//AJz/5wVSBy0CJg15AAABBwCOAaABagAZQAwCAQAdJBwNQQECAh25AiEAKQArASs1NQD//wCc/+cFUgcUAiYNeQAAAQcA1wGnAWoAFkAKAQAdKRwNQQEBHbkCIQApACsBKzX//wCc/+cFUgbJAiYNeQAAAQcA2AGnAWoAFkAKAQAdIBwNQQEBHbkCIQApACsBKzX//wCc/+cFUgciAiYNeQAAAQcA2QGnAWoAFkAKAQAkHhwNQQEBIbkCIQApACsBKzX//wCc/+cFUgd/AiYNeQAAAQcA2wGmAZIAGUAMAgEAHSMcDUEBAgImuQIhACkAKwErNTUA//8AnP/nBVIHLgImDXkAAAEHAN0BoAFsABlADAIBAB0kHA1BAQICHbkCIQApACsBKzU1AP//AJz+UgVlBboCJg15AAABBwDeA8cAAAALtgEAMR0PDkEBKzUA//8AOwAAAscHLAImDYYAAAEHAEMAIQFqABZACgEADQwKA0EBAQ25AiEAKQArASs1//8AOwAAAscHLAImDYYAAAEHAI0AOQFqABZACgEADA8KA0EBAQy5AiEAKQArASs1//8AOwAAAscHLAImDYYAAAEHANYALAFqABZACgEADhEKA0EBAQ65AiEAKQArASs1//8AOwAAAscG4QImDYYAAAEHAI4ALAEeABlADAIBAAwTCgNBAQICDLkCIQApACsBKzU1AP//ADIAAALQBxQCJg2GAAABBwDXACwBagAWQAoBAAwYCgNBAQEMuQIhACkAKwErNf//ADsAAALHBwgCJg2GAAABBwDZACwBUAAWQAoBABMNCgNBAQEQuQIhACkAKwErNf//ADv+UgLHBboCJg2GAAABBwDeAI0AAAALtgEADw8JBEEBKzUA//8AOwAAAscG9AImDYYAAAEHANoALQFqABZACgEADA8KA0EBAQy5AiEAKQArASs1//8AOwAAAscFugIGDYYAAP///6wAAAPbBcIAJw2GARQAAAEHAI3+zgAAABS5AAH/zrcODgAAQQENAgA/NQErNf//ADsAAALHBuECJg2GAAABBwCOACwBHgAZQAwCAQAMEwoDQQECAgy5AiEAKQArASs1NQD//wA7AAACxwW6AgYNhgAA//8AOwAAAscG4QImDYYAAAEHAI4ALAEeABlADAIBAAwTCgNBAQICDLkCIQApACsBKzU1AP//AIn/8gIKBx0CJg2HAAABBwCN/6wBWwAWQAoBABQXEhNBAQEUuQIhACkAKwErNf//AE7+WwIKBboCJg2HAAABBgHu4wAAC7YBACMjAABBASs1AP//AIn/8gJpBboAJg2HAAABBwC2ASz/8QASQAoBaxUVExNBARUCAD81ASs1//8Aif/yAqAFugAmDYcAAAEHANoA3P1WAAu2AYQVFRMTQQErNQAAAQAH//ICCgW6ABsAXEAyFRgZFBkSGxoTFBMSGhkICRsYJRUAEiASAhIaHBlHFFcUAhQcExkTGRMMFgIIBRwJDAsAPzPtMj8SOTkvLxDtXRDtAS9dxP3EzDLdxBDdxH2HBMTEEIfExDEwARQeAjMyNjcXBgYjIi4CNREHNTcRMxE3FQcBPQUUKSMSKBYYKEMcX2UvB4KCtIaGAS0nOCMRBQOgCAgxVndHAQdunm4C3v26c51zAP//ADsAAALHBywCJg2GAAABBwBDACEBagAWQAoBAA0MCgNBAQENuQIhACkAKwErNf//ADsAAALHBywCJg2GAAABBwCNADkBagAWQAoBAAwPCgNBAQEMuQIhACkAKwErNf//ADsAAALHBywCJg2GAAABBwDWACwBagAWQAoBAA4RCgNBAQEOuQIhACkAKwErNf//ADsAAALHBuECJg2GAAABBwCOACwBHgAZQAwCAQAMEwoDQQECAgy5AiEAKQArASs1NQD//wAyAAAC0AcUAiYNhgAAAQcA1wAsAWoAFkAKAQAMGAoDQQEBDLkCIQApACsBKzX//wA7AAACxwcIAiYNhgAAAQcA2QAsAVAAFkAKAQATDQoDQQEBELkCIQApACsBKzX//wA7/lICxwW6AiYNhgAAAQcA3gCNAAAAC7YBAA8PCQRBASs1AP//ADsAAALHBvQCJg2GAAABBwDaAC0BagAWQAoBAAwPCgNBAQEMuQIhACkAKwErNf//AKT+WwVgBboCJg17AAABBwHuAXEAAAALtgEACxADAUEBKzUA//8ARv/nA98FwgImDX0AAAEHAEMAvAAAABZACgIAKysQEEECASu5AiIAKQArASs1//8ARv/nA98FwgImDX0AAAEHAI0A1gAAABZACgIAKi0QEEECASq5AiIAKQArASs1//8ARv/nA98FwgImDX0AAAEHANYAvAAAABZACgIALC8QEEECASy5AiIAKQArASs1//8ARv/nA98FqgImDX0AAAEHANcAxgAAABZACgIAKjYQEEECASq5AiIAKQArASs1//8ARv/nA98FwwImDX0AAAEHAI4AxgAAABlADAMCACoxEBBBAgMCKrkCIgApACsBKzU1AP//AEb/5wPfBe0CJg19AAABBwDbAMUAAAAZQAwDAgAqMBAQQQIDAjO5AiIAKQArASs1NQD//wBG/+cD3wVfAiYNfQAAAQcA2ADGAAAAFkAKAgAqLRAQQQIBKrkCIgApACsBKzX//wBG/+cD3wW4AiYNfQAAAQcA2QDGAAAAFkAKAgAxKxAQQQIBLrkCIgApACsBKzX//wBG/lIEAAQ9AiYNfQAAAQcA3gJiAAAAC7YCAD4qAQBBASs1AAAC/6f+aAIgBcIAAwAKADNAFggECQoEBwQGBQQEAiUAAxAHBAUKAQYAP97E3c0/AS/tORkv3RjNETkZEN0YzRE5MTATETMRAwcjEzMTI4m0V3HO2MDhzP5oBb36QwbsqgEY/uj//wCH/lsD+AW6AiYNfwAAAQcB7gDDAAAAC7YBAAsQAwFBASs1AP//AIn/8gIKBx0CJg2HAAABBwCN/6wBWwAWQAoBABQXEhNBAQEUuQIhACkAKwErNf//AE7+WwIKBboCJg2HAAABBgHu4wAAC7YBACMjAABBASs1AP//AIn/8gJpBboAJg2HAAABBwC2ASz/8QASQAoBaxUVExNBARUCAD81ASs1//8Aif/yAqAFugAmDYcAAAEHANoA3P1WAAu2AYQVFRMTQQErNQD//wAH//ICCgW6AgYOmwAA//8ADv5bAj8FLQImDYIAAAEGANzeAAALtgEADQ4BAEEBKzUA//8ADv5bAj8FLQImDYIAAAEGAe7iAAALtgEADBsBAEEBKzUA//8ADgAAAwAGGQAmDYIAAAEHALYBwwBQABJACgEAFBQJCUEBEwcAPzUBKzUAAQAOAAACPwUtABMANkAaExIODBAlCQcFBAIFEBMCAgAPBisKCQwGAAoAPz/Ezf3EEjkvxN3EAS/NxMzE/cTOzcQxMCEjESM1MxEjNTMRMxEzFSMRMxUjAYGymprBwbK+vpmZAgKEARSLAQj++Iv+7IT//wCF/lID5QXCAiYNgwAAAQcAjQDjAAAAFkAKAQAsLx0rQQEBLLkCIgApACsBKzX//wCF/lID5QXCAiYNgwAAAQcA1gDcAAAAFkAKAQAuMR0rQQEBLrkCIgApACsBKzX//wCF/lID5QXDAiYNgwAAAQcAjgDVAAAAGUAMAgEALDMdK0EBAgIsuQIiACkAKwErNTUA//8Ahf5SA+UFwgImDYMAAAEHAEMAwAAAABZACgEALSwdK0EBAS25AiIAKQArASs1AAMAV//dBJsEgwAtAD0ASwDAQG51PQGFCgEuHSE5JBAaJDMrKioAJUQiJCE+HkQhCz8zEDMhITMQA01EJAgJABkAAoYlAVUlZSV1JQMAJQMiZj52PgKDHgFUHmQedB4DiT8BPx4+A0l1CwFWC2YLAnQuhC4CZi4BLgsdAyEhSTYcFbgDK7dJHAMqKysDCwA/My8zEO0/7RE5Lxc5XV1dXRIXOV1dXV0zEjk5XV1dAS/tEhc5Ly8vEjk5ERI5ORDtETk5Mi8zEO0Q7RE5OTEwAF1dJQYGIyIuAjU0NjcuAzU0PgIzMh4CFRQGBxc2NjcXBgYHHgMXByYmAT4DNTQmIyIGFRQeAhMBDgMVFB4CMzI2A05Ns2lRkG1AkZIoMhsKKVB1TD1tUC9ufdoTHgu/FkQlEzQ4ORp1MGz+ly04HwpJNjdLCRkt5f7xOUkpECE5Ty1JhIFORTBXeUlsnkIuSDw1GzRdRSgjQVs4UZJA7yNjLSBMkDISKCglD4wdUQKEGy4sLBk2OTQ1Dh4sPf32ATEfODc3HSlEMBs6AP//ABcCzAKOBbsBBw08AVICUAAJswEABAIAPzU1AP//ACICzAKDBbsBBw09AVICYgAHsgAOAgA/NQD//wBJAt4CbgW7AQcNPwFbAmIAB7IABAIAPzUA//8AKgLMAn8FzQEHDUABVAJiAAu0AgEABAMAPzU1NQAAAgAVARkEyAQxAHMAgADeQChWbgFWbQGKXwF5XwFqXwFnVndWh1YDaUZ5RolGA5dFp0W3RQNVUwFTuAMDQAkOx0XXRQJFRUy4AwO3UXt7JXUvNDy4AwOzHHR0NLgDA7Y4UThROCViuAMDty9nP2cCZ2deuAMDtggAAIIlRT+4Au+3FmdnUVE4L3W4ApSye3R+uALvtiUcICAWXlu4Au+zDggIFrgC6wA/My8z7TIRMy8zM/0yMv7dzTIvMy8Q7TIBLxEzLzPtMy9d7RE5OS8vEO0yLzPtEjk5ETkvEO0yL10z7V0xMF1dXV1dXV1dARQHDgMHByYmJyYmJwYGBw4DIyImJyYmJwYHBiMiLgI1ND4CNz4DNy4DNTQ3NjcXFhYXFhYzMjY3NjY3AyYmJyYmNTQ3NjY3FxMWFhceAzMyNjcDJiY1NDc2NjcWFhceAxceAwUnBgYHBgYHFhYzMjYEyAkEDA4NBRAwVCggKhIWLhwMICQkECA9GxogCyk3ODU4WkAiGCk0HAsyQk8pAgUFAxcTIBsLFQsMOzkXKg4MIRQ7BAQCBAMXChkQFD4IHxMKIiktFA4QAk8CAxcKGQ4CEQ8JDQsIBAcJBQL8+RMtURgVIREWNzIcPAIiJh4OJSYjDCUCDw4LJx0gLREHDgwHDxQTQB47JyYJDxYNFTxCQhsLHiMmEwcWGBUIISsiJqQ+cTY3OQ8KCB8eAREQGgoUHAgiKxEjE2/+zCs+FwwWEgwMGwFwFBwIISwTIxENT0QpOi4mFSQyJRw6bxAgDg0zHAkKIQACAJ0A5gSUBm0AIAAqALRAaR4dGQUYGAsUFBMTDQ4INSJVIgIkIgF8I4wjAkkjASUjASIjIT4LAQ8LHwsvCwMLCyEkJSgpOCloKQOZKAGIKAE5KHkoAigoASkoKicnLCEqIyMkKCcdHRQUGRYICAUDIRYbGxMWDQ0kJwAvzTIvzDIyLxDMzTIyLxDMMi8yLxDNETkvAS/NEjkvEjk5XV1dXV3NzRE5L11dEjk5XV1dXV0z3c0zLzMZLxEzGC8z3d7NMTABFAYjIicGBgcWFhUUByMmJyYmJzcWMzI3MxYzMjczFBYlATMTIRUjASMBA80zMz4TEDMjExcSJQwZDjYqLzFGSA8kCDIzCyIC/TsBrgbQAQhd/sA2/dwGD1pPJRcTAjNiNjJsoEwqYzySWmRTUwkmVfusAbZK/WEFhwACAJ0A5gSUBm0ACQAoAK5AYrgHAZkHAYgHAXkHATgHAQcIBgkaGRkLCgoiJhYWDiYdHYMBAScBAQIBEgECjQIBewIBXAJsAgIBAg8mHyYCJiYAAwQGBioJAAICAwcGFhMZGg4LJigiHRoTEygAGigLCwMGAC/NMi/d3MwSORkvEjk5EjkSORgQzRE5EM0ROS8BL80SOS/NzRE5L105OV1dXV1dXTMvEM0yLxDMMi8zMi8zERI5OV1dXV1dMTABATMTIRUjASMBAQcmJjU0NzY2NycmNTQ2NwcGBhUUFhcWFRQHBhUUFwEIAa4G0AEIXf7ANv3cAso8e3AeCCIaSCtzexI8NR8lSUJBqwZt+6wBtkr9YQWH/gOHBiwmLDYQMiMhFhkwikxtFikNChANGREQQ0QYKA8AAgAaAPIFxwWGAEIAUADtQCeJHwGEGwGFBgFDIAE0IAEVICUgAgcfAXYbAVkGAXkFAWsFAV4FASm4Av2ySjMEuAMDQBMhe0OLQwJaQ2pDAkMjITo6OTkAuAMDQA82SiE2NiFKA1IODBcYGBq4AwO1EQw5OjouuALvQCZITnUzhTMCZjMBVTMBQzNOAAIjAyVmNoY2AjY2Tg4XERISGBcXTrwC7wAlABwC7wAJAC/93u0yLzMzL80ROREzL10SFzkSOTldXV0Q3u0yLzMBL87tMi8zEjkRFzkvLy8Q7TMvORkvETMzXV0YEO0yEO0xMABdXV1dXV1dXV0BXV1dAQYHFRUUBwYGIyImNTQ3BgYHNT4DNxcGFRQhMjY3NjU0JwYjIicmNTQ2NzYzMhcWFhc2NjcmJic3HgMXFhYVBSYmJyYjIhUUFxYzMjYFx3Bvt1LQcsLINlCRTiVeZGcvKGMBSVWmTrIQUUNTNkAbHT1WckALEwcoVy0HKDBDEhgQCgQODP6TDRQGHCZZHRwiEzIDm0UeELu+ZC0soaSOmRBILXQdNzAqEBHtge8hIk+DTyQmJy5dNmczb5odOiAOKBk6YzCLFSAZFw0mcjx3HS0IKE4fERAIAAAEAIUBCgRxByQADwATACMAMwBbvwAkAu0ALAAcAu0AFAATAwC3EBQQFBARNQC4Au2yCAgSuwMAABEABALutAwMEzAguALutRgoKBgYEQAvMy8zLxD9xC8zL+0BL+0yL+0REjk5Ly8Q7RDt3u0xMAEUBwYjIicmNTQ3NjMyFxYlASMBAxQHBiMiJyY1NDc2MzIXFgUUBwYjIicmNTQ3NjMyFxYB8CYmNzYnJiYlODglJgG//UNtArcpJyY3NiYlJSU3NicnAV4nJjc2JiUlJTc2JycGSzUpJycpNTYkJSUko/nmBhr6vTUnJiYlNzklJygnNjUnJiYlNzklJygnAAUAhQEKBacHJAAPABMAIwAzAEMAZb8ANALtADwAJALtACwAHALtshQsE7gDALcQLBAsEBFFALgC7bIICBK7AwAAEQAEAu61DAwTQCAwuALutDgYKCgRAC8zL8TE/cTELzMv7QEv7TIv7RESOTkvLxDtEN7tEP3e7TEwARQHBiMiJyY1NDc2MzIXFiUBIwEDFAcGIyInJjU0NzYzMhcWBRQHBiMiJyY1NDc2MzIXFgUUBwYjIicmNTQ3NjMyFxYB8CYmNzYnJiYlODglJgG//UNtArc9JyY3NiYlJSU3NicnAVQnJjc2JiUlJTc2JycBVCcmNzYmJSUlNzYnJwZLNSknJyk1NiQlJSSj+eYGGvq9NScmJiU3OSUnKCc2NScmJiU3OSUnKCc2NScmJiU3OSUnKCcAAQCZARkBjAJ9AAsAIUAMCQMJAwAGBgAGAAkDAC/NOTkZLy8BGC/NOTkZLy8xMAEGBgcmJic2NjcWFgGMERwMK1wzDSEVIVgB9jlrORg/KjdyOh5EAAABAIkA3QGcBEUAEQBCQCdGEFYQZhADjAsBegsBPgsBLQsBDQ1/DI8MAhgMAQwMAwAECgwNDQMALzMvMwEvM80yMy9dXTkZLzEwAF1dXV1dARQGByM0NjU2NjUQAzcWFhcWAZwPEC4BAQHJSDBCF0ICFiqccwoZEREbCAFUARGbN2o0mAABACwA3QH6BFUAIwBPQCxpFnkWiRYDdQaFBgJEBlQGZAYDBhgLGRkYGBEhICAQCxEgISEZBgQbGBkZEAAvMy8z3s0yETMvMwEvzTIyL80RMy8zGS8REjldXTEwXQEUBwYjIiceAxUUDgIHIy4DJyYnNxYzMjc2Njc3FhYB+icsTRgcDRYQCAMFBgQsAg8TFgk1fzBydFAhCAwGJgQDA9NVLjYGHUxQTh8pR0REJUmDbFMYlKmYqTgRNigCHUEAAQAeAN0CBwRVACcAXEAvmhQBeRSJFAJYE2gTAiIhGwYcHAkVDBYWFRUQDwwJCQYDHxgYHxYhIRYbGxUWFg8ALzMvMzMvETMvEMwyLxDNMjIvAS8zzTIvMxkvERI5MxgvM83ezTEwXV1dARQGIyImJwYGBxYWFRQGByMmJyYmJzcWMzI2NzMWFjMyNzMUFhcWFgIHOS0cMRETPyogFgoKKQweDzsuKjxRKzIJHwUgHTsMIAEBAQEECWFfFx8oKQNUqVgofFX6fUKgXrGFQkw/NnwHEg0MFAAAAQBjAOEBwgRKAB0ATEAjBxcMDAMcDw4OFxcBABwSEhwSFxwDAA8OAwEMDgcHAQ4OAAEAL80zLxI5GS8SORI5GBDNERc5AS8zLxDOMjIvMy8zEM0yLxE5MTABByQ1NDc2NyYmJyY1NCUHBgYVFBYXFhUUBgcGFRQBwiv+zzIcVho0Gj8BFxVRRiYzZC8qWgF5mBRpPUoqYAsWDRwjiOaPITkTEBwTKBcMPzFlJD0AAgAwAXYB9gO0ABAAHgAtQBmLEwF5EwFIE1gTaBMDjRIBABEIGRUMDBsEAC/NMy/NAS/N3s0xMABdXV1dARQHBiMiJyY1NDc2MzIXFhYHNCcmIyIHBhUUMzI3NgH2QkyJTi00P0hWTE4kKzxfVjAnGheZRjEtAq2BVWEhIkVrmLNaKll3PEVARDcycxwcAAEAGwDrAgsEPAAoAElAJ2QodCgCVScBRicBNycBdgABAQEAACAjBxoTGQwHGRoaDA8gHh4AAQAvMzMvM80yMy8zAS8z3DLNEM0yMi8zGS8xMF1dXV1dAQcmJicmJjU0PgI3BgYjIicmNTQ0NzY0NTcWFxYzMjcGBhUUFhcWFgILHCg9FBwWAQIFBDNEEFoaOgMCGhIRH1NHjg4NGRYLKwGXrBctKDZ/Vw87RUUZCAkKFUYNJhgaJA0CKwscH1FyIlWVNBdBAAEAHQDdAggEQgAPADlAG2gPAYkIAXgIAQoKCQUMDQUBBAUBAAAJCgoNBQAvMzMvMzMvMgEv3RnOEjk5GBDOMhkvMTBdXV0BFQYCByMmJyYnNxITMzYSAghOXxQtKTs7XhWzSgcXZgRC1m/+vd3mlI9s7f7//oHNAT4AAQAdAOECCQRFABQAR0AmhhQBdxQBdhGGEQJHEQFaAmoCAgMEDw4BAQAPCw4EDw8BCwoKAAEALzMzLzMRMy8zAS8ZzhjdzjIZLxESOTkxMF1dXV1dAQcmAyMGBgcGBgc1NhI3MxYWFxYWAgkWvkAFFCMSFEYwTl8bLhU6HhlDAdHs8gGSebM5RZZI1l4BROyBxks8cAAAAgApANYB/QRRABoAJQAuQBMLIQcBAQAAFRsHBwkbIx0PDwABAC8zMy/d3jLNMgEvM80yLzMZLxgQ3M0xMAEHJiYnJiY1BiMiNTQ3NjMyFxYWFxcWFhcWFgM0IyIHBhUUMzI2Af0tKzUNBgNUK7I1Rnk8HgwQBAsGFg0FGpZkLCsqfgk0AXWfG2xLHn5kHYRTZ4hCGU02vld3JA8nAZ6XIyMbQQYAAAEAHgDdAgcESwAkAE5AIyQAABkYFCAgBA0HDg4NDQsKBxgZACQeBAIgFCIeFhYNDg4KAC8zLzMzL93eMjLNMhDeMs4yAS8zzTIvMxkvERI5MxgvzcwyMi8zMTABBiMiJxYWFRQGByMCAzcWFhcWFhc2MzIXByYmJyYjIgcWMzI3Agcmmz8sFhsNDCYFqi4YIgoLHhITgUc6CQkRCBgYcCM7KF9EA5/hJT+CQzZ7UQGgARWzN0cTER8O1VgTAwcDCJsXYgACACYA8AH/BDgAFQAlAElAIRgSEhMGIRYUFB0AFhYnHQwhIyMfCBgSEhMTFBQIBgQECAAvMy8zETMvMxEzETMQzTIvMwEvzRI5L80SORkvEjk5MzMRMzEwARQHBiMiJwYjIicmNTQ2NzY2Nyc3AAM0JwYGBwYVFDMyNxYzMjYB/ykuRCMfNT09JSgUGRtVPy0oAQI3oxgwGEJQLjsgNhcfAgdYUFgbMicoSSpjNjaKVTWj/tL+y2f1GkQockpnMykmAAEAHQDdAgkERgAiADJAFgEAABYVDBwcCQcGAQkhGBUWABgTEwcALzMv3d7OMhDezTIBL80yMy/NzDIyLzMxMAEHBgYHBgcjEjcmJjU0PgI3NjMyFwcmIyIHBhUUHgIzMgIJIDloK2kVLw1mYWUOGykbXENIZhVNMlIuLxsoMRVpA22PFFc9lcQBIKUNNy0SJi03I3SGEh8ZFRkYIhcLAAABAAgA3QIeBEgALQBSQCyDFAFUFGQUdBQDBhQWFAIUFyYmHBcBAAkqDQ0bFwABAQMsLCgUCxEqJigoHAAvMy8zM93MMxEzL80yLzMBLzMzLzPdzDIQzTIvEjldXV0xMAEHJiMiBgcGBgcGIyInJicmIyIGBxYSFRQUBwcjLgMnJicmJic2MzIXNjMyAh4KJycwMggBAgIFCAYFBg4YOQsUDjYzAQIhBgwNCwQeLBQ4JmF6SxgQWzUD3BUkR08EJSMJClchMwgHYv7fwgsmGzg0X1A9EYRhLGQ7imRkAAABACgApQH9BEYAJwBGQCRUImQiAgYiFiICIg0dBwAGBhcdFgwNDRYiDSQJBQcHCRYWDAkALzMzLxEzLzMQzTIyAS8zLzMQzTIyLzPNERI5XV0xMAEUFAcGBhUHJiMiBgcnNjY3NjY3NjY3MxQUFxYWFRQGBwYHNjMyFxYB/QIBAR0ec0l6NykmOBQWJQ8IGwshAQEBDw4eMjZTUx07AUANJRoaJQ0DVQ8PmjphKjFwQCKVcwsgFhYiCz+LTaZpCQkYAAEARv9SDFAB0wAQAClADgkJBAoEAA8BAwoJDwIBuQLvAAQAL+0zxN3NAS8zL83NzhE5GS8xMAUhJTUhNTQ3NjcXBgYHBgczDFD09v8ACuYbE0dOJi4KGwHbrqMLRrJNM1ujKD4WPnYAAQBG/x4NxgDtAEoAjUAjQwAWHSEDIzk6NjQwKgMoOBQ2AgMDAAUNBTYFNgVMJiglIxK4Au9ACj4+NCYlJTg5NB24Au+yMDQhuALvsyoqNEm4Au+1BwMCAhQWuQLvADQAL+0yMi8z3O0RMy/tENztEMwyMi8zETMv7QEvM80yEjk5Ly8SORDNMy8zETMzEhc5EM0yERc5ETkxMCUUByc2NTQjIg4CDAMGBiMiJwYjIicmJicmIyIHBiMiNTQ3FwYVFDMyNzY3NjMyFxYzMjU0JzcXFhcWMzI2NiwDPgIzMg3GrRpdIAtsreP+/P7m/ub+8PDFQmBPSW1HPwguJzAiLzuNbrE3GAaaT0lbFD4rM1FRL3oPKhUYKiY2RMjzARMBHgEfAQnotHIPbEx7sxhvKBwLFBodHx0aFAtDQzkHNC85QZv1cFYHJxjQQ1QPL2ZmajFKPF5sLikLFBoeHx4aFAsAAf+6/1IDqQAAAAQAFbQABAEEALkC7wACAC/tMwEvzTIxMAUhNSEVAqr9EAPvrq4LAAACAEb/Ug6MAWsAGgAiAFJAGYcTAXYTARMgGxENEAMDAA0BDRsaGiQGCBi4Au+2HRARIAUDAbgC77MTCQcgAC8zxMT9MsQQzDLe7QEvMxEzL93MXTIZLzIYEM0ROTldXTEwBSEiJwYjISU1ITI3NjU0Jic3EjMyNzc2MzIVBzQjIgcHMzIOjP0mQk44bfbJ/wAKOToeLAYFHzeGWV6jYWaXo1MxRHXnVq4/P6IMDhdFGj4jPP7fXq9e/hxkQXQAAv9bAAAApgGyACQAMABLQCQAJRsXFRUYGw0IEA4OLQYBCB4bFQ4NGAQXEBAGHgIhKCgCLgEAL93EMy/NETk5Mi/MFzkBLzPdzDMzMy8zEjkSOTIvMxDczTEwMyE1MzI2NzY1NC4CJyc2NxYXFhYXBgcnFhYVFAYHNjYzMhYVIzQmIyIOAgczMjam/rULDyIZDQgLDAQVBg0GFgcTCwELEA0NBgQkQCYoJzUeHA0iJSUPfSgdOxIPIB0ROz4yCAowGxEJAgQBFi0ELUAeFCkXGiIrMBENCQ8UCwwAAAH/kQI8AEIDkQAeADpAGxscCRYWFRUPDgYJFQMcHAAWARYYBg8DAQMDDwAvMy9dM93OXTIvETkBLzMzzTIvMxkvGBDczTEwExQGIyImJxYWFRQGBwYHIyYmJyYmJzcWMzI2NzMWFkIeHwUKBRQHAQEBAREJDgoKIxgSLCwgEwMOAgEDXx4pAQEwTyYGEwkLDDhLHh09IDpBJB0LGQAAAf+3Aj0AcwOTACUAR0AgISEgIBoWBwYRAAEBGRMWIA4hIQcHAAQjIwQOExMODhoALzMvMy8QzTIvEMwyLzIvEjkBLzMzMy/NM97NEM0yLzMZLzEwEzMWFjMyNzMVFBYVFAYjIiYnBgcWFhUUBgcjJiYnJiYnNxYzMjYlDAIMCxgDDQEWEQsSBw4iDQgEBBACCAYGFhIQFiAREwOQGBQvDQUJAiYkCQweAyBAIw8wITFFGhw7JUQzGQAAAf+bAkQAaAOVACcAQkAeExYgIBgWAQAIJAwMFgABAQMmJiQgIhETEQoKEREXAC8zLzMvETMQzTI5Mi/NMi8zAS8zLzPdzDIQzTIvEjkxMBMHJiMiBgcGBwYjIicuAyMiBxYWFRUjJiYnLgMnNjMyFzYzMmgEDhASFAIBAgIDAwECAgYPDQkJFRMOBQcFCA0QFQ4kMB0JBiMVA2wJDhsfDw4DBAwYEgsFJm9LMyk7ERspJSYYNScn//8ANv5OBCADdQImA6EAAAEHDtsCgAAAAB5ACwIBAC4tGRNBAgEuuP/AswwQNC4ALys1NQErNTX//wA2/k4ENQNpAiYDogAAAQcO2wJE/9gAHkALAgEAZD8EBEECAUC4/8CzDBE0QAAvKzU1ASs1Nf///7r/QgQ9A2sCJgOjAAABBw7bAhz/QgAnQAsCAQAYFwEAQQIBGLj/wLMJGDQYuP/AswwlNBgALysrNTUBKzU1AP///7r/QgQ9A2sCJgOjAAABBw7bAhz/QgAnQAsCAQAYFwEAQQIBGLj/wLMJGDQYuP/AswwlNBgALysrNTUBKzU1AP//ADb+TgQgA3UCJgOhAAAAJw7bArwAZAEHBm0BuP/EAD5AGAQDAGReGRJBAgEALi0ZEkEEA2NAEhU0Y7j/wLYJETRjAgEuuP/AswsQNC4ALys1NS8rKzU1ASs1NSs1Nf//ADb+TgQ1A2kCJgOiAAAAJw7bAlgAPAEHBm0BuP+wAFBAGAQDAHJwBARBAgEAZD8EBEEEA3VAEhU0dbj/wLMMDTR1uP/AtgkONHUCAUC4/8CzERI0QLj/wLMMDjRAAC8rKzU1LysrKzU1ASs1NSs1Nf///7r+SAQ9A2sCJgOjAAAAJw7bAhz/QgEHBm0BLP7UAEpAEwQDAE5IAQBBAgEAGBcBAEEEA024/8CzHCw0Tbj/wLMVFzRNuP/AtgkRNE0CARi4/8CzEyU0GAAvKzU1LysrKzU1ASs1NSs1Nf///7r+SAQ9A2sCJgOjAAAAJw7bAhz/QgEHBm0BLP7UAEpAEwQDAE5IAQBBAgEAGBcBAEEEA024/8CzHCw0Tbj/wLMVFzRNuP/AtgkRNE0CARi4/8CzEyU0GAAvKzU1LysrKzU1ASs1NSs1Nf//AD7/bAaSBsYCJgOxAAAAJwUuA/wEUgEHDtsE2AUUACxAGwQDAFBPTUdBAgEATUc0NEEEA1ACAUxADBE0TAAvKzU1LzU1ASs1NSs1Nf//AD7/bAaSBsYCJgOxAAAAJwUuA/wEUgEHDtsE2AUUACxAGwQDAFBPTUdBAgEATUc0NEEEA1ACAUxADBE0TAAvKzU1LzU1ASs1NSs1Nf///7oBJQQ/BsYCJgOzAAAAJwUuAZAEUgEHDtsCgAUUAC9AFgQDAEVEQjxBAgEAQjwpKUEEA0UCAUG4/8CzCQs0QQAvKzU1LzU1ASs1NSs1NQD///+6ASUEPwbGAiYDswAAACcFLgGQBFIBBw7bAoAFFAAvQBYEAwBFREI8QQIBAEI8KSlBBANFAgFBuP/AswkLNEEALys1NS81NQErNTUrNTUA//8ASv9GA+kGxgImA60AAAAnBS4BpARSAQcO2wKUBRQALEAbBAMAKCclH0ECAQAhHxkaQQQDKAIBJEAMETQkAC8rNTUvNTUBKzU1KzU1//8ASv9GA+kGxgImA60AAAAnBS4BpARSAQcO2wKUBRQALEAbBAMAKCclH0ECAQAhHxkaQQQDKAIBJEAMETQkAC8rNTUvNTUBKzU1KzU1//8ANv5OBCAGoAImA6EAAAEHBTMBLAAAABVACwIBAC4tBxJBAgEuAC81NQErNTUA//8ANv5OBDUGoAImA6IAAAEHBTMBLAAAABVACwIBAEA/KTNBAgFAAC81NQErNTUA////ugElBD0GoAImA6MAAAEHBTMA8AAAABVACwIBABgXCwNBAgEYAC81NQErNTUA////ugElBD0GoAImA6MAAAEHBTMA8AAAABVACwIBABgXCwNBAgEYAC81NQErNTUA////wwEKAVIGTQImA40AAAEHDtwAMgK8ABO5AAH/4bYVFQ0NQQEkAC81ASs1AP///18BJQHWBk0CJgOOAAABBw7c/84CvAARQAkBABcXDAxBASYALzUBKzUA////6QEKAVIGTwImA40AAAEHDt0AMgK8ABFACQEAICANDUEBLwAvNQErNQD///+FASUB1gZPAiYDjgAAAQcO3f/OArwAE7kAAf/Iti0tDAxBATEALzUBKzUA//8AMv+nBNkDsgImAzUAAAEHDtwCJgAAABFACQEAUTwhM0EBSwAvNQErNQD//wAk/x8EtQORAiYDNgAAAQcO3AImAAAAEUAJAQBMVRovQQFGAC81ASs1AP///7r/cwH0BIsCJgUpAAAAJw7cAMgA+gAGBS4HJ////7r/cwH0BIsCJgUpAAAAJw7cAMgA+gAGBS4HJ///ADL/pwTZA7ICJgM1AAABBw7dAiYAAAARQAkBAFxHITNBAVYALzUBKzUA//8AJP8fBLUDkwImAzYAAAEHDt0CJgAAABFACQEAQkIvL0EBUQAvNQErNQD///+6/3MB9ASNAiYFKQAAACcO3QDIAPoABgUu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ADoARP+0ADoASP/bADoATAAAADoAUv/bADoAVf/bADoAWP/bADoAXP/uADwAA//bADwAD/74ADwAEP9EADwAEf74ADwAHf+PADwAHv97ADwAJP9oADwARP9oADwASP9EADwATP+0ADwAUv9EADwAU/9oADwAVP9EADwAWP+PADwAWf+PAEkASf/bAEkAtgAlAFUAD/+PAFUAEf+PAFUAtgBMAFkAD/9oAFkAEf9oAFoAD/+PAFoAEf+PAFwAD/9oAFwAEf9oALUAtf/bALYAA/+0ALYAVv/bALYAtv/bAMQCLf9gAMQCNv9gAMQCTP9gAMQCUf+8AMQCVP+8ASsAD/8fASsAEf8fASsB+ACkASsB+f9EASsB+/9EASsCAf9EASsCGv+oASsCJwBYASwB+f/bASwB+//bASwCAf/bASwCCv++ASwCD/++AS0B+f/FAS0CCv++AS0CD/++AS8BMv/jAS8CHP/ZAS8CJP/JAS8CjP/jATIBLv/jATIBL//jATIBMf/jATIBM//jATICEP/jATICF//jATICIP/jATICIv/jATICJv/jATICK//jATMBMv/jATMCHP/ZATMCJP/JATMCjP/jAfEBLP/VAfEBLf/FAfECBf/VAfECCf9oAfECCv9oAfECD/9oAfECFv/bAfECHv/bAfECJP/bAfUCCv++AfYBLP+NAfYBLf+NAfYBLv9GAfYBMf9GAfYBM/9GAfYB+ACqAfYB+f9oAfYB+/9oAfYCAf9oAfYCBf+NAfYCDf+eAfYCEv9oAfYCE/+0AfYCGP9oAfYCGv+0AfYCG/9oAfYCHf9oAfYCIP9GAfYCJwBiAfYCKf9GAfcCCv/RAfcCD//RAfkAA/+PAfkAtv9oAfkBLP/VAfkBLf/FAfkCBf/VAfkCCf9oAfkCCv9oAfkCD/9oAfkCFv/bAfkCHv/bAfkCJP/bAfsAA/+PAfsBLP/VAfsCBf/VAfsCCf+JAfsCCv9oAfsCD/9oAgABLP/BAgABLf+PAgABLv/nAgABL//nAgABMf/nAgABM//nAgACBf/BAgACEP/nAgACF//nAgACGf/nAgACH//nAgACIP/nAgACJv/nAgACKf/nAgACK//nAgEAA/+PAgEBLP/VAgECBf/VAgECCf9oAgECCv9oAgECD/9oAgUB+f/bAgUB+//VAgUCAf/bAgUCCv++AgUCD/++AgcAA//bAgcAD/76AgcAEf76AgcB+f9oAgcB+/9oAgcCAf9oAggBMv+eAggCjP+eAgkAA//bAgkAD/8fAgkAEf8fAgkAHf8fAgkAHv8fAgkBLP/bAgkBLf/bAgkBLv8fAgkBMP8fAgkBMf8fAgkBM/8fAgkB+AC8AgkB+f9oAgkB+/9oAgkCAf9oAgkCBf/bAgkCDf/bAgkCEP8fAgkCEf8fAgkCFP9OAgkCFv9OAgkCGP9qAgkCGv+0AgkCHf9qAgkCHv+PAgkCIP8fAgkCI/9QAgkCJP+PAgkCJf9qAgkCJwC8AgkCKP9OAgkCKf8fAgkCKv9OAgoAA//bAgoAD/76AgoAEP9GAgoAEf76AgoAHf+PAgoAHv+PAgoBLP+NAgoBLf+NAgoBLv9GAgoBMf9GAgoBM/9GAgoB+AC8AgoB+f9oAgoB+/9oAgoCAf9oAgoCBf+NAgoCDf+eAgoCEv9oAgoCE/+0AgoCFv+eAgoCGP9oAgoCGv+0AgoCG/9oAgoCHf9oAgoCIP9GAgoCJwB5AgoCKf9GAgwBLv+yAgwBL/+yAgwBMf+yAgwBM/+yAgwCEP+yAgwCGf/ZAgwCIP+yAgwCJv+yAgwCKf+yAgwCK/+yAg0CCv/RAg0CD//RAg8AA//bAg8BLP+NAg8BLf+NAg8BLv9GAg8BMf9GAg8BM/9GAg8B+ACqAg8B+f9oAg8B+/9oAg8CAf9oAg8CBf+NAg8CDf+eAg8CEv9oAg8CE/+0Ag8CGP9oAg8CGv+0Ag8CG/9oAg8CHf9oAg8CIP9GAg8CJwBiAg8CKf9GAhcBLv93AhcBL/+0AhcBMf93AhcBMv+qAhcBM/93AhcCEP93AhcCEv/bAhcCFv+qAhcCGP/bAhcCGf+eAhcCGv/bAhcCG//bAhcCHv+qAhcCIP93AhcCJv93AhcCKf93AhcCK/93AhcCjP+qAhkCHP/ZAhsBLv/nAhsBL//nAhsBMf/nAhsBM//nAhsCEP/nAhsCF//nAhsCGf/nAhsCH//nAhsCIP/nAhsCIv/nAhsCJv/nAhsCKf/nAhsCK//nAhwBLv/hAhwBL//hAhwBMf/hAhwBM//bAhwCEP/hAhwCH//hAhwCIP/hAhwCIv/RAhwCI//PAhwCJv/hAhwCKf/hAhwCKv/PAhwCK//hAh8BLv/JAh8BL//JAh8BMf/JAh8BM//JAh8CEP/JAh8CF//JAh8CH//JAh8CIP/JAh8CIv/JAh8CKf/JAiABMv/jAiACHP/ZAiACJP/JAiACjP/jAiEBMv/jAiECHP/ZAiECjP/jAiQBLv/JAiQBL//JAiQBMf/JAiQBM//JAiQCEP/JAiQCF//JAiQCIP/JAiQCIv/JAiQCJv/JAiQCKf/JAiQCK//JAiYBMv/jAiYCHP/ZAiYCJP/JAiYCjP/jAikBMv/jAikCHP/ZAikCJP/JAikCjP/jAisBMv/jAisCHP/ZAisCJP/JAisCjP/jAi4AD/8GAi4AEf8GAi4Aqf93Ai4Aqv93Ai4Asv/TAjQAtv9gAjUAtv93AjoAtv+NAjoCPgBEAjoCQf/pAjoCRQAtAjoCSP/TAjoCSf/pAjoCS//TAjoCTP9gAjoCTf+mAjoCTv+8AjoCUf9gAjoCV//TAjoCWgAXAjoCbP/TAjoCbf/pAjoCbgAXAjoCdwAtAjsCOv/TAjsCQf/pAjsCSP/pAjsCS//pAjsCTP+kAjsCTf/RAjsCTv/pAjsCT//TAjsCUf+kAjsCVP+8AjsCV//pAjsCWf/pAjsCZf/pAjsCbf/TAjwCOv+8AjwCPv/TAjwCQP/TAjwCQf+8AjwCRf/pAjwCSP+8AjwCS/+8AjwCTP93AjwCTf+8AjwCTv+8AjwCT/+mAjwCUf+kAjwCVP+NAjwCWf+8AjwCXv/pAjwCZv/pAjwCbP+8AjwCbf/pAjwCb//pAjwCcf+8AjwCef/pAj0AD/8GAj0AEf8GAj0Aqf93Aj0Aqv93Aj0Asv/TAj0COv93Aj0CPv93Aj0CQf/TAj0CRf+NAj0CRv/RAj0CSP+NAj0CS/+kAj0CWf+8Aj0CWv+NAj0CXP+NAj0CXv93Aj0CX/93Aj0CYv+NAj0CZf+NAj0CZv+NAj0CZ/+NAj0CaP93Aj0Cav+NAj0Cbf93Aj0Cdf+NAj0Cdv+NAj0CeP+NAj0Cef93Aj4CTQAXAj4CTv/TAj4CUf+6Aj4CYQBEAj4CaAAXAj4CbQAtAj8CQf/TAj8Ca//pAkACQf/pAkACSP/TAkACS//pAkACTAAXAkACTQAtAkACVAAtAkACWgAXAkACX//nAkACaP/pAkACbf/pAkECRf/pAkECSP/pAkECS//pAkECTP/TAkECTf/pAkECTv/pAkECUf/TAkECWf/pAkQCQf/pAkQCSP/pAkQCS//pAkQCTQAXAkQCTv+6AkUCTv/pAkUCWwAXAkUCbQAXAkYCTv/pAkYCUf/pAkYCWgAXAkYCXwAXAkYCaAAXAkYCawAXAkYCbQAXAkYCcf/pAkYCdwAXAkgCOv/TAkgCPv/TAkgCQP/TAkgCRf/pAkgCTf/TAkgCT/+kAkgCUf/TAkgCWf/TAkgCXv/TAkgCZf/pAkgCb//pAkoAD/59AkoAEf59AkoAHf/TAkoAHv/TAkoAqv+NAkoCOv93AkoCPv93AkoCQP/pAkoCQf/TAkoCRf+NAkoCRv/pAkoCSP/TAkoCS//pAkoCTP+kAkoCTf/TAkoCTv/pAkoCT/+kAkoCWf/TAkoCWv+8AkoCXv9gAkoCX/+mAkoCaP+mAkoCd//TAkoCef+8AksCOv/TAksCPv/TAksCQf/pAksCRf+8AksCRv/pAksCSP/TAksCTP+8AksCTf+8AksCT/+NAksCUf+8AksCVP+6AksCV//pAksCWgAXAksCYAAtAksCcf/pAkwAD/8dAkwAEf8dAkwAqf+mAkwAqv+mAkwAsv/TAkwCOv+8AkwCPv+8AkwCQAAXAkwCQf/pAkwCRf/TAkwCSP+kAkwCTv+8AkwCWf/TAkwCWv+kAkwCXP+mAkwCX/+NAkwCYv+mAkwCZP+mAkwCZf+kAkwCZv+mAkwCaP9gAkwCaf+mAkwCav+NAkwCa/+NAkwCbf+NAkwCb/+mAkwCc/+mAkwCdf+mAkwCdv+mAkwCeP+mAkwCef+NAk0AD/7wAk0AEf7wAk0AHf/TAk0AHv/TAk0Aqf+mAk0Aqv+kAk0Asv/pAk0COv93Ak0CPv+kAk0CQf/TAk0CRf+8Ak0CSP+8Ak0CTv+8Ak0CV//TAk0CWf/TAk0CW//TAk0CXP+NAk0CXf+kAk0CXv9gAk0CX/93Ak0CYP+8Ak0CYf+NAk0CYv+kAk0CY/+8Ak0CZP+kAk0CZf93Ak0CZv+kAk0CZ/+kAk0CaP93Ak0Caf+kAk0Cav+kAk0Ca/93Ak0Cb/+kAk0CcP+kAk0Ccv+kAk0Cc/+kAk0CeP+kAk0Cef93Ak4COv/TAk4CPv+8Ak4CRf+8Ak4CTP+NAk4CTf+kAk4CUf/TAk4CWf+6Ak4CZf+8Ak8CQf/TAk8CSP+8Ak8CS/+8Ak8CTv+8Ak8CV/+6Ak8CaP/pAk8Cbf/TAlACSP/TAlACWgAtAlMCWgAXAlMCbQAtAlQAtv93AlQCWf+8AlYAtv9gAlYCOv/TAlYCPv/TAlYCQP+8AlYCQf/pAlYCRf+6AlYCRv/TAlYCSP/TAlYCS//TAlYCTP8zAlYCT/+kAlYCUf9gAlYCV//pAlYCWf+kAlcCPv+8AlcCQP/nAlcCQf/pAlcCRf+8AlcCT/+6AlcCWf/TAlcCXv+8AlcCYAAXAlcCZf+8AlcCZv/pAlcCef/pAlgCOv+8AlgCPv+mAlgCQP/TAlgCRf+kAlgCSP/pAlgCS//pAlgCTP+NAlgCT/+kAlgCUf+8AlgCXv+kAlgCZf+kAlgCZv/pAloCYf/pAloCbP/TAloCbf/pAloCcf/TAlsCWv/RAlsCXv+kAlsCX//pAlsCYP/pAlsCYf/TAlsCZf+kAlsCZv/TAlsCa//pAlsCbf/TAlsCbv/pAlsCb/+8AlsCcf+8AlsCdP+8AlsCd//pAlsCef/TAlwCWv/pAlwCW//pAlwCXv/pAlwCX//pAlwCYP/pAlwCYf/pAlwCZf/RAlwCZv/pAlwCaP/pAlwCa//pAlwCbP/TAlwCbf/TAlwCbv/pAlwCcf+kAlwCdP+8AlwCef/pAl0AD/8GAl0AEf8GAl0CWv/TAl0CXv+kAl0CX//TAl0CYf/pAl0CZf/TAl0CaP/TAl0Ca//TAl0Cef/pAl4CdP/TAl4CdwAXAl8CW//pAl8CXv/TAl8CYP/pAl8CYf/TAl8CZf+8Al8CbP+8Al8Cbf/pAl8Cb//TAl8Ccf+8AmACWwAXAmACbQAXAmACcf/pAmACdAAtAmECW//pAmECXv/TAmECX//pAmECYf/pAmECZf/pAmECaP/pAmECa//pAmECbf/pAmECbv/pAmECcf+8AmECdP/TAmQCWgAtAmQCWwAtAmQCXwAXAmQCYQAXAmQCZQAXAmQCaAAXAmQCawAXAmQCbAAXAmQCbQAXAmQCdwAXAmUCaAAXAmUCcf/TAmYCW//pAmYCYf/pAmYCbQAXAmgCXv/TAmgCYP/pAmgCYf/pAmgCZf/TAmgCbP/TAmgCbf/pAmgCb//pAmgCcf/TAmoCXv/RAmoCYf/pAmoCZf+6AmoCbP/TAmoCbf/pAmoCb//pAmoCcf/TAmoCef/pAmsCYAAXAmsCaAAXAmsCcf/pAmsCdwAXAmwAD/8dAmwAEf8dAmwCWv/pAmwCXv+8AmwCX//pAmwCYABEAmwCZf/TAmwCaP/pAmwCa//pAmwCbQAXAm0AD/8zAm0AEf8zAm0AqgAXAm0CWv/pAm0CWwAXAm0CXv+8Am0CX//pAm0CYAAXAm0CZf/TAm0CZv/pAm0CaP/nAm0Cav/pAm0Ca//pAm0Cbv/pAm0Cd//pAm0Cef/pAm4CW//pAm4CXv/TAm4CZf/TAm4CbP/TAm4Cbf/pAm4Ccf/TAm4Cef/pAm8CWv/pAm8CW//pAm8CX//pAm8CYf/pAm8CaP/pAm8Ca//pAm8CbP/pAm8Cbv/pAm8Ccf/TAnACX//pAnACYf/pAnACaP/pAnACa//pAnMCX//pAnMCaP/pAnMCbQAXAnYCbP9gAnYCcf93AncCXv/TAncCXwAXAncCYf/pAncCZf/TAncCaAAXAncCbP/TAncCb//pAncCef/pAngCXv/TAngCYP/pAngCZf/TAngCZv/pAngCbP/TAngCb//pAngCcf/TAoYAD/8zAoYAEf8zAogAD/8GAogAEf8GAogAHf/TAogAHv/TAogAqf9gAogAqv9gAogAsv/TAowBLv/jAowBMf/jAowBM//jAowCEP/jAowCF//jAowCIP/jAowCIv/jAowCJv/jAowCK//jAAAAOgK+AAAAAwAAAAACGgAAAAAAAwAAAAEACgIaAAAAAwAAAAIADgKcAAAAAwAAAAMARAJ+AAAAAwAAAAQACgIaAAAAAwAAAAUAGALCAAAAAwAAAAYADgLaAAAAAwAAAAcAZAIaAAAAAwAAAAgAMAL2AAAAAwAAAAkAigUGAAAAAwAAAA0NGAWQAAEAAAAAAAABDRKoAAEAAAAAAAEABRO1AAEAAAAAAAIABxP1AAEAAAAAAAMAIhPmAAEAAAAAAAQABRO1AAEAAAAAAAUADBQIAAEAAAAAAAYABxQUAAEAAAAAAAcAMRO1AAEAAAAAAAgAGBKvAAEAAAAAAAkARRQbAAEAAAAAAA0GjBRgAAMAAQQDAAIADBrsAAMAAQQFAAIAEBr8AAMAAQQGAAIADBsMAAMAAQQHAAIAEBsYAAMAAQQIAAIAEBsoAAMAAQQJAAACHgLoAAMAAQQJAAEACgIaAAMAAQQJAAIADgKcAAMAAQQJAAMARAJ+AAMAAQQJAAQACgIaAAMAAQQJAAUAGALCAAMAAQQJAAYADgLaAAMAAQQJAAcAYhs4AAMAAQQJAAgAMAL2AAMAAQQJAAkAigUGAAMAAQQJAA0NKhuaAAMAAQQKAAIADBrsAAMAAQQLAAIAECjEAAMAAQQMAAIADBrsAAMAAQQOAAIADCjUAAMAAQQQAAIADijkAAMAAQQTAAIAEijyAAMAAQQUAAIADBrsAAMAAQQVAAIAEBrsAAMAAQQWAAIADBrsAAMAAQQZAAIADikEAAMAAQQbAAIAECjUAAMAAQQdAAIADBrsAAMAAQQfAAIADBrsAAMAAQQkAAIADikSAAMAAQQqAAIADikgAAMAAQQtAAIADikuAAMAAQgKAAIADBrsAAMAAQgWAAIADBrsAAMAAQwKAAIADBrsAAMAAQwMAAIADBrsAKkAIAAyADAAMQA1ACAAVABoAGUAIABNAG8AbgBvAHQAeQBwAGUAIABDAG8AcgBwAG8AcgBhAHQAaQBvAG4ALgAgAEEAbABsACAAUgBpAGcAaAB0AHMAIABSAGUAcwBlAHIAdgBlAGQALgAgAA0ADQBIAGUAYgByAGUAdwAgAE8AcABlAG4AVAB5AHAAZQAgAEwAYQB5AG8AdQB0ACAAbABvAGcAaQBjACAAYwBvAHAAeQByAGkAZwBoAHQAIACpACAAMgAwADAAMwAgACYAIAAyADAAMAA3ACwAIABSAGEAbABwAGgAIABIAGEAbgBjAG8AYwBrACAAJgAgAEoAbwBoAG4AIABIAHUAZABzAG8AbgAuACAAVABoAGkAcwAgAGwAYQB5AG8AdQB0ACAAbABvAGcAaQBjACAAZgBvAHIAIABCAGkAYgBsAGkAYwBhAGwAIABIAGUAYgByAGUAdwAgAGkAcwAgAG8AcABlAG4AIABzAG8AdQByAGMAZQAgAHMAbwBmAHQAdwBhAHIAZQAgAHUAbgBkAGUAcgAgAHQAaABlACAATQBJAFQAIABMAGkAYwBlAG4AcwBlADsAIABzAGUAZQAgAGUAbQBiAGUAZABkAGUAZAAgAGwAaQBjAGUAbgBzAGUAIABkAGUAcwBjAHIAaQBwAHQAaQBvAG4AIABmAG8AcgAgAGQAZQB0AGEAaQBsAHMALgBBAHIAaQBhAGwAIAAgAGkAcwAgAGEAIAB0AHIAYQBkAGUAbQBhAHIAawAgAG8AZgAgAFQAaABlACAATQBvAG4AbwB0AHkAcABlACAAQwBvAHIAcABvAHIAYQB0AGkAbwBuAC4ATQBvAG4AbwB0AHkAcABlADoAQQByAGkAYQBsACAAUgBlAGcAdQBsAGEAcgAgACgATQBpAGMAcgBvAHMAbwBmAHQAKQBWAGUAcgBzAGkAbwBuACAANgAuADkAMABBAHIAaQBhAGwATQBUAKkAIAAyADAAMQA1ACAAVABoAGUAIABNAG8AbgBvAHQAeQBwAGUAIABDAG8AcgBwAG8AcgBhAHQAaQBvAG4ALgAgAEEAbABsACAAUgBpAGcAaAB0AHMAIABSAGUAcwBlAHIAdgBlAGQALgAgAA0ACgANAAoASABlAGIAcgBlAHcAIABPAHAAZQBuAFQAeQBwAGUAIABMAGEAeQBvAHUAdAAgAGwAbwBnAGkAYwAgAGMAbwBwAHkAcgBpAGcAaAB0ACAAqQAgADIAMAAwADMAIAAmACAAMgAwADAANwAsACAAUgBhAGwAcABoACAASABhAG4AYwBvAGMAawAgACYAIABKAG8AaABuACAASAB1AGQAcwBvAG4ALgAgAFQAaABpAHMAIABsAGEAeQBvAHUAdAAgAGwAbwBnAGkAYwAgAGYAbwByACAAQgBpAGIAbABpAGMAYQBsACAASABlAGIAcgBlAHcAIABpAHMAIABvAHAAZQBuACAAcwBvAHUAcgBjAGUAIABzAG8AZgB0AHcAYQByAGUAIAB1AG4AZABlAHIAIAB0AGgAZQAgAE0ASQBUACAATABpAGMAZQBuAHMAZQA7ACAAcwBlAGUAIABlAG0AYgBlAGQAZABlAGQAIABsAGkAYwBlAG4AcwBlACAAZABlAHMAYwByAGkAcAB0AGkAbwBuACAAZgBvAHIAIABkAGUAdABhAGkAbABzAC4ATQBvAG4AbwB0AHkAcABlACAAVAB5AHAAZQAgAEQAcgBhAHcAaQBuAGcAIABPAGYAZgBpAGMAZQAgAC0AIABSAG8AYgBpAG4AIABOAGkAYwBoAG8AbABhAHMALAAgAFAAYQB0AHIAaQBjAGkAYQAgAFMAYQB1AG4AZABlAHIAcwAgADEAOQA4ADIAWQBvAHUAIABtAGEAeQAgAHUAcwBlACAAdABoAGkAcwAgAGYAbwBuAHQAIABhAHMAIABwAGUAcgBtAGkAdAB0AGUAZAAgAGIAeQAgAHQAaABlACAARQBVAEwAQQAgAGYAbwByACAAdABoAGUAIABwAHIAbwBkAHUAYwB0ACAAaQBuACAAdwBoAGkAYwBoACAAdABoAGkAcwAgAGYAbwBuAHQAIABpAHMAIABpAG4AYwBsAHUAZABlAGQAIAB0AG8AIABkAGkAcwBwAGwAYQB5ACAAYQBuAGQAIABwAHIAaQBuAHQAIABjAG8AbgB0AGUAbgB0AC4AIAAgAFkAbwB1ACAAbQBhAHkAIABvAG4AbAB5ACAAKABpACkAIABlAG0AYgBlAGQAIAB0AGgAaQBzACAAZgBvAG4AdAAgAGkAbgAgAGMAbwBuAHQAZQBuAHQAIABhAHMAIABwAGUAcgBtAGkAdAB0AGUAZAAgAGIAeQAgAHQAaABlACAAZQBtAGIAZQBkAGQAaQBuAGcAIAByAGUAcwB0AHIAaQBjAHQAaQBvAG4AcwAgAGkAbgBjAGwAdQBkAGUAZAAgAGkAbgAgAHQAaABpAHMAIABmAG8AbgB0ADsAIABhAG4AZAAgACgAaQBpACkAIAB0AGUAbQBwAG8AcgBhAHIAaQBsAHkAIABkAG8AdwBuAGwAbwBhAGQAIAB0AGgAaQBzACAAZgBvAG4AdAAgAHQAbwAgAGEAIABwAHIAaQBuAHQAZQByACAAbwByACAAbwB0AGgAZQByACAAbwB1AHQAcAB1AHQAIABkAGUAdgBpAGMAZQAgAHQAbwAgAGgAZQBsAHAAIABwAHIAaQBuAHQAIABjAG8AbgB0AGUAbgB0AC4ADQANAFQAaABlACAAZgBvAGwAbABvAHcAaQBuAGcAIABsAGkAYwBlAG4AcwBlACwAIABiAGEAcwBlAGQAIABvAG4AIAB0AGgAZQAgAE0ASQBUACAAbABpAGMAZQBuAHMAZQAgACgAaAB0AHQAcAA6AC8ALwBlAG4ALgB3AGkAawBpAHAAZQBkAGkAYQAuAG8AcgBnAC8AdwBpAGsAaQAvAE0ASQBUAF8ATABpAGMAZQBuAHMAZQApACwAIABhAHAAcABsAGkAZQBzACAAdABvACAAdABoAGUAIABPAHAAZQBuAFQAeQBwAGUAIABMAGEAeQBvAHUAdAAgAGwAbwBnAGkAYwAgAGYAbwByACAAQgBpAGIAbABpAGMAYQBsACAASABlAGIAcgBlAHcAICAcAEwAYQB5AG8AdQB0ACAATABvAGcAaQBjIB0AIABhAHMAIABqAG8AaQBuAHQAbAB5ACAAZABlAHYAZQBsAG8AcABlAGQAIABiAHkAIABSAGEAbABwAGgAIABIAGEAbgBjAG8AYwBrACAAYQBuAGQAIABKAG8AaABuACAASAB1AGQAcwBvAG4ALgAgAA0ADQBQAGUAcgBtAGkAcwBzAGkAbwBuACAAaQBzACAAaABlAHIAZQBiAHkAIABnAHIAYQBuAHQAZQBkACwAIABmAHIAZQBlACAAbwBmACAAYwBoAGEAcgBnAGUALAAgAHQAbwAgAGEAbgB5ACAAcABlAHIAcwBvAG4AIABvAGIAdABhAGkAbgBpAG4AZwAgAGEAIABjAG8AcAB5ACAAbwBmACAAdABoAGUAIABPAHAAZQBuAFQAeQBwAGUAIABMAGEAeQBvAHUAdAAgAGwAbwBnAGkAYwAgAGYAbwByACAAQgBpAGIAbABpAGMAYQBsACAASABlAGIAcgBlAHcAIABhAG4AZAAgAGEAcwBzAG8AYwBpAGEAdABlAGQAIABkAG8AYwB1AG0AZQBuAHQAYQB0AGkAbwBuACAAZgBpAGwAZQBzACAAKAB0AGgAZQAgIBwATABhAHkAbwB1AHQAIABMAG8AZwBpAGMAIABTAG8AZgB0AHcAYQByAGUgHQApACwAIAB0AG8AIABkAGUAYQBsACAAaQBuACAAdABoAGUAIABMAGEAeQBvAHUAdAAgAEwAbwBnAGkAYwAgAFMAbwBmAHQAdwBhAHIAZQAgAHcAaQB0AGgAbwB1AHQAIAByAGUAcwB0AHIAaQBjAHQAaQBvAG4ALAAgAGkAbgBjAGwAdQBkAGkAbgBnACAAdwBpAHQAaABvAHUAdAAgAGwAaQBtAGkAdABhAHQAaQBvAG4AIAB0AGgAZQAgAHIAaQBnAGgAdABzACAAdABvACAAdQBzAGUALAAgAGMAbwBwAHkALAAgAG0AbwBkAGkAZgB5ACwAIABtAGUAcgBnAGUALAAgAHAAdQBiAGwAaQBzAGgALAAgAGQAaQBzAHQAcgBpAGIAdQB0AGUALAAgAHMAdQBiAGwAaQBjAGUAbgBzAGUALAAgAGEAbgBkAC8AbwByACAAcwBlAGwAbAAgAGMAbwBwAGkAZQBzACAAbwBmACAAdABoAGUAIABMAGEAeQBvAHUAdAAgAEwAbwBnAGkAYwAgAFMAbwBmAHQAdwBhAHIAZQAsACAAYQBuAGQAIAB0AG8AIABwAGUAcgBtAGkAdAAgAHAAZQByAHMAbwBuAHMAIAB0AG8AIAB3AGgAbwBtACAAdABoAGUAIABMAGEAeQBvAHUAdAAgAEwAbwBnAGkAYwAgAFMAbwBmAHQAdwBhAHIAZQAgAGkAcwAgAGYAdQByAG4AaQBzAGgAZQBkACAAdABvACAAZABvACAAcwBvACwAIABzAHUAYgBqAGUAYwB0ACAAdABvACAAdABoAGUAIABmAG8AbABsAG8AdwBpAG4AZwAgAGMAbwBuAGQAaQB0AGkAbwBuAHMAOgANAA0AVABoAGUAIABhAGIAbwB2AGUAIABjAG8AcAB5AHIAaQBnAGgAdAAgAG4AbwB0AGkAYwBlACAAYQBuAGQAIAB0AGgAaQBzACAAcABlAHIAbQBpAHMAcwBpAG8AbgAgAG4AbwB0AGkAYwBlACAAcwBoAGEAbABsACAAYgBlACAAaQBuAGMAbAB1AGQAZQBkACAAaQBuACAAYQBsAGwAIABjAG8AcABpAGUAcwAgAG8AcgAgAHMAdQBiAHMAdABhAG4AdABpAGEAbAAgAHAAbwByAHQAaQBvAG4AcwAgAG8AZgAgAHQAaABlACAATABhAHkAbwB1AHQAIABMAG8AZwBpAGMAIABTAG8AZgB0AHcAYQByAGUALgANAA0AVABIAEUAIABTAE8ARgBUAFcAQQBSAEUAIABJAFMAIABQAFIATwBWAEkARABFAEQAIAAnAEEAUwAgAEkAUwAnACwAIABXAEkAVABIAE8AVQBUACAAVwBBAFIAUgBBAE4AVABZACAATwBGACAAQQBOAFkAIABLAEkATgBEACwAIABFAFgAUABSAEUAUwBTACAATwBSACAASQBNAFAATABJAEUARAAsACAASQBOAEMATABVAEQASQBOAEcAIABCAFUAVAAgAE4ATwBUACAATABJAE0ASQBUAEUARAAgAFQATwAgAFQASABFACAAVwBBAFIAUgBBAE4AVABJAEUAUwAgAE8ARgAgAE0ARQBSAEMASABBAE4AVABBAEIASQBMAEkAVABZACwAIABGAEkAVABOAEUAUwBTACAARgBPAFIAIABBACAAUABBAFIAVABJAEMAVQBMAEEAUgAgAFAAVQBSAFAATwBTAEUAIABBAE4ARAAgAE4ATwBOAEkATgBGAFIASQBOAEcARQBNAEUATgBUAC4AIABJAE4AIABOAE8AIABFAFYARQBOAFQAIABTAEgAQQBMAEwAIABUAEgARQAgAEEAVQBUAEgATwBSAFMAIABPAFIAIABDAE8AUABZAFIASQBHAEgAVAAgAEgATwBMAEQARQBSAFMAIABCAEUAIABMAEkAQQBCAEwARQAgAEYATwBSACAAQQBOAFkAIABDAEwAQQBJAE0ALAAgAEQAQQBNAEEARwBFAFMAIABPAFIAIABPAFQASABFAFIAIABMAEkAQQBCAEkATABJAFQAWQAsACAAVwBIAEUAVABIAEUAUgAgAEkATgAgAEEATgAgAEEAQwBUAEkATwBOACAATwBGACAAQwBPAE4AVABSAEEAQwBUACwAIABUAE8AUgBUACAATwBSACAATwBUAEgARQBSAFcASQBTAEUALAAgAEEAUgBJAFMASQBOAEcAIABGAFIATwBNACwAIABPAFUAVAAgAE8ARgAgAE8AUgAgAEkATgAgAEMATwBOAE4ARQBDAFQASQBPAE4AIABXAEkAVABIACAAVABIAEUAIABTAE8ARgBUAFcAQQBSAEUAIABPAFIAIABUAEgARQAgAFUAUwBFACAATwBSACAATwBUAEgARQBSACAARABFAEEATABJAE4ARwBTACAASQBOACAAVABIAEUAIABTAE8ARgBUAFcAQQBSAEUALgANqSAyMDE1IFRoZSBNb25vdHlwZSBDb3Jwb3JhdGlvbi4gQWxsIFJpZ2h0cyBSZXNlcnZlZC4gDQ1IZWJyZXcgT3BlblR5cGUgTGF5b3V0IGxvZ2ljIGNvcHlyaWdodCCpIDIwMDMgJiAyMDA3LCBSYWxwaCBIYW5jb2NrICYgSm9obiBIdWRzb24uIFRoaXMgbGF5b3V0IGxvZ2ljIGZvciBCaWJsaWNhbCBIZWJyZXcgaXMgb3BlbiBzb3VyY2Ugc29mdHdhcmUgdW5kZXIgdGhlIE1JVCBMaWNlbnNlOyBzZWUgZW1iZWRkZWQgbGljZW5zZSBkZXNjcmlwdGlvbiBmb3IgZGV0YWlscy5BcmlhbCBpcyBhIHRyYWRlbWFyayBvZiBUaGUgTW9ub3R5cGUgQ29ycG9yYXRpb24uTW9ub3R5cGU6QXJpYWwgUmVndWxhciAoTWljcm9zb2Z0KVZlcnNpb24gNi45MEFyaWFsTVRNb25vdHlwZSBUeXBlIERyYXdpbmcgT2ZmaWNlIC0gUm9iaW4gTmljaG9sYXMsIFBhdHJpY2lhIFNhdW5kZXJzIDE5ODJZb3UgbWF5IHVzZSB0aGlzIGZvbnQgYXMgcGVybWl0dGVkIGJ5IHRoZSBFVUxBIGZvciB0aGUgcHJvZHVjdCBpbiB3aGljaCB0aGlzIGZvbnQgaXMgaW5jbHVkZWQgdG8gZGlzcGxheSBhbmQgcHJpbnQgY29udGVudC4gIFlvdSBtYXkgb25seSAoaSkgZW1iZWQgdGhpcyBmb250IGluIGNvbnRlbnQgYXMgcGVybWl0dGVkIGJ5IHRoZSBlbWJlZGRpbmcgcmVzdHJpY3Rpb25zIGluY2x1ZGVkIGluIHRoaXMgZm9udDsgYW5kIChpaSkgdGVtcG9yYXJpbHkgZG93bmxvYWQgdGhpcyBmb250IHRvIGEgcHJpbnRlciBvciBvdGhlciBvdXRwdXQgZGV2aWNlIHRvIGhlbHAgcHJpbnQgY29udGVudC4NDVRoZSBmb2xsb3dpbmcgbGljZW5zZSwgYmFzZWQgb24gdGhlIE1JVCBsaWNlbnNlIChodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01JVF9MaWNlbnNlKSwgYXBwbGllcyB0byB0aGUgT3BlblR5cGUgTGF5b3V0IGxvZ2ljIGZvciBCaWJsaWNhbCBIZWJyZXcg0kxheW91dCBMb2dpY9MgYXMgam9pbnRseSBkZXZlbG9wZWQgYnkgUmFscGggSGFuY29jayBhbmQgSm9obiBIdWRzb24uIA0NUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weSBvZiB0aGUgT3BlblR5cGUgTGF5b3V0IGxvZ2ljIGZvciBCaWJsaWNhbCBIZWJyZXcgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlINJMYXlvdXQgTG9naWMgU29mdHdhcmXTKSwgdG8gZGVhbCBpbiB0aGUgTGF5b3V0IExvZ2ljIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgTGF5b3V0IExvZ2ljIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgTGF5b3V0IExvZ2ljIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6DQ1UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBMYXlvdXQgTG9naWMgU29mdHdhcmUuDQ1USEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuDQBOAG8AcgBtAGEAbABuAHkAbwBiAHkBDQBlAGoAbgDpAG4AbwByAG0AYQBsAFMAdABhAG4AZABhAHIAZAOaA7EDvQO/A70DuQO6A6wAQQByAGkAYQBsACAAaQBzACAAYQAgAHQAcgBhAGQAZQBtAGEAcgBrACAAbwBmACAAVABoAGUAIABNAG8AbgBvAHQAeQBwAGUAIABDAG8AcgBwAG8AcgBhAHQAaQBvAG4ALgBZAG8AdQAgAG0AYQB5ACAAdQBzAGUAIAB0AGgAaQBzACAAZgBvAG4AdAAgAGEAcwAgAHAAZQByAG0AaQB0AHQAZQBkACAAYgB5ACAAdABoAGUAIABFAFUATABBACAAZgBvAHIAIAB0AGgAZQAgAHAAcgBvAGQAdQBjAHQAIABpAG4AIAB3AGgAaQBjAGgAIAB0AGgAaQBzACAAZgBvAG4AdAAgAGkAcwAgAGkAbgBjAGwAdQBkAGUAZAAgAHQAbwAgAGQAaQBzAHAAbABhAHkAIABhAG4AZAAgAHAAcgBpAG4AdAAgAGMAbwBuAHQAZQBuAHQALgAgACAAWQBvAHUAIABtAGEAeQAgAG8AbgBsAHkAIAAoAGkAKQAgAGUAbQBiAGUAZAAgAHQAaABpAHMAIABmAG8AbgB0ACAAaQBuACAAYwBvAG4AdABlAG4AdAAgAGEAcwAgAHAAZQByAG0AaQB0AHQAZQBkACAAYgB5ACAAdABoAGUAIABlAG0AYgBlAGQAZABpAG4AZwAgAHIAZQBzAHQAcgBpAGMAdABpAG8AbgBzACAAaQBuAGMAbAB1AGQAZQBkACAAaQBuACAAdABoAGkAcwAgAGYAbwBuAHQAOwAgAGEAbgBkACAAKABpAGkAKQAgAHQAZQBtAHAAbwByAGEAcgBpAGwAeQAgAGQAbwB3AG4AbABvAGEAZAAgAHQAaABpAHMAIABmAG8AbgB0ACAAdABvACAAYQAgAHAAcgBpAG4AdABlAHIAIABvAHIAIABvAHQAaABlAHIAIABvAHUAdABwAHUAdAAgAGQAZQB2AGkAYwBlACAAdABvACAAaABlAGwAcAAgAHAAcgBpAG4AdAAgAGMAbwBuAHQAZQBuAHQALgANAAoADQAKAFQAaABlACAAZgBvAGwAbABvAHcAaQBuAGcAIABsAGkAYwBlAG4AcwBlACwAIABiAGEAcwBlAGQAIABvAG4AIAB0AGgAZQAgAE0ASQBUACAAbABpAGMAZQBuAHMAZQAgACgAaAB0AHQAcAA6AC8ALwBlAG4ALgB3AGkAawBpAHAAZQBkAGkAYQAuAG8AcgBnAC8AdwBpAGsAaQAvAE0ASQBUAF8ATABpAGMAZQBuAHMAZQApACwAIABhAHAAcABsAGkAZQBzACAAdABvACAAdABoAGUAIABPAHAAZQBuAFQAeQBwAGUAIABMAGEAeQBvAHUAdAAgAGwAbwBnAGkAYwAgAGYAbwByACAAQgBpAGIAbABpAGMAYQBsACAASABlAGIAcgBlAHcAICAcAEwAYQB5AG8AdQB0ACAATABvAGcAaQBjIB0AIABhAHMAIABqAG8AaQBuAHQAbAB5ACAAZABlAHYAZQBsAG8AcABlAGQAIABiAHkAIABSAGEAbABwAGgAIABIAGEAbgBjAG8AYwBrACAAYQBuAGQAIABKAG8AaABuACAASAB1AGQAcwBvAG4ALgAgAA0ACgANAAoAUABlAHIAbQBpAHMAcwBpAG8AbgAgAGkAcwAgAGgAZQByAGUAYgB5ACAAZwByAGEAbgB0AGUAZAAsACAAZgByAGUAZQAgAG8AZgAgAGMAaABhAHIAZwBlACwAIAB0AG8AIABhAG4AeQAgAHAAZQByAHMAbwBuACAAbwBiAHQAYQBpAG4AaQBuAGcAIABhACAAYwBvAHAAeQAgAG8AZgAgAHQAaABlACAATwBwAGUAbgBUAHkAcABlACAATABhAHkAbwB1AHQAIABsAG8AZwBpAGMAIABmAG8AcgAgAEIAaQBiAGwAaQBjAGEAbAAgAEgAZQBiAHIAZQB3ACAAYQBuAGQAIABhAHMAcwBvAGMAaQBhAHQAZQBkACAAZABvAGMAdQBtAGUAbgB0AGEAdABpAG8AbgAgAGYAaQBsAGUAcwAgACgAdABoAGUAICAcAEwAYQB5AG8AdQB0ACAATABvAGcAaQBjACAAUwBvAGYAdAB3AGEAcgBlIB0AKQAsACAAdABvACAAZABlAGEAbAAgAGkAbgAgAHQAaABlACAATABhAHkAbwB1AHQAIABMAG8AZwBpAGMAIABTAG8AZgB0AHcAYQByAGUAIAB3AGkAdABoAG8AdQB0ACAAcgBlAHMAdAByAGkAYwB0AGkAbwBuACwAIABpAG4AYwBsAHUAZABpAG4AZwAgAHcAaQB0AGgAbwB1AHQAIABsAGkAbQBpAHQAYQB0AGkAbwBuACAAdABoAGUAIAByAGkAZwBoAHQAcwAgAHQAbwAgAHUAcwBlACwAIABjAG8AcAB5ACwAIABtAG8AZABpAGYAeQAsACAAbQBlAHIAZwBlACwAIABwAHUAYgBsAGkAcwBoACwAIABkAGkAcwB0AHIAaQBiAHUAdABlACwAIABzAHUAYgBsAGkAYwBlAG4AcwBlACwAIABhAG4AZAAvAG8AcgAgAHMAZQBsAGwAIABjAG8AcABpAGUAcwAgAG8AZgAgAHQAaABlACAATABhAHkAbwB1AHQAIABMAG8AZwBpAGMAIABTAG8AZgB0AHcAYQByAGUALAAgAGEAbgBkACAAdABvACAAcABlAHIAbQBpAHQAIABwAGUAcgBzAG8AbgBzACAAdABvACAAdwBoAG8AbQAgAHQAaABlACAATABhAHkAbwB1AHQAIABMAG8AZwBpAGMAIABTAG8AZgB0AHcAYQByAGUAIABpAHMAIABmAHUAcgBuAGkAcwBoAGUAZAAgAHQAbwAgAGQAbwAgAHMAbwAsACAAcwB1AGIAagBlAGMAdAAgAHQAbwAgAHQAaABlACAAZgBvAGwAbABvAHcAaQBuAGcAIABjAG8AbgBkAGkAdABpAG8AbgBzADoADQAKAA0ACgBUAGgAZQAgAGEAYgBvAHYAZQAgAGMAbwBwAHkAcgBpAGcAaAB0ACAAbgBvAHQAaQBjAGUAIABhAG4AZAAgAHQAaABpAHMAIABwAGUAcgBtAGkAcwBzAGkAbwBuACAAbgBvAHQAaQBjAGUAIABzAGgAYQBsAGwAIABiAGUAIABpAG4AYwBsAHUAZABlAGQAIABpAG4AIABhAGwAbAAgAGMAbwBwAGkAZQBzACAAbwByACAAcwB1AGIAcwB0AGEAbgB0AGkAYQBsACAAcABvAHIAdABpAG8AbgBzACAAbwBmACAAdABoAGUAIABMAGEAeQBvAHUAdAAgAEwAbwBnAGkAYwAgAFMAbwBmAHQAdwBhAHIAZQAuAA0ACgANAAoAVABIAEUAIABTAE8ARgBUAFcAQQBSAEUAIABJAFMAIABQAFIATwBWAEkARABFAEQAIAAnAEEAUwAgAEkAUwAnACwAIABXAEkAVABIAE8AVQBUACAAVwBBAFIAUgBBAE4AVABZACAATwBGACAAQQBOAFkAIABLAEkATgBEACwAIABFAFgAUABSAEUAUwBTACAATwBSACAASQBNAFAATABJAEUARAAsACAASQBOAEMATABVAEQASQBOAEcAIABCAFUAVAAgAE4ATwBUACAATABJAE0ASQBUAEUARAAgAFQATwAgAFQASABFACAAVwBBAFIAUgBBAE4AVABJAEUAUwAgAE8ARgAgAE0ARQBSAEMASABBAE4AVABBAEIASQBMAEkAVABZACwAIABGAEkAVABOAEUAUwBTACAARgBPAFIAIABBACAAUABBAFIAVABJAEMAVQBMAEEAUgAgAFAAVQBSAFAATwBTAEUAIABBAE4ARAAgAE4ATwBOAEkATgBGAFIASQBOAEcARQBNAEUATgBUAC4AIABJAE4AIABOAE8AIABFAFYARQBOAFQAIABTAEgAQQBMAEwAIABUAEgARQAgAEEAVQBUAEgATwBSAFMAIABPAFIAIABDAE8AUABZAFIASQBHAEgAVAAgAEgATwBMAEQARQBSAFMAIABCAEUAIABMAEkAQQBCAEwARQAgAEYATwBSACAAQQBOAFkAIABDAEwAQQBJAE0ALAAgAEQAQQBNAEEARwBFAFMAIABPAFIAIABPAFQASABFAFIAIABMAEkAQQBCAEkATABJAFQAWQAsACAAVwBIAEUAVABIAEUAUgAgAEkATgAgAEEATgAgAEEAQwBUAEkATwBOACAATwBGACAAQwBPAE4AVABSAEEAQwBUACwAIABUAE8AUgBUACAATwBSACAATwBUAEgARQBSAFcASQBTAEUALAAgAEEAUgBJAFMASQBOAEcAIABGAFIATwBNACwAIABPAFUAVAAgAE8ARgAgAE8AUgAgAEkATgAgAEMATwBOAE4ARQBDAFQASQBPAE4AIABXAEkAVABIACAAVABIAEUAIABTAE8ARgBUAFcAQQBSAEUAIABPAFIAIABUAEgARQAgAFUAUwBFACAATwBSACAATwBUAEgARQBSACAARABFAEEATABJAE4ARwBTACAASQBOACAAVABIAEUAIABTAE8ARgBUAFcAQQBSAEUALgANAAoATgBvAHIAbQBhAGEAbABpAE4AbwByAG0A4QBsAG4AZQBOAG8AcgBtAGEAbABlAFMAdABhAG4AZABh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pcCl2qXypgymKKY+plamcKaKpqamxKbcpvanEqcqp0SnYAAEAAEAAagcAAgAAQABrVwACAABAAytsq3Erdit7q4ArhSuKq48rlCuZq54rowACAABAAOvAK8UryoACAABAAuvmK+sr8Kv2q/usASwHLAwsEawXrByAAgAAQAEsPaxDLEksT4ACAABADuxzLHisfqyErIqskSyXrJ6spSyrrLKsuazBLMcszazULNqs4azorPAs9yz+LQWtDS0VLRstIS0nrS4tNK07LUItSS1QrVctXa1krWutcy16LYEtiC2PrZYtnS2kLautsy24rb6txK3KrdEt163ereUt663yrfmAAQAAQABuKAACAABAAG6iAAIAAEAAbqiAAgAAQABusQABgAAAAG65gAGAAEAAbs8AAYAAQABvDgACAABAAO8/r0SvSYABgABAAG9qAAIAAEAA754voy+ogAIAAEABr88v1C/ZL94v4y/oAAIAAEABMACwBbAKsA+AAgAAQABwK4ABgABAAHBLAAIAAEABMIUwijCPsJWAAQAAQABwrQAAQABAAHC1AABAAEAAcLcAAEAAQABwuIAAQAAAAHC8gABAAAAAcL+AAEAAAABwwwAAQAAAAHDGgABAAAAAcMoAAEAAAABwzYAAQAAAAHDQAABAAAAAcNKAAEAAAABw1QAAQAAAAHDXgABAAAAAcNoAAEAAAABw3QAAQAAAAHDggABAAAAAcOQAAEAAAABw54AAQAAAAHDrAABAAAAAcO2AAEAAAABw8QAAQAAAAHD0gABAAAAAcPgAAEAAAABw+4AAQAAAAHD+AABAAAAAcQGAAEAAAABxBQAAQAAAAHEIgABAAAAAcQwAAEAAAABxDwAAQAAAAHESgABAAAAAcRYAAEAAAABxGYAAQAAAAHEdAABAAAAAcR+AAEAAAABxIgAAQAAAAHEkgABAAAAAcScAAEAAAABxKYAAQAAAAHEsAABAAAAAcS6AAEAAAABxMQAAQAAAAHEzgABAAAAAcTYAAEAAAABxOIAAQAAAAHE7AABAAAAAcT6AAEAAAABxQgAAQAAAAHFFgAEAAEAAcUkAAQAAQABx3wABAABAAHIYgAEAAEAAclCAAQAAQAByiIABAABAAHKhgAEAAEAAcweAAQAAQABzQQABAABAAHNbgAEAAEAAc5OAAQAAQABzrIABAABAAHPiAAEAAEAAdBuAAQAAQAB0VQABAABAAHSOgAGAAEAAdN0AAYAAQAB09gABgABAAHUPAAEAAEAAdSgAAQAAQAB1fgAASvoAAQAAAEMAiICTAJWAlwCwgMMA2oDuAQGBWgF+gaAB8YH0AfeB+gH3gfyB/IINAfyB/IIQgiUCOoI+AoCB/IH8goYCPgKWgfyB/IKZApkChgKpgqmCuQK5Av+DEwMfgykDLYMpAfyCmQKpgzgDRYI+AfyDRYNFg0WCPgNbA2aDeAOAg6EDpoO6A8iD2wPpg/YEAIQDBC+EVwOhBGWEhwSZhJsEqIS2AykEwITEAykDKQMpBM+E0gThhPME9YUVBTSFQQTzBUyFfwWXhbkF34XqBe6GBQTzBPMGGYYrBjCE8wY8BPMGV4aRBrGG2QcKhxsHJ4TzBPMHLgc0hPMHVQeBh50E8we5h74HzYfeB+iH6wf0h/kIBIgPCBGIFQgdiCYIKog1CEWITQhWiFsIXohhCGmIcQhziHsIhIiKCJKIqQi5iM8CqYjfiQwJIYk3CU2IkoiSiJKIkoiSiJKJNwiSiJKIkoi5iLmJXQlNgqmCqYKpiN+I34jfiN+JIYkhiSGJIYk3CTcJNwiSiWGJcAlhiXeJfwlhiXeJgomKCZaJpgmsgg0JYYl3ibQCDQm0BM+Jx4nRCfeKCAoKigwKDAozij0KSYpfCnCKewnRCo+Ez4o9CnsKPQqUCqaJ94rNCkmK24roCo+Kj4oMCgwKlAqUCu2IhIiEiISIhIiEiISIhIiEiISIhIiEiIoIigiKCIoIigiKCIoIigiKCIoIigACgAk/48AN//bADz/2wHx/48B+f+PAfv/jwIB/48CCf/bAgr/2wIP/9sAAg2j/zgOCP84AAEAFP9oABkAA/+PADf/aAA5/2gAOv+0ADz/aABZ/9sAWv/bAFz/2wC2/2gNnP9oDZ7/aA2f/7QNof9oDcP/aA3z/2gN9P9oDfX/aA32/7AN/f+0Df7/tA3//7QOAP+0DgH/aA4C/2gOA/9oABIAD/8dABH/HQAk/48Nif9dDZL/dA2j/zgNqv9dDav/XQ2s/10Nrf9dDa7/XQ2v/10NxP9dDcX/XQ3G/10N3v90Dgf/XQ4I/zgAFwAD/7QAN/9oADn/aAA6/2gAPP9oAFz/tAC2/48NnP9oDZ7/aA2f/2gNof9oDcP/aA3z/2gN9P9oDfX/aA32/2gN/f9oDf7/aA3//2gOAP9oDgH/aA4C/2gOA/9oABMAA//bAA/++AAR/vgAJP9oDYn/aA2S/6YNo/8kDar/aA2r/2gNrP9oDa3/aA2u/2gNr/9oDcT/aA3F/2gNxv9oDd7/pg4H/2gOCP8kABMAN//bADn/2wA6/9sAPP/bDZz/2w2e/9sNn//bDaH/2w3D/9sN8//bDfT/2w31/9sN/f/bDf7/2w3//9sOAP/bDgH/2w4C/9sOA//bAFgAA//bAA//HQAQ/48AEf8dAB3/HQAe/x0AJP9oADL/2wBE/x0ARv8dAEj/HQBM/7QAUv8dAFX/tABW/x0AWP+0AFr/jwBc/48Ndf/iDXb/4g18/9sNff8dDYH/HQ2D/7QNif9oDYv/2w2P/9sNkv+6DZf/2w2Z/9sNo/+6DaT/2w2q/2gNq/9oDaz/aA2t/2gNrv9oDa//aA2w/9sNuv/bDbv/2w28/9sNvf/bDb7/2w3E/2gNxf9oDcb/aA3H/9sNyP/bDcn/2w3K/9sN0v/bDdP/2w3U/9sN1f/bDd7/ug3o/9sN6f/bDer/2w4H/2gOCP+6Dmf/4g5o/+IOaf/iDmr/4g5r/+IObP/iDm3/4g5u/+IOb//iDnD/4g5x/+IOcv/iDnP/4g50/+IOdf/iDnb/4g53/+IOeP/iDnn/4g56/+IOe//iDnz/4g6t/x0Ouf+0Drr/tA67/7QOvP+0ACQAD/9EABD/jwAR/0QAHf+0AB7/tAAk/2gARP9oAEj/jwBM/9sAUv+PAFX/tABY/7QAXP+0DX3/aA2B/2gNg/+0DYn/aA2S/9gNo/+SDar/aA2r/2gNrP9oDa3/aA2u/2gNr/9oDcT/aA3F/2gNxv9oDd7/2A4H/2gOCP+SDq3/aA65/7QOuv+0Drv/tA68/7QAIQAP/48AEP/bABH/jwAd/9sAHv/bACT/tABE/7QASP/bAFL/2wBV/9sAWP/bAFz/7g19/7QNgf+0DYP/7g2J/7QNo//ODar/tA2r/7QNrP+0Da3/tA2u/7QNr/+0DcT/tA3F/7QNxv+0Dgf/tA4I/84Orf+0Drn/7g66/+4Ou//uDrz/7gBRAAP/2wAP/vgAEP9EABH++AAd/48AHv97ACT/aABE/2gASP9EAEz/tABS/0QAU/9oAFT/RABY/48AWf+PDXX/ug12/8QNff9EDYH/RA2J/2gNi/+cDY//nA2S/6YNl/+cDZn/nA2j/2oNpP+cDab/nA2q/2gNq/9oDaz/aA2t/2gNrv9oDa//aA2w/5wNuv+cDbv/nA28/5wNvf+cDb7/nA3E/2gNxf9oDcb/aA3H/5wNyP+cDcn/nA3K/5wN0v+cDdP/nA3U/5wN1f+cDd7/pg3o/5wN6f+cDer/nA4H/2gOCP9qDgn/nA5n/7oOaP+6Dmn/ug5q/7oOa/+6Dmz/ug5t/7oObv+6Dm//ug5w/7oOcf+6DnL/xA5z/8QOdP/EDnX/xA52/8QOd//EDnj/xA55/8QOev/EDnv/xA58/8QOrf9EAAIASf/bALYAJQADAA//jwAR/48AtgBMAAIAD/9oABH/aAACAA//jwAR/48AEA2c/2gNnv9oDZ//tA2h/2gNw/9oDfP/aA30/2gN9f9oDfb/sA39/7QN/v+0Df//tA4A/7QOAf9oDgL/aA4D/2gAAw4d/9EOJ//RDir/0QAUDYn/ag2S/zgNo/8GDar/ag2r/2oNrP9qDa3/ag2u/2oNr/9qDcT/ag3F/2oNxv9qDd7/OA4H/2oOCP8GDgr/ag4N/2oOFP9qDiL/ag45/40AFQC1/9sNif9qDZL/OA2j/wYNqv9qDav/ag2s/2oNrf9qDa7/ag2v/2oNxP9qDcX/ag3G/2oN3v84Dgf/ag4I/wYOCv9qDg3/ag4U/2oOIv9qDjn/jQADAAP/tABW/9sAtv/bAEINdf+6DXb/xA19/0QNgf9EDYn/aA2L/5wNj/+cDZL/pg2X/5wNmf+cDaP/ag2k/5wNpv+cDar/aA2r/2gNrP9oDa3/aA2u/2gNr/9oDbD/nA26/5wNu/+cDbz/nA29/5wNvv+cDcT/aA3F/2gNxv9oDcf/nA3I/5wNyf+cDcr/nA3S/5wN0/+cDdT/nA3V/5wN3v+mDej/nA3p/5wN6v+cDgf/aA4I/2oOCf+cDmf/ug5o/7oOaf+6Dmr/ug5r/7oObP+6Dm3/ug5u/7oOb/+6DnD/ug5x/7oOcv/EDnP/xA50/8QOdf/EDnb/xA53/8QOeP/EDnn/xA56/8QOe//EDnz/xA6t/0QABQIt/2ACNv9gAkz/YAJR/7wCVP+8ABANnP9oDZ7/aA2f/2gNof9gDcP/YA3z/2gN9P9oDfX/aA32/7AN/f9oDf7/aA3//2gOAP9oDgH/YA4C/2AOA/9gAAINo//EDgj/xAAQDZz/aA2e/2gNn/9oDaH/aA3D/2gN8/9oDfT/aA31/2gN9v9oDf3/aA3+/2gN//9oDgD/aA4B/2gOAv9oDgP/aAAPDZz/2w2e/9sNn//bDaH/2w3D/9sN8//bDfT/2w31/9sN/f/bDf7/2w3//9sOAP/bDgH/2w4C/9sOA//bAEYNdf/iDXb/4g18/9sNff8dDYH/HQ2D/7QNif9oDYv/2w2P/9sNkv+6DZf/2w2Z/9sNo/+6DaT/2w2q/2gNq/9oDaz/aA2t/2gNrv9oDa//aA2w/9sNuv/bDbv/2w28/9sNvf/bDb7/2w3E/2gNxf9oDcb/aA3H/9sNyP/bDcn/2w3K/9sN0v/bDdP/2w3U/9sN1f/bDd7/ug3o/9sN6f/bDer/2w4H/2gOCP+6Dmf/4g5o/+IOaf/iDmr/4g5r/+IObP/iDm3/4g5u/+IOb//iDnD/4g5x/+IOcv/iDnP/4g50/+IOdf/iDnb/4g53/+IOeP/iDnn/4g56/+IOe//iDnz/4g6t/x0Ouf+0Drr/tA67/7QOvP+0ABMAD/8fABH/HwH4AKQB+f9EAfv/RAIB/0QCGv+oAicAWA4K/0QODf9EDhH/zg4U/0QOGP/ODiH/zg4i/0QOJQBaDib/zg4o/84OKQBaAAwB+f/bAfv/2wIB/9sCCv++Ag//vg4K/9UODf/VDhT/1Q4d/74OIv/VDif/vg4q/74ACQH5/8UCCv++Ag//vg4K/8UODf/FDhT/xQ4i/8UOJ/++Dir/vgAEATL/4wIc/9kCJP/JAoz/4wAKAS7/4wEv/+MBMf/jATP/4wIQ/+MCF//jAiD/4wIi/+MCJv/jAiv/4wANDYn/pg2j/7oNqv+mDav/pg2s/6YNrf+mDa7/pg2v/6YNxP+mDcX/pg3G/6YOB/+mDgj/ugAVDX3/tA2B/7QNg//uDYn/tA2j/84Nqv+0Dav/tA2s/7QNrf+0Da7/tA2v/7QNxP+0DcX/tA3G/7QOB/+0Dgj/zg6t/7QOuf/uDrr/7g67/+4OvP/uAAsNif9qDar/ag2r/2oNrP9qDa3/ag2u/2oNr/9qDcT/ag3F/2oNxv9qDgf/agARASz/1QEt/8UCBf/VAgn/aAIK/2gCD/9oAhb/2wIe/9sCJP/bDhH/1Q4Y/9UOHP9oDh3/aA4e/8UOJv/VDif/aA4q/2gACAIK/74OCv/VDg3/1Q4U/9UOHf++DiL/1Q4n/74OKv++ACABLP+NAS3/jQEu/0YBMf9GATP/RgH4AKoB+f9oAfv/aAIB/2gCBf+NAg3/ngIS/2gCE/+0Ahj/aAIa/7QCG/9oAh3/aAIg/0YCJwBiAin/Rg4K/2gODf9oDhH/jQ4U/2gOGP+NDh7/jQ4h/54OIv9oDiUAUA4m/40OKP+eDikAUAAFAgr/0QIP/9EOHf/RDif/0Q4q/9EAEwAD/48Atv9oASz/1QEt/8UCBf/VAgn/aAIK/2gCD/9oAhb/2wIe/9sCJP/bDhH/1Q4Y/9UOHP9oDh3/aA4e/8UOJv/VDif/aA4q/2gADgAD/48BLP/VAgX/1QIJ/4kCCv9oAg//aA4R/9UOGP/VDhz/aA4d/2gOHv/FDib/1Q4n/2gOKv9oABIBLP/BAS3/jwEu/+cBL//nATH/5wEz/+cCBf/BAhD/5wIX/+cCGf/nAh//5wIg/+cCJv/nAin/5wIr/+cOEf/BDhj/wQ4m/8EADgAD/48BLP/VAgX/1QIJ/2gCCv9oAg//aA4R/9UOGP/VDhz/aA4d/2gOHv/FDib/1Q4n/2gOKv9oAAwB+f/bAfv/1QIB/9sCCv++Ag//vg4K/9UODf/VDhT/1Q4d/74OIv/VDif/vg4q/74ACgAD/9sAD/76ABH++gH5/2gB+/9oAgH/aA4K/2gODf9oDhT/aA4i/2gAAgEy/54CjP+eACwAA//bAA//HwAR/x8AHf8fAB7/HwEs/9sBLf/bAS7/HwEw/x8BMf8fATP/HwH4ALwB+f9oAfv/aAIB/2gCBf/bAg3/2wIQ/x8CEf8fAhT/TgIW/04CGP9qAhr/tAId/2oCHv+PAiD/HwIj/1ACJP+PAiX/agInALwCKP9OAin/HwIq/04OCv9oDg3/aA4R/9sOFP9oDhj/2w4h/9sOIv9oDiUAWg4m/9sOKP/bDikAWgAnAAP/2wAP/voAEP9GABH++gAd/48AHv+PASz/jQEt/40BLv9GATH/RgEz/0YB+AC8Afn/aAH7/2gCAf9oAgX/jQIN/54CEv9oAhP/tAIW/54CGP9oAhr/tAIb/2gCHf9oAiD/RgInAHkCKf9GDgr/aA4N/2gOEf+NDhT/aA4Y/40OHv+NDiH/ng4i/2gOJQBQDib/jQ4o/54OKQBQAA4BLv+yAS//sgEx/7IBM/+yAhD/sgIZ/9kCIP+yAib/sgIp/7ICK/+yDgr/iA4N/4gOFP+IDiL/iAAhAAP/2wEs/40BLf+NAS7/RgEx/0YBM/9GAfgAqgH5/2gB+/9oAgH/aAIF/40CDf+eAhL/aAIT/7QCGP9oAhr/tAIb/2gCHf9oAiD/RgInAGICKf9GDgr/aA4N/2gOEf+NDhT/aA4Y/40OHv+NDiH/ng4i/2gOJQBQDib/jQ4o/54OKQBQABIBLv93AS//tAEx/3cBMv+qATP/dwIQ/3cCEv/bAhb/qgIY/9sCGf+eAhr/2wIb/9sCHv+qAiD/dwIm/3cCKf93Aiv/dwKM/6oAAQIc/9kADQEu/+cBL//nATH/5wEz/+cCEP/nAhf/5wIZ/+cCH//nAiD/5wIi/+cCJv/nAin/5wIr/+cADQEu/+EBL//hATH/4QEz/9sCEP/hAh//4QIg/+ECIv/RAiP/zwIm/+ECKf/hAir/zwIr/+EACgEu/8kBL//JATH/yQEz/8kCEP/JAhf/yQIf/8kCIP/JAiL/yQIp/8kAAwEy/+MCHP/ZAoz/4wALAS7/yQEv/8kBMf/JATP/yQIQ/8kCF//JAiD/yQIi/8kCJv/JAin/yQIr/8kAAg5A/9MOVv/TAA8AD/8GABH/BgCp/3cAqv93ALL/0w4u/40OM/93Djn/dw49/3cOQP/TDkT/dw5H/40OSv+NDlb/0w5Y/7wAEQ4s/+QOLv/TDjP/0w41/+QON//uDjn/0w49/9MOQP/pDkT/0w5H/9MOSv/TDkv/5A5M/+4OTv+/DlD/7g5T/+wOVv/pAAIOTf/pDlD/6QAfALb/YA4s/zMOLv/TDjD/0w4z/9MONP/TDjX/Mw44/9MOOv/TDjv/0w48/9MOPf/TDj7/0w5B/9MOQ//TDkT/0w5F/9MORv/TDkf/0w5I/9MOSf/TDkr/0w5L/zMOT//TDlH/0w5S/9MOVP/TDlX/0w5X/9MOWP+kDln/0wAfALb/dw4s/zMOLv/TDjD/0w4z/9MONP/TDjX/Mw44/9MOOv/TDjv/0w48/9MOPf/TDj7/0w5B/9MOQ//TDkT/0w5F/9MORv/TDkf/0w5I/9MOSf/TDkr/0w5L/zMOT//TDlH/0w5S/9MOVP/TDlX/0w5X/9MOWP+kDln/0wAMDiwAFw4u/+kONQAXDjcALQ5A/+kOR//pDkr/6Q5LABcOTAAtDk3/ug5TAC0OVv/pAAsOLv+8DjP/vA45/3cOPf+8DkD/0w5E/7wOR/+8Dkr/vA5N/7wOVv/TDlj/0wAyALb/jQI+AEQCQf/pAkUALQJI/9MCSf/pAkv/0wJM/2ACTf+mAk7/vAJR/2ACV//TAloAFwJs/9MCbf/pAm4AFwJ3AC0OLP9gDi7/0w4w/+kOMwBEDjT/6Q41/2AON/+mDjj/6Q46/+kOO//pDjz/6Q49AEQOPv/pDkD/6Q5B/+kOQ//pDkQARA5F/+kORv/pDkf/0w5I/+kOSf/pDkr/0w5L/2AOTP+mDk//6Q5R/+kOUv/pDlT/6Q5V/+kOVv/pDlf/6Q5Z/+kAGAI6/9MCQf/pAkj/6QJL/+kCTP+kAk3/0QJO/+kCT//TAlH/pAJU/7wCV//pAln/6QJl/+kCbf/TDiz/pA4u/+kONf+kDjf/0Q5A/+kOR//pDkr/6Q5L/6QOTP/RDlb/6QAhAjr/vAI+/9MCQP/TAkH/vAJF/+kCSP+8Akv/vAJM/3cCTf+8Ak7/vAJP/6YCUf+kAlT/jQJZ/7wCXv/pAmb/6QJs/7wCbf/pAm//6QJx/7wCef/pDiz/lQ4u/+kONf+VDjf/vA5H/+kOSv/pDkv/lQ5M/7wOTf/pDk7/pg5Q/9MOWP/pACYAD/8GABH/BgCp/3cAqv93ALL/0wI6/3cCPv93AkH/0wJF/40CRv/RAkj/jQJL/6QCWf+8Alr/jQJc/40CXv93Al//dwJi/40CZf+NAmb/jQJn/40CaP93Amr/jQJt/3cCdf+NAnb/jQJ4/40Cef93Di7/jQ4z/3cOOf93Dj3/dw5A/9MORP93Dkf/jQ5K/40OVv/TDlj/vAAKAk0AFwJO/9MCUf+6AmEARAJoABcCbQAtDjcAFw5MABcOTf/TDlD/ugAEAkH/0wJr/+kOQP/TDlb/0wAWAkH/6QJI/9MCS//pAkwAFwJNAC0CVAAtAloAFwJf/+cCaP/pAm3/6Q4sABcOLv/pDjUAFw43AC0OQP/pDkf/6Q5K/+kOSwAXDkwALQ5N/7oOUwAtDlb/6QAUAkX/6QJI/+kCS//pAkz/0wJN/+kCTv/pAlH/0wJZ/+kOLP+VDi7/6Q41/5UON/+8Dkf/6Q5K/+kOS/+VDkz/vA5N/+kOTv+mDlD/0w5Y/+kAEQJB/+kCSP/pAkv/6QJNABcCTv+6DiwAFw4u/+kONQAXDjcALQ5A/+kOR//pDkr/6Q5LABcOTAAtDk3/ug5TAC0OVv/pAAUCTv/pAlsAFwJtABcOTf/pDlD/6QALAk7/6QJR/+kCWgAXAl8AFwJoABcCawAXAm0AFwJx/+kCdwAXDk3/6Q5Q/+kAGwI6/9MCPv/TAkD/0wJF/+kCTf/TAk//pAJR/9MCWf/TAl7/0wJl/+kCb//pDiz/3Q4u/+kOM/+kDjX/3Q45/9MOPf+kDj//5w5A/+kORP+kDkf/6Q5K/+kOS//dDk7/pA5Q/9MOVv/pDlj/0wA5AA/+fQAR/n0AHf/TAB7/0wCq/40COv93Aj7/dwJA/+kCQf/TAkX/jQJG/+kCSP/TAkv/6QJM/6QCTf/TAk7/6QJP/6QCWf/TAlr/vAJe/2ACX/+mAmj/pgJ3/9MCef+8Diz/1g4u/+kOMP/pDjP/dw40/+kONf/WDjf/0w44/+kOOv/pDjv/6Q48/+kOPf93Dj7/6Q5A/9MOQf/pDkP/6Q5E/3cORf/pDkb/6Q5H/+kOSP/pDkn/6Q5K/+kOS//WDkz/0w5P/+kOUf/pDlL/6Q5U/+kOVf/pDlb/0w5X/+kOWf/pACACOv/TAj7/0wJB/+kCRf+8Akb/6QJI/9MCTP+8Ak3/vAJP/40CUf+8AlT/ugJX/+kCWgAXAmAALQJx/+kOLP/kDi7/0w4z/9MONf/kDjf/7g45/9MOPf/TDkD/6Q5E/9MOR//TDkr/0w5L/+QOTP/uDk7/vw5Q/+4OU//sDlb/6QAnAA//HQAR/x0Aqf+mAKr/pgCy/9MCOv+8Aj7/vAJAABcCQf/pAkX/0wJI/6QCTv+8Aln/0wJa/6QCXP+mAl//jQJi/6YCZP+mAmX/pAJm/6YCaP9gAmn/pgJq/40Ca/+NAm3/jQJv/6YCc/+mAnX/pgJ2/6YCeP+mAnn/jQ4u/6QOM/+8Dj3/vA5A/+kORP+8Dkf/pA5K/6QOVv/pADEAD/7wABH+8AAd/9MAHv/TAKn/pgCq/6QAsv/pAjr/dwI+/6QCQf/TAkX/vAJI/7wCTv+8Alf/0wJZ/9MCW//TAlz/jQJd/6QCXv9gAl//dwJg/7wCYf+NAmL/pAJj/7wCZP+kAmX/dwJm/6QCZ/+kAmj/dwJp/6QCav+kAmv/dwJv/6QCcP+kAnL/pAJz/6QCeP+kAnn/dw4u/7wOM/+8Djn/dw49/7wOQP/TDkT/vA5H/7wOSv+8Dk3/vA5W/9MOWP/TABACOv/TAj7/vAJF/7wCTP+NAk3/pAJR/9MCWf+6AmX/vA4s/+cOM/+8DjX/5w43/6QOPf+8DkT/vA5L/+cOTP+kAAwCQf/TAkj/vAJL/7wCTv+8Alf/ugJo/+kCbf/TDi7/vA5A/9MOR/+8Dkr/vA5W/9MABgJI/9MCWgAtDjcAFw5MABcOTf/TDlD/ugAGAloAFwJtAC0ONwAXDkwAFw5N/9MOUP+6ACAAtv93Aln/vA4s/zMOLv/TDjD/0w4z/9MONP/TDjX/Mw44/9MOOv/TDjv/0w48/9MOPf/TDj7/0w5B/9MOQ//TDkT/0w5F/9MORv/TDkf/0w5I/9MOSf/TDkr/0w5L/zMOT//TDlH/0w5S/9MOVP/TDlX/0w5X/9MOWP+kDln/0wAsALb/YAI6/9MCPv/TAkD/vAJB/+kCRf+6Akb/0wJI/9MCS//TAkz/MwJP/6QCUf9gAlf/6QJZ/6QOLP8zDi7/0w4w/9MOM//TDjT/0w41/zMOOP/TDjr/0w47/9MOPP/TDj3/0w4+/9MOQf/TDkP/0w5E/9MORf/TDkb/0w5H/9MOSP/TDkn/0w5K/9MOS/8zDk//0w5R/9MOUv/TDlT/0w5V/9MOV//TDlj/pA5Z/9MAGwI+/7wCQP/nAkH/6QJF/7wCT/+6Aln/0wJe/7wCYAAXAmX/vAJm/+kCef/pDiz/3Q4u/+kOM/+kDjX/3Q45/9MOPf+kDj//5w5A/+kORP+kDkf/6Q5K/+kOS//dDk7/pA5Q/9MOVv/pDlj/0wAcAjr/vAI+/6YCQP/TAkX/pAJI/+kCS//pAkz/jQJP/6QCUf+8Al7/pAJl/6QCZv/pDiz/3Q4u/+kOM/+kDjX/3Q45/9MOPf+kDj//5w5A/+kORP+kDkf/6Q5K/+kOS//dDk7/pA5Q/9MOVv/pDlj/0wAEAmH/6QJs/9MCbf/pAnH/0wAPAlr/0QJe/6QCX//pAmD/6QJh/9MCZf+kAmb/0wJr/+kCbf/TAm7/6QJv/7wCcf+8AnT/vAJ3/+kCef/TABACWv/pAlv/6QJe/+kCX//pAmD/6QJh/+kCZf/RAmb/6QJo/+kCa//p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AKv++gCx/0YAsv9GDgr/aA4N/2gOEf+NDhT/aA4Y/40OIf+eDiL/aA4m/40OKP+eAAYOCv/FDg3/xQ4U/8UOIv/FDif/vg4q/74ABwAP/5wAEf+cAKv/nA4K/84ODf/ODhT/zg4i/84AEwAD/9sAD/76ABD/RgAR/voAHf+PAB7/jwCr/voAsf9GALL/Rg4K/2gODf9oDhH/jQ4U/2gOGP+NDh7/jQ4h/54OIv9oDib/jQ4o/54ACQAF/8QACv/EALT/xAC2/8QOLP9MDjX/TA43/84OS/9MDkz/zgAmAA//BgAQ/9MAEf8GAKv/BgCx/9MAsv/TDi7/tQ4w/9EOMv+SDjP/xw40/9EOOP/RDjn/dw46/9EOO//RDjz/0Q49/8cOPv/RDkD/0w5B/9EOQ//RDkT/xw5F/9EORv/RDkf/tQ5I/9EOSf/RDkr/tQ5N/8QOT//RDlH/0Q5S/9EOVP/RDlX/0Q5W/9MOV//RDlj/vA5Z/9EAEA4s/9oOLv/TDjP/0w41/9oON/+8Djn/8Q49/9MOQP/pDkT/0w5H/9MOSv/TDkv/2g5M/7wOTv+1DlP/ug5W/+kAAg43/+IOTP/iAAEOMQCWACcABf93AAr/dwC0/3cAtv93Diz/TA4u/9MOMP/TDjP/0w40/9MONf9MDjf/ug44/9MOOf/TDjr/0w47/9MOPP/TDj3/0w4+/9MOP/+8DkH/0w5D/9MORP/TDkX/0w5G/9MOR//TDkj/0w5J/9MOSv/TDkv/TA5M/7oOT//TDlH/0w5S/9MOU/9qDlT/0w5V/9MOV//TDlj/vA5Z/9MACQAF/8QACv/EALT/xAC2/8QOLP9CDjX/Qg43/9gOS/9CDkz/2AAMDiwAFw4u/9MONQAXDjcAFw5A/+kOR//TDkr/0w5LABcOTAAXDk3/ug5TAC0OVv/pABUAD/7wABD/6QAR/vAAHf/TAB7/0wCr/vAAsf/pALL/6Q4u/7wOL//iDjL/xA4z/9YOOf93Dj3/1g5A/9MORP/WDkf/vA5K/7wOTf+8Dlb/0w5Y/9MAEQAF/40ACv+NALT/jQC2/40OLP9gDi7/0w4zAEQONf9gDjf/pg49AEQOQP/pDkQARA5H/9MOSv/TDkv/YA5M/6YOVv/pAAoOLP+kDi7/6Q41/6QON//RDkD/6Q5H/+kOSv/pDkv/pA5M/9EOVv/p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1NzQONTW0D7U1tBo1OLQaNTi0ETU1tBE1NbQbtTi0G7U4tCM1QbQjNUG0JLVBtCS1QbQvNVC0LzVQtDC1ULQwtVC0PLVWtDy1VrQ+NVg0PjVZtDy1VrQ8tVa0P7VYND+1WbRKNVa0SjVWtEu1XjRLtV40SjVWtEo1VrRNNV40TTVeNFA1YrRQNWK0UDVitFA1YrRQNWK0UDVitFA1YrRQNWK0UbVkNFM1ZbRgtVg0YjVYNFS1ZDRWNWW0Y7VYNGU1WDRuNWo0bjVqNG+1IjRxNWu0fTV0tH01dLRytSI0dDVrtIM1djSDNXY0mbVYNJm1WDSotYs0qLWLNKo1a7SqNWu0rrWONK61jjSxtZK0sbWStLS1lbS0tZW0ALUiNAC1IjTAtZ60wjWdNMO1oDTFNaG01bWpNNW1qTTqtaq07DWsNOq1rbTsNa8z/DUlM/w1JTPwNRYz/DUiNHW1IjR3NWu0frV0s+Q1CjPltQuz5zUKM+i1C7PhNRAz4rURs+E1CjPitQu01zWpNNc1qTTYtak02LWpNO21qrTvNawz9LUWM/S1FjQCNSI0AjUiM/Y1FjP2NRY0A7UiNAO1IjPwNRez8DUXs/w1JrP8NSaz8bUZM/G1GTP9tSgz/bUoM/Y1FjP2NRY0BTUiNAU1IjP2NRYz9jUWNAU1IjQFNSIz8DUcM/A1HDP8NSsz/DUrNBK1NbQStTW0HTU4tB01OLQUNTW0FDU1tB61OLQetTi0DjU1tA+1NbQaLie0GjU6NA41NbQPtTW0GjU7tBo1O7QVtTW0FbU1tB61OLQetTi0DjU1tA+1NbQaLcY0Gi3GNCY1QzQmNUM0IzVEtCM1RLQjNUY0IzVGNCY1R7QmNUe0J7VBtCe1QbQjNUk0IzVJNCk1QbQpNUG0KrVKtCq1SrQsNUw0LDVMNDI1ULQyNVC0M7VQtDO1ULQvNVI0LzVSNC81U7QvNVO0LzVVNC81VTQvNVO0LzVTtDU1ULQ1NVC0ODVQtDg1ULQ8tVa0PLVWtEE1WzRBNVs0PLVWtDy1VrQ+NVy0PjVctDy1VrQ8tVa0QrVctEK1XLRKNVa0SjVWtEu1X7RLtV+0SjVWtEo1VrROtV40TrVeNFA1YrRQNWK0V7VkNFk1ZbRmtVg0aDVYNG41ajRuNWo0bjVqNHW1bTR3NW00bjVqNG41ajR4tW00eLVtNG41ajRuNWo0ejUiNHo1a7RuNWo0bjVqNHW1brR3NXA0bjVqNG41ajR7tSI0e7VrtIA1dLSANXS0gbV0tIG1dLSltYg0pbWINKc1ibSnNYm0hLV3tIY1d7SZtVg0mbVYNIe1djSHtXY0nLVYNJy1WDSJNXY0iTV2NJ41WDSeNVg0gzV5NIM1eTSZtX80mbV/NI21d7SPNXe0n7VYNJ+1WDSQtXe0kjV3tKE1WDShNVg0jbV6tI81erSftYC0n7VzNI21fDSPNXw0n7WCNJ+1g7SQtXe0kjV3s+Q1WDPkNVg0qLWLNKi1izSrtWu0q7VrtKi1izSotYs0rTVrtK01a7SotYs0qLWLNK01a7StNWu0qLWMtKi1jLSqNW60qjVutLS1lzS0tZc0ALUjtAC1I7S2NZW0tjWVtLe1lbS3tZW0tLWYtLS1mLQAtSg0ALUoNLk1lbS5NZW0ETU1tBE1NbQbtT60G7U+tMm1ozTLNZ00zLWktM41pLTPtaS01bWpNNW1qTTVtak01bWpNNo1qTTaNak027WpNNu1qTTdNak03TWpNN61qTTetak04DWpNOA1qTThtak04bWpNOq1qrTwtbC08jWqtPO1rDQGtSU0BrUlNOM1qTTjNak09TWyNOw1s7T1NbU07DWztPs1ubT8tbs0/jW5tP+1uzQ8tVa0PLVWtEK1WzRCtVs0SjVWtEo1VrRNNWE0TTVhNFq1ZDQRNWW0Y7VnNGU1aLSutY+00TWmNNK1p7SKtXe0jDV3tC21QbQttUG0M7VQtDO1ULTGtaA0yDWhtMa1oDTINaGz8DUds/A1HbP8NSyz/DUss/M1FLPzNRSz/zUjs/81I7PwNRqz8DUas/w1LjP8NS4z8bUas/G1GrP9tS4z/bUuM/e1HzP3tR80ALUvtAC1L7PwNSCz8DUgs/w1MTP8NTEz+TUWM/k1FjQGtSI0BrUiNBc1NbQXNTW0IDU4tCA1OLQONTW0D7U1tBo1PrQaNT60JjVNtCY1TbQjNU80IzVPNC81ULQvNVC0PLVWtDy1VrRCtVg0QrVZtFw1ZDRdtWW0abVYNGs1WDRfNWQ0WTVltGa1WDRoNVg0V7VkNFk1ZbRstVg0aDVYNG41ajRuNWo0dbVxtHc1czRuNWo0bjVqNHW1cDR3NW60k7V3tJU1d7SctVg0nLVYNIq1d7SMNXe0orVYNKK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o2qo5q8oo6yo7K8QjsSo8q8uo7Ko+K80o2qo4K74o7io/q86o76o1K9Ao7io4K86o7ipBK9GjripCq9Mo8SpEK7ao8SpFq7ajnaohq9So8qpHK6So9CpIq6eo9apKK68o9CpLq6eo2SpfK7yo2SpfK7yo2SpfK7yo3ypgq7yo2Spgq7ypB6pfK7yo2qkNq92o3ypiK7+o3ypiK7+o3ypiK7+o3ypiK7+pCSpjq80pCqplK8EozSpmq98ozSpoK6kjtappq74pDCprK7ypDCprK7ypDCprK7ypDCprK7ypDCprK7yo46psq+Co46psq74pDCpsq74o3Cpsq74o3yppq7+o9ypNK9YoyipOq68pDapuK+IpDyppq+Oo0aq2LAwo+KpQK7ao+ipRq7ao9apTK68pEipxK+mpE6pyq+spEKppq+UjmSp0K7CmYapUq7ao+6pHK6So+KpQK7ao/SpHK9eo+6pHK6So/qpWK9kpACpWK9qpAapXq9qpAypZK9wpBKpTK68pBKpTK68pBKpTK68pBipaq6epBipcK6epBipaq6epFSnwK6ko3ymjq+yo4ijdq+4pFqp1q7mpGCp3K86pGapHK+Oo3CpiK++oxyojK6Mo3yppq+ao8qpdq7spEKppq+Uoxypvq7Co3yppq+gpGyp4q62jtap6K/EpACp7q6kjmqojK/KjrikNq/QpHKp9K/WjrKp+q7ypHip9K/WpH6p+q7yjrKojK/co8qqAK7mo3ypgq+ypISqBq/ipIqpBK/opJCpTK6MpJaj3K6Aoxyj3K6SpJyqDK/upIqqEq/opKKqGK6Sjtapsq/cpKiqHq+ypK6qJK8cpLSqKq+yo4KOaq8cpLSonq+yo5SkYK8cpBip0K6ejtapiK7ymbyp0K6epLqqMK7ypMCqNq68o3yqPK7yo8qp0K/WpCSqQq/0o+Kp0K/WpMapmq/6o+KpHLAAjtyqSK++pMyohrAGpNKqTrAMpNipHK6ApNKqVLASpN6p0K6epOSqWq7+pN6p0K6eo46qYK7+o+KpHLAYpOqqZq++o+KpHLAYpPCqZq++jnaqbK6MpPaqcrAepPyqeK7Co+ipRrAApQKpsq/cpQip0K6Go3yqMK/cpQ6qfq6Go3yqMK/cpRSqhK6So3ypgq7+pBiqhK6SpDCpgq7+pRqqhK6SpSCpgq7+pSaqNq62pSypsrAkpTKp0K62jtap6LAkoyiqirAqpTiqWrAkpT6p0K6epUSqkK74pUqqiq6eo3yqlq74pVCn6q9kpVaqnK6kpAaqoq6kpVapmq6kpAaqqK6kpVapoK6kpVykYLAwo4KmUrA2pWKqrrA8pWiqtLBCpW6qirBIo3yOlLBOpXSoyK74o0Conq/oo4KmUrBUpUqqirBao6CqurAkjnaotq7Oo6Co/rAko9ap0K68pQKqMK7ypBKp0K68pQKqwK7ypXqj3LBIpYCmRrBgmYapHK6SjtypfLBmo0Cj3K6ApNKqxq80pYap0K6eo46qwK74pYyp0K6eo46psq74pN6p0K6epDCprK74pZKqirBajqCo4LAkpZiqzK+spZ6q0q6epaSp0K56jtyqwLBspCSm4q8cpZisOq7gpaqsQK9ApZisRq7gpaqsTK9ApZisOq7gpaqsQK9ApaSrSq7CpEKo/rBsoyiq3q68o6aq5K7yoy6req7Oo6aqeK7+pqCmjrGwpqaowrG2mYamjq56pqysUrG8pbyrdLHCjqaoyLHIo+6rdK6SprKsWK7+o+6rdK6SjtaoyK7+prisXrHOpr6sZK8cpsSmUrHUo4KmTLHaoyij3LHgjqao2rHmpBKj3LHsprKsaq+apsqosLHyjqapBLH4pYaosK7OprKscK7+pXqqirH+ptCsdq92paSotq56ptascK92paSotq56pEKpBK92mYas0LAAjrKpgrDYpris1rHOpmqs3K/0pBKs4q68pDCppq7+pN6s6K7Oo46ppq7+jnaq6q/WjqapBK7+o3yq8K/cpaqqiq6YpbCoqq6MpGCq9q6wpbCq/K6MpbarAq74pbyrCK9epcKrDq6GpcirFK7yoxyrCLAAoyirGq62jo6rIK6MoxarAq7+jqao4LByjmqrJq6MoxarLLAYoxyrMrB4pc6rOK62pbCrPrB+pdSrRLCEo4ijdrCKpdqnMK6kpeCrSq7mpSyrUK74o4Kk9q/0pGCl1LCQpearVrCEoy6qiq/WpeyozrCWoyirXK68o0arYq68pfKraK74jnarbq6GoxarULAkpXqrdLCco1KojK7Cjrio8q86pfiojK7mpf6ktLBOpNKjarCio0Coqq6Ao3ajLrCoo0CoqrCupeCrGq/WjnCotrC0pgSrgLC6pDCrerDApbCohrDGjripBLDMoxyohrDSpMyojK/Ko46rUK74pkys7rMkjqaozrMqp1qs9LMwp2Cs+rM2p2atALM8p2ytBrNCp3KtDLNIp3ijRrEyp36tErNOp4StGLNUp4qtHrNajqarvK7+p5CtJLNgp5apuLNmoyiqbK62o2qozrAkpSatKq62o3Cp6LAkptys6K6Sp5ytMLJkoyimfLAqjqao2rDqpBKtNrAqpDCpprDqpJCtPLNso46tQrAko5StSLNyp6KtTrMwp6is+rN4p66tALN+p7Ss4q62jtap6LAkjo6tVK/WoxyojLOEpJCs6K9ejtapgq7yptytWq56pGCpgq+amYatWq56jrKpgq+apJCtYK9eo46ppq7+paStYK9eo3yppq7+pripXq98pVas3K9kpripXq98pVapjrHOpYas4q68pSytZq7ypBKs4q68o3ytZq7+pJCtbK7Op7qtcrOKo+6tbK7Oo3atcq8QpRqteK7Oo46ppq7+pYateK7Oo46ppq7+o0CtYLOQpNKlyLOWo3CmjrBOp8Cr7LOcpvSqfrOip8atfq74jo6j3K/up8ykSK+Opnamjq7+pbCohrOojripBLOumYas0K56jrKpgrDYpbyohrKajqaoyLDqpBKs4q68pDCprK7+p9KthK7Cjtypgq92peyqeLDYo2qrhrDepgqozrDeoxaozq7+phCpBLDkjqCpBK/cphakSLDqo3yrSq7+jqarjK7+jqarkq7+phyrmLDwphCrmLD2phCpBLD2piKpBLD8pFSrnrECo3yrCLAko6arpLAko6apBK7ypiiozrEIjtCrqq7UjqaozrAkoxaozq7+oxaozrEOo4KjuK8cpi6mTK8cpi6mTK8cpjSjFrEUpjSjFrEUo4ikYLEaoxarsLCWpjqrtrEgpjqrtrEmpjqrtrEspeyozrBOpgqozrBOjqarvK7+o6aozq7ypkCrwq62pkaryK68pQKjRrEypkyrzrE4plKjHLE4pkyl8rE+o6yr1LFEo6yr1LEao6yr1K8QpliO6LA8o2qpBK7+jqaqeLBmo7ir2rFKpjSjIrFQpl6jLrFWpmSjdrCoo0Cr4LFcpmqmXrFio7KmXrFco2qrpK74juir5rDepiKpBLBmpiKr7LBmo76r8q9Aphal1LBmpXSozrBmjripBK/QjripBLFoo2qqeLFuo6aqeLFupl6l1LA8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gjQAAYUQAAGFFgMzghyE/oIchP6CIoUEgiKFBIIchP6CKIUKgi6FEIIihQSCNIUWgjqFHIIchP6CQIUigkaFKIIihQSCLoUQghyE/oIuhRCCIoUEghyE/oIohQqCIoUEghyE/oJMhS6CHIT+ghyE/oIohQqCQIUigkCFIoI6hRyCQIUigkCFIoI0hRaCQIUigkCFIoJShTSCUoU0gjqFHIJShTSCRoUogkCFIoJAhSKCQIUigkCFIoJYhTqCOoUcgjSFFoJAhSKCOoUcgiKFBII6hRyCOoUcgjqFHIJehP6CXoT+giKFBIIchP6CZIUEgmqFEIJkhQSCQIUigkCFIoJAhSKCQIUigkCFIoJAhSKCOoUcgkCFIoJAhSKCQIUigkCFIoI0hRaCNIUWgjSFFoI0hRaCQIUigkCFIoJAhSKCQIUigkCFIoJAhSKCQIUigkCFIoJAhSKCQIUigiiFCoJwhUCCLoUQgnyFRoIohQqCQIUigl6E/oJehP6CaoUQgnCFQIJMhS6COoUcghyE/oJehP6CXoT+gl6E/oJehP6CXoT+gnaFFoJ2hRaCdoUWgnaFFoJqhRCCaoUQgmqFEIJkhQSCZIUEgmSFBII0hRaCQIUiglKFNIJehP6COoUcgoKFCoI6hRyCIoUEgkCFIoJehP6COoUcghyE/oJAhSKCaoUQgkCFIoI0hRaCiIVMgjqFHIIihQSCOoUcgmSFBII6hRyCQIUighyE/oJAhSKCHIT+gkCFIoJkhQSCjoVSgiKFBIIchP6CQIUigl6E/oJAhSKClIUiglKFNIJAhSKCmoVYgkCFIoKghV6CZIUEgkCFIoJkhQSCQIUigmqFEIJAhSKCZIUEgliFOoJkhQSCWIU6gl6E/oI6hRyCKIUKgjSFFoKChQqCpoVkgmSFBIJAhSKCZIUEgkCFIoKChQqCOoUcgoKFCoI6hRyCrIVqgrKFcIK4hXaCHIT+gkCFIoJkhQSCOoUcgmSFBII6hRyCHIT+gkCFIoJehP6CQIUigl6E/oJAhSKCaoUQgkCFIoJqhRCCQIUigi6FEIJAhSKCZIUEgpSFIoIihQSCQIUigjSFFoI0hRaCNIUWgjSFFoJ2hRaCNIUWgjSFFoJShTSCOoUcglKFNIIchP6COoUcgjqFHIJAhSKCUoU0giKFBIJAhSKCvoV8gkCFIoIuhRCCQIUigi6FEIJAhSKCIoUEgliFOoJehP6COoUcgiiFCoI0hRaCZIUEgkCFIoIihQSCQIUigmSFBIJAhSKCIoUEgkCFIoJMhS6CIoUEgl6E/oI6hRyCUoU0hCCFLoIihQSEIIUugiKFBIQghS6CIoUEgl6E/oI6hRyCxIWCgsqFiIMShcqDGIXQghyE/oJAhSKCXoT+gkCFIoJehP6CQIUigl6E/oJAhSKCXoT+gkCFIoJehP6ClIUigl6E/oJAhSKCXoT+gkCFIoJehP6CQIUigl6E/oKUhSKCXoT+gpSFIoJehP6CQIUigl6E/oJAhSKCXoT+gkCFIoJehP6CQIUigl6E/oJAhSKCXoT+gkCFIoJehP6CQIUigl6E/oKUhSKCXoT+gkCFIoJ2hRaCUoU0gjSFFoJShTSCLoUQgkCFIoJqhRCCQIUigmqFEIJAhSKCaoUQgkCFIoJqhRCCQIUigmqFEIKUhSKCaoUQgkCFIoQmhYKCyoWIhCaFgoLKhYiEJoWCgsqFiIQmhYKCyoWIgsSFgoLKhYiCIoUEgkCFIoJkhQSCQIUihCyFyoMYhdCELIXKgxiF0IQshcqDGIXQhCyFyoMYhdCELIXKgxiF0IIchP6COoUcgl6E/oI6hRyCXoT+gjqFHIJehP6CQIUignaFFoJShTSCaoUQgkCFIoJkhQSCQIUigtCFjoJAhSKCQIUigtaFlILchZqCQIUigtyFmoJAhSKCIoUEgiKFBII6hRyCIoUEguKFoILchZqCQIUiguiFpoIchP6CuIV2giiFCoIuhRCC7oWsgvSFsoJShTSCNIUWghyE/oI6hRyCUoU0gjqFHIL6hbiCIoUEgkCFIoIuhRCDAIW+gwaE/oMMhcSCQIUighyE/oIchP6COoUcgx6F1oMkhdyCNIUWgiiFCoI0hRaCKIUKgyqF4oIihQSDMIXogjqFHIIohQqCOoUcgiiFCoIohQqCQIUig0KF+oM2he6CQIUihESG0oRKhtiEUIbehFaG5IJGhSiEXIbqhEqG2IRihvCEaIb2gkCFIoRuhUCCfIVGgi6FEIJAhSKCaoUQgkCFIoJehP6EMoUcgi6FEIJAhSKCaoUQgkCFIoKChQqDuoZsglKFNIR0htKESobYhFCG3oJqhRCCQIUihHqG/IMehdaCZIUEgkCFIoJehP6CQIUigl6E/oJAhSKCXoT+gkCFIoJehP6CQIUignaFFoI0hRaCdoUWgjSFFoJqhRCCQIUigmqFEIJAhSKCZIUEgliFOoJkhQSCWIU6gmSFBIJAhSKCZIUEgkCFIoIohQqCNIUWg7qGbISAhwKCZIUEgpSFIoSGhwiEjIcOhJKHFIIohQqCOoUcgl6E/oJAhSKCHIT+gkCFIoJqhRCCQIUigl6E/oI6hRyCQIUigkCFIoJAhSKCQIUigjqFHII6hRyCQIUigkCFIoJAhSKDPIX0g0KF+oNChfqDSIYAg06GBoI0hRaCQIUigkCFIoNUhgyDWoYSg2CGGIJAhSKCQIUigkCFIoJShTSCUoU0glKFNINmhh6DbIYkglKFNINyhiqCRoUogkaFKIJGhSiCQIUigkCFIoN4hjCCQIUig36GNoOEhjyDioZCgliFOoJYhTqCWIU6gliFOoJYhTqCWIU6gliFOoOQhkiDkIZIgjqFHIJShTSDloZOglKFNIOchlSCNIUWgjSFFoJAhSKDooZag6iGYII6hRyCIoUEgjqFHIOuhmaCOoUcg7SGSIO6hmyDuoZsgjqFHII6hRyCOoUcgjqFHIIuhRCDwIZyg06GBoNUhgyDxoZ4g8yGfoI6hRyD0oaEgkCFIoI6hRyCOoUcg9iGioPehpCD5IaWg+qGnIPwhqKD9oaog/yGroQChrSECIa6hA6GwIQUhsaCHIT+gkCFIoJehP6CQIUighyE/oJAhSKCHIT+gkCFIoJkhQSCOoUcgmSFBIJAhSKCIoUEgkCFIoIihQSCQIUigiKFBIJAhSKCIoUEgkCFIoJehP6CQIUigl6E/oJAhSKCHIT+gkCFIoIchP6CQIUigl6E/oJAhSKCgoUKgnaFFoJqhRCCQIUigmSFBIJAhSKCIoUEgkCFIoJkhQSClIUigiKFBIJAhSKCIoUEgkCFIoI0hRaCUoU0gnaFFoJ2hRaCXoT+hDKFHIIchP6COoUcghyE/oI6hRyCQIUiglKFNIKUhSKEOIU0gkCFIoJShTSCQIUiglKFNIQ+hSiCRoUohD6FKIJGhSiCRoUogkaFKIJkhQSCQIUigiKFBIJAhSKCIoUEgkCFIoIihQSCQIUigmqFEIJAhSKCaoUQgpSFIoJqhRCCQIUigmqFEIJAhSKCXoT+gkCFIoJehP6CQIUigmSFBIJYhTqCIoUEgliFOoJkhQSCWIU6giKFBIJYhTqCXoT+gjqFHIIchP6COoUcgl6E/oQyhRyCXoT+hDKFHIJehP6COoUcgoKFCoI0hRaCKIUKgjSFFoIohQqCNIUWgiiFCoI0hRaCIoUEgkCFIoIihQSCQIUigiKFBIJAhSKCZIUEgkCFIoJkhQSClIUigl6E/oI6hRyCHIT+gjqFHIQghS6CIoUEgkyFLoIihQSCXoT+gjqFHIJehP6COoUcgl6E/oI6hRyCgoUKgjqFHIIohQqCOoUcgiiFCoI6hRyCQIUigjSFFoIihQSCOoUcgkCFIoQ4hTSebJ5yglKFNIJShTSEmIcag5yGVISehyCEpIcmhBqGzIQahsyEqocshKqHLIIchP6CIoUEgjqFHIJAhSKCKIUKgjqFHII6hRyEsIcygkCFIoJAhSKCNIUWgkaFKIJAhSKCQIUigliFOoJYhTqCOoUcgjSFFoI6hRyCQIUigySF3ILohaaEtoc4glKFNIJShTSCQIUig6iGYIOihlqCQIUigkCFIoI0hRaEvIc+gjqFHIJShTSCRoUogkCFIoJAhSKCWIU6gjqFHITCh0SCOoUcgjqFHII6hRyCQIUigkCFIoJAhSKCQIUig0KF+oNChfqEyIdKglKFNII6hRyCUoU0gkCFIoO6hmyEzodQghyHVoIih1yE1IdighyHVoJAh2iCOoduglKHdITah3qCQIdogiKHXIJYh4CCHIdWgjqHboTmh5KCQIdoglKHdIJAh2iCHIdWgiKHXIJAh2iCNIeGgjqHboTgh4yCUoU0AAIAAwiNCI8AAAsxCzMAAwvtC+0ABgACACcAJAA9AAAARABdABoAYgCBADQAiQCJAFQAkACRAFUAoAChAFcApgCmAFkArACwAFoAuQC6AF8AxgDVAGEA4ADlAHEA5wDsAHcA9gD/AH0BAgEqAIcBigGMALABlgHVALMB3QHkAPMEagRtAPsEpAUDAP8FJAUlAV8Giga8AWEGwAbDAZQGyAbRAZgG1wcGAaIHCQcXAdIHHQceAeEHIQd/AeMJfwoUAkILCQsJAtgLDgsPAtkLEgsXAtsL3wvoAuEMcAyeAusM9Q0CAxoNGw0bAygNHQ0jAykNKg0qAzANLQ0tAzEPbw9vAzIAAQCkAKoAAQAMABIAAQAAbcwASG4Ibg5uFG4abiBuJm32bixuMm44bj5uMm5EbixtzG5KblBuVm5cbmJt0m38bmhuPm5ubnRt2G3Ybdhuem3YboBt6m3YboZuhm6MbpJumG6ebdhsTG6kbqpusG62bd5t3m68bsJuyG7ObeRt5G3kbept8G32bfZt9m38bdJt/G3wbfZt5G32beRuAm3ebfxt6gABAAEIWQACAAsAJAA9AAAARABdABoAeQB6ADQAfQB/ADYArgCuADkAzwDPADoA0QDSADsA1ADUAD0ByQHKAD4E0ATTAEAE6ATrAEQAAQBYAF4AAQAMABIAAQAAbeoAIm3qbfBt9m38bgJuCG4ObhRt/G4abiBuJm4sbjJuOG4+bkRuSm5QblZuXG5iblZuaG5ubnRuem6AbnRudG6AbixuLG6GAAEAAQhkAAIAFwAkACQAAAAmACYAAQAoACgAAgAqACoAAwAsACwABAAuAC8ABQAxADIABwA1ADgACQBEAEQADQBGAEYADgBIAEgADwBKAEoAEABMAEwAEQBOAE8AEgBRAFIAFABVAFgAFgB0AHQAGgB2AHYAGwB+AH4AHACAAIAAHQDMAMwAHgDSANMAHwEOAQ4AIQABBngGfgABAAwAEgABAAB33gMyd9535Hfqd/B39nf8eAJ4CG2UeA54CHgUeBp4IHfqeCZ4FHgseDJtIngyeDh4PnhEeEp4UHgUeFZ4XG3ueGJ4aHhueHRtanh6eHRtam3Qbcp4XHiAeIZtanhKeIxtyniSeAJ4mHieeKR33nfeeKp39nggd+p4MngUeBR4FHgUeBR4FHjCeGJ4YnhieGJ4yHhobZR4zm3KeFx4XHhceFx4XG3Kbcptym3KbbJ4sHfqeNR4XHl8d9533nfqeOZ47HieeEp33nf2d9539nf2eLZ4vG2UeCZ36nfqd+p4MngyeDJ48ngUbWp4MnhKeFB4pHfweNp4Snied/x44HgCeG5tlHj4eP536nhcd+p4XG2yd954FHkEeQp38G3ud/B5EHkWd/Z4YngUbWp4FG1qeBRtanggbcp4IG3Kd+p4XHgsbWp4LHkceDJ4SnkieShtIniMeDJtyngybcp4UHikeFB4pHhQeS55NHfeeBR36nhcd+p4XHf2eGJ39nhid/Z4YngCeG54AnhueTp4bngIbcp4CG3KePJ4znjOeM5tlHjOeUB5RngOeHp5THfqeHR4bnlSeVh4FHleeWR36nhcd+p4XHgseWp4MnhKbSJ4jHgybcp4Mm3KeDJtynlweXZ4PngCeEp4nm1qeD54Ang+eAJ4PngCeEp4nnfqeFx4Mm3Kd954FHfeeBR33ngUd954FHfeeBR33ngUd954FHfeeBR33ngUd954FHfeeBR33ngUd/Z6DHf2eGJ39nhid/Z4Ynf2eGJ39nhid/Z4Ynf2egxtlG1qehJ6GHoeeiR36nhcd+p4XHfqeFx36nhcd+p4XHoeeiR36nhcd+p4XHfqeFx36nhceh56JHoqbcp4Mm3KeDJtyngybcp4Mm3KeDJtynoqbcp6MHieeEp4nnhKeJ533ngUbZRtanfqeFx4Mm3Kd+p4YnhWeYJ4mHhWeYh4VniYd+p4XHfwd+p5jm2yeZR5mnmgeaZ4AnmsebJ5uG2UeAh4dG1qbcp5vnggecR36nnKedB51njgedx4MnhKeV554nnobSJ4jHnuefR4Mnh0eJ54UHikefp6AHhcbSJ6BniAfBZ8HHwifCh8Lnw0fDp8QHxGbQp75njUeAJ8THgCeG54CHh0fFJ8WHxSfFh5+nxMeHp8FnwcfCJ4AnhufF58ZHggbcp33ngUd954FHf2eGJ39nhiePJ8anjOeM536nhcd+p4XHgseCZ4LG1eeDJtsngybb55InkofHB8dngIeHR8fHyCeaB35G06d954FHj4eMJ36nhceEp4nnhibe5tCm0KbSJ7Jnssbe5tCm0KbSJtIm0ibQp7MnhueG5tCns4bQp7Pm3KeWRtXm1ebV57RHtEe0p7UHtWe1x7Ym3ue2h4dG0Ke257dHt6e4B7gHuGeOB5QG1qe4x6eHhce5J7mHuee6R65Huqe7Bt7m0KbTpt7nu2bcptiHu8eKR4bnhue8J7yHvOeeJ36nhcbSJtCnvUe9p6AG0iecR7jHvge+Z77HvyeV57+Hgge/536nmOfAR4dHfeeBR35HhWejZ6PHpCekh4qnjCd/Bt7npObe56VHpIelpt7nj4emB39nhid/Z4Ynj4emZ6bHpyePh4wnf8eGh4AnhueAh4dHgIenh4CHh0eAh4dHp+eoR6inqQbZR4zngIeHR4CHh0eUx6SHleepZ5XnqWepx6onqoeq54Gm3QeBpt0HgabdB4IG3KeCB59Hq0ekh5rHj+d+p4XHfqeFx36nhcd+p4XHgmeIB4JniAeCxtangserp4LHrAesZ6ongyeEp6zHrSeDJ4SngyeEp6zHrSbSJ4jHpIerp62HreeeJ65Hmseup68Hr2evx7Angybcp4Mm3KeDh4knrMewh4PngCeD57DnhEeJh4RHiYeEp4nnhQeKR4UHp4exR7GnsgeIx4AnieeBRtXo6+bWp4enyIe558iHyOfAp8EHyUeIZ33nfqeFx4FG0ieqh5rHyaeFZt7nhoeBptyniAbWptanhKeIx4pHhufKB4+Hu2bV5tXniAeDh4VnymfKx8snhufLh8vnzEfMp4gHxkefp80HzWfNx4qnzifOh87nz0fPp9AG0KfQZ9DH0SfOJ4FHnWd+R4Mnfed/Z4YngOeHp9GH0eeCxtanhKeJ59MHgUbWp4FHgmeCx4FHiMfSR9KgABAAEIZQACACYAJAA9AAAARABdABoAYgCBADQAiQCJAFQAkACRAFUAoAChAFcApgCmAFkArACwAFoAuQC6AF8AxgDVAGEA4ADlAHEA5wDsAHcA9gD/AH0BAgEqAIcBigGMALABlgHVALMB3QHkAPMEagRtAPsEpAUDAP8FJAUlAV8Giga8AWEGwAbDAZQGyAbRAZgG1wcGAaIHCQcXAdIHHQceAeEHIQd/AeMJfwoUAkILCQsJAtgLDgsPAtkLEgsXAtsL3wvoAuEMcAyeAusM9Q0CAxoNGw0bAygNHQ0jAykNKg0qAzANLQ0tAzEAAQBoAHAAAgAMABYAAgAAZkAAAWZAABRmPGY8ZkJmQmZIZkhmKmYqZk5mTmZUZpZmWmZaZmBmYGX0ZfRmZmZmZlRmVGZsZmxmcmZyZfRl9GZ4ZnhmfmZ+ZoRmhGYeZh5mimaKZpBmkAABAAIIXwhgAAIABQBFAEcAAABJAEsAAwBNAFEABgBTAFoACwBdAF0AEwABDOwM9gACAAwAHgAEAABnvgABakYAAGfEAAFqTAMzZ7hoBme4aAZnvmgGZ75oBme4aAZnxGgGZ8poBme+aAZn0GgGZ9ZoBme4aAZn3GgGZ+JoBme+aAZnymgGZ7hoBmfKaAZnvmgGZ7hoBmfEaAZnvmgGZ7hoBmfoaAZnuGgGZ7hoBmfEaAZn3GgGZ9xoBmfWaAZn3GgGZ9xoBmfQaAZn3GgGZ9xoBmfuaAZn7mgGZ9ZoBmfuaAZn4mgGZ9xoBmfcaAZn3GgGZ9xoBmf0aAZn1mgGZ9BoBmfcaAZn1mgGZ75oBmfWaAZn1mgGZ9ZoBme4aAZnuGgGZ75oBme4aAZnvmgGZ8poBme+aAZn3GgGZ9xoBmfcaAZn3GgGZ9xoBmfcaAZn1mgGZ9xoBmfcaAZn3GgGZ9xoBmfQaAZn0GgGZ9BoBmfQaAZn3GgGZ9xoBmfcaAZn3GgGZ9xoBmfcaAZn3GgGZ9xoBmfcaAZn3GgGZ8RoBmf6aAZnymgGaABoBmfEaAZn3GgGZ7hoBme4aAZnymgGZ/poBmfoaAZn1mgGZ7hoBme4aAZnuGgGZ7hoBme4aAZnuGgGZ9BoBmfQaAZn0GgGZ9BoBmfKaAZnymgGZ8poBme+aAZnvmgGZ75oBmfQaAZn3GgGZ+5oBme4aAZn1mgGZ8RoBmfWaAZnvmgGZ9xoBme4aAZn1mgGZ7hoBmfcaAZnymgGZ9xoBmfQaAZoBmgGZ9ZoBme+aAZn1mgGZ75oBmfWaAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme+aAZoDGgGZ75oBme4aAZn3GgGZ7hoBmfcaAZn3GgGZ+5oBmfcaAZoEmgGZ9xoBmgYaAZnvmgGZ9xoBme+aAZn3GgGZ8poBmfcaAZnvmgGZ/RoBme+aAZn9GgGZ7hoBmfWaAZnxGgGZ9BoBmfEaAZoHmgGZ75oBmfcaAZnvmgGZ9xoBmfEaAZn1mgGZ8RoBmfWaAZoJGgGaCpoBmgwaAZnuGgGZ9xoBme+aAZn1mgGZ75oBmfWaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnymgGZ9xoBmfKaAZn3GgGZ8poBmfcaAZnvmgGZ9xoBme+aAZn3GgGZ9BoBmfQaAZn0GgGZ9BoBmfQaAZn0GgGZ9BoBmfuaAZn1mgGZ+5oBme4aAZn1mgGZ9ZoBmfcaAZn7mgGZ75oBmfcaAZoNmgGZ9xoBmfKaAZn3GgGZ8poBmfcaAZnvmgGZ/RoBme4aAZn1mgGZ8RoBmfQaAZnvmgGZ9xoBme+aAZn3GgGZ75oBmfcaAZnvmgGZ9xoBmfoaAZnvmgGZ7hoBmfWaAZn7mgGZ+hoBme+aAZn6GgGZ75oBmfoaAZnvmgGZ7hoBmfWaAZoPGgGaEJoBmiKaAZokGgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBmfQaAZn7mgGZ9BoBmfuaAZnymgGZ9xoBmfKaAZn3GgGZ8poBmfcaAZnymgGZ9xoBmfKaAZn3GgGZ8poBmfcaAZnymgGZ9xoBmg8aAZoQmgGaDxoBmhCaAZoPGgGaEJoBmg8aAZoQmgGaDxoBmhCaAZnvmgGZ9xoBme+aAZn3GgGaIpoBmiQaAZoimgGaJBoBmiKaAZokGgGaIpoBmiQaAZoimgGaJBoBme4aAZn1mgGZ7hoBmfWaAZnuGgGZ9ZoBme4aAZn3GgGZ9BoBmfuaAZnymgGZ9xoBme+aAZn3GgGaEhoBmfcaAZn3GgGaE5oBmhUaAZn3GgGaFRoBmfcaAZnvmgGZ75oBmfWaAZnvmgGaFpoBmhUaAZn3GgGaGBoBme4aAZoMGgGZ8RoBmfKaAZoZmgGaGxoBmfuaAZn0GgGZ7hoBmfWaAZn7mgGZ9ZoBmhyaAZnvmgGZ9xoBmfKaAZoeGgGaH5oBmiEaAZn3GgGZ7hoBme4aAZn1mgGaJZoBmicaAZn0GgGZ8RoBmfQaAZnxGgGaKJoBme+aAZoqGgGZ9ZoBmfEaAZn1mgGZ8RoBmfEaAZn3GgGaLpoBmiuaAZn3GgGaZhoBmmeaAZppGgGaapoBmfiaAZpsGgGaZ5oBmm2aAZpvGgGZ9xoBmf6aAZoAGgGZ8poBmfcaAZnymgGZ9xoBme4aAZn1mgGZ8poBmfcaAZnymgGZ9xoBmfEaAZpMmgGZ+5oBmmYaAZpnmgGaaRoBmfKaAZn3GgGacJoBmiWaAZnvmgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ9BoBmfQaAZn0GgGZ9BoBmfKaAZn3GgGZ8poBmfcaAZnvmgGZ/RoBme+aAZn9GgGZ75oBmfcaAZnvmgGZ9xoBmfEaAZn0GgGaTJoBmnIaAZnvmgGZ9xoBmnOaAZp1GgGadpoBmfEaAZn1mgGZ7hoBmfcaAZnuGgGZ9xoBmfKaAZn3GgGZ7hoBmfWaAZn3GgGZ9xoBmfcaAZn3GgGZ9ZoBmfWaAZn3GgGZ9xoBmfcaAZotGgGaLpoBmi6aAZowGgGaMZoBmfQaAZn3GgGZ9xoBmjMaAZo0mgGaNhoBmfcaAZn3GgGZ9xoBmfuaAZn7mgGZ+5oBmjeaAZo5GgGZ+5oBmjqaAZn4mgGZ+JoBmfiaAZn3GgGZ9xoBmjwaAZn3GgGaPZoBmj8aAZpAmgGZ/RoBmf0aAZn9GgGZ/RoBmf0aAZn9GgGZ/RoBmkIaAZpCGgGZ9ZoBmfuaAZpDmgGZ+5oBmkUaAZn0GgGZ9BoBmfcaAZpGmgGaSBoBmfWaAZnvmgGZ9ZoBmkmaAZn1mgGaSxoBmkyaAZpMmgGZ9ZoBmfWaAZn1mgGZ9ZoBmfKaAZpOGgGaMZoBmjMaAZpPmgGaURoBmfWaAZpSmgGZ9xoBmfWaAZn1mgGaVBoBmlWaAZpXGgGaWJoBmloaAZpbmgGaXRoBml6aAZpgGgGaYZoBmmMaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme+aAZn1mgGZ75oBmfcaAZnvmgGZ9xoBme+aAZn3GgGZ75oBmfcaAZnvmgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ7hoBmfcaAZnxGgGZ9BoBmfKaAZn3GgGZ75oBmfcaAZnvmgGZ9xoBme+aAZn3GgGZ75oBmfcaAZnvmgGZ9xoBmfQaAZn7mgGZ9BoBmfQaAZnuGgGZ9ZoBme4aAZn1mgGZ7hoBmfWaAZn3GgGZ+5oBmfcaAZn7mgGZ9xoBmfuaAZn3GgGZ+5oBmfiaAZn4mgGZ+JoBmfiaAZn4mgGZ+JoBme+aAZn3GgGZ75oBmfcaAZnvmgGZ9xoBme+aAZn3GgGZ8poBmfcaAZnymgGZ9xoBmfKaAZn3GgGZ8poBmfcaAZnuGgGZ9xoBme4aAZn3GgGZ75oBmf0aAZnvmgGZ/RoBme+aAZn9GgGZ75oBmf0aAZnuGgGZ9ZoBme4aAZn1mgGZ7hoBmfWaAZnuGgGZ9ZoBme4aAZn1mgGZ8RoBmfQaAZnxGgGZ9BoBmfEaAZn0GgGZ8RoBmfQaAZnvmgGZ9xoBme+aAZn3GgGZ75oBmfcaAZnvmgGZ9xoBme+aAZn3GgGZ7hoBmfWaAZnuGgGZ9ZoBmfoaAZnvmgGZ+hoBme+aAZnuGgGZ9ZoBme4aAZn1mgGZ7hoBmfWaAZnxGgGZ9ZoBmfEaAZn1mgGZ8RoBmfWaAZn3GgGZ9BoBme+aAZn1mgGZ9xoBmfuaAaGtGgGZ+5oBmfuaAZp4GgGaRRoBmnmaAZp7GgGaZJoBmmSaAZp8mgGafJoBme4aAZnvmgGZ9ZoBmfcaAZnxGgGZ9ZoBmfWaAZp+GgGZ9xoBmfcaAZn0GgGZ+JoBmfcaAZn3GgGZ/RoBmf0aAZn1mgGZ9BoBmfWaAZn3GgGaJxoBmhgaAZp/mgGZ+5oBmfuaAZn3GgGaSBoBmkaaAZn3GgGZ9xoBmfQaAZqBGgGZ9ZoBmfuaAZn4mgGZ9xoBmfcaAZn9GgGZ9ZoBmoKaAZn1mgGZ9ZoBmfWaAZn3GgGZ9xoBmfcaAZn3GgGaLpoBmi6aAZqEGgGZ+5oBmfWaAZn7mgGZ9xoBmkyaAZqFmgGZ7hoBme+aAZqHGgGZ7hoBmfcaAZn1mgGZ+5oBmoiaAZn3GgGZ75oBmf0aAZnuGgGZ9ZoBmouaAZn3GgGZ+5oBmfcaAZnuGgGZ75oBmfcaAZn0GgGZ9ZoBmooaAZn7mgGAAIAAQsKCw0AAAACACcAJAA9AAAARABdABoAYgCBADQAiQCJAFQAkACRAFUAoAChAFcApgCmAFkArACwAFoAuQC6AF8AxgDVAGEA4ADlAHEA5wDsAHcA9gD/AH0BAgEqAIcBigGMALABlgHVALMB3QHkAPMEagRtAPsEpAUDAP8FJAUlAV8Giga8AWEGwAbDAZQGyAbRAZgG1wcGAaIHCQcXAdIHHQceAeEHIQd/AeMJfwoUAkILCQsJAtgLDgsPAtkLEgsXAtsL3wvoAuEMcAyeAusM9Q0CAxoNGw0bAygNHQ0jAykNKg0qAzANLQ0tAzEPbw9vAzIAAQGQAgAAAQAMAQ4AQAAAWJwAAFiiAABYqAAAWK4AAFi0AABYugAAWMAAAFjGAABYtAAAWMwAAFjSAABY2AAAWLQAAFjeAABY3gAAWOQAAFjGAABY6gAAWPAAAFjwAABY8AAAWPYAAFjeAABY3gAAWPwAAFkCAABZCAAAWQ4AAFi0AABZFAAAWRoAAFkCAABZIAAAWSAAAFkgAABZIAAAWSAAAFkgAABZIAAAWSAAAFkgAABZIAAAWSAAAFkgAABZIAAAWSYAAFksAABZLAAAWSwAAFkyAABZOAAAWOoAAFk+AABZRAAAWQ4AAFkOAABZSgAAWUoAAFlKAABZSgAAWUoAAFlKAABZSgAAWVAAQFhUWFpYYFhmWGxYclh4WH5Yflh+WGxYbFhsWGxYbFhsWIRYbFhsWGxYbFiKWJBYllicWH5YbFhsWJBYbFiiWKhYrliuWLRYrliuWK5YtFi0WK5Yrli6WK5Yrli0WH5YkFiQWGxYbFiKWMBYlljGWMZYtFjMWMxYzFjMWMxYzFjSAAIAEgR0BHQAAAR6BHoAAQSSBJMAAghCCFIABAhYCFgAFQh6CHwAFgh/CIEAGQiDCIMAHAiHCIkAHQiQCJwAIAjvCPIALQspCysAMQswCzAANAvsC+wANQzEDMUANgzHDMcAOA0RDRYAOQ0YDRgAPwACABIEdAR0AAAEegR6AAEEkgSTAAIIQghSAAQIWAhYABUIegh8ABYIfwiBABkIgwiDABwIhwiJAB0IkAicACAI7wjyAC0LKQsrADELMAswADQL7AvsADUMxAzFADYMxwzHADgNEQ0WADkNGA0YAD8AAQESAWoAAQAMALoAKwAAVcAAAFXGAABVxgAAVcYAAFXGAABVzAAAVcwAAFXSAABVzAAAVdgAAFXeAABV5AAAVeQAAFXkAABV6gAAVfAAAFX2AABV9gAAVdgAAFXYAABV/AAAVdgAAFYCAABVxgAAVcwAAFXqAABWCAAAVg4AAFYOAABVxgAAVdIAAFXSAABV0gAAVggAAFYUAABWFAAAVhQAAFYUAABWFAAAVhQAAFYUAABWFAAAVhQAK1VsVXJVclVyVXJVclVyVXJVclV4VXJVclVyVXJVclVyVXJVclVyVXJVclV4VXJVclVyVXJVclVyVXJVclVyVXJVclVyVXJVclVyVXJVclVyVXJVclVyAAIADgSVBJUAAAhUCFcAAQhaCF4ABQhhCGMACghmCHAADQh2CHkAGAiCCIIAHAiECIYAHQiKCIsAIAssCy8AIgvqC+sAJgzGDMYAKA0XDRcAKQ0ZDRkAKgACAA4ElQSVAAAIVAhXAAEIWgheAAUIYQhjAAoIZghwAA0Idgh5ABgIggiCABwIhAiGAB0IigiLACALLAsvACIL6gvrACYMxgzGACgNFw0XACkNGQ0ZACoAAgF4AAUAXAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIAAIABQIsAjAAAAIyAjIABQI0AlkABgKIAogALA4rDlkALQACARAABQBCACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIAAIABAErAS0AAAHxAfcAAwH5Ag8ACg4KDioAIQACBAgABQEAACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAAkAEgAJABIACQASAACAE0AJAA9AAAAYgBoABoAkACRACEArACvACMAugC6ACcAxgDUACgA4ADgADcA4gDiADgA5ADkADkA5wDnADoA6QDpADsA6wDrADwA9gD2AD0A+AD5AD4A+wD7AEAA/QD9AEEBAgECAEIBBAEEAEMBBgEGAEQBCAEJAEUBCwELAEcBDQENAEgBDwEPAEkBEQERAEoBEwETAEsBFQEVAEwBFwEXAE0BGQEZAE4BGwEbAE8BHQEdAFABHwEfAFEBIQEhAFIBIwEjAFMBJQElAFQBJwEnAFUBKQEpAFYBigGKAFcBlgGWAFgBmAGYAFkBmgGaAFoBnAGcAFsBngGeAFwBoAGgAF0BogGiAF4BpAGkAF8BpgGmAGABqAGoAGEBqgGqAGIBrAGsAGMBrgGuAGQBsAGwAGUBsgGyAGYBtAG0AGcBtgG2AGgBuQG5AGkBuwG7AGoBvQG9AGsBvwG/AGwBwQHBAG0BwwHDAG4BxQHFAG8BxwHHAHAByQHJAHEBywHLAHIBzQHNAHMBzwHPAHQB0QHRAHUB0wHTAHYB1gHWAHcB2AHYAHgB2gHaAHkB3QHdAHoB3wHfAHsB4QHhAHwB4wHjAH0NRw1HAH4NiQ4JAH8AAwABABIAAQAYAAAAAQAAAEMAAQABBkwAAgABDsgO1gAAAAMAAQASAAEAGAAAAAEAAABEAAEAAQuhAAIAAQ7IDtYAAAADAAEAEgABABgAAAABAAAARQABAAELogACAAEOyA7WAAAAAwABABIAAQAYAAAAAQAAAEYAAQABC6QAAgABDsgO1gAAAAMAAQASAAEAGAAAAAEAAABHAAEAAQ9IAAIAAQ7IDtYAAAADAAEAFAABABoAAQAaAAEAAABIAAEAAQZMAAIAAQ7IDtYAAAADAAEAFAABABoAAQAaAAEAAABJAAEAAQuhAAIAAQ7IDtYAAAADAAEAFAABABoAAQAaAAEAAABKAAEAAQuiAAIAAQ7IDtYAAAADAAEAFAABABoAAQAaAAEAAABLAAEAAQukAAIAAQ7IDtYAAAADAAEAFAABABoAAQAaAAEAAABMAAEAAQ9IAAIAAQ7IDtYAAAADAAIAFAAeAAEAFAAAAAEAAABNAAIAAQ7IDtYAAAABAAEGTAADAAIAFAAeAAEAFAAAAAEAAABOAAIAAQ7IDtYAAAABAAELoQADAAIAFAAeAAEAFAAAAAEAAABPAAIAAQ7IDtYAAAABAAELogADAAIAFAAeAAEAFAAAAAEAAABQAAIAAQ7IDtYAAAABAAELpAADAAIAFAAeAAEAFAAAAAEAAABRAAIAAQ7IDtYAAAABAAEPSAADAAEAFgABABwAAgAcABwAAQAAAFIAAQABBkwAAgABDsgO1gAAAAMAAQAWAAEAHAACABwAHAABAAAAUwABAAEO1wACAAEOyA7WAAAAAwABABYAAQAcAAIAHAAcAAEAAABUAAEAAQ7YAAIAAQ7IDtYAAAADAAEAFgABABwAAgAcABwAAQAAAFUAAQABDtoAAgABDsgO1gAAAAMAAQAWAAEAHAACABwAHAABAAAAVgABAAEPdAACAAEOyA7WAAAAAwACABYAIAABABYAAQAWAAEAAABXAAIAAQ7IDtYAAAABAAEGTAADAAIAFgAgAAEAFgABABYAAQAAAFgAAgABDsgO1gAAAAEAAQ7XAAMAAgAWACAAAQAWAAEAFgABAAAAWQACAAEOyA7WAAAAAQABDtgAAwACABYAIAABABYAAQAWAAEAAABaAAIAAQ7IDtYAAAABAAEO2gADAAIAFgAgAAEAFgABABYAAQAAAFsAAgABDsgO1gAAAAEAAQ90AAMAAwAWABYAIAABABYAAAABAAAAXAACAAEOyA7WAAAAAQABBkwAAwADABYAFgAgAAEAFgAAAAEAAABdAAIAAQ7IDtYAAAABAAEO1wADAAMAFgAWACAAAQAWAAAAAQAAAF4AAgABDsgO1gAAAAEAAQ7YAAMAAwAWABYAIAABABYAAAABAAAAXwACAAEOyA7WAAAAAQABDtoAAwADABYAFgAgAAEAFgAAAAEAAABgAAIAAQ7IDtYAAAABAAEPdAADAAEAGAABAB4AAwAeAB4AHgABAAAAYQABAAEO1wACAAEOyA7WAAAAAwABABgAAQAeAAMAHgAeAB4AAQAAAGIAAQABDtgAAgABDsgO1gAAAAMAAQAYAAEAHgADAB4AHgAeAAEAAABjAAEAAQ7aAAIAAQ7IDtYAAAADAAEAGAABAB4AAwAeAB4AHgABAAAAZAABAAEPdAACAAEOyA7WAAAAAwACABgAIgABABgAAgAYABgAAQAAAGUAAgABDsgO1gAAAAEAAQ7XAAMAAgAYACIAAQAYAAIAGAAYAAEAAABmAAIAAQ7IDtYAAAABAAEO2AADAAIAGAAiAAEAGAACABgAGAABAAAAZwACAAEOyA7WAAAAAQABDtoAAwACABgAIgABABgAAgAYABgAAQAAAGgAAgABDsgO1gAAAAEAAQ90AAMAAwAYABgAIgABABgAAQAYAAEAAABpAAIAAQ7IDtYAAAABAAEO1wADAAMAGAAYACIAAQAYAAEAGAABAAAAagACAAEOyA7WAAAAAQABDtgAAwADABgAGAAiAAEAGAABABgAAQAAAGsAAgABDsgO1gAAAAEAAQ7aAAMAAwAYABgAIgABABgAAQAYAAEAAABsAAIAAQ7IDtYAAAABAAEPdAADAAQAGAAYABgAIgABABgAAAABAAAAbQACAAEOyA7WAAAAAQABDtcAAwAEABgAGAAYACIAAQAYAAAAAQAAAG4AAgABDsgO1gAAAAEAAQ7YAAMABAAYABgAGAAiAAEAGAAAAAEAAABvAAIAAQ7IDtYAAAABAAEO2gADAAQAGAAYABgAIgABABgAAAABAAAAcAACAAEOyA7WAAAAAQABD3QAAQAyADgAAQAMABIAAQAAROYAD3oCegJ6CHoOehp6FHpEeiB6JnosejJPonosejh6PgABAAECmAACAAgCpwKnAAACrQKtAAECrwKvAAICsgKyAAMCtQK1AAQCxgLGAAULCQsJAAYLuQvAAAcAAQLIAuQABAAMAEYADgAARHoAAkR6AAJEegACRHoAAER6AAFEegABRHoAAUR6AAFEegACRHoAA0R6AANEegADRHoAAUR6AFBynHHceMZ0lFFmceJ4zHcuTpxx6HjSdzRP7HHueNh3OlKAcfR42HdAcqJx+njed0ZyqHIGeOp3UnKuchJ49ndecq5yEnj2d15yonH6eN53RnK0chh4/HdkTrRyHnkCd3BRqHIkdjJ3dlKAcfR42HdAUa5yKnkId3xyunIweQ53gkNEcjZ5FHeIcsByPHkad45DznJCeSB2+EPOckJ48HeaUahyJHksd6ByxnJOeTJ3pnLMclR5OHescMhyWnk+ceJOSHJgeUR3XkMgcmZ5RHeyUbRybHWcd7hPvHJIeSZ3lE+8ckh5JneUT7xySHkmd5RytHIYePx3ZHK0chh4/HdkUahyJHYyd3ZRqHIkdjJ3dk+8ckh5JneUQyByZnlEd7JDIHJmeUR3skMgcmZ5RHeyQyByZnlEd7JynHHceMZ0lFFmceJ4zHcuTpxx6HjSdzRP7HHueNh3OlKAcfR42HdATk5yAHjkd0xOcnIMePB3WHKuchJ49ndeTk5yAHjkd0xytHIYePx3ak60ch55AndwUahyJHYyd3ZRrnIqeQh3fENEcjZ5FHeIcsByPHkad45DznJCePB3mlGociR5LHegcsxyVHk4d6xwyHJaeT5x4k5IcmB5RHdeQyByZnlEd7JRtHJsdZx3uHKicfp43ndGUWZx4njMdy5OtHIeeQJ3cFGociR5LHegcuRykHNud9xPvHJIeSZ3lHKWcdZ4wHcoQwhycnlKd75y0nJ4eVB3xE5CcmB5VnfKQ85yQnkgdvhy2HJ+c0p30E5CcmB5VnfKct5yhHlcd9ZPhnKKeIpzaE6cceh40nc0T+xx7njYdzpSgHH0eNh3QFG0cmx1nHe4AAIABAKNApUAAAKXApcACQvCC8QACgv4C/gADQACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAwAAAAEAEgABACgAAQAAAHEAAgADAo0ClQAAApcClwAJC/gL+AAKAAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwADAAAAAQA8AAIARABEAAEAAAByAAMAAAABACgAAgAwAGQAAQAAAHIAAwAAAAEAFAACABwAVgABAAAAcgABAAICjQKRAAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwABAAEClAABAAECkgABALQAugABAAwAEgABAABAiABQP4ZxQnJccRJKkHJocahyaHJ6cmhxYHKAcoZyaHE2cmhyjEpOP4ZyknKYcSRyVnKkcWBygEtESpBKkEqQcWBxYHKGcoZKTnKAcqpygHKqP4ZxQnJccRJKkHJuca5yenJucWBygHKGcTZyjEpOcpJymHJWcqRxYHKAS0RydHJWcZZynnKGSpA/kkpOcRJKkHKAcoZKkHFgS0RxlnEScmJLRAABAAEClgACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAwAAAAEAVAABAFoAAQAAAHMAAwAAAAEAQgACAE4ASAABAAAAcwADAAAAAQAuAAMAOgA6ADQAAQAAAHMAAwAAAAEAGAAEACQAJAAkAB4AAQAAAHMAAQABApYAAQABAqAAAgAIApkCmQAABJUElQABBnUGdQACCEYIRgADCVkJdgAEC/QL9AAiC/YL9gAjD/IP8wAkAAMAAAABAjAAAgI2AjwAAQAAAHQAAwAAAAECHAACAiICOAABAAAAdAADAAAAAQIIAAMCDgIqAiQAAQAAAHQAAwAAAAEB8gACAfgCSAABAAAAdAADAAAAAQHeAAMB5AIAAjQAAQAAAHQAAwAAAAEByAABAiQAAQAAAHQAAwAAAAEBtgADAdgBvAHCAAEAAAB0AAMAAAABAaAABAHCAcIBpgGsAAEAAAB0AAMAAAABAYgABQGqAaoBqgGOAZQAAQAAAHQAAwAAAAEBbgADAZABdAGKAAEAAAB0AAMAAAABAVgABAF6AV4BegF0AAEAAAB0AAMAAAABAUAABAFiAWIBRgFcAAEAAAB0AAMAAAABASgABQFKAUoBLgFKAUQAAQAAAHQAAwAAAAEBDgAFATABMAEwARQBKgABAAAAdAADAAAAAQD0AAYBFgEWARYA+gEWARAAAQAAAHQAAwAAAAEA2AADAPoA3gEuAAEAAAB0AAMAAAABAMIABADkAMgA5AEYAAEAAAB0AAMAAAABAKoABADMAMwAsAEAAAEAAAB0AAMAAAABAJIABQC0ALQAmAC0AOgAAQAAAHQAAwAAAAEAeAAFAJoAmgCaAH4AzgABAAAAdAADAAAAAQBeAAYAgACAAIAAZACAALQAAQAAAHQAAwAAAAEAQgACAGQAngABAAAAdAADAAAAAQAuAAMAUABQAIoAAQAAAHQAAwAAAAEAGAAEADoAOgA6AHQAAQAAAHQAAQABApYAAQABAqAAAgACAo0ClwAAC/gL+AALAAEAAQLjAAIACAKZApkAAASVBJUAAQZ1BnUAAghGCEYAAwlZCXYABAv0C/QAIgv2C/YAIw/yD/MAJAABAAEC0gABAAECzQADAAAAAQM8AAIDQgOCAAEAAAB1AAMAAAABAygAAwOuAy4DbgABAAAAdQADAAAAAQMSAAQDmAOYAxgDWAABAAAAdQADAAAAAQL6AAMDAAO0A7oAAQAAAHUAAwAAAAEC5AAEA2oC6gOeA6QAAQAAAHUAAwAAAAECzAAFA1IDUgLSA4YDjAABAAAAdQADAAAAAQKyAAICuAOCAAEAAAB1AAMAAAABAp4AAwMkAqQDbgABAAAAdQADAAAAAQKIAAQDDgMOAo4DWAABAAAAdQADAAAAAQJwAAMCdgMqA0YAAQAAAHUAAwAAAAECWgAEAuACYAMUAzAAAQAAAHUAAwAAAAECQgAFAsgCyAJIAvwDGAABAAAAdQADAAAAAQIoAAMCLgLiAwQAAQAAAHUAAwAAAAECEgAEApgCGALMAu4AAQAAAHUAAwAAAAEB+gAFAoACgAIAArQC1gABAAAAdQADAAAAAQHgAAMB5gJmAiYAAQAAAHUAAwAAAAEBygAEAlAB0AJQAhAAAQAAAHUAAwAAAAEBsgAFAjgCOAG4AjgB+AABAAAAdQADAAAAAQGYAAQBngIeAlICWAABAAAAdQADAAAAAQGAAAUCBgGGAgYCOgJAAAEAAAB1AAMAAAABAWYABgHsAewBbAHsAiACJgABAAAAdQADAAAAAQFKAAMBUAHQAhoAAQAAAHUAAwAAAAEBNAAEAboBOgG6AgQAAQAAAHUAAwAAAAEBHAAFAaIBogEiAaIB7AABAAAAdQADAAAAAQECAAUBCAGIAbwB5AHqAAEAAAB1AAMAAAABAOgABgFuAO4BbgGiAcoB0AABAAAAdQADAAAAAQDMAAcBUgFSANIBUgGGAa4BtAABAAAAdQADAAAAAQCuAAQAtAE0AWgBhAABAAAAdQADAAAAAQCWAAUBHACcARwBUAFsAAEAAAB1AAMAAAABAHwABgECAQIAggECATYBUgABAAAAdQADAAAAAQBgAAQAZgDmARoBPAABAAAAdQADAAAAAQBIAAUAzgBOAM4BAgEkAAEAAAB1AAMAAAABAC4ABgC0ALQANAC0AOgBCgABAAAAdQADAAEBAAABABIAAAABAAAAdQABAAEClgACAAoGdQZ1AAAJWwldAAEJXwlgAAQJZAlkAAYJZglmAAcJaQlpAAgJbwlvAAkJcglzAAoJdgl2AAwP8g/zAA0AAgAKAqECvQAAAsICygAdAs0C1gAmAtgC4gAwAuQC5wA7BnQGdAA/BncGdwBACwkLCQBBC7kLwABCD+4P8QBKAAIACAKZApkAAASVBJUAAQZ1BnUAAghGCEYAAwlZCXYABAv0C/QAIgv2C/YAIw/yD/MAJAABAAECoAACAAICjQKXAAAL+Av4AAsAAQABAs0AAQABAuMAAQABAtIAAQABAqUAAQABApYAAQABApsAAQTaBRQABwAMAGoAFwABOEoAAThKAAA4SgABOEoAAThKAAE4SgABOEoAAThKAAY4SgABOEoABDhKAAE4SgADOEoAAjhKAAE4SgABOEoAADhKAAE4SgABOEoABThKAAE4SgABOEoAAThKAFE28EVgZopFYHAmRTZmeGhAQ2hDGkNoQcppJGbeaExkgDbMZIBkemkwQh5lrGZsQgZmbEOYQk5m8GheNrRC8Da0Z4xCHmb2aGpmrjd6Zq5p5EJgZvxofGR6QdxkemZsZdBnCGbqNrRC8Da0Z7BnUGcOaIg2tEQKNrRntmlaZxRoamauN3pmrmnkQmBm/GiORVRqwkVUZ7xCYGcaaI5mwEWWZsBqJkJgZyBolGZaQYJprja0aWBnJmbqZIZC8GSGZ7BnUGcOaI5GLEQKRixCKkJIZzJoamauN3pmrmnkQmBm/GhkRNZGLETWZ1xm5Gc4Qq5khm1uZIZBdmlsZxRooGbGQ4ZmxkS4RNZFNmimRixDhkYsZ+xpcmdEaKxmbDeAZmxn8ml4Z0pouEUSQgZFEnBEQY5CYGi+RRI3XEUSQ5hBuDcmaMRFckQKRXJGFGl+Z1ZojkNoasJDaGe8QfpnGmjKRZZwaEWWRKBCSGdcaNZB3GpWQdxmfmbYZ2hoajcacIw3GmY2QmBnDmhqNxpwjDcaZjZCYGcOaGo3GnCMNxpmNkJgZw5ojkVUasJFVGe8QmBnGmiORVRqwkVUZ7xCYGcaaJpmWkGCaa42tGlmZyxommZaQYJprja0aWZnLEKuRVpBpkVacD5pbGc+aMpFlnBuabRwSkJIZ1xo0EWWcGhpukSgaYRnYmjKRZZwdGm0cEpCSGdcaNBFlnBoabpEoGmEZ2I28EVgZopFYHAmRTZmeGhAQ2hDGkNoQcppJGbeaExkgDbMZIBkemkwQh5lrGZsQgZmbEOYQk5m8GheNrRC8Da0Z4xCHmb2aHBmtGpEZrRpeGlIZwJogmWaZ6plmm5YaVRFHmiINrRECja0Z7ZpWmcUaHBmtGpEZrRpeGlIZwJojkVUasJFVGe8QmBnGmiOZsBFlmbAaiZCYGcgaJRmWkGCaa42tGlgZyZojkYsRApGLEIqQkhnMmhkRNZGLETWZ1xm5Gc4Qq5khm1uZIZBdmlsZxRopkYsQ4ZGLGfsaXJnRGisZmw3gGZsZ/JpeGdKaL5FEjdcRRJDmEG4NyZoxEVyRApFckYUaX5nVmiOQ2hqwkNoZ7xB+mcaaMpFlnBoRZZEoEJIZ1xo1kHcalZB3GZ+ZthnaGh2ZrpvlmmoaoZpTmb8aEZmlnBiZpZwLGkqZuRoUmacQipmnHAyaTZm6miyZsxC8GbMabpmrmdQaJRkdHCGaa5wXGlgZyZoajcacIw3GmY2QmBnDjb8ZHRC8GR0N4BkgGbYQbhGFHB6QYJwUGbAZnhlrEHcbaRB3EOGQk5m8GheQzJC3kMyalxCHmb2aI5mWkGUZlpqYkJgZyBolEHccIBprjeAaWBnJmheQzJC3kMyam5CHmcOaI5GLEGIRixwVkH6Zxpo1mbSQdBm0mp6ZthnaEKuRVQ2tEVURRJpbGduaFJmnEIqZpxwMmk2ZupoWGaiQXxmonA4aTxl0GhkZqhB4maoZ4xpQmWgaGRmqGpWZqhmfmlCZ2gAAgAJApsCmwAABnUGdQABCVoJXQACCV8JYQAGCWQJaQAJCW8JcAAPCXIJcwARCXUJdgATD/IP8wAVAAIACAKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARAv3C/cATA/uD/EATQADAAIAFAAaAAEASAAAAAEAAAB2AAEAAQKWAAIABwKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARA/uD/EATAACAAMJWglaAAAJcAlwAAEJdQl1AAIAAwAAAAEA8AABAPgAAQAAAHcAAwAAAAEA3gACARQA5gABAAAAdwADAAAAAQDKAAMBAAEAANIAAQAAAHcAAwAAAAEAtAABAR4AAQAAAHcAAwAAAAEAogACANgBDAABAAAAdwADAAAAAQCOAAMAxADEAPgAAQAAAHcAAwAAAAEAeAABAOgAAQAAAHcAAwAAAAEAZgACAJwA1gABAAAAdwADAAAAAQBSAAMAiACIAMIAAQAAAHcAAwAAAAEAPAABALIAAQAAAHcAAwAAAAEAKgACAGAAoAABAAAAdwADAAAAAQAWAAMATABMAIwAAQAAAHcAAQACCVoJcAACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAgAIApkCmQAABJUElQABBnUGdQACCEYIRgADCVkJdgAEC/QL9AAiC/YL9gAjD/IP8wAkAAEAAQKcAAEAAQvXAAEAAQvYAAMAAQBAAAEARgABAE4AAQAAAHgAAwABACwAAQAyAAIAegCAAAEAAAB4AAMAAQAWAAEAHAACAGQAagABAAAAeAABAAEClgABAAIJWglwAAIACgKhAr0AAALCAsoAHQLNAtYAJgLYAuIAMALkAucAOwZ0BnQAPwZ3BncAQAsJCwkAQQu5C8AAQg/uD/EASgABAAECoAACAAICjQKXAAAL+Av4AAsAAwACAO4A7gABARwAAAABAAAAeQADAAMBDgDaANoAAQEIAAAAAQAAAHkAAwAEAPgA+ADEAMQAAQDyAAAAAQAAAHkAAwACAKwA4AABANoAAAABAAAAeQADAAMAzACYAMwAAQDGAAAAAQAAAHkAAwAEALYAtgCCALYAAQCwAAAAAQAAAHkAAwACAGoA5AABAJgAAAABAAAAeQADAAMAigBWANAAAQCEAAAAAQAAAHkAAwAEAHQAdABAALoAAQBuAAAAAQAAAHkAAwACACgAqAABAFYAAAABAAAAeQADAAIAFACaAAEAQgAAAAEAAAB5AAIABwKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARA/uD/EATAABAAEJaAACAAsCjQKZAAACmwKbAA0ElQSVAA4GdQZ1AA8IRghGABAJWQl3ABEL9Av0ADAL9gv2ADEL+Av4ADIP7Q/tADMP8g/zADQAAQABApwAAQABC9cAAQABC9gAAwADAGQAagBqAAEAmAAAAAEAAAB6AAMABABOAFQAiABUAAEAggAAAAEAAAB6AAMABQA2ADwAcABwADwAAQBqAAAAAQAAAHoAAwAGABwAIgBWAFYAVgAiAAEAUAAAAAEAAAB6AAEAAQKWAAIABwKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARA/uD/EATAABAAEJaAACAAsCjQKZAAACmwKbAA0ElQSVAA4GdQZ1AA8IRghGABAJWQl3ABEL9Av0ADAL9gv2ADEL+Av4ADIP7Q/tADMP8g/zADQAAwACBjgGPgABBmwAAQasAAEAAAB7AAMAAwYiBtYGKAABBlYAAQaWAAEAAAB7AAMAAgYKBhAAAQY+AAIGxgZ+AAEAAAB7AAMAAwauBfIF+AABBiYAAQZmAAEAAAB7AAMABAaWBpYF2gXgAAEGDgABBk4AAQAAAHsAAwADBnwFwAXGAAEF9AACBnwGNAABAAAAewADAAQGYgZiBaYFrAABBdoAAgZiBhoAAQAAAHsAAwADBYoGPgWQAAEFvgACBkYF/gABAAAAewADAAQGLAVwBiQFdgABBaQAAQXkAAEAAAB7AAMABQYSBhIFVgYKBVwAAQWKAAEFygABAAAAewADAAQF9gU6Be4FQAABBW4AAgX2Ba4AAQAAAHsAAwAFBdoF2gUeBdIFJAABBVIAAgXaBZIAAQAAAHsAAwACBQAFBgABBTQAAgXwBfYAAQAAAHsAAwADBOgFnATuAAEFHAACBdgF3gABAAAAewADAAIEzgTUAAEFAgADBYoFvgXEAAEAAAB7AAMAAwVwBLQEugABBOgAAgWkBaoAAQAAAHsAAwAEBVYFVgSaBKAAAQTOAAIFigWQAAEAAAB7AAMAAwU6BH4EhAABBLIAAwU6BW4FdAABAAAAewADAAQFHgUeBGIEaAABBJYAAwUeBVIFWAABAAAAewADAAMERAT4BEoAAQR4AAMFAAU0BToAAQAAAHsAAwAEBOQEKATcBC4AAQRcAAIFGAUeAAEAAAB7AAMABQTIBMgEDATABBIAAQRAAAIE/AUCAAEAAAB7AAMABASqA+4EogP0AAEEIgADBKoE3gTkAAEAAAB7AAMABQSMBIwD0ASEA9YAAQQEAAMEjATABMYAAQAAAHsAAwACA7ADtgABA+QAAgSgBLYAAQAAAHsAAwACA5gDngABA8wAAgSIBKQAAQAAAHsAAwADA4AENAOGAAEDtAACBHAEhgABAAAAewADAAMDZgQaA2wAAQOaAAIEVgRyAAEAAAB7AAMAAgNMA1IAAQOAAAMECAQ8BFIAAQAAAHsAAwADA+4DMgM4AAEDZgACBCIEOAABAAAAewADAAQD1APUAxgDHgABA0wAAgQIBB4AAQAAAHsAAwADA7gC/AMCAAEDMAADA7gD7AQCAAEAAAB7AAMABAOcA5wC4ALmAAEDFAADA5wD0APmAAEAAAB7AAMAAgLCAsgAAQL2AAMDfgOyA84AAQAAAHsAAwADA2QCqAKuAAEC3AACA5gDtAABAAAAewADAAQDSgNKAo4ClAABAsIAAgN+A5oAAQAAAHsAAwADAy4CcgJ4AAECpgADAy4DYgN+AAEAAAB7AAMABAMSAxICVgJcAAECigADAxIDRgNiAAEAAAB7AAMAAwI4AuwCPgABAmwAAwL0AygDPgABAAAAewADAAQC2AIcAtACIgABAlAAAgMMAyIAAQAAAHsAAwAEArwCAAK0AgYAAQI0AAIC8AMGAAEAAAB7AAMABAKgAeQCmAHqAAECGAADAqAC1ALqAAEAAAB7AAMAAgKCAoIAAQH6AAMCggK2AswAAQAAAHsAAwADAawCYAGyAAEB4AADAmgCnAKyAAEAAAB7AAMABAJMAZACRAGWAAEBxAACAoAClgABAAAAewADAAUCMAIwAXQCKAF6AAEBqAACAmQCegABAAAAewADAAQCEgFWAgoBXAABAYoAAwISAkYCXAABAAAAewADAAIBOAE+AAEBbAABAkoAAQAAAHsAAwADASIB1gEoAAEBVgABAjQAAQAAAHsAAwACAQoBEAABAT4AAgHGAhwAAQAAAHsAAwADAa4A8gD4AAEBJgABAgQAAQAAAHsAAwAEAZYBlgDaAOAAAQEOAAEB7AABAAAAewADAAMBfADAAMYAAQD0AAIBfAHSAAEAAAB7AAMABAFiAWIApgCsAAEA2gACAWIBuAABAAAAewADAAMAigE+AJAAAQC+AAIBRgGcAAEAAAB7AAMABAEsAHABJAB2AAEApAABAYIAAQAAAHsAAwAFARIBEgBWAQoAXAABAIoAAQFoAAEAAAB7AAMABAD2ADoA7gBAAAEAbgACAPYBTAABAAAAewADAAUA2gDaAB4A0gAkAAEAUgACANoBMAABAAAAewABAAEClgACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAgAKBnUGdQAACVsJXQABCV8JYAAECWQJZAAGCWYJZgAHCWkJaQAICW8JbwAJCXIJcwAKCXYJdgAMD/IP8wANAAIACgKhAr0AAALCAsoAHQLNAtYAJgLYAuIAMALkAucAOwZ0BnQAPwZ3BncAQAsJCwkAQQu5C8AAQg/uD/EASgABAAICmAKbAAIACAKZApkAAASVBJUAAQZ1BnUAAghGCEYAAwlZCXYABAv0C/QAIgv2C/YAIw/yD/MAJAABAAECoAACAAICjQKXAAAL+Av4AAsAAQABAuMAAQABAtIAAQABAs0AAQGIAcIAAgAMAEYADgAAJuYAACbmAAAm5gAAJuYAACbmAAAm5gAAJuYAACbmAAAm5gAAJuYAACbmAAAm5gAAJuYAACbmAFA0IDHaVYYwqFWAMOQwqDJYUzRWTFVuWKQw3ljaUzRWcFlMVnZVblikVThY4DDeWOYl2ljsUzRWcDJYMOpZUjDeNLxWLllYMDY07FjyWV5Y/iXaVrJZZFkEWWpZCllwNNRVkjN4JVxZEFl2VT5VLFT2VSxU9lUsVPZVOFjgVThY4CXaWOwl2ljsJdpY+CVcWRAlXFkQJVxZECVcWRA0IDHaVYYwqFWAMOQwqDJYUzRWTFgaWDhZRjDeWUxWdlgaWDhVOFjgMN5Y5iXaWOwyWDDqNLxWLllYMDZZXlj+JdpWsllqWQpZcDTUVZIzeCVcWRBZdlU+VW5YpFWGMKgw3ljmJdpWsiV0WUBVLFT2UzQw6ll8WRZVSjJGVZJZHFleWSJZglkoWYhZLlmOWTRWmlk6VYAw5DCoMlhTNFZMWXZVPgACAAkCmQKZAAAJWQlZAAEJXgleAAIJYgljAAMJagluAAUJcQlxAAoJdAl0AAsL9Av0AAwL9gv2AA0AAgAHAqACvQAAAsICygAeAs0C5wAnBncGdwBCCwkLCQBDC7kLwABED+4P8QBMAAMAAAABABIAAQAaAAEAAAB8AAEAAgKZC/YAAQACAo0CkQADAAAAAQASAAEAGgABAAAAfQABAAICmQv2AAIAAgKSApUAAAv4C/gABAADAAAAAQASAAEAGgABAAAAfgABAAICmQv2AAIAAgKOApAAAAKXApcAAwABAEAAVgABAAwAOgALAAAkgAAAXeYAAF3sAABd7AAAJIAAAF3yAABd8gAAXfgAAF34AABd/gAAXfgAAlDCJFIAAgADAo0ClQAAApcClwAJC/gL+AAKAAEAAgKZC/YAAQC0AOgABAAMAEIADQAAJCIAASQiAAEkIgADJCIAASQiAAEkIgABUHQAASQiAAIkIgABUHoAASQiAANQngAAJCIADlAyUEpQXFBuUDJQSlBcUHRQMlBKUFwtoFAyUEpQXDFgUDJQSlBcUG5QMlBQUFxQelAyUEpQXFB6UDJQSlBcUIBQMlBKUFxQgFAyUFBQXFCGUDhQUFBiI4BQOFBWUGIvGlA4UFZQYi8aUDJQSlBcUIAAAgAIApkCmQAACVkJWQABCV4JXgACCWIJYwADCWoJbgAFCXEJcQAKCXQJdAALC/YL9gAMAAIABAKNApUAAAKXApcACQvCC8QACgv4C/gADQABAHgAjgACAAwAHgAEAAAjHgAAIx4AASMeAAEjHgAWT3BP+k9wT/pPcE/6T3BP+k9wT/pPcE/6T3BP+k9wT/pPcE/6T3BP+k+sT9BPsk/WT7hP3E++T+JPvk/oT7JP4k/ET9BPvk/uT6xP9E+sT/RPyk/iT3BP+gACAAMCjQKNAAACkQKSAAEClAKUAAMAAgAKAo0ClQAAApcClwAJCVkJWQAKCV4JXgALCWMJYwAMCWoJbgANCXEJcQASC/QL9AATC/YL9gAUC/gL+AAVAAMAAQA8AAEAQgABAHYAAQAAAH8AAwABAJYAAQAuAAEAYgABAAAAfwADAAEAiAABABoAAQBOAAEAAAB/AAEAAQKWAAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwACAAgCmQKZAAAJWQlZAAEJXgleAAIJYwljAAMJagluAAQJcQlxAAkL9Av0AAoL9gv2AAsAAQABAsIAAQABAsMAAQBwAKQAAgAMAD4ADAAAIZoAACGaAAAhmgAAIZoAACGaAAAhmgAAIZoAASGaAAAhmgAAIZoAACGaAAAhmgAMTmJODk4aTmhOGk5oThpObk5cThRN3k50Td5Oek4OTmhOXE6AThpOhk4aToZNzE4IAAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwACAAgCmQKZAAAJWQlZAAEJXgleAAIJYwljAAMJagluAAQJcQlxAAkL9Av0AAoL9gv2AAsAAwACAD4AcgABAHgAAAABAAAAgAADAAMAbACCAIgAAQBkAAAAAQAAAIAAAwACABQAoAABAE4AAAABAAAAgAACAAgCmQKZAAAJWQlZAAEJXgleAAIJYwljAAMJagluAAQJcQlxAAkL9Av0AAoL9gv2AAsAAQABAo0AAQACCWIJdAACAAMCjQKVAAAClwKXAAkL+Av4AAoAAQABApkAAgAHAqACvQAAAsICygAeAs0C5wAnBncGdwBCCwkLCQBDC7kLwABED+4P8QBMAAEAAQKRAAMAAgB4AKwAAQCyAAAAAQAAAIEAAwACAGQApgABAJ4AAAABAAAAgQADAAIAUACYAAEAigAAAAEAAACBAAMAAgA8AIoAAQB2AAAAAQAAAIEAAwACACgAfAABAGIAAAABAAAAgQADAAIAFABuAAEATgAAAAEAAACBAAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwABAAECkgABAAIJYgl0AAEAAQKTAAEAAQKUAAEAAQKVAAEAAQKXAAEAAQv4AAMAAgBQAIQAAQCKAAAAAQAAAIIAAwACADwAfgABAHYAAAABAAAAggADAAIAKABwAAEAYgAAAAEAAACCAAMAAgBiAHgAAQBOAAAAAQAAAIIAAgAIApkCmQAACVkJWQABCV4JXgACCWMJYwADCWoJbgAECXEJcQAJC/QL9AAKC/YL9gALAAEAAQKOAAEAAgliCXQAAQABAo8AAQABApAAAgADAo0ClQAAApcClwAJC/gL+AAKAAEAAQKZAAMAAAABABIAAQBMAAEAAACDAAIACQZ1BnUAAAlbCV0AAQlfCWAABAlkCWQABglmCWkABwlvCXAACwlyCXMADQl2CXYADw/yD/MAEAACAAkGdQZ1AAAJWwldAAEJXwlgAAQJZAlkAAYJZglpAAcJbwlwAAsJcglzAA0Jdgl2AA8P8g/zABAAAQB8ALYAAQAMAFYAEgAASv4AAEosAABLBAAASwoAAEosAABLEAAASiwAAB3aAABLFgAASiwAAEscAABKLAAASiwAAEscAABKLAAASyIAAEsoAAAd2gASSvBK5ErqSkhK5EpmSkhK8Er2SjxKnEqcSpxK5ErkSuRK6kpIAAIACQZ1BnUAAAlbCV0AAQlfCWAABAlkCWQABglmCWkABwlvCXAACwlyCXMADQl2CXYADw/yD/MAEAACAAkGdQZ1AAAJWwldAAEJXwlgAAQJZAlkAAYJZglpAAcJbwlwAAsJcglzAA0Jdgl2AA8P8g/zABAAAwABAFwAAQCiAAEAqAABAAAAhAADAAEASAABAI4AAgBIAJQAAQAAAIQAAwABADIAAQB4AAMAMgAyAH4AAQAAAIQAAwABABoAAQBgAAQAGgAaABoAZgABAAAAhAACAAsCjQKZAAACmwKbAA0ElQSVAA4GdQZ1AA8IRghGABAJWQl3ABEL9Av0ADAL9gv2ADEL+Av4ADIP7Q/tADMP8g/zADQAAQABApEAAQABAq0AAQAaACIAAQAMABYAAgAAHDwAABw8AAEbbAABAAICnQKeAAEAAQsJAAEACgADAGT/5wABAAEFOwABAAgAAQCCAAEAAQU7AAIAEAADAAL/5//O/+f/zgABAAIC9w1XAAEACgAF+mD92gACAAEOyA7WAAAAAQAMAAf62ABk/doAAgABDsgO1gAAAAEADAAH+ogAZP3aAAIAAQ7IDtYAAAABAAwAB/jGAGT92gACAAEOyA7WAAAAAQAMAAf4xgBk/doAAgABDsgO1gAAAAEACAAB/u0AAgABDsgO1gAAAAEACAAB/u0AAgABDsgO1gAAAAEACAAB/u0AAgABDsgO1gAAAAEACAAB/u0AAgABDsgO1gAAAAEACAAB/u0AAgABDsgO1gAAAAEACgAF+3P92gACAAEOyA7WAAAAAQAMAAf76wBk/doAAgABDsgO1gAAAAEADAAH+5sAZP3aAAIAAQ7IDtYAAAABAAwAB/nZAGT92gACAAEOyA7WAAAAAQAMAAf52QBk/doAAgABDsgO1gAAAAEACAAB/u0AAgABDsgO1gAAAAEADAAH9m4AZP3aAAIAAQ7IDtYAAAABAAwAB/cEAGT92gACAAEOyA7WAAAAAQAMAAf0egBk/doAAgABDsgO1gAAAAEADAAH9HoAZP3aAAIAAQ7IDtYAAAABAAgAAf7tAAIAAQ7IDtYAAAABAAwAB/iUAGT92gACAAEOyA7WAAAAAQAMAAf5KgBk/doAAgABDsgO1gAAAAEADAAH9qAAZP3aAAIAAQ7IDtYAAAABAAwAB/agAGT92gACAAEOyA7WAAAAAQAKAAX8hv3aAAIAAQ7IDtYAAAABAAwAB/q6AGT92gACAAEOyA7WAAAAAQAMAAf7UABk/doAAgABDsgO1gAAAAEADAAH+MYAZP3aAAIAAQ7IDtYAAAABAAwAB/jGAGT92gACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAIAAH+7QACAAEOyA7WAAAAAQAMAAf7zQBk/doAAgABDsgO1gAAAAEADAAH/EUAZP3aAAIAAQ7IDtYAAAABAAwAB/nZAGT92gACAAEOyA7WAAAAAQAMAAf52QBk/doAAgABDsgO1gAAAAECHAIyAAMADAA6AAsAABg8AAIYPAACGDwAAhg8AAAYPAABGDwAARg8AAEYPAABGDwAAhg8AAEYPABQIgpP9CNOIhBGLk0kFzxP+k3SIZhGWE3YI1RGWExYSXZQAEuqTj5HJE3eTXhOjEkWTXhOjEkWSXZQAEuqTZZQDEzKRmpP+kyUFtZF+EymI1RGWExYRvRQEkxYTZxF/kzcJUBQGEz0IhZOek3qSthQHkxwTahQKky+If5QME3YTa5GHE0AJYJGOklqIihN9k32IihQNk38R/xQPE4CIZhQQk4ITaJQJE3wTaJQJE3wTaJQJE3wTZZQDEzKTZZQDEzKFtZF+EymFtZF+EymTaJQJE3wR/xQPE4CR/xQPE4CR/xQPE4CR/xQPE4CIgpP9CNOIhBGLk0kFzxP+k3SIZhGWE3YI1RGWExYTjhGEEzuIcJQBk3kTXhOjEkWTjhGEEzuTZZQDEzKRmpP+kyUFtZF+EymRvRQEkxYJUBQGEz0IhZOek3qTahQKky+If5QME3YJYJGOklqIihN9k32IihQNk38R/xQPE4CIZhQQk4ISXZQAEuqIhBGLk0kRmpP+kyUIf5QME3YTkpOgE4sTaJQJE3wTjJP7kkKIzxJ1k4OTbpPBE4UF6JOkk4aSthQHkxwTkRPsk4gF6JOkk4aTcZPcE4mTZBOqkgUFzxP+k3SIZhGWE3YI1RGWExYIZhQQk4IAAIAAwKNApUAAAKXApcACQv4C/gACgACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAQC4AMAAAQAMABYAAgAAFdwAABXcAFAfjBUqSzwgEEtCS0hLTktUS1RLSEtaH9ofXEtCS1RLYEtmH2IVZktsFUJLckioS3gf7Ei0INYf7B/sH+xLWktaH1wfXB/sSLRItEi0SLQfjBUqSzwgEEtCSJwfXEtUSJxLWh/aH1xLVEtmH2JLbBVCSKhLeB/sSLQg1ktIFSof2hVCReof7CCsH8hLfkuEFWZGFEuES4pLkEs8IBBLQiDWAAEAAgKNApEAAgAHAqACvQAAAsICygAeAs0C5wAnBncGdwBCCwkLCQBDC7kLwABED+4P8QBMAAEAtAC6AAEADAASAAEAABTuAFBIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKSIpIikiKAAEAAQKWAAIABwKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARA/uD/EATAABALQAugABAAwAEgABAAAUBgBQEwREwEXaRJAeDkXmRSZF5kX4ReZE3kX+RgRF5kS0ReZGCh3MEwRGEEYWRKJF1EYiRN5F/h7CHg4eDh4ORN5E3kYERgQdzEX+RihF/kYoEwREwEXaRJAeDkXsRSxF+EXsRN5F/kYERLRGCh3MRhBGFkXURiJE3kX+HsJF8kXURRRGHEYEHg4TEB3MRJAeDkX+RgQeDkTeHsJFFESQReAewgABAAEClgACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAQAsADIAAQAMABIAAQAAEx4ADEQmRDJEPkQyRDJESkQmRDhEREQ4REpELAABAAEClgACAAkCogKiAAACpQKmAAECqQKpAAMCrwKwAAQCzwLPAAYC0gLTAAcC1QLVAAkC2gLaAAoP7g/uAAsAAQFcAXIAAgAMABoAAwAAErIAABKyAAESsgBQRlJLdEZYS3pGXkuARmRLhkZqS4xGcEuSRoJLpEaOS7BGlEu2RnBLkkaaS5JGmkuSRqBLvEaOS7BGmkvCRnBLkkamS8hGrEvORrJL1Ea4S9pGvkvgRsRL5kbKS+xG0EvyRppL+EbWS8JG4kv+RnBLkkZwS5JGcEuSRppLkkaaS5JDUkQeQ1JEHkasS85G1kvCRtxEPEbWS8JG3EQ8RlJLdEZYS3pGXkuARmRLhkZqS4xGdkuYRohLqkaUS7ZGdkuYRppLkkaaS5JGoEu8RppLwkamS8hGrEvORrhL2ka+S+BGykvsRtBL8kaaS/hG1kvCRuJL/kZ8S55GWEt6RppLkka+S+BGoEu8RnBLkkZMREhG6EwERmRLhkZqS4xGmkuSRqBLvEZqS4xGmkv4RuJL/kZeS4BGZEuGRmpLjEbiS/4AAgADCVoJWgAACXAJcAABCXUJdQACAAIABwKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARA/uD/EATAABALgAwAABAAwAFgACAAAREgAAERIAUB58HIQ9nD+ID9A/yj2WD9AP0D/KHnA/3D92PaIfSD/KHfI9oj/iH0g/iB4uHi4ejhyEHrIa+BA2EDYQNh5wHnA/dj92HnYesh6yHrIesh58HIQ9nD+ID9A/0D62D9A/0B5wP9w/dh9IHfI9oh9IP4geLh6OHIQeshr4P9Y/sj+4P+g9kBA2PZAfMBr4HE4/dhr4HE4fSD/uP7g/vj/EP8QAAQACCVoJcAACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAQAwADgAAQAMABYAAgAAECQAABAkAAxBCkEQQRZBEEEQQSJBChnOQRwZzkEiPsoAAQACCVoJcAACAAkCogKiAAACpQKmAAECqQKpAAMCrwKwAAQCzwLPAAYC0gLTAAcC1QLVAAkC2gLaAAoP7g/uAAsAAQC0ALoAAQAMABIAAQAAD7IAUB0gGyg8QD4sDnQ+bjw6DnQOdD5uHRQ+gD4aPEYd7D5uHJY8Rj6GHew+LBzSHNIdMhsoHVYZnA7aDtoO2h0UHRQ+Gj4aHRodVh1WHVYdVh0gGyg8QD4sDnQ+dD1aDnQ+dB0UPoA+Gh3sHJY8Rh3sPiwc0h0yGygdVhmcPnpBSkFQQWI8NA7aPDQd1BmcGvI+GhmcGvId7D6SQVBBVkFcQVwAAQABCWgAAgAHAqACvQAAAsICygAeAs0C5wAnBncGdwBCCwkLCQBDC7kLwABED+4P8QBMAAEALAAyAAEADAASAAEAAA7KAAxDLEMyP7pDMkMyOQZDLEM4Qz5DODkGQGgAAQABCWgAAgAJAqICogAAAqUCpgABAqkCqQADAq8CsAAEAs8CzwAGAtIC0wAHAtUC1QAJAtoC2gAKD+4P7gALAAEAZACkAAEADABKAA8AAA5eAAAOXgAADl4AAA5eAAAOXgAADl4AAA5eAAAOXgAADl4AAA5eAAAOXgAADl4AAA5eAAAOXgAADl4ADEJqQnANTkJwQnBCgkJqQnZCfEJ2QoI80AACAAoGdQZ1AAAJWwldAAEJXwlgAAQJZAlkAAYJZglmAAcJaQlpAAgJbwlvAAkJcglzAAoJdgl2AAwP8g/zAA0AAgAJAqICogAAAqUCpgABAqkCqQADAq8CsAAEAs8CzwAGAtIC0wAHAtUC1QAJAtoC2gAKD+4P7gALAAEAuADAAAEADAAWAAIAAA2AAAANgABQRN5E5ETqRPBE9jzIO5BFCEUIPMg7nD0iRQ5E9kUURAZAEEUaRSBFIEUORCRFLEUyRJxFOESoRSZFJkUmO5w7nEUORQ5FJkU4RThFOEU4RN5E5ETqRPBE9kT8RQJFCET8O5w9IkUORRRAEEUaRSBFDkUsRTJEnEU4RKg8yETkPSJFDkVQRSY9NEU+RUREckUgREJEckVKRH5E6kTwRPZEqAABAAICmQv2AAIABwKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARA/uD/EATAABALgAwAABAAwAFgACAAAMkgAADJIAUELQQtZC3ELiQuhC7kL6QwBDAELuQiJDBkMMQuhDEkMYQx5DJEMqP0xDDEM2QzxC4kNCQ0hDTkMwQzBDMEIiQiJDDEMMQzBDSENIQ0hDSELQQtZC3ELiQuhC9D5QQwBC9EIiQwZDDEMSQx5DJD9MQwxDPELiQ0JDSENOQu5C1kMGQwxDckMwQspDVENaQ0JDKkNgQ0JDZkNsQtxC4kLoQ04AAQACApkL9gACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAQC4AMAAAQAMABYAAgAAC6QAAAukAFBCkEKWQpxB9EKiPdpCTkKoQqg92kE0Qq5B3EKiQrRCKkK6QsBCxj5eQdxCSELMQtJCVELYQt5ChEKEQoRBNEE0QdxB3EKEQthC2ELYQthCkEKWQpxB9EKiO6w7lEKoO6xBNEKuQdxCtEK6QsA+XkHcQsxC0kJUQthC3j3aQpZCrkHcQvxChEKKQuRC6kLwQsZC0kLwQnhC9kKcQfRCokLeAAEAAgKZC/YAAgAHAqACvQAAAsICygAeAs0C5wAnBncGdwBCCwkLCQBDC7kLwABED+4P8QBMAAEA4AEUAAEADAA+AAwAAAq2AAAKtgAACrYAAAq2AAAKtgAACrYAAAq2AAAKtgAACrYAAAq2AAAKtgAACrYAUBQOOWoJTDpyOnIUvBQ4FM4UzhS8QzYX+EAYFM4UXD0qGMQ9WhQaOmw/7j08PU5DPBYeFh4J6BguGC4YLkM2QzZAGEAYGC4WHhYeFh4WHhQOOWoJTDpyOnJDMBRiFM5DMEM2F/hAGBRcGMQ9WjpsP+49TkM8Fh4WHgnoFLw5ahf4P+4VshguQyoJ3ENCQ0gUGhYeQ0hDTkMYCUw6cjpyCegAAgAIApkCmQAACVkJWQABCV4JXgACCWMJYwADCWoJbgAECXEJcQAJC/QL9AAKC/YL9gALAAIABwKgAr0AAALCAsoAHgLNAucAJwZ3BncAQgsJCwkAQwu5C8AARA/uD/EATAABADAAOAABAAwAFgACAAAJdAAACXQADBd6CPgI+Aj4CPgI+Aj4CPgI+Aj4CPgTnAABAAIJYgl0AAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwABADAAOAABAAwAFgACAAAJCAAACQgADBZsB64HrgeuB64HrgeuFEQHrgeuB64WbAABAAIJYgl0AAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwABADAAOAABAAwAFgACAAAInAAACJwADBPYEtAS0BLQEtAS0BLQCCYS0BLQEtAT2AABAAIJYgl0AAIACAKZApkAAAlZCVkAAQleCV4AAgljCWMAAwlqCW4ABAlxCXEACQv0C/QACgv2C/YACwABAPgBMgABAAwAVgASAAAIMAAACDAAAAgwAAAIMAAACDAAAAgwAAAIMAAACDAAAAgwAAAIMAAACDAAAAgwAAAIMAAACDAAAAgwAAAIMAAACDAAAAgwAFA3bhJmNG4TLDeGN5IR1jeqN7A3kje2N7w3yDeqEiQ3kjfON9Q32jfmN+w3+BJmEXA3tjf+Nng3pDekN6Q3tje2N8g3yDfgOAQ4CjgEOAo3bhJmNG4TLDeGN5g3pDewN5g3tje8N8gSJDfON9Q35jfsEmYRcDe2N/42eDeeN3Q3wjfyODQ3pBIkOBYTgDgcOCIUBDgoOC4Umjd6N4A3jDgQAAIACQZ1BnUAAAlbCV0AAQlfCWAABAlkCWQABglmCWkABwlvCXAACwlyCXMADQl2CXYADw/yD/MAEAACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAQC0ALoAAQAMABIAAQAABtAAUDO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74zvjO+M74AAQABApEAAgAHAqACvQAAAsICygAeAs0C5wAnBncGdwBCCwkLCQBDC7kLwABED+4P8QBMAAH/EwYOAAH+3QYOAAEACQS/AAEAAAS2AAECrQdEAAECowdEAAEClAYUAAECwQYUAAEC7gYUAAEC2gdEAAEDGwYUAAEDwAYUAAEC0AYUAAEDzwYUAAEDKgYUAAECKwTDAAECRATDAAECSQTDAAECSQYUAAEB/gTDAAEC0ATDAAEB6gTDAAECwQTDAAECdgTDAAECOgYUAAEB/gYUAAEDDAYUAAECPwTDAAH/8QLxAAEDIAW4AAEEjgSsAAEFLAS6AAEE7QSsAAEEvwW4AAEEdwW4AAEFWwSqAAEE/gW4AAEBegW4AAEDTgW4AAEEmwW4AAEBTQW7AAEGEgW4AAEFAQW4AAEFbQSsAAEEwgSsAAEFWASsAAEFDQSsAAEEegSqAAEEoQW4AAEFCgW4AAEFEwW4AAEHSgW4AAEE4wW4AAEEegW4AAEDogOiAAEDzwOiAAEDnwOKAAED1QWyAAEDwAOiAAECUgXKAAED5AQjAAEDtwOiAAEBLAQmAAEBLwQmAAEDNgQmAAEBJgWyAAEGEgOiAAEDnwOrAAEDwwQmAAECfwQdAAEDXQOsAAEB9QQ1AAEDvQQmAAEDkwQmAAEFcwQmAAEDZgQmAAEDnAQmAAEDsQQmAAEGXgOiAAED/AOiAAEG4AOiAAEBbgQmAAEEBgOiAAED6gQmAAEDUgOiAAEDGAOrAAEDIAOiAAEDhAOiAAEBOwQoAAEBLAQoAAEF8QQoAAED0gQoAAEELAQoAAECcQQoAAEEgAPYAAEBhgQoAAEBXgQoAAEDygQoAAEDrAQoAAEAGwFWAAEAAAFWAAEACQFWAAEACAHaAAH/7gK1AAECOgIwAAEA5gHCAAEA3AMbAAEDnACWAAEB4AImAAEB/gImAAEDGwLuAAECMAImAAECngLuAAEChQNIAAEDDALuAAEC7gLuAAEC3wNIAAECowNIAAEC0ALuAAEBHQLuAAEC+ALuAAEA+gMgAAEA+gLuAAEDZgLuAAEDKgLuAAEC0AQaAAEDIALuAAEC7gQaAAECqALuAAECZwLuAAEC2gLuAAEDygLuAAECowLuAAECWALuAAECKwFFAAECTgImAAECKwImAAECOgImAAEBBAImAAECJgImAAEA5gSwAAEA5gImAAEA4QImAAEA5gMgAAEDZgImAAECPwImAAECWAImAAEA8AImAAEB9AImAAEC3wImAAH/8AQyAAEETAVuAAEEsAW0AAEDawOiAAEDdQQaAAEDZgOiAAEDkwQaAAEDogQaAAEEsAVuAAEEvwW0AAEEzgW0AAECowW0AAEDKgW0AAEEGgVuAAED6AVuAAEEdAW0AAEEGgW0AAEEoQW0AAEBHQW0AAEDDAW0AAEEgwW0AAEFcwW0AAEEOAVuAAEEkgVuAAEEVgVuAAEDwAVuAAEEagW0AAEHFwW0AAEEkgW0AAEEKQW0AAEDkwW0AAEB/gW0AAEA/wQaAAEDDAQaAAEA4QW0AAEFwwOiAAEDegOiAAEDhAQaAAECZwQzAAEDBwOiAAEBEwVfAAEFNwQaAAEDOQQaAAEDZgQaAAEDSAQaAAH/4gAAAAECnv/OAAEDFv/xAAECvAAAAAEDIP/xAAEBHQAAAAECo//OAAECWAAAAAEC1f/OAAECsv/OAAECiv/xAAECbAAAAAEC1f/xAAEB9P/xAAECMP/xAAECRP/xAAECEv5cAAEA3AAAAAEB9P/OAAEA0gAAAAECJv/OAAECJv/xAAEB6v/xAAEBdwAAAAEB/gAAAAEBRQAAAAEBBAAAAAEAwwAAAAEAWgBkAAEDUgB4AAEDIABpAAEDjgAAAAEC7v62AAEDegAAAAEA3P8GAAEDcAAAAAEF0gAAAAEDUgBpAAEDhP6iAAECowAyAAEBwgAAAAEDhAAAAAEEHwAAAAEDdQAAAAEDegBpAAH9S/9+AAEAAP+IAAEAAP+cAAEAAP+wAAEAAP9qAAEAAP8uAAEAAP+1AAEAAP/OAAEABf9qAAEAAP90AAEAAP9RAAEAAP7tAAEAAP/EAAEAAP9+AAEAAAAAAAH9S/5cAAEAAP34AAEAAP5cAAH+1wX+AAH92wYMAAH+7wYLAAH+7QYLAAEAAASqAAEAAATLAAEAAAYeAAEAAAS/AAEAAAT2AAEAAAR/AAH/tQSqAAEAAARuAAEAaQSqAAEAAAS1AAEAAAPzAAEAAAS6AAEAAAXsAAEAAATDAAEAAAPpAAEAAATOAAEAAAShAAEAAARaAAEAAAHCAAEAAARqAAEAAASwAAH/7AR/AAEAFAR/AAH/8QR/AAEAAARgAAEAAATEAAEAAAR0AAH+4geWAAH95Ac6AAH+7wdsAAH+4gdsAAEAAAZAAAEAAAXcAAEAAAbvAAEAAAYOAAEAAAa9AAEAAAbWAAEAAAZyAAEAAAakAAEAAAeFAAEAAAc6AAEAAAcIAAEAAAUUAAEAAAYiAAEAAAX6AAEAAAZtAAEAAAZ8AAEAAAZDAAEAAAaBAAECWAWgAAECWAXBAAEFVgg0AAEFxwg0AAEE4wg0AAEGOQg0AAECOQg0AAEEAAg0AAEEcwg0AAEGqgg0AAEHjQg0AAEBxwg0AAECqgg0AAEIAAg0AAEHHQg0AAEAAAg0AAEE6wg0AAECVQg0AAECrAg0AAEDAAg0AAEF4Qg0AAEDjQg0AAEE1Qg0AAEFyQg0AAEG3Ag0AAEFPwg0AAEGBQg0AAEGEQg0AAEFQAg0AAEGegg0AAEEdAg0AAEE/gg0AAEHDAg0AAEHIAg0AAEG8gg0AAEFVwg0AAEGCQg0AAEG1Qg0AAEFWwg0AAEE8gg0AAEDCwg0AAEF+wg0AAEGLgg0AAED5Qg0AAEF6Qg0AAEDqwg0AAEFDQg0AAEEDwg0AAEEeAg0AAEEAgg0AAEE7wg0AAECngg0AAECbgg0AAEEkwg0AAEEbAg0AAEGUwg0AAEGPwg0AAEEZgg0AAEEVQg0AAECFAg0AAECywg0AAEEjAg0AAEEYAg0AAEEKAg0AAEEVAg0AAEEXAg0AAEEQAg0AAEEawg0AAEDLgg0AAEDOwg0AAEHtwg0AAEHQAg0AAEICwg0AAEFswg0AAEDbwg0AAEFwAg0AAEGHAg0AAEFSgg0AAEFDwg0AAED4gg0AAEEOAg0AAEFfwg0AAEKqgg0AAEJxwg0AAEIZAg0AAEIfwg0AAEDnAg0AAEHjgg0AAEGKwg0AAEIRgg0AAEDfgg0AAEFpgg0AAEE1gg0AAEEhgg0AAEFdAg0AAEFegg0AAEC8Ag0AAEHGAg0AAEEpQg0AAEGSQg0AAEFtAg0AAEDGAg0AAEFNAg0AAEDoAg0AAEFWAg0AAEF5gg0AAEFMAg0AAED6wg0AAH/WwWgAAH/WwXBAAECfwXBAAECfAWgAAECYQWyAAEBpwYPAAEFVgdsAAEFxwdsAAEE4wdsAAEGOQdsAAECOQdsAAEEAAdsAAEEcwdsAAEGqgdsAAEHjQdsAAEBxwdsAAECqgdsAAEFVgiYAAEFxwiYAAEGOQiYAAEIAAdsAAECOQiYAAEHHQdsAAEE4wiYAAEAAAdsAAEE6wdsAAEEcwiYAAECVQdsAAECrAdsAAEDAAdsAAEF4QdsAAEDjQdsAAEE1QdsAAEFyQdsAAEG3AdsAAEFPwdsAAEGBQdsAAEGEQdsAAEFQAdsAAEGegdsAAEEdAdsAAEE/gdsAAEHDAdsAAEHIAdsAAEG8gdsAAEFVwdsAAEGCQdsAAEG1QdsAAEFWwdsAAEE8gdsAAEDCwdsAAEF+wdsAAEGLgdsAAED5QdsAAEF6QdsAAEDqwdsAAEFDQdsAAEEDwdsAAEEeAdsAAEEAgdsAAEE7wdsAAECngdsAAECbgdsAAEEkwdsAAEEbAdsAAEGUwdsAAEGPwdsAAEEZgdsAAEEVQdsAAECFAdsAAECywdsAAEEjAdsAAEEYAdsAAEEKAdsAAEEVAdsAAEEXAdsAAEEQAdsAAEEawdsAAEDLgdsAAEDOwdsAAEHtwdsAAEHQAdsAAEICwdsAAEFswdsAAEDbwdsAAEFwAdsAAEGHAdsAAEFSgdsAAEFDwdsAAED4gdsAAEEOAdsAAEFfwdsAAEHjQiYAAEG3AiYAAEG1QiYAAEEAAiYAAEBxwiYAAEGqgiYAAEKqgiYAAEJxwdsAAEIZAdsAAEIfwdsAAEDnAdsAAEHjgdsAAEGKwdsAAEIAAiYAAEKqgdsAAEIRgdsAAEDfgdsAAEFpgdsAAEE1gdsAAEEhgdsAAEFdAdsAAEFegdsAAEC8AdsAAEHGAdsAAEEpQdsAAEGSQdsAAEFtAdsAAEDGAdsAAEFNAdsAAEDoAdsAAEFWAdsAAEF5gdsAAEFMAdsAAED6wdsAAH/W//iAAH/Vf/BAAH/TAAAAAECq/5NAAEC4/5NAAECcf5NAAEDHP5NAAEBHP5NAAECAP5NAAECOf5NAAEDVf5NAAEDxv5NAAEA4/5NAAEBVf5NAAEEAP5NAAEDjv5NAAEAAP5NAAECdf5NAAEBKv5NAAEBVv5NAAEBgP5NAAEC8P5NAAEBxv5NAAECav5NAAEC5P5NAAEDbv5NAAECn/5NAAEDAv5NAAEDCP5NAAECoP5NAAEDPf5NAAECOv5NAAECf/5NAAEDhv5NAAEDkP5NAAEDef5NAAEDBP5NAAEDav5NAAECrf5NAAECef5NAAEBhf5NAAEC/f5NAAEDF/5NAAEB8v5NAAEC9P5NAAEB1f5NAAEChv5NAAECB/5NAAECPP5NAAECAf5NAAECd/5NAAEBT/5NAAEBN/5NAAECSf5NAAECNv5NAAEDKf5NAAEDH/5NAAECM/5NAAECKv5NAAEBCv5NAAEBZf5NAAECRv5NAAECMP5NAAECFP5NAAECLv5NAAECIP5NAAECNf5NAAEBl/5NAAEBnf5NAAED2/5NAAEDoP5NAAEEBf5NAAEC2f5NAAEBt/5NAAEC4P5NAAEDDv5NAAECpf5NAAECh/5NAAEB8f5NAAECHP5NAAECv/5NAAEFVf5NAAEE4/5NAAEEMv5NAAEEP/5NAAEBzv5NAAEDx/5NAAEDFf5NAAEEI/5NAAEBv/5NAAEC0/5NAAECa/5NAAECQ/5NAAECuv5NAAECvf5NAAEBeP5NAAEDjP5NAAECUv5NAAEDJP5NAAEC2v5NAAEBjP5NAAECmv5NAAEB0P5cAAECq/5cAAEC4/5cAAECrP5cAAECOf5cAAECAP5cAAEA4/5cAAEC8/5cAAEBVf5cAAEBHP5cAAECmP5cAAEB9f5cAAEAKP/2AAEEvwAAAAEDIAAAAAEDtgAAAAEC+AAAAAEEVgAAAAEA8AAAAAEEBgAAAAEEnAAAAAECOgAAAAEDrAAAAAEFqgAAAAEEiAAAAAEA5gAAAAEFAAAAAAEDXAAAAAEClAAAAAEFbgAAAAEEpgAAAAECigAAAAEEGgAAAAECxgAAAAECqAAAAAEC0AAAAAEA+gAAAAECvP5wAAEDZgAAAAEApf56AAEA0v5wAAEDcP5wAAEBXgAAAAEB4AAAAAEDUgAAAAEBSv5wAAEDPgAAAAEDNP5wAAEHCAAAAAEBIgAAAAEBDQAAAAECWP5wAAEBVAAAAAEBDgAAAAEFeAAAAAECsgAAAAEA0v5cAAEHHAAAAAEF8AAAAAEBGAAAAAEC0P5wAAECRP5wAAEFPP5wAAEEBv5wAAEEsP5wAAEC+P5wAAEAtAAAAAECnv5IAAEBfP5IAAEChf56AAEDzwAAAAEDhP5wAAEBaP5wAAEBQP5wAAEFFAAAAAEBDv5wAAEE2AAAAAED6AAAAAEDIP5cAAEBVP5cAAEDrP5wAAED1P5wAAEBrv6iAAED0AAAAAEDNAAAAAEETAAAAAEDAv5wAAEB4wAAAAEC7gAAAAEAtP5cAAEC7v5wAAEFWgAAAAEA4wAAAAEGGAAAAAEDcP5cAAEFyP5cAAEETP5cAAEBpAAAAAEEnP7UAAECiv5cAAEBpP6iAAEDNP5cAAEDogAAAAEDDP5wAAEDDP5cAAECdgAAAAEDcABkAAEBBP7AAAEAyP7AAAEC+P7AAAECEv7AAAECvP7AAAECgP7AAAECdv7AAAECMP7AAAECvP7UAAECWP7UAAEClP7AAAECqP7UAAECgP5wAAECJv5wAAECbP5wAAEC7v6iAAECbP6iAAEDmAAAAAEE4gAAAAECnv6EAAEBXv6iAAEBBP6iAAEA0v7UAAECxv7UAAEA+v7UAAECiv5wAAEA8P5wAAEC7v7UAAEBSv7UAAEBVP7UAAEDIP7UAAECgP7UAAEBzP7UAAECiv7UAAEBgP7UAAEBXv5cAAECOf5wAAEDIP6iAAECOf6iAAEC+P5cAAECCP5cAAEB4P7UAAEEPQAAAAEC1f7UAAECZP7UAAECnf7UAAECyAAAAAEEGv5cAAEBHP6iAAECRP5cAAEDhP5cAAEBQAAAAAEBVP5wAAECvP5cAAEFyAAAAAEFtP5wAAEFeP5wAAEEEP5wAAEFiwAAAAEExAAAAAECEv5wAAEBzAAAAAECOv5wAAEBuAAAAAEBkP5cAAEAyP6iAAEBGP6iAAEBcgAAAAEBaABkAAEBcv5wAAEFRgAAAAED6P5wAAEBrgAAAAECJgAAAAECRAAAAAEDXAAJAAEBhv5cAAECMAAAAAEG9AAAAAEFjP5wAAEG1gAAAAECYv6iAAEE7P5wAAEC2gAAAAEEjf5cAAEFjP5cAAEJ2AAAAAEI8gAAAAEHlAAAAAEGuAAAAAEFjP56AAECbP56AAEH5AAAAAEGXv56AAEFAP56AAECqP5wAAEDyv5wAAEC2v5wAAEGngAAAAEA5v5wAAEBLAAAAAECCP8GAAEB6v8GAAEEhP5wAAEDDAAAAAEDwP6iAAEBQABGAAEFZAAAAAECEgAAAAECbwHcAAEDHf5wAAEDmP5wAAEBGP5wAAEDXP5wAAEA+v5wAAEF3P5wAAEDov5wAAEAlv5wAAEC5P5wAAEDUv5wAAEEfv5wAAEEav5wAAEEGv5wAAEETP5wAAEDtv5wAAECqAAyAAEB1v5wAAEBBP5wAAEAjP5wAAEFzf5cAAEEgP5cAAECAAAAAAEDHAAAAAEDIwAAAAECcQYUAAECigYUAAECowYUAAEDIAYUAAEC1QYUAAEBIgYUAAEC+wYUAAECdgYUAAEDUgYUAAEDBwYUAAECqAYUAAECcQYdAAECIQTDAAECIQYUAAECJgTDAAECEgYUAAEBkAYUAAECRAYUAAEA6wYUAAEA4QYUAAECJgYUAAEA3AYUAAEDZgTDAAECOgTDAAECMATDAAEBpATDAAEBEwYUAAEB9ATDAAEC3wTDAAEClAdEAAECowdsAAEC1QdEAAEDIAdEAAEFFAYUAAEClAdsAAECngdEAAECvAdsAAECywdEAAEBLAdsAAEBIgdsAAEBIgdEAAEA+gdsAAEDIAdsAAEC1QdsAAECSQZUAAEBaAYUAAEBBAYUAAECMAYUAAEDhATDAAECbATDAAECCAYUAAEETAYUAAEDtgTDAAEBLATDAAECqAdsAAEB9AYUAAECcQdsAAEDPgdsAAEDKgdsAAEDDwdsAAECFwYUAAECmgYUAAECNwTDAAECigdsAAECQAXvAAECrAYUAAECvgdiAAECWAdsAAEA6wdsAAECWAYUAAECNQYUAAEDKQdsAAEBcgYUAAECbAYUAAEA/wYUAAECgAdsAAEC2gdsAAECDQZUAAECDAYUAAECAwYUAAEB0QYUAAECigXcAAECKwYUAAEDAgdsAAEDLwdsAAECvAdEAAECxgdsAAECTgYUAAEDSAdsAAECHAYUAAEDXAdsAAECJgZUAAEC8wdsAAECewdsAAECywYUAAEBJwdsAAEBGAYUAAEBJwYUAAEDDAdsAAEA0gYUAAEC5AYUAAECEgTDAAECsgYUAAEBfATDAAEC7gdsAAEC7gdEAAEC2gYUAAEDzwdsAAEC6QYUAAECsgdsAAEC3wYUAAECgAYUAAECPwX/AAECvAYUAAEDBwaLAAECJgUUAAEDOQaLAAEDhAYUAAEBLAYUAAEC+AYUAAEDkwYUAAECWATDAAECowTDAAECigZFAAEBQAYUAAEDegYUAAECTgTDAAEBzATDAAECDQYUAAEB4ATDAAECDQTDAAEB+QTDAAEA6wTDAAEBXgYUAAEDUgTDAAEDawTDAAEDBwTDAAEBwgTDAAEBwgYUAAEA8ATDAAEB2wYUAAEAlgYUAAEA5gYUAAECRAWCAAECPwYUAAEFqgYUAAEFkQYUAAEB9AYYAAED6AYUAAECHAZUAAECvATDAAECngYUAAECFATDAAECSQZ8AAECRAZ8AAEBHQdsAAEA5gZ8AAEBHQYUAAEC7gZjAAECCATDAAECCAZ8AAECdgdsAAEChQYUAAECUwYUAAEBrgdsAAEC0AdsAAECPwdsAAECRAdsAAECcQdEAAEA6wdEAAEDVwdsAAEDXAYUAAEDXATDAAEBgQYUAAEBgQTDAAEB7wYUAAEB7wTDAAEB7wdsAAECAwTDAAEC6QZ8AAEB9AZ8AAEBkAdsAAEIPgdsAAEHngYUAAEGSgYUAAEHbAYUAAEFyAYUAAECrQYUAAEIsQYUAAEGlQYUAAEFPAYUAAEFFAdsAAEDcAYUAAEB9AdsAAEIXAYUAAEHvATDAAEGaATDAAEDNAdsAAEBfAYUAAEBkATDAAECJgdsAAECYgYUAAECrQdsAAEDjAYUAAEDjATDAAEClAZ4AAEC7gZ4AAECJgWLAAECcQZ4AAECUgY4AAEBmQTDAAECOQUGAAEBhQUMAAECOgTuAAEEZgZ4AAEA4wTuAAEA6wTuAAECMATuAAECRgTuAAECAATDAAECLgTuAAEA3ATDAAEA4QTDAAEBuAUGAAECnwYUAAECRAYeAAEC8wZ3AAECOQTDAAECIQYeAAEBEwYeAAECmAUIAAEB9QTuAAEE4gYUAAEEsAYUAAEEfgYUAAEBdwYUAAEDygYUAAEGDgYUAAEE+wYUAAEFAAYUAAEFLQYUAAEElwYUAAEDogTDAAEDzwTDAAEEGgTDAAEF+gTDAAED3gTDAAEECwTDAAEEOATDAAEDGwTDAAEDdQTDAAEBwgXzAAED7QTDAAED6ATDAAED8QTDAAEETAZAAAED6AZAAAEEsAZ4AAEE+wZAAAEFFAZAAAEFAAZAAAEHcQYUAAEFeAYUAAED6AZ4AAEETAZ4AAEFFAZ4AAEEGgZ4AAECigZ4AAECvAZAAAECJgZ4AAEFAAZ4AAEFZAZ4AAEFLQZ4AAEDogUUAAED6AUUAAEDzwUUAAECowUUAAECPwUUAAEC7gUUAAECvAUUAAEEJAUUAAED3gUUAAEECwUUAAEGpAUUAAEFFAUUAAEHtwYUAAEHFwTDAAEFVQZ4AAEEzgZ4AAEDdQUUAAEFeAZ4AAEEGgUUAAEB9AZ4AAEFRgZ4AAEDtgUUAAED+QZ4AAED+QYUAAEE0QYUAAEEAgTDAAEErQZ4AAEDygZ4AAECHAZ4AAEDtgYUAAED/AUUAAEFkQZ4AAEEKQUUAAEC0AUUAAEDkwUUAAECWAXzAAEDGwXzAAEEOAUUAAEEVgUUAAED1AUUAAEFoAYUAAEDZgYUAAEETATDAAEFVQZAAAEE4gZ4AAEFVQYUAAEERwZ4AAED/AYUAAEC5AUUAAEC0AZ4AAECvAZ4AAEEgwZ4AAECOgUUAAED/ATDAAED7QUUAAECKwXzAAEHjwZ4AAEF3AUUAAEEdAYUAAEG1gYUAAEEgwTDAAEFvgYUAAED3gYUAAEDsQYUAAEEnAYUAAEEKQYUAAEFNwYUAAEGzAYUAAEFKATDAAEF+gYUAAEFKAYUAAEE3QYUAAEEgwYUAAEEkgYUAAEG+QYUAAEFggYUAAEGnwYUAAEFRgYUAAEEGgYUAAEGNgYUAAEFjAYUAAEGrgYUAAEFcwTDAAEFZAYUAAEFCgYUAAEFwwYUAAEGWQYUAAEEVgTDAAEEMwTDAAEE4gTDAAEDnQTDAAECHATDAAEEKQTDAAEE3QTDAAEERwTDAAEGQATDAAEEAQTDAAEGDgTDAAEF3ATDAAECZwTDAAEC/QTDAAEDwATDAAEDnQYUAAEEsATDAAEDIATDAAEE9gTDAAEDmATDAAEFRgTDAAECigTDAAEHhQTDAAEG+QTDAAEHbATDAAEEMwYUAAEFqgTDAAEFkQTDAAEE7ATDAAEFFATDAAEHjwYUAAEF6wTDAAEHgAYUAAEFvgTDAAEDogUnAAEDzwUnAAECgAZTAAECOgUnAAED3gUnAAED6AUnAAED7QSSAAEGCQTDAAEGJwYUAAEGVATDAAEGRQYUAAEGGATDAAEEzgYUAAEEvwYUAAEE7AYUAAEFoATDAAECxgYUAAEFoAUnAAED7QUnAAEDwAUnAAECZwYUAAEEOAZAAAECigZAAAECbAUUAAEFeAZAAAEFRgZAAAEDfwTDAAEKWgZAAAEJkgTDAAEINATDAAEIAgYUAAEGcgYUAAEJLgYUAAEHOgYUAAEF3AYUAAEHowZAAAEFUAZAAAEEGgZAAAEFqgZAAAEEsAZAAAEEAQUUAAECWAUUAAEKcwYUAAEH0AYUAAEEZQZAAAEE4gZAAAEEBgUUAAEFNwZAAAEDGwUUAAEFSwZAAAEERwYUAAEFMgZAAAEGYgYUAAEGYgTDAAEFYwZ4AAEEyAYMAAED3QXUAAEDcgTDAAEEcwQ+AAEDCwSoAAEEdASKAAEFqAYUAAEBxwSKAAED/ASKAAEEjASKAAEEXASKAAEBXgTDAAEDPAQ+AAEEcwUnAAEFggY4AAEEDwSiAAEEcgUnAAEB1QYMAAEEAATDAAEEaATDAAED6wTuAAH9Tv+IAAEAAP+BAAEAD/+IAAEAD/+1AAEAAP82AAEAAP+/AAEAAP/JAAEAAP+DAAEAAP9sAAEAAP9QAAEAAP7rAAEAAP+MAAH/8f+1AAH/9v/UAAEAAP+SAAEAAP/cAAECnv+IAAECcf+IAAEDFv+IAAECiv+IAAECvP+IAAEDOf+IAAEC1f+IAAEBIv+IAAEBzP+IAAECWP+IAAEDUv+IAAEDIP+IAAEClP+IAAEDDP+IAAEC7v+IAAECdv+IAAECqP+IAAEDz/+IAAECo/+IAAECmf+IAAECMP+IAAECJv+IAAECRP+IAAEBCf+IAAECJv3ZAAEA6/+IAAEAeP3ZAAEA4f+IAAEDZv+IAAECP/3ZAAEB6v+IAAEBXv+IAAEB/v+IAAEC3/+IAAEB4P3ZAAECDP+IAAEC1f3ZAAEEM/+IAAEC0P+IAAEBLP+IAAEBGP+IAAEA+v+IAAECCP3aAAEBJ/+IAAECKP+IAAEDXP+IAAECbP+IAAEB9P3ZAAECOv+IAAECRP3ZAAEETP+IAAEDtv+IAAECUv+IAAEA3P+IAAEB9P+IAAECDf3ZAAECiv3aAAEB4P3aAAEDB/+IAAECP/+IAAECo/3aAAECUv3aAAECvP3aAAEA5v+IAAEAw/+IAAECsv+IAAECcf2oAAEBXv2oAAEBkP+IAAECZ/+IAAEB2/3aAAECJv3aAAEDIP3aAAEBd/3aAAEBRf3aAAEBwv+IAAEAS/3aAAEC7v3aAAECP/3aAAEAr/3aAAEC1f3aAAEBLP3aAAECDf+IAAEB9P3aAAECMP3aAAEBIv3aAAECgP3aAAEDhP+IAAEA1/+IAAECCP+IAAECWP3aAAECsv5wAAEBE/3aAAEBfP+IAAEC+P3aAAECwf+IAAEDcP+IAAEB/v3aAAECgP+IAAECA/+IAAECTv3aAAECSf+IAAECTv+IAAEB4P+IAAECRP3aAAEB2/+DAAEB0f+DAAECMP+DAAEA+v3aAAEB+f3aAAECHP3aAAEBWf+IAAEBVP3aAAEDSP+IAAEDSP3aAAEDUv3aAAECK/3aAAEBSv+IAAEBkP3aAAEA6/3aAAECDf3aAAEAlv3aAAEA8P3aAAEBXv3aAAEBMf+IAAECEv8kAAECEv3aAAECOv3aAAEB2/+IAAECK/+IAAEBuP+IAAEFkf+IAAEE+/3aAAEFkf8kAAEEAf+IAAEEGv3aAAECHP+IAAECiv4+AAECJv4+AAECNf+IAAECvP4+AAECMP4+AAEBHf+IAAEBHf4+AAEA4f4+AAEDFv4+AAECK/4+AAEDIP+RAAEC1f5wAAECA/4+AAECnv4+AAECqP3aAAECSf3aAAECSf4+AAECgP4+AAECOv4+AAECqP4+AAECHP4+AAEClP4+AAECsv3aAAECy/3aAAEDPv+IAAEC0P4+AAECNf4+AAEC7v4+AAECYv4+AAEC3/3aAAECEv+IAAECsv4+AAECbP4+AAEA1/4+AAEA6/5wAAECbP3aAAEDV/+IAAEDXP4+AAECxv4+AAEC0P3aAAEC2v4+AAEBSv4+AAEBXv4+AAEB7/+IAAEB5f4+AAECt/+IAAECj/4+AAEB4P4+AAEBaP+IAAECdv4+AAEBY/5wAAEBNv4+AAECdv3aAAEC2v3aAAECA/3aAAEB+f4+AAEDz/4+AAEC3/4+AAECZ/4+AAEB/v4+AAECCP4+AAEBcv+IAAEB1v+IAAEA5v3aAAEINP+IAAEH0P+IAAEGVP+IAAEGQP+IAAEFVf3aAAEHnv+IAAEGJ/3aAAEE7P3aAAEFHv+IAAEDev+IAAECU/3aAAEAZP3aAAEHvP+IAAEGcv+IAAEBBP3aAAEA8P+IAAECdv12AAEBXv12AAEBwv3aAAEC2v+IAAECbP7UAAECA/7UAAEDjP+IAAEDjP3ZAAECnv8kAAEDFv8kAAECMP8kAAECdv8kAAEB6v3ZAAECDP3ZAAECOf3ZAAEBhf+IAAECOv3ZAAEEZv+IAAEA4/+IAAECRv+IAAECMP3ZAAEBCf3ZAAEA4f3ZAAEDZv3ZAAEA6/3ZAAEB/v3ZAAEB2/3ZAAEB0f3ZAAECRP4qAAECAP3ZAAECLv3ZAAEAeP3aAAECn/+IAAECRP4+AAEC8/5IAAECOf5IAAECAP+IAAECmP+IAAEB9f+IAAECYATkAAEEdgROAAECYP+IAAEEwQdsAAECYP5NAAEEwQg0AAEEKwAAAAEDIAYYAAEA5gaQAAEDhAYYAAEAoAcIAAEA5gYiAAEAoAcmAAEAtAcmAAEDhAZAAAEDhAaQAAEDZgdsAAEDUgdsAAEDIAcmAAEDPgccAAECvAcmAAEC2gcmAAEDcAYYAAEA5gaGAAEDtgYYAAEDjgYYAAEEGgXcAAEC7gbWAAEA+gPUAAEFkQYiAAEJLgPoAAEHHARMAAEE4gaGAAEBXgUAAAEETAScAAEC8wSDAAEDhABLAAEBwgAZAAEDtgCWAAEBSgB9AAEB9P8kAAEBVP8kAAEBrv84AAEBSv84AAEDUv6YAAEBSgAZAAED6P6YAAED1ABLAAECEgAZAAEEBgCWAAED6ACWAAEEfgCMAAECvACMAAEA+gCMAAEF3ACMAAEEZQCMAAEC7gCMAAEHbP6iAAEFeP8GAAEDUv8GAAEBLP9qAAEBBAZUAAEBBAaQAAEBBAbWAAEBBAZAAAEA3AZyAAEA5gdiAAEA8AfQAAEBBAeFAAEBBAbqAAEBBAeoAAEBBAchAAEA+ga4AAEBBAdsAAEA8AZZAAEA8AdsAAEAAAbgAAEAlga4AAEAoAdsAAEAAAW5AAEAMgcIAAEAAAWMAAEAAAZZAAEAAAVGAAEAAAW0AAEAAAa4AAEAAATiAAEAAAeeAAEAAAZUAAEAAAXIAAEAAAYYAAEAyAdiAAEAyAfkAAEAyAh6AAEAyAiEAAEAtAhcAAEA+v6iAAEA+v9qAAEAAP4+AAEAAP40AAEAAP5wAAEAAP4MAAEAAP8aAAEA+v6EAAEA+v3uAAEBFwQmAAEAtAbZAAEAeAbZAAEAtAcoAAEAeAcoAAEAtAYoAAEAeAYoAAEAtAc/AAEAeAc/AAEAtAc8AAEAeAc8AAEAtAaJAAEAeAaJAAEAtAaLAAEAeAaLAAECGgSwAAECGgVCAAECGgX1AAECGgagAAECGgYEAAECGgVGAAECGgUxAAEAtAXRAAEA8ATSAAEAtAXOAAEAtAaBAAEA8AWOAAEAtAbcAAEAtAZ8AAEAtAZAAAEA8AVtAAEAtAdYAAEA8AajAAEAtAU/AAEAtAVBAAEBngShAAEBngSVAAEBngVZAAEBngW2AAEBngZAAAEBngYiAAEBngWgAAEBnga+AAEBpASXAAEBpAWVAAEBpAW2AAEBpAZAAAEBpAXcAAEBpAbcAAEBOwUeAAEA/wZPAAEA5gddAAEBHQZAAAEA1wcIAAEA9gbMAAEA8wbMAAEBTwX5AAECKgRgAAECKgWVAAEB7gbcAAECKgWLAAECKgWOAAECKgYFAAECKgZNAAECKgYEAAECKgcCAAEClgRHAAEBLASdAAEBLAV9AAEBLAT7AAEBLAWMAAEBLAXIAAEBLAZOAAEBLATVAAEBLATrAAEClgSDAAEBaARqAAEBaAS5AAEBaAVQAAEBLAaVAAEBGgT6AAEBngQnAAEBGgZdAAEBngWVAAEA3gcIAAEA6gYEAAEBGgYhAAEBGgZVAAEBngVRAAEA3gbqAAEBLAS3AAEA8ARIAAEBLAWVAAEA8AWVAAEA8AZoAAEA8AYEAAEBLAW1AAEA8AVRAAEBLAZoAAECfwRKAAEA8AYLAAEA8AXjAAEA8AYoAAEA8AYMAAEA8AWHAAEA8AUfAAEA8AXDAAEAtAbMAAEAeAa4AAEB6gV3AAEB6gR/AAEB6gVBAAEBrgWMAAECDQVDAAEBfASzAAEBuASzAAECDQZvAAEB0QdEAAEBfAWlAAEBuAWlAAEBfAVMAAEBuAVMAAEBfAV9AAEBuAV9AAEBfAWTAAEBuAWTAAECDQa4AAECSQa4AAEBLAXfAAEBLAWjAAEA8Aa/AAEA8AbvAAEBLAaKAAEAtAchAAEAtAbvAAEA8Aa4AAECTgTXAAEBpAUTAAEBrwVDAAEA8AaNAAEA8AdcAAEA8AddAAEBTwPLAAEBEwS1AAEBmgQ5AAEBmgU3AAEB6QVmAAEB6QRHAAEB6QaMAAEB6QZAAAEB6QcsAAEB6QZdAAEAtAWYAAEA5wadAAEA6gRhAAEA5wUhAAEBIgVgAAEBXgQjAAEBIgY1AAEBXgWLAAEA6gWOAAEA5wZWAAEBCgPLAAEBRgTGAAEBRgTsAAEAeATSAAEBLAQYAAEB1gTpAAECTgQEAAECTgTGAAECTgVlAAECTgUnAAECTgWNAAECTgYpAAECTgTrAAECTgU4AAECEgYnAAECTgUpAAECTgRtAAECTgRvAAEBmgUlAAEBjASiAAEBmgOyAAEBjANtAAEBmgPWAAEBjAOGAAEBmgNtAAEBmgSlAAEBjAPdAAEBmgPuAAEBjAPNAAEBjAPPAAEBjAJBAAEB6QOvAAECYQKHAAEB6QRiAAECYQMiAAEB6QQ7AAECYQMZAAEB6QQ9AAECYQMbAAEBaQQjAAEAtAOzAAEA8ACSAAEBLABxAAEA8P8EAAEAtP8EAAEA8P8YAAEAtP8YAAEA8ABxAAEBKv+hAAEBogA1AAEBKv+cAAEBov/IAAEBKv+JAAEBKv8FAAEBKv9KAAEBKv+IAAEBKv+lAAEA8P/5AAEA8P9lAAEA8P9gAAEA8P40AAEA8P+MAAEA8P4hAAEA8P4VAAEA8P8GAAEA8P5TAAEA8P84AAEA8P8tAAEA8P9MAAEA8P4WAAEA6v4SAAECWP+PAAECWP/5AAECWP84AAECWP6iAAECWP5dAAECWP6YAAECWP8GAAEBiwA1AAEBXgA1AAEBi/+MAAEBi/8pAAEBXv8pAAEBx/7UAAEBZAA1AAEBdQA1AAEBt/5wAAEBx/7xAAEClP8oAAEClP6/AAEClP7ZAAECHP7nAAEEOv+oAAEBpP/5AAEBpAA1AAEC0P7tAAEC0P4hAAEDSP+BAAEDSP2oAAEEEP8LAAEB4P/5AAEA3v3WAAEA6v3WAAECHP7tAAEBpP7tAAECB//5AAEBLP/5AAEA8P8pAAEBLP5dAAEBaP5dAAEBaP8QAAEBLP8QAAEBcv7vAAECDf/5AAECbP/5AAEA4f7VAAEBQP/EAAEBQP/YAAEBQP/FAAEBpP4hAAEBpP8QAAEBpP5wAAEBLP5wAAECHP5dAAEBpP5dAAEELv/5AAEDDP/5AAEBr/9aAAEBN/5dAAECA/96AAECA/6KAAECA/8+AAEB1v/5AAEB1v8pAAEB6f70AAEAgf8GAAEAgf7/AAEARf8GAAEA8P/eAAEBX//5AAEBJgAaAAEBXgAQAAEBmv8KAAEBJv/eAAEBRv/dAAEAtP55AAEBaP4gAAEBmv7rAAEB1v8vAAEByP6nAAEAeP8KAAEAeP7GAAEB1v6nAAEA8P9AAAEA8P7GAAEA8P8gAAEA8P5IAAEA8P4gAAEBrf6hAAEBrf2jAAEB4QAAAAEAtP9FAAH/jAdYAAEA4QbqAAEA3AZKAAEA8AaaAAEA8P+wAAEAuf9MAAEBjATLAAEBmgWmAAEBjAQDAAEBmgTeAAEBjAPxAAEBmgVFAAEA8P8vAAEA8P6nAAEA8P8oAAEBXv/FAAEBEwTDAAEAAP/sAAEAAAD6AAEAAAGQAAEAAAIwAAEAAAEsAAEAAAH0AAEAAAImAAEAAAFeAAEAAAFUAAEAAAG4AAEAAAHgAAEAAP7UAAEAAP5IAAEAAP6sAAEDcABLAAEBXgB9AAEDcACWAAEDcAYsAAEA5gYsAAEA/wUUAAEBDgT7AAEA+gWMAAEBDgUUAAEA/wTsAAEAwwTYAAEA8AUUAAEA9QUUAAEA0gYnAAEA0gWCAAEA4QX6AAEAHgRlAAEAPAQ4AAEAKAQ4AAEAFAQ4AAEAAAQ4AAEAAAQuAAEAAARlAAEAAAYsAAEAAAVLAAEAAAT7AAEAAAWgAAEAAATsAAH/oAQuAAEA+wQiAAEA+gV4AAEBBAUUAAEAAAAtAAEAAABLAAEB4AUfAAEBEwYDAAEBmgZ/AAEA8AAjAAEA8ABfAAEAwwCWAAH/4gBLAAEAAAC0AAEAAACWAAH/8QDDAAEA+gBfAAEAmwCWAAEAAP/xAAEA8P8fAAECWP9EAAEClP6wAAEBNv7vAAEB4P+DAAEAeP8fAAH/dAAAAAH/agAAAAH/zgAAAAH/2AAAAAH+8gAAAAH/BgAAAAH/GgAAAAH+ygAAAAH+ogAAAAH/9gAAAAEAlgAAAAECYgAAAAEBmgAAAAEBkAAAAAECTgAAAAH+UgAAAAH+XAAAAAH+SAAAAAH+hAAAAAH+DAAAAAH+rAAAAAH9dgAAAAH9YgAAAAH9WAAAAAH9qAAAAAH9ngAAAAH9igAAAAH9RAAAAAH+FgAAAAH+wAAAAAH+1AAAAAH97gAAAAH9+AAAAAH+IAAAAAH+NAAAAAH+KgAAAAH92gAAAAEAKAAAAAH/sAAAAAH/7AAAAAEAFAAAAAEAggAAAAH/xAAAAAH/ugAAAAH/nAAAAAH+PgAAAAH+cAAAAAH9vAAAAAH9MAAAAAEBHQQaAAECcQU+AAECYv9qAAEAHgAAAAEAAAPtAAEAAAVkAAEDAgSDAAEBigAAAAEBZwAAAAEBSQAAAAEAnwAAAAEB8wAAAAEBjwAAAAEAJQAAAAEAdwAAAAEAhgAAAAEA2wAAAAEBhQAAAAEAkAAAAAEAiwAAAAEBKwAAAAEBowAAAAH+nQAAAAEAWQAAAAEBcQAAAAEBPwAAAAEBIQAAAAH/WwAAAAEA5QAAAAEB3wAAAAECJQAAAAEB6QAAAAEBwQAAAAEB1QAAAAEDJAAAAAECUgAAAAEDUQAAAAECawAAAAEBgAAAAAECDQAAAAEB6gAAAAEAqAAAAAEBCQAAAAECCAAAAAEBEwAAAAH/kAAAAAEB9AAAAAEATQAAAAEBaAAAAAEDpwAAAAEC1QAAAAED/AAAAAECAwAAAAEB1gC0AAEBkAC0AAEB9AC0AAECWAC0AAEA/AAAAAEBTwAAAAEARgAAAAEBfAAAAAECHAAAAAECHAC0AAEDAgAAAAEBNgAAAAEBOgAAAAEBEgAAAAEAxwAAAAEBIwAAAAEBjgAAAAEBDwAAAAEBYgAAAAEBVQAAAAEBhwAAAAEBeAAAAAEBIAAAAAEBPgAAAAEAMgAAAAEAMgD6AAEBOQAAAAEBKAAAAAEBfgAAAAEBWgAAAAEBZgAAAAEBXQAAAAEBjAAAAAEBUAAAAAEAigAAAAEBSAAAAAEBggAAAAEDNgAAAAECwgC0AAECYgC0AAEC7gC+AAEDVAAAAAEDVAC0AAEB5AAAAAECNgAAAAEB5AD6AAEC4wAAAAEDTQAAAAEDIgAAAAEClgAAAAECdAAAAAECdAC0AAEDiwAAAAECLAAAAAEDSAAAAAEDBAAAAAEDEAAAAAEDCwAAAAEC5wAAAAEC7wC0AAECrAAAAAEDxQAAAAEDjQAAAAED7QAAAAEDpwC0AAED4AAAAAED6gAAAAEDAAAAAAED4wAAAAEDLAAAAAEDlv/yAAEAdAAAAAH//wAAAAEAxgAAAAH/tAAAAAEAGAAAAAEAyAAAAAEAfAAAAAEAZAAAAAEAtwAAAAEADAAAAAEAgQAAAAEA2gAAAAEAuAAAAAEAeAAAAAH/KQAAAAH/GgD6AAEAqgAAAAEAmgAAAAEApgAAAAEASgAAAAEAWgAAAAEAUAAAAAEAwgAAAAEAjAAAAAH/YQAAAAEAoAAAAAECSwAAAAEB5wAAAAECBgAAAAECXwAAAAECAQAAAAEAwAAAAAEAIwAAAAEASQAAAAEAmwAAAAEAswAAAAEBDAAAAAEAcAAAAAEBCgAAAAEAsQAAAAEBXAAAAAEAZgAAAAEAygAAAAEBLgAAAAEBYQAAAAEAtgAAAAEBhAAAAAEBTgAAAAH/vQAAAAH/vQC0AAEBSgAAAAEBMAAAAAEBPAAAAAEBWAAAAAEBIgC0AAEB1gCgAAEBkACgAAEB9ACgAAECWACgAAECHACgAAEA/ADcAAEC4QAAAAECsQAAAAEC7wAAAAEAbgAAAAEA+AAAAAEA6wAAAAEA+QAAAAEBTAAAAAEAZwAAAAEA6gAAAAEAvgAAAAH/nQAAAAEArgAAAAEAzAAAAAEA2AAAAAEAuQAAAAEA9AAAAAH/zwAAAAEBBQAAAAEDggAAAAECOAAAAAECWgAAAAECuAAAAAECwgAAAAED9wAAAAECFQAAAAECgQAAAAEEEAAAAAEEQgAAAAEEgAAAAAEDZAAAAAEDhgAAAAEEeQAAAAED9AAAAAEE0wAAAAEDTgAAAAEBsgAAAAECXQAAAAH/jgAAAAECSQAAAAECFwAAAAEATAAAAAEBvQAAAAECtwAAAAECngAAAAECrQAAAAEDKgAAAAEC/QAAAAEELgAAAAEAlwAAAAEAVgAAAAH/rAAAAAEAiAAAAAEAnAAAAAH/HgAAAAH/cAAAAAH/kwAAAAH/6AAAAAEAkgAAAAH/EQAAAAH+8QAAAAH/tgAAAAH/1AAAAAEAsAAAAAH86QAAAAH/ZgAAAAEAfgAAAAEALgAAAAH/hwAAAAEAOAAAAAH9pwAAAAH/8gAAAAEA9gAAAAEAzgAAAAEA4gAAAAEBfQAAAAEBMgAAAAEA+wAAAAEBvgAAAAEAjQAAAAH/JAAAAAEA0gDcAAEA3ADcAAEAdADcAAEAxgDcAAEAdwDcAAEAyADcAAEAZADcAAEAtwDcAAEADADcAAEAgQDcAAEA2gDcAAEAxwDcAAEAuADcAAEAeADcAAH/KQDcAAEAfADcAAEAtADcAAEAqgDcAAEAmgDcAAEApgDcAAEAWgDcAAEAUADcAAEAwgDcAAEAjADcAAH/YQDcAAEAoADcAAEA5gDcAAECCwAAAAEBlAAAAAEB5gAAAAECVwAAAAEBuwAAAAECKwAAAAEBzQAAAAECIAAAAAECPwAAAAEBKgAAAAEBBwAAAAEA6QAAAAEAPwAAAAEBLwAAAAH/xQAAAAEAFwAAAAEAJgAAAAEAewAAAAEBJQAAAAEABQAAAAEAKwAAAAEBQwAAAAH93QAAAAH/+QAAAAEBEQAAAAEA3wAAAAEAwQAAAAEAywAAAAH+mwAAAAEAhQAAAAEBrQAAAAEBiQAAAAEBdQAAAAECYAAAAAEBxQAAAAECtQAAAAEBDv/OAAH+jv/OAAEA6gBkAAEA9QBkAAH/JP9WAAEBIv5cAAEAyP/OAAEBpP/OAAEAlv/OAAEAtP/OAAECCP/OAAEBDAAUAAEC5AAAAAED1AAAAAECTAAAAAECywAAAAEDygAAAAEBxwAAAAH/owAAAAECgAAAAAECQQAAAAEAYQAAAAEFJgAAAAEEUQAAAAEEagAAAAEEkgAAAAEEsAAAAAEBGwAAAAEBpwAAAAEBAgAAAAEBVwAAAAEB7QAAAAEBnQAAAAEDUAAAAAEB9wAAAAECZQAAAAECPQAAAAECUQAAAAEC2AAAAAECoQAAAAEB3gAAAAEDLQAAAAEB/AAAAAEC6QAAAAEB1gAAAAEB5QAAAAEDfwAAAAEC3wAAAAEDYAAAAAEDPQAAAAEDHwAAAAECdQAAAAEDyQAAAAEDZQAAAAEB+wAAAAECTQAAAAECXAAAAAEDWwAAAAECYQAAAAEDAQAAAAEDeQAAAAEAGQAAAAECLwAAAAEDRwAAAAEDFQAAAAEC9wAAAAEA1wAAAAECuwAAAAED+wAAAAEDvwAAAAEDlwAAAAEDqwAAAAEE+gAAAAEEKAAAAAEFJwAAAAEEQQAAAAEDVgAAAAEDvgAAAAEDnAAAAAEDfgAAAAEC0wAAAAEDxAAAAAEDugAAAAECwAAAAAED2AAAAAECjgAAAAEDpgAAAAEDdAAAAAEDGgAAAAEEhwAAAAEEHgAAAAED9gAAAAEECgAAAAEE9QAAAAEEWgAAAAEEoAAAAAEDtQAAAAECvwAAAAECogAAAAEB+AAAAAEDTAAAAAEC6AAAAAEB0AAAAAECNAAAAAEC3gAAAAEChAAAAAEC/AAAAAECygAAAAECmAAAAAECegAAAAECPgAAAAEDOAAAAAEDQgAAAAEDLgAAAAEEfQAAAAEE0gAAAAEC2QAAAAECZgAAAAECQwAAAAEBewAAAAEA7QAAAAEBtwAAAAEAxQAAAAECfwAAAAEBNQAAAAECGwAAAAEB/QAAAAEBOwAAAAECBwAAAAECiQAAAAECxQAAAAECnQAAAAEDGAAAAAECpAAAAAECWQAAAAECvQAAAAEC1AAAAAECcAAAAAEFFwAAAAEERAAAAAEDwgAAAAEDMv/yAAEDnQAAAAEE7AAAAAEGEQAKAAEGEQAAAAEFKAAAAAEEJAAAAAEEFgAAAAEDuwAAAAEDQAAAAAECMwAAAAEBtgAAAAEEGAAAAAEEdAAAAAED3gAAAAEEzgAAAAEBcgCgAAEBCgCgAAEBXACgAAEBDQCgAAEBXgCgAAEBDgCgAAEBYQCgAAEAtgCgAAEBKwCgAAEBhACgAAEBXQCgAAEBTgCgAAH/vQCgAAEBIgCgAAEBEgCgAAEBSgCgAAEBQACgAAEBMACgAAEBPACgAAEA8ACgAAEA5gCgAAEBWACgAAEA+gCgAAEBNgCgAAEBfACgAAEBxgAAAAEBoAAAAAEBBgAAAAEA8wAAAAEB4gAAAAEAeABpAAEB9P5XAAEA4gQEAAEBLP7rAAECSAZAAAEAeAJJAAEEOv90AAEDSP7+AAEAAAAKAa4IxgAFYXJhYgAgY3lybADGZ3JlawDsaGVicgEUbGF0bgEkABwABEZBUiAANk1MWSAAUlNORCAAblVSRCAAigAA//8ACgAFABQACgApAC4AQwBXADMAZwAfAAD//wALAAYAFQALACoALwA9AEQAWAA0AGgAIAAA//8ACwAHABYADAArADAAPgBFAFkANQBpACEAAP//AAsACAAXAA0ALAAxAD8ARgBaADYAagAiAAD//wALAAkAGAAOAC0AMgBAAEcAWwA3AGsAIwAEAAAAAP//AA4AGgAkADgASABNAFIAYgAAAF0AbABxAHYAewCAAAQAAAAA//8ADwAbACUADwA5AEkATgBTAGMAAQBeAG0AcgB3AHwAgQAEAAAAAP//AAMAGQAQAFwAEAACTFRIIAA0VFJLIABaAAD//wAPABwAJgARADoASgBPAFQAZAACAF8AbgBzAHgAfQCCAAD//wAQAB0AJwASADsAQQBLAFAAVQBlAAMAYABvAHQAeQB+AIMAAP//ABAAHgAoABMAPABCAEwAUQBWAGYABABhAHAAdQB6AH8AhACFYzJzYwMgYzJzYwMqYzJzYwM0YzJzYwM+YzJzYwNIY2FsdANSY2FsdANYY2FsdANeY2FsdANkY2FsdANqY2NtcANwY2NtcAN8Y2NtcAOIY2NtcAOUY2NtcAOgY2NtcAOsY2NtcAO2Y2NtcAPmY2NtcAPwY2NtcAP6ZGxpZwQEZGxpZwQMZGxpZwQUZGxpZwQcZGxpZwQkZGxpZwQsZG5vbQQyZG5vbQQ4ZG5vbQQ+ZG5vbQREZG5vbQRKZmluYQRQZmluYQRWZmluYQRcZmluYQRiZmluYQRoZnJhYwRuZnJhYwR4ZnJhYwSCZnJhYwSMZnJhYwSWaW5pdASgaW5pdASmaW5pdASsaW5pdASyaW5pdAS4aXNvbAS+aXNvbATEaXNvbATKaXNvbATQaXNvbATWbGlnYQTcbGlnYQTqbGlnYQT4bGlnYQUGbGlnYQUUbG51bQUibG51bQUobG51bQUubG51bQU0bG51bQU6bG9jbAVAbG9jbAVGbG9jbAVMbG9jbAVSbG9jbAVYbG9jbAVebWVkaQVkbWVkaQVqbWVkaQVwbWVkaQV2bWVkaQV8bnVtcgWCbnVtcgWIbnVtcgWObnVtcgWUbnVtcgWab251bQWgb251bQWob251bQWwb251bQW4b251bQXAcG51bQXIcG51bQXOcG51bQXUcG51bQXacG51bQXgcmxpZwXmcmxpZwXscmxpZwXycmxpZwX4cmxpZwX+cmxpZwYEc2FsdAYKc2FsdAYQc2FsdAYWc2FsdAYcc2FsdAYic21jcAYoc21jcAYyc21jcAY8c21jcAZGc21jcAZQc3MwMQZac3MwMQZgc3MwMQZmc3MwMQZsc3MwMQZyc3MwMQZ4c3MwMQZ+c3MwMQaEc3MwMQaKc3MwMQaQc3MwMgaWc3MwMgacc3MwMgaic3MwMgaoc3MwMgauc3MwMwa0c3MwMwa6c3MwMwbAc3MwMwbGc3MwMwbMdG51bQbSdG51bQbadG51bQbidG51bQbqdG51bQbydW5pYwb6dW5pYwcAdW5pYwcGdW5pYwcMdW5pYwcSAAAAAwArACwALQAAAAMAKwAsAC0AAAADACsALAAtAAAAAwArACwALQAAAAMAKwAsAC0AAAABABcAAAABABcAAAABABcAAAABABcAAAABABcAAAAEAAQABQAJAAoAAAAEAAQABQAJAAoAAAAEAAQABQAJAAoAAAAEAAQABQAJAAoAAAAEAAQABQAJAAoAAAADAAAAAQACAAAAFgAwADEAMgAzADQANQA2ADcAOAA5ADoAOwA8AD0APgA/AEAAQQBCAEMARABFAAAAAwAAAAEAAgAAAAMAAAABAAIAAAADAAAAAQACAAAAAgAVABYAAAACABUAFgAAAAIAFQAWAAAAAgAVABYAAAACABUAFgAAAAEALgAAAAEAHAAAAAEAHAAAAAEAHAAAAAEAHAAAAAEAHAAAAAEADAAAAAEADAAAAAEADAAAAAEADAAAAAEADAAAAAMAGQAaABsAAAADABkAGgAbAAAAAwAZABoAGwAAAAMAGQAaABsAAAADABkAGgAbAAAAAQAOAAAAAQAOAAAAAQAOAAAAAQAOAAAAAQAOAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAAAQALAAAABQARABIAEwAUABYAAAAFABEAEgATABQAFgAAAAUAEQASABMAFAAWAAAABQARABIAEwAUABYAAAAFABEAEgATABQAFgAAAAEAJwAAAAEAJwAAAAEAJwAAAAEAJwAAAAEAJwAAAAEACAAAAAEABwAAAAEADwAAAAEABgAAAAEAAwAAAAEAIQAAAAEADQAAAAEADQAAAAEADQAAAAEADQAAAAEADQAAAAEAHQAAAAEAHQAAAAEAHQAAAAEAHQAAAAEAHQAAAAIAIgAkAAAAAgAiACQAAAACACIAJAAAAAIAIgAkAAAAAgAiACQAAAABACUAAAABACUAAAABACUAAAABACUAAAABACUAAAABABAAAAABABAAAAABABAAAAABABAAAAABABAAAAABAC8AAAABAB4AAAABAB4AAAABAB4AAAABAB4AAAABAB4AAAADACgAKQAqAAAAAwAoACkAKgAAAAMAKAApACoAAAADACgAKQAqAAAAAwAoACkAKgAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAGAAAAAEAHgAAAAEAHgAAAAEAHgAAAAEAHgAAAAEAHgAAAAEAIAAAAAEAIAAAAAEAIAAAAAEAIAAAAAEAIAAAAAEAHwAAAAEAHwAAAAEAHwAAAAEAHwAAAAEAHwAAAAIAIwAmAAAAAgAjACYAAAACACMAJgAAAAIAIwAmAAAAAgAjACYAAAABACAAAAABACAAAAABACAAAAABACAAAAABACAAWwC4AMAAyADQANgA4AEUARwBJAEsATYBQAFIAVABWAFgAWgBcAF4AYABiAGQAa4BuAHCAcoB0gHaAeIB6gHyAfoCAgIKAhICGgIiAioCMgI6AkICSgJSAloCYgJqAnICegKCApAC0ALYAuAC6ALwAvgDAAMIAxADGAMgAygDMAM4A24DdgN+A6wDtAO8A9gD4APoA/AD+AQABAgEEAQYBCAEKAQwBDgEQARIBFAEWARgBGgEcAR4AAYBAAABA8gABAAAAAEEWAAEAAAAAQnEAAEAAAABC2QABAABAAELagAGAAkAFwxkDHYMigygDLIMxgzcDPQNBg0aDTANSA1aDW4NhA2cDa4Nwg3YDfAOAg4WDiwAAQABAAEOVAABAAkAAQ5uAAEAAQABDngABgABAAIOkg6kAAYAAQACDtoO7gABAAkAAQ8wAAEACQABDz4AAQAJAAEV0AABAAkAARpMAAEACQABHsgABAAJAAEfDgAEAAEAASBuAAQACQABIJIABAABAAEgtgAEAAkAASDwAAYAAQAMIUghXCH0IhAixCLeI5AjuiScJNAlyCX6AAYAAQACJsgm1gAGAAkAAiboJv4AAQAJAAEnLAABAAAAASdeAAYAAAABJ2QAAQAAAAEniAABAAAAASekAAEAAAABJ8AAAQAAAAEn3AABAAAAAShmAAEAAAABKYgAAQAAAAEsggABAAAAASyIAAEAAAABLKQAAQAAAAEswAABAAAAASzcAAEAAAABLPgAAQAAAAEtFAABAAAAAS0wAAEAAAABLZwAAQAAAAEt+gABAAAAATDaAAEAAAABMUYAAQAAAAExnAAEAAEAATR0AAQAAQABNIQABgABAAQ0ljSoNLw00AAGAAEAHTVoNX41ljWuNcg13DXyNgg2IDY4NlI2ajaENpg2rjbGNt429DcMNyY3QDdWN243hjeeN7g30jfuOAgAAQAAAAE41gAEAAEAATjcAAQAAQABOPAABAABAAE5HAAEAAEAATlOAAYAAQABOwYABAABAAE7XAAEAAEAATt0AAQAAQABSn4ABAABAAFLLgAEAAEAAUyoAAQAAQABTNYAAQABAAFM5gAGAAEAGEzsTQBNFk0uTUhNXk12TZBNrE3ATdZN7k4ITh5ONE5MTmROfk6YTrRO0E7kTvpPDgAGAAEAAU/qAAQAAQABUBAABgABABRQKFBAUFZQblCEUJxQslDKUOBQ+FEOUSZRPFFUUWpRglGYUbBRxlHeAAYAAQABUsoABAABAAFTXAAGAAEAC1OgU7hT0FPmU/xUElQoVD5UVFRqVIAAAQEAAAFVlAABAAkAAVWwAAIAAQABVeIAAgABAAFWbgAEAAEAAVb6AAQAAQABVw4ABAABAAFXPgAEAAEAAVdqAAQAAQABV/oABAABAAFYhgACAAEAAVi4AAEACQABWMoAAQAAAAFY5gABAAEAAVkCAAEAAQABWQgAAQABAAFZDgAEAAEAAVkUAAQAAQABWTIAAgABAAFZQgACAAEAAVnUAAIAAQABWoIAAwAAAAEAEgABACgAAQAAAEYAAgADAEwATQAAAbMBswACBzoHOgADAAIAEgR0BHQAAAR6BHoAAQSSBJMAAghCCFIABAhYCFgAFQh6CHwAFgh/CIEAGQiDCIMAHAiHCIkAHQiQCJwAIAjvCPIALQspCysAMQswCzAANAvsC+wANQzEDMUANgzHDMcAOA0RDRYAOQ0YDRgAPwABBWoABQAQASICNANGBFgAHAA6AEIASgBSAFoAYgBqAHIAegCCAIgAkACYAKAAqACwALYAvgDGAM4A1gDeAOQA7AD0APwBBAEMB7YAAwesB60HtwADB6wHrge4AAMHrAevB7kAAwesB7AHugADB60HrAe7AAMHrQetB7wAAwetB64HvQADB60Hrwe+AAMHrQewB78AAgetB8AAAweuB6wHwQADB64HrQfCAAMHrgeuB8MAAweuB68HxAADB64HsAfFAAIHrgfGAAMHrwesB8cAAwevB60HyAADB68HrgfJAAMHrwevB8oAAwevB7AHywACB68HzAADB7AHrAfNAAMHsAetB84AAwewB64HzwADB7AHrwfQAAMHsAewB9EAAgewABwAOgBCAEoAUgBaAGIAaABwAHgAgACIAJAAmACgAKgAsAC2AL4AxgDOANYA3gDkAOwA9AD8AQQBDAfSAAMHrAesB9MAAwesB60H1AADB6wHrgfVAAMHrAevB9YAAwesB7AH1wACB6wH2AADB60HrAfZAAMHrQeuB9oAAwetB68H2wADB60HsAfcAAMHrgesB90AAweuB60H3gADB64HrgffAAMHrgevB+AAAweuB7AH4QACB64H4gADB68HrAfjAAMHrwetB+QAAwevB64H5QADB68HrwfmAAMHrwewB+cAAgevB+gAAwewB6wH6QADB7AHrQfqAAMHsAeuB+sAAwewB68H7AADB7AHsAftAAIHsAAcADoAQgBKAFIAWgBiAGgAcAB4AIAAiACQAJYAngCmAK4AtgC+AMYAzgDWAN4A5ADsAPQA/AEEAQwH7gADB6wHrAfvAAMHrAetB/AAAwesB64H8QADB6wHrwfyAAMHrAewB/MAAgesB/QAAwetB6wH9QADB60HrQf2AAMHrQeuB/cAAwetB68H+AADB60HsAf5AAIHrQf6AAMHrgesB/sAAweuB60H/AADB64Hrwf9AAMHrgewB/4AAwevB6wH/wADB68HrQgAAAMHrweuCAEAAwevB68IAgADB68HsAgDAAIHrwgEAAMHsAesCAUAAwewB60IBgADB7AHrggHAAMHsAevCAgAAwewB7AICQACB7AAHAA6AEIASgBSAFoAYgBoAHAAeACAAIgAkACWAJ4ApgCuALYAvgDEAMwA1ADcAOQA6gDyAPoBAgEKCAoAAwesB6wICwADB6wHrQgMAAMHrAeuCA0AAwesB68IDgADB6wHsAgPAAIHrAgQAAMHrQesCBEAAwetB60IEgADB60HrggTAAMHrQevCBQAAwetB7AIFQACB60IFgADB64HrAgXAAMHrgetCBgAAweuB64IGQADB64HrwgaAAMHrgewCBsAAgeuCBwAAwevB6wIHQADB68HrQgeAAMHrweuCB8AAwevB7AIJQACB7AIIAADB7AHrAghAAMHsAetCCIAAwewB64IIwADB7AHrwgkAAMHsAewABwAOgBCAEoAUgBaAGIAaABwAHgAgACIAJAAlgCeAKYArgC2AL4AxADMANQA3ADkAOwA8gD6AQIBCggmAAMHrAesCCcAAwesB60IKAADB6wHrggpAAMHrAevCCoAAwesB7AIKwACB6wILAADB60HrAgtAAMHrQetCC4AAwetB64ILwADB60HrwgwAAMHrQewCDEAAgetCDIAAweuB6wIMwADB64HrQg0AAMHrgeuCDUAAweuB68INgADB64HsAg3AAIHrgg4AAMHrwesCDkAAwevB60IOgADB68Hrgg7AAMHrwevCDwAAwevB7AIPQACB68IPgADB7AHrAg/AAMHsAetCEAAAwewB64IQQADB7AHrwACAAEHrAewAAAAAQGSAAMADABuAQAACAASABwAJgAwADoARABOAFgM0wAECEMIUQSSDNQABAhDCFEEkwzVAAQIQwhSBJIM1gAECEMIUgSTDNcABAhFCFEEkgzYAAQIRQhRBJMM2QAECEUIUgSSDNoABAhFCFIEkwAMABoAJAAuADgAQgBMAFYAYABqAHQAfgCIDNsABAhDCFEEkgzcAAQIQwhRBJMM3QAECEMIUgSSDN4ABAhDCFIEkwzfAAQIRQhRBJIM4AAE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Ay0DLQAEAzEDMQAFAzUDNQAGA4EDgQAHA4MDgwAIA4UDhQAJA4cDhwAKA4kDiQALA40DjQAMA48DjwANA5MDkwAOA5UDlQAPA5kDmQAQA50DnQARA6EDoQASA6UDpQATA6kDqQAUA6sDqwAVA60DrQAWA68DrwAXA7EDsQAYA7UDtQAZA7kDuQAaA70DvQAbA8EDwQAcA8UDxQAdA8kDyQAeA80DzQAfA9ED0QAgA9UD1QAhA9kD2QAiA90D3QAjA+ED4QAkA+UD5QAlA+kD6QAmA+sD6wAnA+0D7QAoA+8D7wApA/ED8QAqBSgFKAArBSwFLAAsBTwFPAAtBT4FPgAuBUAFQAAvBUIFQgAwBUQFRAAxBUYFRgAyBUgFSAAzBUoFSgA0BU4FTgA1BVIFUgA2BVYFVgA3BVoFWgA4BV4FXgA5BWIFYgA6BWYFZgA7BWoFagA8BW4FbgA9BXIFcgA+BXYFdgA/BXoFegBABX4FfgBBBYAFgABCBYIFggBDBYQFhABEBYYFhgBFBYgFiABGBYoFigBHBYwFjABIBY4FjgBJBZAFkABKBZIFkgBLBZQFlABMBZYFlgBNBZgFmABOBZoFmgBPBZwFnABQBZ4FngBRBaAFoABSBaQFpABTBagFqABUBawFrABVBbAFsABWBbQFtABXBbYFtgBYBboFuwBZBb8FvwBbBcMFwwBcBccFxwBdBcsFywBeBc8FzwBfBdEF0QBgBdMF0wBhBdcF1wBiBdsF2wBjBd8F3wBkBeMF4wBlBecF5wBmBesF6wBnBe8F7wBoBfMF8wBpBfcF9wBqBfsF+wBrBf8F/wBsBgMGAwBtBgcGBwBuBgsGCwBvBg8GDwBwBhEGEQBxBhMGEwByBhcGFwBzBhkGGQB0Bh0GHQB1Bh8GIgB2BiQGJAB6BiYGJgB7BigGKAB8BioGKgB9BiwGLAB+Bi4GLgB/BjAGMACABjIGMgCBBjQGNACCBjgGOACDBjoGOgCEBj4GPgCFBkAGQACGBkIGQgCHBlwGXACIBmAGYACJBmQGZACKBnIGcgCLC7ELsQCMC7MLswCNC7ULtQCODAIMAgCPDAYMBgCQDAoMCgCRDA4MDgCSDBIMEgCTDBYMFgCUDBoMGgCVDB4MHgCWDCIMIgCXDCYMJgCYDCgMKACZDCoMKgCaDCwMLACbDDAMMACcDDQMNACdDDgMOACeDDwMPACfDEAMQACgDEQMRAChDEgMSACiDEwMTACjDFAMUACkDFQMVAClDFgMWACmDFwMXACnDGAMYACoDGQMZACpDGwMbACqDt8O3wCrDuMO4wCsDucO5wCtDusO6wCuDu0O7QCvDvEO8QCwDvMO8wCxDvUO9QCyDvkO+QCzDv0O/QC0DwEPAQC1DwMPAwC2DwUPBQC3DwcPBwC4DwkPCQC5Dw0PDQC6DxEPEQC7DxUPFQC8DycPJwC9DysPKwC+Dy8PLwC/DzMPMwDADzcPNwDBDzsPOwDCD6YPpgDDD6oPqgDED64PrgDFD7IPsgDGD7YPtgDHD7oPugDID74PvgDJD8IPwgDKD8YPxgDLD8oPygDMD8wPzADND84PzgDOEGgQaADPEG0QbQDQEG8QbwDREHMQcwDSEHcQdwDTEHkQeQDUAAIBJgCQAyEDKQMwAzQD8wOLA5EDlwObA58DowOnA7MDtwO7A78DwQPFA8wD0APUA9gD2wPgA+MD5wPsA+wFKQPzBSkFKwOLBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFogWmBaoFrgWyBbQFuQUrBb4FwgXGBcoFzgPUBcYF1gXaBd0F4QXlBeoF7gXyBfYF+gX+BgIGBgYKBg0D5wVMBhUDIgYbBmwGNgVUAyIGXgZiBmcF4Qu4DAQMCAwMDBAMFAwYDBwMIAwkDC4MMww3DDsMPwxDDEcMSwxPDFIMVgxaDF4MYgxmDG4O4g7mDuoO8A74DvwPAA8MDxAPFA8YDyoPLg8yDzYPOg8+D6kPrQ+xD7UPuQ+9D8EPxQ/JEGsQchB2AAIAjwMfAx8AAAMnAycAAQMtAy0AAgMxAzEAAwM1AzUABAOJA4kABQOPA48ABgOVA5UABwOZA5kACAOdA50ACQOhA6EACgOlA6UACwOxA7EADAO1A7UADQO5A7kADgO9A70ADwPBA8EAEAPFA8UAEQPJA8kAEgPNA80AEwPRA9EAFAPVA9UAFQPZA9kAFgPdA90AFwPhA+EAGAPlA+UAGQPpA+kAGgPrA+sAGwPvA+8AHAPxA/EAHQUoBSgAHgUsBSwAHwVIBUgAIAVKBUoAIQVOBU4AIgVSBVIAIwVWBVYAJAVaBVoAJQVeBV4AJgViBWIAJwVmBWYAKAVqBWoAKQVuBW4AKgVyBXIAKwV2BXYALAV6BXoALQWgBaAALgWkBaQALwWoBagAMAWsBawAMQWwBbAAMgW0BbQAMwW2BbYANAW6BbsANQW/Bb8ANwXDBcMAOAXHBccAOQXLBcsAOgXPBc8AOwXRBdEAPAXTBdMAPQXXBdcAPgXbBdsAPwXfBd8AQAXjBeMAQQXnBecAQgXrBesAQwXvBe8ARAXzBfMARQX3BfcARgX7BfsARwX/Bf8ASAYDBgMASQYHBgcASgYLBgsASwYPBg8ATAYRBhEATQYTBhMATgYXBhcATwYZBhkAUAYfBh8AUQY0BjQAUgY6BjoAUwY+Bj4AVAZcBlwAVQZgBmAAVgZkBmQAVwZyBnIAWAu1C7UAWQwCDAIAWgwGDAYAWwwKDAoAXAwODA4AXQwSDBIAXgwWDBYAXwwaDBoAYAweDB4AYQwiDCIAYgwsDCwAYwwwDDAAZAw0DDQAZQw4DDgAZgw8DDwAZwxADEAAaAxEDEQAaQxIDEgAagxMDEwAawxQDFAAbAxUDFQAbQxYDFgAbgxcDFwAbwxgDGAAcAxkDGQAcQxsDGwAcg7fDt8Acw7jDuMAdA7nDucAdQ7tDu0Adg71DvUAdw75DvkAeA79Dv0AeQ8JDwkAeg8NDw0Aew8RDxEAfA8VDxUAfQ8nDycAfg8rDysAfw8vDy8AgA8zDzMAgQ83DzcAgg87DzsAgw+mD6YAhA+qD6oAhQ+uD64Ahg+yD7IAhw+2D7YAiA+6D7oAiQ++D74Aig/CD8IAiw/GD8YAjBBoEGgAjRBvEG8AjhBzEHMAjwACASYAkAMhAykDLwMzA/MDiwORA5cDmwOfA6MDpwOzA7cDuwO/A8EDxQPLA88D0wPXA9sD3wPjA+cD6wPrBSkD8wUpBSoDiwVMBVAFVAVYBVwFYAVkBWgFbAVwBXQFeAV8BaIFpgWqBa4FsgW0BbgFKgW9BcEFxQXJBc0D0wXFBdUF2QXdBeEF5QXpBe0F8QX1BfkF/QYBBgUGCQYNA+cFTAYVAyEGGwZrBjYFVAMhBl4GYgZmBeELtwwEDAgMDAwQDBQMGAwcDCAMJAwuDDIMNgw6DD4MQgxGDEoMTgxSDFYMWgxeDGIMZgxuDuEO5Q7pDu8O9w77Dv8PCw8PDxMPFw8pDy0PMQ81DzkPPQ+oD6wPsA+0D7gPvA/AD8QPyBBqEHEQdQACAI8DHwMfAAADJwMnAAEDLQMtAAIDMQMxAAMDNQM1AAQDiQOJAAUDjwOPAAYDlQOVAAcDmQOZAAgDnQOdAAkDoQOhAAoDpQOlAAsDsQOxAAwDtQO1AA0DuQO5AA4DvQO9AA8DwQPBABADxQPFABEDyQPJABIDzQPNABMD0QPRABQD1QPVABUD2QPZABYD3QPdABcD4QPhABgD5QPlABkD6QPpABoD6wPrABsD7wPvABwD8QPxAB0FKAUoAB4FLAUsAB8FSAVIACAFSgVKACEFTgVOACIFUgVSACMFVgVWACQFWgVaACUFXgVeACYFYgViACcFZgVmACgFagVqACkFbgVuACoFcgVyACsFdgV2ACwFegV6AC0FoAWgAC4FpAWkAC8FqAWoADAFrAWsADEFsAWwADIFtAW0ADMFtgW2ADQFugW7ADUFvwW/ADcFwwXDADgFxwXHADkFywXLADoFzwXPADsF0QXRADwF0wXTAD0F1wXXAD4F2wXbAD8F3wXfAEAF4wXjAEEF5wXnAEIF6wXrAEMF7wXvAEQF8wXzAEUF9wX3AEYF+wX7AEcF/wX/AEgGAwYDAEkGBwYHAEoGCwYLAEsGDwYPAEwGEQYRAE0GEwYTAE4GFwYXAE8GGQYZAFAGHwYfAFEGNAY0AFIGOgY6AFMGPgY+AFQGXAZcAFUGYAZgAFYGZAZkAFcGcgZyAFgLtQu1AFkMAgwCAFoMBgwGAFsMCgwKAFwMDgwOAF0MEgwSAF4MFgwWAF8MGgwaAGAMHgweAGEMIgwiAGIMLAwsAGMMMAwwAGQMNAw0AGUMOAw4AGYMPAw8AGcMQAxAAGgMRAxEAGkMSAxIAGoMTAxMAGsMUAxQAGwMVAxUAG0MWAxYAG4MXAxcAG8MYAxgAHAMZAxkAHEMbAxsAHIO3w7fAHMO4w7jAHQO5w7nAHUO7Q7tAHYO9Q71AHcO+Q75AHgO/Q79AHkPCQ8JAHoPDQ8NAHsPEQ8RAHwPFQ8VAH0PJw8nAH4PKw8rAH8PLw8vAIAPMw8zAIEPNw83AIIPOw87AIMPpg+mAIQPqg+qAIUPrg+uAIYPsg+yAIcPtg+2AIgPug+6AIkPvg++AIoPwg/CAIsPxg/GAIwQaBBoAI0QbxBvAI4QcxBzAI8AAgAaAAoP9A/1BocGhgL/D/YP9wYfA+oP/AACAAgC7ALtAAADAAMAAAIDCgMKAAMDDAMMAAQD4QPi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AFQAVAAJAFcAVwAKAFwAXAALAGkAbgAMALkAuQASAMsAzgATAOEA4QAXAOoA6gAYAPgA+AAZAQMBAwAaAQUBBQAbAQ4BDgAcARABEAAdARIBEgAeASABIAAfASIBIgAgAZcBlwAhAawBrAAiAbABsAAjAbIBsgAkAbUBtwAlAboBugAoAcgByAApAdQB1AAqAeQB5AArBwoHCgAsAAIBSAChDXUNdg14DXcNeQ11ACUAJgAnDXYAKQAqACsALAAtAC4ALw14DXcAMgAzADQANQA2ADcNeQA5ADoAOwA8AD0Oaw5sDnMOfQ6DDmgOZw5pDmsOag5sAGQOcw5yDnQOdQDOAMwAzQ59AM8A0QDQAGcArg6CDoEOgwCQAJEOZw5qAK8Aug5pDnQOaA51DnIOgg6BAOAA4gDkAOcA6QDrAPYA+QD7AP0BCA5uDm4Obw5vAQYOeQ55DnoOegENAQ8BEQ5+Dn4OgA6AARcBGQEbAR0BHwEhDocOhw6IDogBJwEpAYoObQ5tAZgBmg52DnYOdw53DngOeAGiAaQBpgGoAaoBrAGuAbABsgG0AbYBuQ5/Dn8BvQG/AcEBwwHFAccOhA6EDoUOhQ6GDoYOiQ6JAdEB0w5wDnAB2AHaAd0B3wHhAeMHBwACAEkAJAAkAAAAKAAoAAEAMAAxAAIAOAA4AAQARABdAAUAYgBjAB8AZQBmACEAaABzACMAdQB/AC8AgQCBADoAoAChADsArACtAD0AsACwAD8AuQC5AEAAxgDKAEEA0gDSAEYA1ADUAEcA4QDhAEgA4wDjAEkA5QDlAEoA6ADoAEsA6gDqAEwA7ADsAE0A9wD3AE4A+gD6AE8A/AD8AFAA/gD/AFEBAgEFAFMBBwEHAFcBCQEMAFgBDgEOAFwBEAEQAF0BEgEWAF4BGAEYAGMBGgEaAGQBHAEcAGUBHgEeAGYBIAEgAGcBIgEmAGgBKAEoAG0BKgEqAG4BiwGLAG8BlgGXAHABmQGZAHIBmwGhAHMBowGjAHoBpQGlAHsBpwGnAHwBqQGpAH0BqwGrAH4BrQGtAH8BrwGvAIABsQGxAIEBswGzAIIBtQG1AIMBtwG3AIQBugG8AIUBvgG+AIgBwAHAAIkBwgHCAIoBxAHEAIsBxgHGAIwByAHQAI0B0gHSAJYB1AHUAJcB1gHXAJgB2QHZAJoB2wHbAJsB3gHeAJwB4AHgAJ0B4gHiAJ4B5AHkAJ8HCAcIAKAAAgAIAAENiAABAAEATAACABoACg1hDWINYw1kDWUNZg1nDWgNaQ1qAAIAAQATABwAAAACABoACgATABQAFQAWABcAGAAZABoAGwAcAAIAAQ1hDWoAAAACABoACg1hDWINYw1kDWUNZg1nDWgNaQ1qAAIAAQ1rDXQAAAACABoACg1rDWwNbQ1uDW8NcA1xDXINcw10AAIAAQATABwAAAACABoACgATABQAFQAWABcAGAAZABoAGwAcAAIAAQ1rDXQAAAACABoACg1rDWwNbQ1uDW8NcA1xDXINcw10AAIAAQ1hDWoAAAACAGQALw45DjoOOw48Dj0OPg4/DkAOQQ5CDkMORA5FDkYORw5IDkkOSg5LDkwOTQ5ODk8OUA5RDlIOUw5UDlUOVg5XDlgOKw4sDi0OLg4vDjAOMQ4yDjMONA41DjYONw44DlkAAgACAloChwAAAokCiQAuAAIASgAiDgoODQ4ODhsOHA4eDiIOIw4kDiUOCw4MDg8OEA4RDhIOEw4UDhUOFg4XDhgOGg4bDh0OHw4gDiEOKQ4qDiYOJw4oDhkAAgAEAS4BMwAAAhACEwAGAhUCKwAKAowCjAAhAAIBCgCCDr0NiQ2KDYsNjA2NDY4Njw2QDZENkg2TDZQNlQ2WDZcNmA2ZDZoNmw2cDZ0Nng2fDaANoQ2iDasNqg2sDa4NrQ2vDbANsg2xDbMNtA22DbUNtw24DbkNuw26DbwNvg29DcANvw3BDcINqQ2jDaYNpA4CDZENpQ3xDgYNqA3DDacN0g3wDccNyA3MDcUNxg3LDdAN0Q3gDeIN4w3kDeYN6g3rDe0N7g3zDfUN+g37DgQOBQ3dDcQNyQ3KDc0Nzg3PDdMN1Q3UDdYN1w3YDdkN2g3bDd4N3w3hDeUN5w3oDekN7A3vDfYN9w34DfkN/A39DgEOBw4IDgkN/g3/DgAOAw3yDdwAAgBPAAkACQAAAEQAXQABAGkAgQAbAIkAiQA0AKAAoQA1ALAAsAA3ALkAuQA4ANUA1QA5AOEA4QA6AOMA4wA7AOUA5QA8AOgA6AA9AOoA6gA+AOwA7AA/APcA9wBAAPoA+gBBAPwA/ABCAP4A/wBDAQMBAwBFAQUBBQBGAQcBBwBHAQoBCgBIAQwBDABJAQ4BDgBKARABEABLARIBEgBMARQBFABNARYBFgBOARgBGABPARoBGgBQARwBHABRAR4BHgBSASABIABTASIBIgBUASQBJABVASYBJgBWASgBKABXASoBKgBYAYsBiwBZAZcBlwBaAZkBmQBbAZsBmwBcAZ0BnQBdAZ8BnwBeAaEBoQBfAaMBowBgAaUBpQBhAacBpwBiAakBqQBjAasBqwBkAa0BrQBlAa8BrwBmAbEBsQBnAbMBswBoAbUBtQBpAbcBtwBqAboBugBrAbwBvABsAb4BvgBtAcABwABuAcIBwgBvAcQBxABwAcYBxgBxAcgByAByAcoBygBzAcwBzAB0Ac4BzgB1AdAB0AB2AdIB0gB3AdQB1AB4AdcB1wB5AdkB2QB6AdsB2wB7Ad4B3gB8AeAB4AB9AeIB4gB+AeQB5AB/BwgHCACADYgNiACBAAIAZAAvDisOLA4tDi4OLw4wDjEOMg4zDjQONQ42DjcOOA45DjoOOw48Dj0OPg4/DkAOQQ5CDkMORA5FDkYORw5IDkkOSg5LDkwOTQ5ODk8OUA5RDlIOUw5UDlUOVg5XDlgOWQACAAICLAJZAAACiAKIAC4AAgBIACEODA4RDh4OIg4jDiQOJQ4mDicOKA4KDgsODQ4ODg8OEA4SDhMOFA4VDhYOFw4YDhkOGg4bDhwOHQ4fDiAOIQ4pDioAAgADASsBLQAAAfEB9wADAfkCDwAKAAIBCACBDr0NiQ2KDYsNjA2NDY4Njw2QDZENkg2TDZQNlQ2WDZcNmA2ZDZoNmw2cDZ0Nng2fDaANoQ2iDa4Nrw2wDbINuQ2+DcINow2mDaoNrQ29DaQOAg2sDbMNqw20DbENtg23DbgNtQ27DbwNug3ADcENvw2lDfEOBg2oDcMNpw3SDdwN8A3HDcgNxQ3GDcsNzA3QDdEN4A3iDeMN5A3mDeoN6w3tDe4N8w31DfoN+w4EDgUN3Q3EDckNyg3NDc4Nzw3TDdUN1A3WDdcN2A3ZDdoN2w3eDd8N4Q3lDecN6A3pDewN7w32DfcN+A35DfwN/Q4BDgcOCA4JDf4N/w4ADgMN8g2pAAIATgAJAAkAAAAkAD0AAQBiAGgAGwCQAJEAIgCsAK8AJAC6ALoAKADGANQAKQDgAOAAOADiAOIAOQDkAOQAOgDnAOcAOwDpAOkAPADrAOsAPQD2APYAPgD4APkAPwD7APsAQQD9AP0AQgECAQIAQwEEAQQARAEGAQYARQEIAQkARgELAQsASAENAQ0ASQEPAQ8ASgERAREASwETARMATAEVARUATQEXARcATgEZARkATwEbARsAUAEdAR0AUQEfAR8AUgEhASEAUwEjASMAVAElASUAVQEnAScAVgEpASkAVwGKAYoAWAGWAZYAWQGYAZgAWgGaAZoAWwGcAZwAXAGeAZ4AXQGgAaAAXgGiAaIAXwGkAaQAYAGmAaYAYQGoAagAYgGqAaoAYwGsAawAZAGuAa4AZQGwAbAAZgGyAbIAZwG0AbQAaAG2AbYAaQG5AbkAagG7AbsAawG9Ab0AbAG/Ab8AbQHBAcEAbgHDAcMAbwHFAcUAcAHHAccAcQHJAckAcgHLAcsAcwHNAc0AdAHPAc8AdQHRAdEAdgHTAdMAdwHWAdYAeAHYAdgAeQHaAdoAegHdAd0AewHfAd8AfAHhAeEAfQHjAeMAfgcHBwcAfw1HDUcAgAABABIAAQAIAAEABALnAAICrAABAAECoAABABQAAQAIAAEABALnAAMC6QKsAAEAAQKgAAMAAAABAE4AAQBUAAEAAABTAAMAAAABADwAAgCIAI4AAQAAAFMAAwAAAAEAKAACAHQArgABAAAAUwADAAAAAQAUAAIAYACgAAEAAABTAAEAAQKyAAIACwKNApUAAAKXApcACQKZApkACglZCVkACwleCV4ADAljCWMADQlqCW4ADglxCXEAEwv0C/QAFAv2C/YAFQv4C/gAFgABAAEClgACAAgCmQKZAAAJWQlZAAEJXgleAAIJYwljAAMJagluAAQJcQlxAAkL9Av0AAoL9gv2AAsAAQABCXQAAQABCWIAAwACArwDAgABAwgAAQMOAAEAAABUAAMAAwKmAqYC7AABAvIAAQL4AAEAAABUAAMAAwKOAw4C1AABAtoAAQLgAAEAAABUAAMABAJ2AnYC9gK8AAECwgABAsgAAQAAAFQAAwABAuQAAQKoAAEC6gABAAAAVAADAAICSALQAAEClAABAtYAAQAAAFQAAwABAroAAQJ+AAIDAAIyAAEAAABUAAMAAgIcAqQAAQJoAAIC6gIcAAEAAABUAAMAAQKMAAECUAADAtIC2ALeAAEAAABUAAMAAgHsAnQAAQI4AAMCugLAAsYAAQAAAFQAAwABAloAAQIeAAMCoAKmAloAAQAAAFQAAwACAboCQgABAgYAAwKIAo4CQgABAAAAVAADAAECgAABAewAAQIuAAEAAABUAAMAAQJsAAEB2AACAloBjAABAAAAVAADAAECVgABAcIAAwJEAkoB/gABAAAAVAADAAECPgABAaoAAwIsAjICOAABAAAAVAADAAIBRgImAAEBkgABAdQAAQAAAFQAAwACATACEAABAXwAAgH+ATAAAQAAAFQAAwACARgB+AABAWQAAwHmAewBoAABAAAAVAADAAIA/gHeAAEBSgADAcwB0gHYAAEAAABUAAMAAgHKAdAAAQEwAAEBNgABAAAAVAADAAMBtAGoAboAAQEaAAEBIAABAAAAVAADAAMBkAGcAaIAAQECAAEBCAABAAAAVAADAAMAngGEAYoAAQDqAAEA8AABAAAAVAADAAQAhgCGAWwBcgABANIAAQDYAAEAAABUAAMABABsAVIBRgFYAAEAuAABAL4AAQAAAFQAAwAFAFIAUgE4ASwBPgABAJ4AAQCkAAEAAABUAAMABAA2ARABHAEiAAEAggABAIgAAQAAAFQAAwAFABwAHAD2AQIBCAABAGgAAQBuAAEAAABUAAIACwKNApkAAAKbApsADQSVBJUADgZ1BnUADwhGCEYAEAlZCXcAEQv0C/QAMAv2C/YAMQv4C/gAMg/tD+0AMw/yD/MANAABAAECrAABAAEJYQACAAcCoAK9AAACwgLKAB4CzQLnACcGdwZ3AEILCQsJAEMLuQvAAEQP7g/xAEwAAQACApgCmwABAAEClgACAAoCoQK9AAACwgLKAB0CzQLWACYC2ALiADAC5ALnADsGdAZ0AD8GdwZ3AEALCQsJAEELuQvAAEIP7g/xAEoAAQABAqAAAQABAqUAAQABApgAAQABC/UAAQABAp4AAQABArkAAgAIAAEJcQABAAEL9AABABYAAQAIAAEABAZ3AAQC6QKpApQAAQABAqkAAQAqAAMADAAWACAAAQAEC8IAAgKZAAEABAvDAAICmQABAAQLxAACApkAAgABAo4CkAAAAAEAMAADAAwAGAAkAAEABAvCAAMC6QKZAAEABAvDAAMC6QKZAAEABAvEAAMC6QKZAAIAAQKOApAAAAABAboAAQAIADYAbgB0AHoAgACGAIwAkgCYAJ4ApACqALAAtgC8AMIAyADOANQA2gDgAOYA7ADyAPgA/gEEAQoBEAEWARwBIgEoAS4BNAE6AUABRgFMAVIBWAFeAWQBagFwAXYBfAGCAYgBjgGUAZoBoAGmAawCjQACAo0CjgACAo4CjwACAo8CkAACApACkQACApECkgACApICkwACApMClAACApQClQACApUClgACApYClwACApcCmAACApgCmQACApkCmwACApsElQACBJUGdQACBnUIRgACCEYJWQACCVkJWgACCVoJWwACCVsJXAACCVwJXQACCV0JXgACCV4JXwACCV8JYAACCWAJYQACCWEJYgACCWIJYwACCWMJZAACCWQJZQACCWUJZgACCWYJZwACCWcJaAACCWgJaQACCWkJagACCWoJawACCWsJbAACCWwJbQACCW0JbgACCW4JbwACCW8JcAACCXAJcQACCXEJcgACCXIJcwACCXMJdAACCXQJdQACCXUJdgACCXYJdwACCXcL9AACC/QL9gACC/YL+AACC/gP7QACD+0P8gACD/IP8wACD/MAAQABCwkAAwAAAAEAEgABABgAAQAAAFUAAQABAAMAAgALAo0CmQAAApsCmwANBJUElQAOBnUGdQAPCEYIRgAQCVkJdwARC/QL9AAwC/YL9gAxC/gL+AAyD+0P7QAzD/IP8wA0AAEAGgABAAgAAgAGAAwL9wACCIwL9wACAukAAQABArAAAQ6uAIYBEgEsAUYBYAF6AZQBrgHIAeIB/AIWAjACSgJkAn4CmAKyAswC5gMAAxoDNANOA2gDggOcA7YD0APqBAQEHgQ4BFIEbASGBKAEugTUBO4FCAUiBTwFVgVwBYoFpAW+BdgF8gYMBiYGQAZaBnQGjgaoBsIG3Ab2BxAHKgdEB14HeAeSB6wHxgfgB/oIFAguCEgIYgh8CJYIsAjKCOQI/gkYCTIJTAlmCYAJmgm0Cc4J6AoCChwKNgpQCmoKhAqeCrgK0grsCwYLIAs6C1QLbguIC6ILvAvWC/AMCgwkDD4MWAxyDIwMpgzADNoM9A0ODSgNQg1cDXYNkA2qDcQN3g34DhIOLA5GDmAOeg6UAAMACAAOABQCjQACCIwCjQACAukCjQACAugAAwAIAA4AFAKOAAIIjAKOAAIC6QKOAAIC6AADAAgADgAUAo8AAgiMAo8AAgLpAo8AAgLoAAMACAAOABQCkAACCIwCkAACAukCkAACAugAAwAIAA4AFAKRAAIIjAKRAAIC6QKRAAIC6AADAAgADgAUApIAAgiMApIAAgLpApIAAgLoAAMACAAOABQCkwACCIwCkwACAukCkwACAugAAwAIAA4AFAKUAAIIjAKUAAIC6QKUAAIC6AADAAgADgAUApUAAgiMApUAAgLpApUAAgLoAAMACAAOABQClgACCIwClgACAukClgACAugAAwAIAA4AFAKXAAIIjAKXAAIC6QKXAAIC6AADAAgADgAUApgAAgiMApgAAgLpApgAAgLoAAMACAAOABQCmQACCIwCmQACAukCmQACAugAAwAIAA4AFAKbAAIIjAKbAAIC6QKbAAIC6AADAAgADgAUAqAAAgiMAqAAAgLpAqAAAgLoAAMACAAOABQCoQACCIwCoQACAukCoQACAugAAwAIAA4AFAKiAAIIjAKiAAIC6QKiAAIC6AADAAgADgAUAqMAAgiMAqMAAgLpAqMAAgLoAAMACAAOABQCpAACCIwCpAACAukCpAACAugAAwAIAA4AFAKlAAIIjAKlAAIC6QKlAAIC6AADAAgADgAUAqYAAgiMAqYAAgLpAqYAAgLoAAMACAAOABQCpwACCIwCpwACAukCpwACAugAAwAIAA4AFAKoAAIIjAKoAAIC6QKoAAIC6AADAAgADgAUAqkAAgiMAqkAAgLpAqkAAgLoAAMACAAOABQCqgACCIwCqgACAukCqgACAugAAwAIAA4AFAKrAAIIjAKrAAIC6QKrAAIC6AADAAgADgAUAqwAAgiMAqwAAgLpAqwAAgLoAAMACAAOABQCrQACCIwCrQACAukCrQACAugAAwAIAA4AFAKuAAIIjAKuAAIC6QKuAAIC6AADAAgADgAUAq8AAgiMAq8AAgLpAq8AAgLoAAMACAAOABQCsAACCIwCsAACAukCsAACAugAAwAIAA4AFAKxAAIIjAKxAAIC6QKxAAIC6AADAAgADgAUArIAAgiMArIAAgLpArIAAgLoAAMACAAOABQCswACCIwCswACAukCswACAugAAwAIAA4AFAK0AAIIjAK0AAIC6QK0AAIC6AADAAgADgAUArUAAgiMArUAAgLpArUAAgLoAAMACAAOABQCtgACCIwCtgACAukCtgACAugAAwAIAA4AFAK3AAIIjAK3AAIC6QK3AAIC6AADAAgADgAUArgAAgiMArgAAgLpArgAAgLoAAMACAAOABQCuQACCIwCuQACAukCuQACAugAAwAIAA4AFAK6AAIIjAK6AAIC6QK6AAIC6AADAAgADgAUArsAAgiMArsAAgLpArsAAgLoAAMACAAOABQCvAACCIwCvAACAukCvAACAugAAwAIAA4AFAK9AAIIjAK9AAIC6QK9AAIC6AADAAgADgAUAsIAAgiMAsIAAgLpAsIAAgLoAAMACAAOABQCwwACCIwCwwACAukCwwACAugAAwAIAA4AFALEAAIIjALEAAIC6QLEAAIC6AADAAgADgAUAsUAAgiMAsUAAgLpAsUAAgLoAAMACAAOABQCxgACCIwCxgACAukCxgACAugAAwAIAA4AFALHAAIIjALHAAIC6QLHAAIC6AADAAgADgAUAsgAAgiMAsgAAgLpAsgAAgLoAAMACAAOABQCyQACCIwCyQACAukCyQACAugAAwAIAA4AFALKAAIIjALKAAIC6QLKAAIC6AADAAgADgAUAs0AAgiMAs0AAgLpAs0AAgLoAAMACAAOABQCzgACCIwCzgACAukCzgACAugAAwAIAA4AFALPAAIIjALPAAIC6QLPAAIC6AADAAgADgAUAtAAAgiMAtAAAgLpAtAAAgLoAAMACAAOABQC0QACCIwC0QACAukC0QACAugAAwAIAA4AFALSAAIIjALSAAIC6QLSAAIC6AADAAgADgAUAtMAAgiMAtMAAgLpAtMAAgLoAAMACAAOABQC1AACCIwC1AACAukC1AACAugAAwAIAA4AFALVAAIIjALVAAIC6QLVAAIC6AADAAgADgAUAtYAAgiMAtYAAgLpAtYAAgLoAAMACAAOABQC1wACCIwC1wACAukC1wACAugAAwAIAA4AFALYAAIIjALYAAIC6QLYAAIC6AADAAgADgAUAtkAAgiMAtkAAgLpAtkAAgLoAAMACAAOABQC2gACCIwC2gACAukC2gACAugAAwAIAA4AFALbAAIIjALbAAIC6QLbAAIC6AADAAgADgAUAtwAAgiMAtwAAgLpAtwAAgLoAAMACAAOABQC3QACCIwC3QACAukC3QACAugAAwAIAA4AFALeAAIIjALeAAIC6QLeAAIC6AADAAgADgAUAt8AAgiMAt8AAgLpAt8AAgLoAAMACAAOABQC4AACCIwC4AACAukC4AACAugAAwAIAA4AFALhAAIIjALhAAIC6QLhAAIC6AADAAgADgAUAuIAAgiMAuIAAgLpAuIAAgLoAAMACAAOABQC4wACCIwC4wACAukC4wACAugAAwAIAA4AFALkAAIIjALkAAIC6QLkAAIC6AADAAgADgAUAuUAAgiMAuUAAgLpAuUAAgLoAAMACAAOABQC5gACCIwC5gACAukC5gACAugAAwAIAA4AFALnAAIIjALnAAIC6QLnAAIC6AADAAgADgAUBJUAAgiMBJUAAgLpBJUAAgLoAAMACAAOABQGdQACCIwGdQACAukGdQACAugAAwAIAA4AFAZ3AAIIjAZ3AAIC6QZ3AAIC6AADAAgADgAUCEYAAgiMCEYAAgLpCEYAAgLoAAMACAAOABQJWQACCIwJWQACAukJWQACAugAAwAIAA4AFAlaAAIIjAlaAAIC6QlaAAIC6AADAAgADgAUCVsAAgiMCVsAAgLpCVsAAgLoAAMACAAOABQJXAACCIwJXAACAukJXAACAugAAwAIAA4AFAldAAIIjAldAAIC6QldAAIC6AADAAgADgAUCV4AAgiMCV4AAgLpCV4AAgLoAAMACAAOABQJXwACCIwJXwACAukJXwACAugAAwAIAA4AFAlgAAIIjAlgAAIC6QlgAAIC6AADAAgADgAUCWEAAgiMCWEAAgLpCWEAAgLoAAMACAAOABQJYgACCIwJYgACAukJYgACAugAAwAIAA4AFAljAAIIjAljAAIC6QljAAIC6AADAAgADgAUCWQAAgiMCWQAAgLpCWQAAgLoAAMACAAOABQJZQACCIwJZQACAukJZQACAugAAwAIAA4AFAlmAAIIjAlmAAIC6QlmAAIC6AADAAgADgAUCWcAAgiMCWcAAgLpCWcAAgLoAAMACAAOABQJaAACCIwJaAACAukJaAACAugAAwAIAA4AFAlpAAIIjAlpAAIC6QlpAAIC6AADAAgADgAUCWoAAgiMCWoAAgLpCWoAAgLoAAMACAAOABQJawACCIwJawACAukJawACAugAAwAIAA4AFAlsAAIIjAlsAAIC6QlsAAIC6AADAAgADgAUCW0AAgiMCW0AAgLpCW0AAgLoAAMACAAOABQJbgACCIwJbgACAukJbgACAugAAwAIAA4AFAlvAAIIjAlvAAIC6QlvAAIC6AADAAgADgAUCXAAAgiMCXAAAgLpCXAAAgLoAAMACAAOABQJcQACCIwJcQACAukJcQACAugAAwAIAA4AFAlyAAIIjAlyAAIC6QlyAAIC6AADAAgADgAUCXMAAgiMCXMAAgLpCXMAAgLoAAMACAAOABQJdAACCIwJdAACAukJdAACAugAAwAIAA4AFAl1AAIIjAl1AAIC6Ql1AAIC6AADAAgADgAUCXYAAgiMCXYAAgLpCXYAAgLoAAMACAAOABQJdwACCIwJdwACAukJdwACAugAAwAIAA4AFAsJAAIIjAsJAAIC6QsJAAIC6AADAAgADgAUC7kAAgiMC7kAAgLpC7kAAgLoAAMACAAOABQLugACCIwLugACAukLugACAugAAwAIAA4AFAu7AAIIjAu7AAIC6Qu7AAIC6AADAAgADgAUC7wAAgiMC7wAAgLpC7wAAgLoAAMACAAOABQLvQACCIwLvQACAukLvQACAugAAwAIAA4AFAu+AAIIjAu+AAIC6Qu+AAIC6AADAAgADgAUC78AAgiMC78AAgLpC78AAgLoAAMACAAOABQLwAACCIwLwAACAukLwAACAugAAwAIAA4AFAv0AAIIjAv0AAIC6Qv0AAIC6AADAAgADgAUC/YAAgiMC/YAAgLpC/YAAgLoAAMACAAOABQL+AACCIwL+AACAukL+AACAugAAwAIAA4AFA/tAAIIjA/tAAIC6Q/tAAIC6AADAAgADgAUD+4AAgiMD+4AAgLpD+4AAgLoAAMACAAOABQP7wACCIwP7wACAukP7wACAugAAwAIAA4AFA/wAAIIjA/wAAIC6Q/wAAIC6AADAAgADgAUD/EAAgiMD/EAAgLpD/EAAgLoAAMACAAOABQP8gACCIwP8gACAukP8gACAugAAwAIAA4AFA/zAAIIjA/zAAIC6Q/zAAIC6AACABACjQKZAAACmwKbAA0CoAK9AA4CwgLKACwCzQLnADUElQSVAFAGdQZ1AFEGdwZ3AFIIRghGAFMJWQl3AFQLCQsJAHMLuQvAAHQL9Av0AHwL9gv2AH0L+Av4AH4P7Q/zAH8AAQCiAA0AIAAqADQAPgBIAFIAXABmAHAAegCEAI4AmAABAAQCjQACAo0AAQAEAo4AAgKOAAEABAKPAAICjwABAAQCkAACApAAAQAEApEAAgKRAAEABAKSAAICkgABAAQCkwACApMAAQAEApQAAgKUAAEABAKVAAIClQABAAQClgACApYAAQAEApcAAgKXAAEABAv1AAIL9QABAAQL+AACC/gAAgADAo0ClwAAC/UL9QALC/gL+AAMAAEBWgAWADIAPABOAGAAcgCEAI4AmACiAKwAtgDIANIA3ADmAPAA+gEMARYBIAEqAUgAAQAEAs0AAgKYAAIABgAMAs4AAgKYAuQAAgKbAAIABgAMAs8AAgKYD+4AAgKbAAIABgAMAtAAAgKYD+8AAgKbAAIABgAMAtEAAgKYD/AAAgKbAAEABALSAAICmAABAAQC0wACApgAAQAEAtQAAgKYAAEABALVAAICmAABAAQC1gACApgAAgAGAAwC1wACApgC5QACApsAAQAEAtgAAgKYAAEABALZAAICmAABAAQC2gACApgAAQAEAtsAAgKYAAEABALcAAICmAACAAYADALdAAICmALmAAICmwABAAQC3gACApgAAQAEAt8AAgKYAAEABALgAAICmAADAAgADgAWAuEAAgKYAskAAwKdApgCygADAp4CmAACAAYADALiAAICmA/xAAICmwACAAYCoAKmAAACqAKsAAcCrgKuAAwCsAKxAA0CswK0AA8CtgK6ABEAAQAuAAIACgAcAAIABgAMAscAAgKdAsgAAgKeAAIABgAMAskAAgKdAsoAAgKeAAEAAgK5AuEAAQASAAEACAABAAQC4wACApYAAQABAqUAAgAIAAEClgABAAEL9QADAAAAAgI4AkAAAQJGAAEAAABWAAMAAAACAiQCLAACAnICMgABAAAAVgADAAAAAgIOAhYAAwJcAlwCHAABAAAAVgADAAAAAgH2Af4ABAJEAkQCRAIEAAEAAABWAAMAAAACAdwB5AACAl4CZAABAAAAVgADAAAAAgHGAc4AAwIUAkgCTgABAAAAVgADAAAAAgGuAbYABAH8AfwCMAI2AAEAAABWAAMAAAACAZQBnAAFAeIB4gHiAhYCHAABAAAAVgADAAAAAgF4AYAAAQIQAAEAAABWAAMAAAACAWQBbAACAbIB/AABAAAAVgADAAAAAgFOAVYAAwGcAZwB5gABAAAAVgADAAAAAgE2AT4ABAGEAYQBhAHOAAEAAABWAAMAAAACARwBJAACAZ4BugABAAAAVgADAAAAAgEGAQ4AAgGIAaoAAQAAAFYAAwAAAAIA8AD4AAMBPgFyAY4AAQAAAFYAAwAAAAIA2ADgAAMBJgFaAXwAAQAAAFYAAwAAAAIAwADIAAQBDgEOAUIBXgABAAAAVgADAAAAAgCmAK4ABAD0APQBKAFKAAEAAABWAAMAAAACAIwAlAAFANoA2gDaAQ4BKgABAAAAVgADAAAAAgBwAHgABQC+AL4AvgDyARQAAQAAAFYAAwAAAAIAVABcAAEA/gABAAAAVgADAAAAAgBAAEgAAgDwAOoAAQAAAFYAAwAAAAIAKgAyAAEBIAABAAAAVgADAAAAAgAWAB4AAgDGAQwAAQAAAFYAAQACAqwC2AABAAEClgACAAoCoQK9AAACwgLKAB0CzQLWACYC2ALiADAC5ALnADsGdAZ0AD8GdwZ3AEALCQsJAEELuQvAAEIP7g/xAEoAAgAIApkCmQAABJUElQABBnUGdQACCEYIRgADCVkJdgAEC/QL9AAiC/YL9gAjD/IP8wAkAAEAAQKgAAIAAgKNApcAAAv4C/gACwABAAECzQABAAEC4wABAAEC0gABAAEJYQACAAsCjQKZAAACmwKbAA0ElQSVAA4GdQZ1AA8IRghGABAJWQl3ABEL9Av0ADAL9gv2ADEL+Av4ADIP7Q/tADMP8g/zADQAAQABCXUAAwACABYAHAACACIAKAAAAAEAAABXAAEAAQKNAAEAAQK2AAEAAQsJAAEAAQKRAAEAGgABAAgAAgAGAAwCwgACAo0CwwACApUAAQABAqoAAwACAcwB6AABAe4AAgIiAlwAAQAAAFgAAwACAbQB0AABAdYAAQJaAAEAAABYAAMAAgGeAmwAAQHAAAIB9AIuAAEAAABYAAMAAgGGAlQAAQGoAAECLAABAAAAWAADAAIBcAJEAAEBkgACAcYCAAABAAAAWAADAAIBWAIsAAEBegABAf4AAQAAAFgAAwACAUICHAABAWQAAgGYAdIAAQAAAFgAAwACASoCBAABAUwAAQHQAAEAAABYAAMAAgEUAfQAAQE2AAIBagGkAAEAAABYAAMAAgD8AdwAAQEeAAEBogABAAAAWAADAAIA5gHMAAEBCAACATwBdgABAAAAWAADAAIAzgG0AAEA8AABAXQAAQAAAFgAAwACALgBpAABANoAAgEOAUgAAQAAAFgAAwACAKABjAABAMIAAQFGAAEAAABYAAMAAgCKAXwAAQCsAAIA4AEaAAEAAABYAAMAAgByAWQAAQCUAAEBGAABAAAAWAADAAIAXAFUAAEAfgACALIA7AABAAAAWAADAAIARAE8AAEAZgABAOoAAQAAAFgAAwACAC4BLAABAFAAAgCEAL4AAQAAAFgAAwACABYBFAABADgAAQC8AAEAAABYAAIABAKOApAAAAKSApUAAwKXApcABwv4C/gACAABAAECogACAAgCmQKZAAAJWQlZAAEJXgleAAIJYwljAAMJagluAAQJcQlxAAkL9Av0AAoL9gv2AAsAAgAJAqICowAAAqUCpgACAqkCqQAEArUCtQAFArcCuAAGAs8C0AAIAtIC0wAKAtUC1QAMAt8C4AANAAIAAwKNApUAAAKXApcACQv4C/gACgACAAYCqgKqAAACrwKvAAECswKzAAICwgLDAAMC1gLWAAUC3ALcAAYAAQABAs8AAQABAqUAAQABAtIAAQABAqkAAQABAtUAAQABArAAAQABAtoAAQABAqYAAQABAtMAAwACABQAFAABAFoAAAABAAAAWQACAAsCjQKVAAAClwKXAAkCmQKZAAoJWQlZAAsJXgleAAwJYwljAA0JagluAA4JcQlxABML9Av0ABQL9gv2ABUL+Av4ABYAAgAKAo0CjQAAApQClAABApkCmQACCVkJWQADCV4JXgAECWMJYwAFCWoJbgAGCXEJcQALC/QL9AAMC/YL9gANAAEANgAEAA4AFgAmAC4AAQAEC/YAAQACAAYADA/zAAIIRg/yAAEAAQAED/MAAQABAAQP8gABAAIAAwSVBJUAAAhGCEcAAQl3CXcAAwADAAAAAQD2AAQBWgGUAZQB2gABAAAAWgADAAAAAQDeAAQBQgF8AXwByAABAAAAWgADAAAAAQDGAAMBKgG2AaoAAQAAAFoAAwAAAAEAsAADARQBoAGaAAEAAABaAAMAAAABAJoAAwD+AZABfgABAAAAWgADAAAAAQCEAAMA6AF6AW4AAQAAAFoAAwAAAAEAbgADANIBagFSAAEAAABaAAMAAAABAFgAAwC8AVQBQgABAAAAWgADAAAAAQBCAAMApgFEAUoAAQAAAFoAAwAAAAEALAADAJABLgE6AAEAAABaAAMAAAABABYAAwB6ARgBKgABAAAAWgACABACjQKZAAACmwKbAA0CoAK9AA4CwgLKACwCzQLnADUElQSVAFAGdQZ1AFEGdwZ3AFIIRghGAFMJWQl3AFQLCQsJAHMLuQvAAHQL9Av0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AxADFgMcAyIDKAMuAzQDOgNAA0YDTANSA1gDXgNkA2oDcAN2A3wDggOIA44DlAOaA6ADpgOsA7IDuAO+A8QDygPQA9YD3APiA+gD7gP0A/oEAAQGBAwEEgQYBB4EJAQqBDAAAgKNC9cAAgKOC9cAAgKPC9cAAgKQC9cAAgKRC9cAAgKSC9cAAgKTC9cAAgKUC9cAAgKVC9cAAgKWC9cAAgKXC9cAAgKYC9cAAgKZC9cAAgKbC9cAAgKgC9cAAgKhC9cAAgKiC9cAAgKjC9cAAgKkC9cAAgKlC9cAAgKmC9cAAgKnC9cAAgKoC9cAAgKpC9cAAgKqC9cAAgKrC9cAAgKsC9cAAgKtC9cAAgKuC9cAAgKvC9cAAgKwC9cAAgKxC9cAAgKyC9cAAgKzC9cAAgK0C9cAAgK1C9cAAgK2C9cAAgK3C9cAAgK4C9cAAgK5C9cAAgK6C9cAAgK7C9cAAgK8C9cAAgK9C9cAAgLCC9cAAgLDC9cAAgLEC9cAAgLFC9cAAgLGC9cAAgLHC9cAAgLIC9cAAgLJC9cAAgLKC9cAAgLNC9cAAgLOC9cAAgLPC9cAAgLQC9cAAgLRC9cAAgLSC9cAAgLTC9cAAgLUC9cAAgLVC9cAAgLWC9cAAgLXC9cAAgLYC9cAAgLZC9cAAgLaC9cAAgLbC9cAAgLcC9cAAgLdC9cAAgLeC9cAAgLfC9cAAgLgC9cAAgLhC9cAAgLiC9cAAgLjC9cAAgLkC9cAAgLlC9cAAgLmC9cAAgLnC9cAAgSVC9cAAgZ1C9cAAgZ3C9cAAghGC9cAAglZC9cAAglaC9cAAglbC9cAAglcC9cAAgldC9cAAgleC9cAAglfC9cAAglgC9cAAglhC9cAAgliC9cAAgljC9cAAglkC9cAAgllC9cAAglmC9cAAglnC9cAAgloC9cAAglpC9cAAglqC9cAAglrC9cAAglsC9cAAgltC9cAAgluC9cAAglvC9cAAglwC9cAAglxC9cAAglyC9cAAglzC9cAAgl0C9cAAgl1C9cAAgl2C9cAAgl3C9cAAgsJC9cAAgu5C9cAAgu6C9cAAgu7C9cAAgu8C9cAAgu9C9cAAgu+C9cAAgu/C9cAAgvAC9cAAgv0C9cAAgv2C9cAAgv4C9cAAg/tC9cAAg/uC9cAAg/vC9cAAg/wC9cAAg/xC9cAAg/yC9cAAg/z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';
        doc.addFileToVFS('arial-normal.ttf', customfont);
		doc.addFont('arial-normal.ttf', 'arial', 'normal');
		doc.setFont('arial');
        var pageWidth = doc.internal.pageSize.getWidth() - 20;
        if (heading !== "") {
            doc.setDrawColor(220, 220, 220);
            doc.setFillColor(parseInt(hColor[1]), parseInt(hColor[2]), parseInt(hColor[3]));
            doc.setTextColor(parseInt(hfColor[1]), parseInt(hfColor[2]), parseInt(hfColor[3]));
            //added color values from variables instead of static
            doc.rect(10, 20, pageWidth, 10, 'F');
            doc.line(10, 20, (pageWidth + 10), 20);
            doc.setFontSize(15);
            doc.text(12, 27, heading);
        }

        if (subHeading !== "") {
            doc.setFillColor(parseInt(shColor[1]), parseInt(shColor[2]), parseInt(shColor[3]));
            doc.setTextColor(parseInt(shfColor[1]), parseInt(shfColor[2]), parseInt(shfColor[3]));
            //added color values from variables instead of static
            doc.rect(10, 30, pageWidth, 8, 'F');
            doc.line(10, 38, (pageWidth + 10), 38);
            doc.setFontSize(10);
            doc.text(12, 35, subHeading);
        }
        if (IsBoolean(this.component.m_exporttopdfgrid.filterdetails)) {
            var compFilterValues = "";
            var ConnectionDetail = gvController.dashboard.m_DataProviders.m_dataUrlIdObjMap[this.component.m_datasource];
            var filterKeys = ConnectionDetail.getKeys();
            for (var j = 0; j < filterKeys.length; j++) {
                compFilterValues += filterKeys[j] + "= '" + ConnectionDetail.getClauseData()[(filterKeys[j]).toLowerCase()] + ((j < filterKeys.length - 1) ? "' | " : "'");
            }
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(8);
            var r = (heading !== "" || subHeading !== "") ? 43 : 15;
            doc.text(compFilterValues, 12, r);
        }
        var startYpos = (heading !== "" || subHeading !== "") ? 45 : 20;
        doc.autoTable(columnHeads, rowdata, {
            theme: temp.component.m_exporttopdfgrid.theme,
            startY: startYpos,
            tableWidth: 'auto',
            margin: {
                horizontal: 10
            },
            styles: {
                overflow: 'linebreak',
                font : 'arial'
            },
            bodyStyles: {
                valign: 'top'
            },
            columnStyles: {
                email: {
                    columnWidth: 'wrap'
                }
            },
            createdHeaderCell: function(cell, cellData) {
                if ((temp.component.m_objecttype == "datagrid") || (temp.component.m_objecttype == "scorecard")) {
                    if (IsBoolean(temp.component.m_usefieldalign)) {
                        cell.styles.halign = textAlign[0][cellData.column.index];
                    } else {
                        cell.styles.halign = temp.component.m_headertextalign;
                    }
                }
            },
            createdCell: function(cell, cellData) {
                if ((temp.component.m_objecttype == "datagrid") || (temp.component.m_objecttype == "scorecard")) {
                    cell.styles.halign = textAlign[cellData.row.index][cellData.column.index];
                    if (IsBoolean(temp.component.getAlertObj()[temp.component.getStringARSC(cellData.column.dataKey)])) {
                        if (temp.component.getAlertObj()[temp.component.getStringARSC(cellData.column.dataKey)].m_alerttype == 'colorfill') {
                            cell.styles.fillColor = alertColorRow[cellData.row.index][cellData.column.index];
                        }
                    }
                }
            }
        }); /*Added createdHeaderCell & createdCell for getting alerts in rows & text alignment */
        if (!IsBoolean(pdfngrid)) {
            var pageCount = doc.internal.getNumberOfPages();

            // For each page, print the page number and the total pages
            for (var i = 1; i <= pageCount; i++) {
                // Go to page i
                doc.setPage(i);
                //Print Page 1 of 4 for example
                doc.text('Page ' + String(i) + ' of ' + String(pageCount), doc.internal.pageSize.getWidth() - 20, doc.internal.pageSize.getHeight() - 10, null, null, "right");
            }
            var data = doc.output();
            var buffer = new ArrayBuffer(data.length);
            var array = new Uint8Array(buffer);
            for (var i = 0; i < data.length; i++) {
                array[i] = data.charCodeAt(i);
            }
            var blob = new Blob([array], {
                type: 'application/pdf',
                encoding: 'raw'
            });
            if (window.saveAs) {
                window.saveAs(blob, fileName + ".pdf");
            } else {
                window.navigator.msSaveBlob(blob, fileName + ".pdf");
            }
        }
    }
};

Plugin.prototype.exportToPrint = function () {
	var	temp = this;
	var divSelector = "#draggableDiv" + temp.component.m_objectid;
	var divObject = $(divSelector)[0];
	var fileName = temp.exportFileName;
	var heading = temp.component.m_pptheading;
	var subHeading = temp.component.m_pptsubheading;
	//remove timeline chart svg rect animation to avoid export issue 
	if ( (temp.svgCharts.indexOf(temp.component.m_componenttype) > -1) && IsBoolean(temp.component.m_enableanimation)) {
		$(divObject).find("svg").find(".timeSeries-stackHighlighter").find("animate").remove();
		$(divObject).find("svg").find(".pointShapeColorAnimation").find("animate").remove();
		for(var i = 1; i<$(divObject).find("svg").find(".pointShapeColorAnimation").length; i= i+2){
			var color =$(divObject).find("svg").find(".pointShapeColorAnimation")[i-1].attributes[1].nodeValue;
			$(divObject).find("svg").find(".pointShapeColorAnimation")[i].setAttribute("stop-color", color);
		}
		$(divObject).find("svg").find(".pointShapeAnimation").find("animate").remove();
	}
	this.removeExportIframe();
	function cb(_canvas){
		dataUrl = _canvas.toDataURL("image/jpeg");
		var windowContent = '<!DOCTYPE html>';
		windowContent += '<html>';
		windowContent += '<head><title></title></head>';
		windowContent += '<body>';
		windowContent += '<div>' + heading + '</div>';
		windowContent += '<div>' + subHeading + '</div>';
		windowContent += '<img src="' + dataUrl + '">';
		windowContent += '</body>';
		windowContent += '</html>';
		var printWin = window.open('','','width=800,height=600');
		printWin.document.write(windowContent);
		printWin.document.close();
		printWin.moveTo(0, 0);
		printWin.resizeTo(screen.width, screen.height);
		setTimeout(function() {
			printWin.print();
			printWin.close();
		}, 250);
	};
	if(((isIE = false || !!document.documentMode) || (isFirefox = typeof InstallTrigger !== 'undefined')) && (temp.svgCharts.indexOf(temp.component.m_componenttype) > -1)){
		var imageData = replaceSvgWithCanvas(divObject);
		var windowContent = '<!DOCTYPE html>';
		windowContent += '<html>';
		windowContent += '<head><title></title></head>';
		windowContent += '<body>';
		windowContent += '<div>' + heading + '</div>';
		windowContent += '<div>' + subHeading + '</div>';
		windowContent += '<img src="' + imageData + '">';
		windowContent += '</body>';
		windowContent += '</html>';
		var printWin = window.open('','','width=800,height=600');
		printWin.document.write(windowContent);
		printWin.document.close();
		printWin.moveTo(0, 0);
		printWin.resizeTo(screen.width, screen.height);
		setTimeout(function() {
			printWin.print();
			printWin.close();
		}, 250);
	} else {
		try{
			html2canvas(divObject, {
				height: ($(divObject).get(0).scrollHeight),
				width: ($(divObject).get(0).scrollWidth),
				backgroundColor: temp.component.m_exportdefaultbgcolor,
				logging: IsBoolean(dGlobals.isDevMode)
			}).then(function(canvas){
				cb(canvas);
			});
		}catch(e){
			console.log(e);
		}
	}
};

Plugin.prototype.showData = function () {
	this.showChartData.drawChart();
};

Plugin.prototype.showChartInfo = function () {
	var component = this.component;
	$("#info").remove();
	var _content = "<div id=\"info\" title=\"Chart Info\">" +
		"<div class=\"info-wrapper\"><span class=\"infoTitle\">Chart Type: </span><span class=\"infoValue\">" + this.component.m_type + "</span><div class=\"clear\"></div></div>" +
		"<div class=\"info-wrapper\"><span class=\"infoTitle\">Chart Name: </span><span class=\"infoValue\">" + this.component.m_objectname + "</span><div class=\"clear\"></div></div>" +
		"<div class=\"info-wrapper\"><span class=\"infoTitle\">Company : </span><span class=\"infoValue\">BDI Systems & Techonlogy</span><div class=\"clear\"></div></div>" +
		"</div>"
		$("body").append(_content);
	$("#info").dialog({
		width : 300,
		height : 100
	});
};
Plugin.prototype.getStringARSC = function (str) {
	return (str) ? (str.toString()).replace(/[^a-z0-9\s]/gi, '').replace(/[_\s]/g, ' ') : str;
};

/**@description Added below method for converting scg to canvas while exporting using custom method**/
Plugin.prototype.replaceSvgWithCanvasForexport = function(tempObject, compref) {
	var temp =this;
    // this.$container = $(tempObject).clone();
    //find all svg elements in $container
    var svgElements = $(tempObject).find('svg');
    this.newelements = svgElements;
    //var svgElements = $("#temp").find('svg');
    $(svgElements).find(".timeSeries-stackHighlighter").each(function(index, element) {
        element.removeAttribute("filter");
    });
    var requiredCanvas = [];
    svgElements.each(function() {
    	if(this.id.indexOf('svgTimeScale') < 0 ) {
        //if (this.id.indexOf('svgImgBVZ') != 0 ) {//&& this.id.indexOf('svgImageContainer') != 0
            var canvas, xml;
            canvas = document.createElement("canvas");
            canvas.className = "screenShotTempCanvas";
            canvas.id = this.id;
            var ctx = canvas.getContext('2d');
            ctx.canvas.width = this.clientWidth;
			ctx.canvas.height = this.clientHeight;
			ctx.canvas.style.position = "absolute";
            ctx.canvas.style.left = "0";
            ctx.canvas.style.top = "0";
            //convert SVG into a XML string
            xml = (new XMLSerializer()).serializeToString(this);
            // Removing the name space as IE throws an error
            xml = xml.replace(/xmlns=\"http:\/\/www\.w3\.org\/2000\/svg\"/, '');
            //draw the SVG onto a canvas
            canvg(canvas, xml, {
                ignoreMouse: true,
                ignoreAnimation: true
            });

            /**DAS-604 */
            //$(canvas).insertAfter(this);
            //hide the SVG element
            //this.className = "tempHide";
            //$(this).attr('class', 'tempHide');
            //$(this).hide();
            requiredCanvas.push(canvas);
            if(compref != undefined){
            	if(IsBoolean(compref.m_hidemaxnmin) && this.innerHTML.indexOf('Maximize') > 0){
                	$(canvas).remove();
                }
            }
        }
    });
    return requiredCanvas;
};

function replaceSvgWithCanvas(tempObject) {
    this.$container = $(tempObject).clone();
    //find all svg elements in $container
    var svgElements = this.$container.find('svg');
    $(svgElements).find(".timeSeries-stackHighlighter").each(function(index, element) {
        element.removeAttribute("filter");
    });
    var requiredCanvas;
    svgElements.each(function() {
        var canvas, xml;
        canvas = document.createElement("canvas");
        canvas.className = "screenShotTempCanvas";
        var ctx = canvas.getContext('2d');
        //convert SVG into a XML string
        xml = (new XMLSerializer()).serializeToString(this);
        // Removing the name space as IE throws an error
        xml = xml.replace(/xmlns=\"http:\/\/www\.w3\.org\/2000\/svg\"/, '');
        //draw the SVG onto a canvas
        canvg(canvas, xml, {
            ignoreMouse: true,
            ignoreAnimation: true
        });
        requiredCanvas = canvas.toDataURL("image/jpeg");
    });
    return requiredCanvas;
};
function replaceSvgWithCanvasForDB(tempObject) {
    this.$container = $(tempObject).clone();
    //find all svg elements in $container
    var svgElements = this.$container.find('svg');
    $(svgElements).find(".timeSeries-stackHighlighter").each(function(index, element) {
        element.removeAttribute("filter");
    });
    var requiredCanvas = [];
    svgElements.each(function() {
        var canvas, xml;
        canvas = document.createElement("canvas");
        canvas.className = "screenShotTempCanvas";
        var ctx = canvas.getContext('2d');
        //convert SVG into a XML string
        xml = (new XMLSerializer()).serializeToString(this);
        // Removing the name space as IE throws an error
        xml = xml.replace(/xmlns=\"http:\/\/www\.w3\.org\/2000\/svg\"/, '');
        //draw the SVG onto a canvas
        canvg(canvas, xml, {
            ignoreMouse: true,
            ignoreAnimation: true
        });
        requiredCanvas.push(canvas);
    });
    return requiredCanvas;
};


//-------------------------Exportpdf.js file---------------------------------
//-------------------------Start of jsPdf.js file----------------------------
(function (global, factory) {
	  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  (global.jsPDF = factory());
	}(this, (function () { 'use strict';

	  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	    return typeof obj;
	  } : function (obj) {
	    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	  };

	  /** @preserve
	   * jsPDF - PDF Document creation from JavaScript
	   * Version 1.4.1 Built on 2018-06-06T07:49:28.721Z
	   *                           CommitID 3233f44044
	   *
	   * Copyright (c) 2010-2016 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
	   *               2010 Aaron Spike, https://github.com/acspike
	   *               2012 Willow Systems Corporation, willow-systems.com
	   *               2012 Pablo Hess, https://github.com/pablohess
	   *               2012 Florian Jenett, https://github.com/fjenett
	   *               2013 Warren Weckesser, https://github.com/warrenweckesser
	   *               2013 Youssef Beddad, https://github.com/lifof
	   *               2013 Lee Driscoll, https://github.com/lsdriscoll
	   *               2013 Stefan Slonevskiy, https://github.com/stefslon
	   *               2013 Jeremy Morel, https://github.com/jmorel
	   *               2013 Christoph Hartmann, https://github.com/chris-rock
	   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
	   *               2014 James Makes, https://github.com/dollaruw
	   *               2014 Diego Casorran, https://github.com/diegocr
	   *               2014 Steven Spungin, https://github.com/Flamenco
	   *               2014 Kenneth Glassey, https://github.com/Gavvers
	   *
	   * Licensed under the MIT License
	   *
	   * Contributor(s):
	   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
	   *    kim3er, mfo, alnorth, Flamenco
	   */

	  /**
	   * Creates new jsPDF document object instance.
	   * @name jsPDF
	   * @class
	   * @param orientation {String/Object} Orientation of the first page. Possible values are "portrait" or "landscape" (or shortcuts "p" (Default), "l") <br />
	   * Can also be an options object.
	   * @param unit {String}  Measurement unit to be used when coordinates are specified.<br />
	   * Possible values are "pt" (points), "mm" (Default), "cm", "in" or "px".
	   * @param format {String/Array} The format of the first page. Can be <ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />
	   * Default is "a4". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array , e.g. [595.28, 841.89]
	   * @returns {jsPDF}
	   * @description
	   * If the first parameter (orientation) is an object, it will be interpreted as an object of named parameters
	   * ```
	   * {
	   *  orientation: 'p',
	   *  unit: 'mm',
	   *  format: 'a4',
	   *  hotfixes: [] // an array of hotfix strings to enable
	   * }
	   * ```
	   */
	  var jsPDF = function (global) {

	    var pdfVersion = '1.3',
	        pageFormats = { // Size in pt of various paper formats
	      'a0': [2383.94, 3370.39],
	      'a1': [1683.78, 2383.94],
	      'a2': [1190.55, 1683.78],
	      'a3': [841.89, 1190.55],
	      'a4': [595.28, 841.89],
	      'a5': [419.53, 595.28],
	      'a6': [297.64, 419.53],
	      'a7': [209.76, 297.64],
	      'a8': [147.40, 209.76],
	      'a9': [104.88, 147.40],
	      'a10': [73.70, 104.88],
	      'b0': [2834.65, 4008.19],
	      'b1': [2004.09, 2834.65],
	      'b2': [1417.32, 2004.09],
	      'b3': [1000.63, 1417.32],
	      'b4': [708.66, 1000.63],
	      'b5': [498.90, 708.66],
	      'b6': [354.33, 498.90],
	      'b7': [249.45, 354.33],
	      'b8': [175.75, 249.45],
	      'b9': [124.72, 175.75],
	      'b10': [87.87, 124.72],
	      'c0': [2599.37, 3676.54],
	      'c1': [1836.85, 2599.37],
	      'c2': [1298.27, 1836.85],
	      'c3': [918.43, 1298.27],
	      'c4': [649.13, 918.43],
	      'c5': [459.21, 649.13],
	      'c6': [323.15, 459.21],
	      'c7': [229.61, 323.15],
	      'c8': [161.57, 229.61],
	      'c9': [113.39, 161.57],
	      'c10': [79.37, 113.39],
	      'dl': [311.81, 623.62],
	      'letter': [612, 792],
	      'government-letter': [576, 756],
	      'legal': [612, 1008],
	      'junior-legal': [576, 360],
	      'ledger': [1224, 792],
	      'tabloid': [792, 1224],
	      'credit-card': [153, 243]
	    };

	    /**
	     * jsPDF's Internal PubSub Implementation.
	     * See mrrio.github.io/jsPDF/doc/symbols/PubSub.html
	     * Backward compatible rewritten on 2014 by
	     * Diego Casorran, https://github.com/diegocr
	     *
	     * @class
	     * @name PubSub
	     * @ignore This should not be in the public docs.
	     */
	    function PubSub(context) {
	      var topics = {};

	      this.subscribe = function (topic, callback, once) {
	        if (typeof callback !== 'function') {
	          return false;
	        }

	        if (!topics.hasOwnProperty(topic)) {
	          topics[topic] = {};
	        }

	        var id = Math.random().toString(35);
	        topics[topic][id] = [callback, !!once];

	        return id;
	      };

	      this.unsubscribe = function (token) {
	        for (var topic in topics) {
	          if (topics[topic][token]) {
	            delete topics[topic][token];
	            return true;
	          }
	        }
	        return false;
	      };

	      this.publish = function (topic) {
	        if (topics.hasOwnProperty(topic)) {
	          var args = Array.prototype.slice.call(arguments, 1),
	              idr = [];

	          for (var id in topics[topic]) {
	            var sub = topics[topic][id];
	            try {
	              sub[0].apply(context, args);
	            } catch (ex) {
	              if (global.console) {
	                console.error('jsPDF PubSub Error', ex.message, ex);
	              }
	            }
	            if (sub[1]) idr.push(id);
	          }
	          if (idr.length) idr.forEach(this.unsubscribe);
	        }
	      };
	    }

	    /**
	     * @constructor
	     * @private
	     */
	    function jsPDF(orientation, unit, format, compressPdf) {
	      var options = {};

	      if ((typeof orientation === 'undefined' ? 'undefined' : _typeof(orientation)) === 'object') {
	        options = orientation;

	        orientation = options.orientation;
	        unit = options.unit || unit;
	        format = options.format || format;
	        compressPdf = options.compress || options.compressPdf || compressPdf;
	      }

	      // Default options
	      unit = unit || 'mm';
	      format = format || 'a4';
	      orientation = ('' + (orientation || 'P')).toLowerCase();

	      var format_as_string = ('' + format).toLowerCase(),
	          compress = !!compressPdf && typeof Uint8Array === 'function',
	          textColor = options.textColor || '0 g',
	          drawColor = options.drawColor || '0 G',
	          activeFontSize = options.fontSize || 16,
	          activeCharSpace = options.charSpace || 0,
	          R2L = options.R2L || false,
	          lineHeightProportion = options.lineHeight || 1.15,
	          lineWidth = options.lineWidth || 0.200025,
	          // 2mm
	      fileId = '00000000000000000000000000000000',
	          objectNumber = 2,
	          // 'n' Current object number
	      outToPages = !1,
	          // switches where out() prints. outToPages true = push to pages obj. outToPages false = doc builder content
	      offsets = [],
	          // List of offsets. Activated and reset by buildDocument(). Pupulated by various calls buildDocument makes.
	      fonts = {},
	          // collection of font objects, where key is fontKey - a dynamically created label for a given font.
	      fontmap = {},
	          // mapping structure fontName > fontStyle > font key - performance layer. See addFont()
	      activeFontKey,
	          // will be string representing the KEY of the font as combination of fontName + fontStyle
	      k,
	          // Scale factor
	      tmp,
	          page = 0,
	          currentPage,
	          pages = [],
	          pagesContext = [],
	          // same index as pages and pagedim
	      pagedim = [],
	          content = [],
	          additionalObjects = [],
	          lineCapID = 0,
	          lineJoinID = 0,
	          content_length = 0,
	          pageWidth,
	          pageHeight,
	          pageMode,
	          zoomMode,
	          layoutMode,
	          creationDate,
	          documentProperties = {
	        'title': '',
	        'subject': '',
	        'author': '',
	        'keywords': '',
	        'creator': ''
	      },
	          API = {},
	          events = new PubSub(API),
	          hotfixes = options.hotfixes || [],


	      /////////////////////
	      // Private functions
	      /////////////////////
	      generateColorString = function generateColorString(options) {
	        var color;

	        var ch1 = options.ch1;
	        var ch2 = options.ch2;
	        var ch3 = options.ch3;
	        var ch4 = options.ch4;
	        var precision = options.precision;
	        var letterArray = options.pdfColorType === "draw" ? ['G', 'RG', 'K'] : ['g', 'rg', 'k'];

	        if (typeof ch1 === "string" && ch1.charAt(0) !== '#') {
	          var rgbColor = new RGBColor(ch1);
	          if (rgbColor.ok) {
	            ch1 = rgbColor.toHex();
	          }
	        }
	        //convert short rgb to long form
	        if (typeof ch1 === "string" && /^#[0-9A-Fa-f]{3}$/.test(ch1)) {
	          ch1 = '#' + ch1[1] + ch1[1] + ch1[2] + ch1[2] + ch1[3] + ch1[3];
	        }

	        if (typeof ch1 === "string" && /^#[0-9A-Fa-f]{6}$/.test(ch1)) {
	          var hex = parseInt(ch1.substr(1), 16);
	          ch1 = hex >> 16 & 255;
	          ch2 = hex >> 8 & 255;
	          ch3 = hex & 255;
	        }

	        if (typeof ch2 === "undefined" || typeof ch4 === "undefined" && ch1 === ch2 && ch2 === ch3) {
	          // Gray color space.
	          if (typeof ch1 === "string") {
	            color = ch1 + " " + letterArray[0];
	          } else {
	            switch (options.precision) {
	              case 2:
	                color = f2(ch1 / 255) + " " + letterArray[0];
	                break;
	              case 3:
	              default:
	                color = f3(ch1 / 255) + " " + letterArray[0];
	            }
	          }
	        } else if (typeof ch4 === "undefined" || (typeof ch4 === 'undefined' ? 'undefined' : _typeof(ch4)) === "object") {
	          // assume RGB
	          if (typeof ch1 === "string") {
	            color = [ch1, ch2, ch3, letterArray[1]].join(" ");
	          } else {
	            switch (options.precision) {
	              case 2:
	                color = [f2(ch1 / 255), f2(ch2 / 255), f2(ch3 / 255), letterArray[1]].join(" ");
	                break;
	              default:
	              case 3:
	                color = [f3(ch1 / 255), f3(ch2 / 255), f3(ch3 / 255), letterArray[1]].join(" ");
	            }
	          }
	          // assume RGBA
	          if (ch4 && ch4.a === 0) {
	            //TODO Implement transparency.
	            //WORKAROUND use white for now
	            color = ['255', '255', '255', letterArray[1]].join(" ");
	          }
	        } else {
	          // assume CMYK
	          if (typeof ch1 === 'string') {
	            color = [ch1, ch2, ch3, ch4, letterArray[2]].join(" ");
	          } else {
	            switch (options.precision) {
	              case 2:
	                color = [f2(ch1), f2(ch2), f2(ch3), f2(ch4), letterArray[2]].join(" ");
	                break;
	              case 3:
	              default:
	                color = [f3(ch1), f3(ch2), f3(ch3), f3(ch4), letterArray[2]].join(" ");
	            }
	          }
	        }
	        return color;
	      },
	          convertDateToPDFDate = function convertDateToPDFDate(parmDate) {
	        var padd2 = function padd2(number) {
	          return ('0' + parseInt(number)).slice(-2);
	        };
	        var result = '';
	        var tzoffset = parmDate.getTimezoneOffset(),
	            tzsign = tzoffset < 0 ? '+' : '-',
	            tzhour = Math.floor(Math.abs(tzoffset / 60)),
	            tzmin = Math.abs(tzoffset % 60),
	            timeZoneString = [tzsign, padd2(tzhour), "'", padd2(tzmin), "'"].join('');

	        result = ['D:', parmDate.getFullYear(), padd2(parmDate.getMonth() + 1), padd2(parmDate.getDate()), padd2(parmDate.getHours()), padd2(parmDate.getMinutes()), padd2(parmDate.getSeconds()), timeZoneString].join('');
	        return result;
	      },
	          convertPDFDateToDate = function convertPDFDateToDate(parmPDFDate) {
	        var year = parseInt(parmPDFDate.substr(2, 4), 10);
	        var month = parseInt(parmPDFDate.substr(6, 2), 10) - 1;
	        var date = parseInt(parmPDFDate.substr(8, 2), 10);
	        var hour = parseInt(parmPDFDate.substr(10, 2), 10);
	        var minutes = parseInt(parmPDFDate.substr(12, 2), 10);
	        var seconds = parseInt(parmPDFDate.substr(14, 2), 10);
	        var timeZoneHour = parseInt(parmPDFDate.substr(16, 2), 10);
	        var timeZoneMinutes = parseInt(parmPDFDate.substr(20, 2), 10);

	        var resultingDate = new Date(year, month, date, hour, minutes, seconds, 0);
	        return resultingDate;
	      },
	          setCreationDate = function setCreationDate(date) {
	        var tmpCreationDateString;
	        var regexPDFCreationDate = /^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|\-0[0-9]|\-1[0-1])\'(0[0-9]|[1-5][0-9])\'?$/;
	        if ((typeof date === 'undefined' ? 'undefined' : _typeof(date)) === undefined) {
	          date = new Date();
	        }

	        if ((typeof date === 'undefined' ? 'undefined' : _typeof(date)) === "object" && Object.prototype.toString.call(date) === "[object Date]") {
	          tmpCreationDateString = convertDateToPDFDate(date);
	        } else if (regexPDFCreationDate.test(date)) {
	          tmpCreationDateString = date;
	        } else {
	          tmpCreationDateString = convertDateToPDFDate(new Date());
	        }
	        creationDate = tmpCreationDateString;
	        return creationDate;
	      },
	          getCreationDate = function getCreationDate(type) {
	        var result = creationDate;
	        if (type === "jsDate") {
	          result = convertPDFDateToDate(creationDate);
	        }
	        return result;
	      },
	          setFileId = function setFileId(value) {
	        value = value || "12345678901234567890123456789012".split('').map(function () {
	          return "ABCDEF0123456789".charAt(Math.floor(Math.random() * 16));
	        }).join('');
	        fileId = value;
	        return fileId;
	      },
	          getFileId = function getFileId() {
	        return fileId;
	      },
	          f2 = function f2(number) {
	        return number.toFixed(2); // Ie, %.2f
	      },
	          f3 = function f3(number) {
	        return number.toFixed(3); // Ie, %.3f
	      },
	          out = function out(string) {
	        string = typeof string === "string" ? string : string.toString();
	        if (outToPages) {
	          /* set by beginPage */
	          pages[currentPage].push(string);
	        } else {
	          // +1 for '\n' that will be used to join 'content'
	          content_length += string.length + 1;
	          content.push(string);
	        }
	      },
	          newObject = function newObject() {
	        // Begin a new object
	        objectNumber++;
	        offsets[objectNumber] = content_length;
	        out(objectNumber + ' 0 obj');
	        return objectNumber;
	      },

	      // Does not output the object until after the pages have been output.
	      // Returns an object containing the objectId and content.
	      // All pages have been added so the object ID can be estimated to start right after.
	      // This does not modify the current objectNumber;  It must be updated after the newObjects are output.
	      newAdditionalObject = function newAdditionalObject() {
	        var objId = pages.length * 2 + 1;
	        objId += additionalObjects.length;
	        var obj = {
	          objId: objId,
	          content: ''
	        };
	        additionalObjects.push(obj);
	        return obj;
	      },

	      // Does not output the object.  The caller must call newObjectDeferredBegin(oid) before outputing any data
	      newObjectDeferred = function newObjectDeferred() {
	        objectNumber++;
	        offsets[objectNumber] = function () {
	          return content_length;
	        };
	        return objectNumber;
	      },
	          newObjectDeferredBegin = function newObjectDeferredBegin(oid) {
	        offsets[oid] = content_length;
	      },
	          putStream = function putStream(str) {
	        out('stream');
	        out(str);
	        out('endstream');
	      },
	          putPages = function putPages() {
	        var n,
	            p,
	            arr,
	            i,
	            deflater,
	            adler32,
	            adler32cs,
	            wPt,
	            hPt,
	            pageObjectNumbers = [];

	        adler32cs = global.adler32cs || jsPDF.API.adler32cs;
	        if (compress && typeof adler32cs === 'undefined') {
	          compress = false;
	        }

	        // outToPages = false as set in endDocument(). out() writes to content.

	        for (n = 1; n <= page; n++) {
	          pageObjectNumbers.push(newObject());
	          wPt = (pageWidth = pagedim[n].width) * k;
	          hPt = (pageHeight = pagedim[n].height) * k;
	          out('<</Type /Page');
	          out('/Parent 1 0 R');
	          out('/Resources 2 0 R');
	          out('/MediaBox [0 0 ' + f2(wPt) + ' ' + f2(hPt) + ']');
	          // Added for annotation plugin
	          events.publish('putPage', {
	            pageNumber: n,
	            page: pages[n]
	          });
	          out('/Contents ' + (objectNumber + 1) + ' 0 R');
	          out('>>');
	          out('endobj');

	          // Page content
	          p = pages[n].join('\n');
	          newObject();
	          if (compress) {
	            arr = [];
	            i = p.length;
	            while (i--) {
	              arr[i] = p.charCodeAt(i);
	            }
	            adler32 = adler32cs.from(p);
	            deflater = new Deflater(6);
	            deflater.append(new Uint8Array(arr));
	            p = deflater.flush();
	            arr = new Uint8Array(p.length + 6);
	            arr.set(new Uint8Array([120, 156])), arr.set(p, 2);
	            arr.set(new Uint8Array([adler32 & 0xFF, adler32 >> 8 & 0xFF, adler32 >> 16 & 0xFF, adler32 >> 24 & 0xFF]), p.length + 2);
	            p = String.fromCharCode.apply(null, arr);
	            out('<</Length ' + p.length + ' /Filter [/FlateDecode]>>');
	          } else {
	            out('<</Length ' + p.length + '>>');
	          }
	          putStream(p);
	          out('endobj');
	        }
	        offsets[1] = content_length;
	        out('1 0 obj');
	        out('<</Type /Pages');
	        var kids = '/Kids [';
	        for (i = 0; i < page; i++) {
	          kids += pageObjectNumbers[i] + ' 0 R ';
	        }
	        out(kids + ']');
	        out('/Count ' + page);
	        out('>>');
	        out('endobj');
	        events.publish('postPutPages');
	      },
	          putFont = function putFont(font) {

	        events.publish('putFont', {
	          font: font,
	          out: out,
	          newObject: newObject
	        });
	        if (font.isAlreadyPutted !== true) {
	          font.objectNumber = newObject();
	          out('<<');
	          out('/Type /Font');
	          out('/BaseFont /' + font.postScriptName);
	          out('/Subtype /Type1');
	          if (typeof font.encoding === 'string') {
	            out('/Encoding /' + font.encoding);
	          }
	          out('/FirstChar 32');
	          out('/LastChar 255');
	          out('>>');
	          out('endobj');
	        }
	      },
	          putFonts = function putFonts() {
	        for (var fontKey in fonts) {
	          if (fonts.hasOwnProperty(fontKey)) {
	            putFont(fonts[fontKey]);
	          }
	        }
	      },
	          putXobjectDict = function putXobjectDict() {
	        // Loop through images, or other data objects
	        events.publish('putXobjectDict');
	      },
	          putResourceDictionary = function putResourceDictionary() {
	        out('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]');
	        out('/Font <<');

	        // Do this for each font, the '1' bit is the index of the font
	        for (var fontKey in fonts) {
	          if (fonts.hasOwnProperty(fontKey)) {
	            out('/' + fontKey + ' ' + fonts[fontKey].objectNumber + ' 0 R');
	          }
	        }
	        out('>>');
	        out('/XObject <<');
	        putXobjectDict();
	        out('>>');
	      },
	          putResources = function putResources() {
	        putFonts();
	        events.publish('putResources');
	        // Resource dictionary
	        offsets[2] = content_length;
	        out('2 0 obj');
	        out('<<');
	        putResourceDictionary();
	        out('>>');
	        out('endobj');
	        events.publish('postPutResources');
	      },
	          putAdditionalObjects = function putAdditionalObjects() {
	        events.publish('putAdditionalObjects');
	        for (var i = 0; i < additionalObjects.length; i++) {
	          var obj = additionalObjects[i];
	          offsets[obj.objId] = content_length;
	          out(obj.objId + ' 0 obj');
	          out(obj.content);        out('endobj');
	        }
	        objectNumber += additionalObjects.length;
	        events.publish('postPutAdditionalObjects');
	      },
	          addToFontDictionary = function addToFontDictionary(fontKey, fontName, fontStyle) {
	        // this is mapping structure for quick font key lookup.
	        // returns the KEY of the font (ex: "F1") for a given
	        // pair of font name and type (ex: "Arial". "Italic")
	        if (!fontmap.hasOwnProperty(fontName)) {
	          fontmap[fontName] = {};
	        }
	        fontmap[fontName][fontStyle] = fontKey;
	      },

	      /**
	       * FontObject describes a particular font as member of an instnace of jsPDF
	       *
	       * It's a collection of properties like 'id' (to be used in PDF stream),
	       * 'fontName' (font's family name), 'fontStyle' (font's style variant label)
	       *
	       * @class
	       * @public
	       * @property id {String} PDF-document-instance-specific label assinged to the font.
	       * @property postScriptName {String} PDF specification full name for the font
	       * @property encoding {Object} Encoding_name-to-Font_metrics_object mapping.
	       * @name FontObject
	       * @ignore This should not be in the public docs.
	       */
	      addFont = function addFont(postScriptName, fontName, fontStyle, encoding) {
	        var fontKey = 'F' + (Object.keys(fonts).length + 1).toString(10),

	        // This is FontObject
	        font = fonts[fontKey] = {
	          'id': fontKey,
	          'postScriptName': postScriptName,
	          'fontName': fontName,
	          'fontStyle': fontStyle,
	          'encoding': encoding,
	          'metadata': {}
	        };
	        addToFontDictionary(fontKey, fontName, fontStyle);
	        events.publish('addFont', font);

	        return fontKey;
	      },
	          addFonts = function addFonts() {

	        var HELVETICA = "helvetica",
	            TIMES = "times",
	            COURIER = "courier",
	            NORMAL = "normal",
	            BOLD = "bold",
	            ITALIC = "italic",
	            BOLD_ITALIC = "bolditalic",
	            ZAPF = "zapfdingbats",
	            SYMBOL = "symbol",
	            standardFonts = [['Helvetica', HELVETICA, NORMAL, 'WinAnsiEncoding'], ['Helvetica-Bold', HELVETICA, BOLD, 'WinAnsiEncoding'], ['Helvetica-Oblique', HELVETICA, ITALIC, 'WinAnsiEncoding'], ['Helvetica-BoldOblique', HELVETICA, BOLD_ITALIC, 'WinAnsiEncoding'], ['Courier', COURIER, NORMAL, 'WinAnsiEncoding'], ['Courier-Bold', COURIER, BOLD, 'WinAnsiEncoding'], ['Courier-Oblique', COURIER, ITALIC, 'WinAnsiEncoding'], ['Courier-BoldOblique', COURIER, BOLD_ITALIC, 'WinAnsiEncoding'], ['Times-Roman', TIMES, NORMAL, 'WinAnsiEncoding'], ['Times-Bold', TIMES, BOLD, 'WinAnsiEncoding'], ['Times-Italic', TIMES, ITALIC, 'WinAnsiEncoding'], ['Times-BoldItalic', TIMES, BOLD_ITALIC, 'WinAnsiEncoding'], ['ZapfDingbats', ZAPF, NORMAL, null], ['Symbol', SYMBOL, NORMAL, null]];

	        for (var i = 0, l = standardFonts.length; i < l; i++) {
	          var fontKey = addFont(standardFonts[i][0], standardFonts[i][1], standardFonts[i][2], standardFonts[i][3]);

	          // adding aliases for standard fonts, this time matching the capitalization
	          var parts = standardFonts[i][0].split('-');
	          addToFontDictionary(fontKey, parts[0], parts[1] || '');
	        }
	        events.publish('addFonts', {
	          fonts: fonts,
	          dictionary: fontmap
	        });
	      },
	          SAFE = function __safeCall(fn) {
	        fn.foo = function __safeCallWrapper() {
	          try {
	            return fn.apply(this, arguments);
	          } catch (e) {
	            var stack = e.stack || '';
	            if (~stack.indexOf(' at ')) stack = stack.split(" at ")[1];
	            var m = "Error in function " + stack.split("\n")[0].split('<')[0] + ": " + e.message;
	            if (global.console) {
	              global.console.error(m, e);
	              if (global.alert) alert(m);
	            } else {
	              throw new Error(m);
	            }
	          }
	        };
	        fn.foo.bar = fn;
	        return fn.foo;
	      },
	          to8bitStream = function to8bitStream(text, flags) {
	        /**
	         * PDF 1.3 spec:
	         * "For text strings encoded in Unicode, the first two bytes must be 254 followed by
	         * 255, representing the Unicode byte order marker, U+FEFF. (This sequence conflicts
	         * with the PDFDocEncoding character sequence thorn ydieresis, which is unlikely
	         * to be a meaningful beginning of a word or phrase.) The remainder of the
	         * string consists of Unicode character codes, according to the UTF-16 encoding
	         * specified in the Unicode standard, version 2.0. Commonly used Unicode values
	         * are represented as 2 bytes per character, with the high-order byte appearing first
	         * in the string."
	         *
	         * In other words, if there are chars in a string with char code above 255, we
	         * recode the string to UCS2 BE - string doubles in length and BOM is prepended.
	         *
	         * HOWEVER!
	         * Actual *content* (body) text (as opposed to strings used in document properties etc)
	         * does NOT expect BOM. There, it is treated as a literal GID (Glyph ID)
	         *
	         * Because of Adobe's focus on "you subset your fonts!" you are not supposed to have
	         * a font that maps directly Unicode (UCS2 / UTF16BE) code to font GID, but you could
	         * fudge it with "Identity-H" encoding and custom CIDtoGID map that mimics Unicode
	         * code page. There, however, all characters in the stream are treated as GIDs,
	         * including BOM, which is the reason we need to skip BOM in content text (i.e. that
	         * that is tied to a font).
	         *
	         * To signal this "special" PDFEscape / to8bitStream handling mode,
	         * API.text() function sets (unless you overwrite it with manual values
	         * given to API.text(.., flags) )
	         * flags.autoencode = true
	         * flags.noBOM = true
	         *
	         * ===================================================================================
	         * `flags` properties relied upon:
	         *   .sourceEncoding = string with encoding label.
	         *                     "Unicode" by default. = encoding of the incoming text.
	         *                     pass some non-existing encoding name
	         *                     (ex: 'Do not touch my strings! I know what I am doing.')
	         *                     to make encoding code skip the encoding step.
	         *   .outputEncoding = Either valid PDF encoding name
	         *                     (must be supported by jsPDF font metrics, otherwise no encoding)
	         *                     or a JS object, where key = sourceCharCode, value = outputCharCode
	         *                     missing keys will be treated as: sourceCharCode === outputCharCode
	         *   .noBOM
	         *       See comment higher above for explanation for why this is important
	         *   .autoencode
	         *       See comment higher above for explanation for why this is important
	         */

	        var i, l, sourceEncoding, encodingBlock, outputEncoding, newtext, isUnicode, ch, bch;

	        flags = flags || {};
	        sourceEncoding = flags.sourceEncoding || 'Unicode';
	        outputEncoding = flags.outputEncoding;

	        // This 'encoding' section relies on font metrics format
	        // attached to font objects by, among others,
	        // "Willow Systems' standard_font_metrics plugin"
	        // see jspdf.plugin.standard_font_metrics.js for format
	        // of the font.metadata.encoding Object.
	        // It should be something like
	        //   .encoding = {'codePages':['WinANSI....'], 'WinANSI...':{code:code, ...}}
	        //   .widths = {0:width, code:width, ..., 'fof':divisor}
	        //   .kerning = {code:{previous_char_code:shift, ..., 'fof':-divisor},...}
	        if ((flags.autoencode || outputEncoding) && fonts[activeFontKey].metadata && fonts[activeFontKey].metadata[sourceEncoding] && fonts[activeFontKey].metadata[sourceEncoding].encoding) {
	          encodingBlock = fonts[activeFontKey].metadata[sourceEncoding].encoding;

	          // each font has default encoding. Some have it clearly defined.
	          if (!outputEncoding && fonts[activeFontKey].encoding) {
	            outputEncoding = fonts[activeFontKey].encoding;
	          }

	          // Hmmm, the above did not work? Let's try again, in different place.
	          if (!outputEncoding && encodingBlock.codePages) {
	            outputEncoding = encodingBlock.codePages[0]; // let's say, first one is the default
	          }

	          if (typeof outputEncoding === 'string') {
	            outputEncoding = encodingBlock[outputEncoding];
	          }
	          // we want output encoding to be a JS Object, where
	          // key = sourceEncoding's character code and
	          // value = outputEncoding's character code.
	          if (outputEncoding) {
	            isUnicode = false;
	            newtext = [];
	            for (i = 0, l = text.length; i < l; i++) {
	              ch = outputEncoding[text.charCodeAt(i)];
	              if (ch) {
	                newtext.push(String.fromCharCode(ch));
	              } else {
	                newtext.push(text[i]);
	              }

	              // since we are looping over chars anyway, might as well
	              // check for residual unicodeness
	              if (newtext[i].charCodeAt(0) >> 8) {
	                /* more than 255 */
	                isUnicode = true;
	              }
	            }
	            text = newtext.join('');
	          }
	        }

	        i = text.length;
	        // isUnicode may be set to false above. Hence the triple-equal to undefined
	        while (isUnicode === undefined && i !== 0) {
	          if (text.charCodeAt(i - 1) >> 8) {
	            /* more than 255 */
	            isUnicode = true;
	          }
	          i--;
	        }
	        if (!isUnicode) {
	          return text;
	        }

	        newtext = flags.noBOM ? [] : [254, 255];
	        for (i = 0, l = text.length; i < l; i++) {
	          ch = text.charCodeAt(i);
	          bch = ch >> 8; // divide by 256
	          if (bch >> 8) {
	            /* something left after dividing by 256 second time */
	            throw new Error("Character at position " + i + " of string '" + text + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
	          }
	          newtext.push(bch);
	          newtext.push(ch - (bch << 8));
	        }
	        return String.fromCharCode.apply(undefined, newtext);
	      },
	          pdfEscape = function pdfEscape(text, flags) {
	        /**
	         * Replace '/', '(', and ')' with pdf-safe versions
	         *
	         * Doing to8bitStream does NOT make this PDF display unicode text. For that
	         * we also need to reference a unicode font and embed it - royal pain in the rear.
	         *
	         * There is still a benefit to to8bitStream - PDF simply cannot handle 16bit chars,
	         * which JavaScript Strings are happy to provide. So, while we still cannot display
	         * 2-byte characters property, at least CONDITIONALLY converting (entire string containing)
	         * 16bit chars to (USC-2-BE) 2-bytes per char + BOM streams we ensure that entire PDF
	         * is still parseable.
	         * This will allow immediate support for unicode in document properties strings.
	         */
	        return to8bitStream(text, flags).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
	      },
	          putInfo = function putInfo() {
	        out('/Producer (jsPDF ' + jsPDF.version + ')');
	        for (var key in documentProperties) {
	          if (documentProperties.hasOwnProperty(key) && documentProperties[key]) {
	            out('/' + key.substr(0, 1).toUpperCase() + key.substr(1) + ' (' + pdfEscape(documentProperties[key]) + ')');
	          }
	        }
	        out('/CreationDate (' + creationDate + ')');
	      },
	          putCatalog = function putCatalog() {
	        out('/Type /Catalog');
	        out('/Pages 1 0 R');
	        // PDF13ref Section 7.2.1
	        if (!zoomMode) zoomMode = 'fullwidth';
	        switch (zoomMode) {
	          case 'fullwidth':
	            out('/OpenAction [3 0 R /FitH null]');
	            break;
	          case 'fullheight':
	            out('/OpenAction [3 0 R /FitV null]');
	            break;
	          case 'fullpage':
	            out('/OpenAction [3 0 R /Fit]');
	            break;
	          case 'original':
	            out('/OpenAction [3 0 R /XYZ null null 1]');
	            break;
	          default:
	            var pcn = '' + zoomMode;
	            if (pcn.substr(pcn.length - 1) === '%') zoomMode = parseInt(zoomMode) / 100;
	            if (typeof zoomMode === 'number') {
	              out('/OpenAction [3 0 R /XYZ null null ' + f2(zoomMode) + ']');
	            }
	        }
	        if (!layoutMode) layoutMode = 'continuous';
	        switch (layoutMode) {
	          case 'continuous':
	            out('/PageLayout /OneColumn');
	            break;
	          case 'single':
	            out('/PageLayout /SinglePage');
	            break;
	          case 'two':
	          case 'twoleft':
	            out('/PageLayout /TwoColumnLeft');
	            break;
	          case 'tworight':
	            out('/PageLayout /TwoColumnRight');
	            break;
	        }
	        if (pageMode) {
	          /**
	           * A name object specifying how the document should be displayed when opened:
	           * UseNone      : Neither document outline nor thumbnail images visible -- DEFAULT
	           * UseOutlines  : Document outline visible
	           * UseThumbs    : Thumbnail images visible
	           * FullScreen   : Full-screen mode, with no menu bar, window controls, or any other window visible
	           */
	          out('/PageMode /' + pageMode);
	        }
	        events.publish('putCatalog');
	      },
	          putTrailer = function putTrailer() {
	        out('/Size ' + (objectNumber + 1));
	        out('/Root ' + objectNumber + ' 0 R');
	        out('/Info ' + (objectNumber - 1) + ' 0 R');
	        out("/ID [ <" + fileId + "> <" + fileId + "> ]");
	      },
	          beginPage = function beginPage(width, height) {
	        // Dimensions are stored as user units and converted to points on output
	        var orientation = typeof height === 'string' && height.toLowerCase();
	        if (typeof width === 'string') {
	          var format = width.toLowerCase();
	          if (pageFormats.hasOwnProperty(format)) {
	            width = pageFormats[format][0] / k;
	            height = pageFormats[format][1] / k;
	          }
	        }
	        if (Array.isArray(width)) {
	          height = width[1];
	          width = width[0];
	        }
	        if (orientation) {
	          switch (orientation.substr(0, 1)) {
	            case 'l':
	              if (height > width) orientation = 's';
	              break;
	            case 'p':
	              if (width > height) orientation = 's';
	              break;
	          }
	          if (orientation === 's') {
	            tmp = width;
	            width = height;
	            height = tmp;
	          }
	        }
	        outToPages = true;
	        pages[++page] = [];
	        pagedim[page] = {
	          width: Number(width) || pageWidth,
	          height: Number(height) || pageHeight
	        };
	        pagesContext[page] = {};
	        _setPage(page);
	      },
	          _addPage = function _addPage() {
	        beginPage.apply(this, arguments);
	        // Set line width
	        out(f2(lineWidth * k) + ' w');
	        // Set draw color
	        out(drawColor);
	        // resurrecting non-default line caps, joins
	        if (lineCapID !== 0) {
	          out(lineCapID + ' J');
	        }
	        if (lineJoinID !== 0) {
	          out(lineJoinID + ' j');
	        }
	        events.publish('addPage', {
	          pageNumber: page
	        });
	      },
	          _deletePage = function _deletePage(n) {
	        if (n > 0 && n <= page) {
	          pages.splice(n, 1);
	          pagedim.splice(n, 1);
	          page--;
	          if (currentPage > page) {
	            currentPage = page;
	          }
	          this.setPage(currentPage);
	        }
	      },
	          _setPage = function _setPage(n) {
	        if (n > 0 && n <= page) {
	          currentPage = n;
	          pageWidth = pagedim[n].width;
	          pageHeight = pagedim[n].height;
	        }
	      },

	      /**
	       * Returns a document-specific font key - a label assigned to a
	       * font name + font type combination at the time the font was added
	       * to the font inventory.
	       *
	       * Font key is used as label for the desired font for a block of text
	       * to be added to the PDF document stream.
	       * @private
	       * @function
	       * @param fontName {String} can be undefined on "falthy" to indicate "use current"
	       * @param fontStyle {String} can be undefined on "falthy" to indicate "use current"
	       * @returns {String} Font key.
	       */
	      _getFont = function _getFont(fontName, fontStyle, options) {
	        var key = undefined,
	            fontNameLowerCase;
	        options = options || {};

	        fontName = fontName !== undefined ? fontName : fonts[activeFontKey].fontName;
	        fontStyle = fontStyle !== undefined ? fontStyle : fonts[activeFontKey].fontStyle;
	        fontNameLowerCase = fontName.toLowerCase();

	        if (fontmap[fontNameLowerCase] !== undefined && fontmap[fontNameLowerCase][fontStyle] !== undefined) {
	          key = fontmap[fontNameLowerCase][fontStyle];
	        } else if (fontmap[fontName] !== undefined && fontmap[fontName][fontStyle] !== undefined) {
	          key = fontmap[fontName][fontStyle];
	        } else {
	          if (options.disableWarning === false) {
	            console.warn("Unable to look up font label for font '" + fontName + "', '" + fontStyle + "'. Refer to getFontList() for available fonts.");
	          }
	        }

	        if (!key && !options.noFallback) {
	          key = fontmap['times'][fontStyle];
	          if (key == null) {
	            key = fontmap['times']['normal'];
	          }
	        }
	        return key;
	      },
	          buildDocument = function buildDocument() {
	        outToPages = false; // switches out() to content

	        objectNumber = 2;
	        content_length = 0;
	        content = [];
	        offsets = [];
	        additionalObjects = [];
	        // Added for AcroForm
	        events.publish('buildDocument');

	        // putHeader()
	        out('%PDF-' + pdfVersion);
	        out("%\xBA\xDF\xAC\xE0");

	        putPages();

	        // Must happen after putPages
	        // Modifies current object Id
	        putAdditionalObjects();

	        putResources();

	        // Info
	        newObject();
	        out('<<');
	        putInfo();
	        out('>>');
	        out('endobj');

	        // Catalog
	        newObject();
	        out('<<');
	        putCatalog();
	        out('>>');
	        out('endobj');

	        // Cross-ref
	        var o = content_length,
	            i,
	            p = "0000000000";
	        out('xref');
	        out('0 ' + (objectNumber + 1));
	        out(p + ' 65535 f ');
	        for (i = 1; i <= objectNumber; i++) {
	          var offset = offsets[i];
	          if (typeof offset === 'function') {
	            out((p + offsets[i]()).slice(-10) + ' 00000 n ');
	          } else {
	            out((p + offsets[i]).slice(-10) + ' 00000 n ');
	          }
	        }
	        // Trailer
	        out('trailer');
	        out('<<');
	        putTrailer();
	        out('>>');
	        out('startxref');
	        out('' + o);
	        out('%%EOF');

	        outToPages = true;

	        return content.join('\n');
	      },
	          getStyle = function getStyle(style) {
	        // see path-painting operators in PDF spec
	        var op = 'S'; // stroke
	        if (style === 'F') {
	          op = 'f'; // fill
	        } else if (style === 'FD' || style === 'DF') {
	          op = 'B'; // both
	        } else if (style === 'f' || style === 'f*' || style === 'B' || style === 'B*') {
	          /*
	           Allow direct use of these PDF path-painting operators:
	           - f    fill using nonzero winding number rule
	           - f*    fill using even-odd rule
	           - B    fill then stroke with fill using non-zero winding number rule
	           - B*    fill then stroke with fill using even-odd rule
	           */
	          op = style;
	        }
	        return op;
	      },
	          getArrayBuffer = function getArrayBuffer() {
	        var data = buildDocument(),
	            len = data.length,
	            ab = new ArrayBuffer(len),
	            u8 = new Uint8Array(ab);

	        while (len--) {
	          u8[len] = data.charCodeAt(len);
	        }return ab;
	      },
	          getBlob = function getBlob() {
	        return new Blob([getArrayBuffer()], {
	          type: "application/pdf"
	        });
	      },

	      /**
	       * Generates the PDF document.
	       *
	       * If `type` argument is undefined, output is raw body of resulting PDF returned as a string.
	       *
	       * @param {String} type A string identifying one of the possible output types.
	       * @param {Object} options An object providing some additional signalling to PDF generator.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name output
	       */
	      _output = SAFE(function (type, options) {
	        var datauri = ('' + type).substr(0, 6) === 'dataur' ? 'data:application/pdf;base64,' + btoa(buildDocument()) : 0;

	        switch (type) {
	          case undefined:
	            return buildDocument();
	          case 'save':
	            if ((typeof navigator === 'undefined' ? 'undefined' : _typeof(navigator)) === "object" && navigator.getUserMedia) {
	              if (global.URL === undefined || global.URL.createObjectURL === undefined) {
	                return API.output('dataurlnewwindow');
	              }
	            }
	            saveAs(getBlob(), options);
	            if (typeof saveAs.unload === 'function') {
	              if (global.setTimeout) {
	                setTimeout(saveAs.unload, 911);
	              }
	            }
	            break;
	          case 'arraybuffer':
	            return getArrayBuffer();
	          case 'blob':
	            return getBlob();
	          case 'bloburi':
	          case 'bloburl':
	            // User is responsible of calling revokeObjectURL
	            return global.URL && global.URL.createObjectURL(getBlob()) || void 0;
	          case 'datauristring':
	          case 'dataurlstring':
	            return datauri;
	          case 'dataurlnewwindow':
	            var nW = global.open(datauri);
	            if (nW || typeof safari === "undefined") return nW;
	          /* pass through */
	          case 'datauri':
	          case 'dataurl':
	            return global.document.location.href = datauri;
	          default:
	            throw new Error('Output type "' + type + '" is not supported.');
	        }
	        // @TODO: Add different output options
	      }),


	      /**
	       * Used to see if a supplied hotfix was requested when the pdf instance was created.
	       * @param {String} hotfixName - The name of the hotfix to check.
	       * @returns {boolean}
	       */
	      hasHotfix = function hasHotfix(hotfixName) {
	        return Array.isArray(hotfixes) === true && hotfixes.indexOf(hotfixName) > -1;
	      };

	      switch (unit) {
	        case 'pt':
	          k = 1;
	          break;
	        case 'mm':
	          k = 72 / 25.4;
	          break;
	        case 'cm':
	          k = 72 / 2.54;
	          break;
	        case 'in':
	          k = 72;
	          break;
	        case 'px':
	          if (hasHotfix('px_scaling') == true) {
	            k = 72 / 96;
	          } else {
	            k = 96 / 72;
	          }
	          break;
	        case 'pc':
	          k = 12;
	          break;
	        case 'em':
	          k = 12;
	          break;
	        case 'ex':
	          k = 6;
	          break;
	        default:
	          throw 'Invalid unit: ' + unit;
	      }

	      setCreationDate();
	      setFileId();

	      //---------------------------------------
	      // Public API

	      /**
	       * Object exposing internal API to plugins
	       * @public
	       */
	      API.internal = {
	        'pdfEscape': pdfEscape,
	        'getStyle': getStyle,
	        /**
	         * Returns {FontObject} describing a particular font.
	         * @public
	         * @function
	         * @param fontName {String} (Optional) Font's family name
	         * @param fontStyle {String} (Optional) Font's style variation name (Example:"Italic")
	         * @returns {FontObject}
	         */
	        'getFont': function getFont() {
	          return fonts[_getFont.apply(API, arguments)];
	        },
	        'getFontSize': function getFontSize() {
	          return activeFontSize;
	        },
	        'getCharSpace': function getCharSpace() {
	          return activeCharSpace;
	        },
	        'getTextColor': function getTextColor() {
	          var colorEncoded = textColor.split(' ');
	          if (colorEncoded.length === 2 && colorEncoded[1] === 'g') {
	            // convert grayscale value to rgb so that it can be converted to hex for consistency
	            var floatVal = parseFloat(colorEncoded[0]);
	            colorEncoded = [floatVal, floatVal, floatVal, 'r'];
	          }
	          var colorAsHex = '#';
	          for (var i = 0; i < 3; i++) {
	            colorAsHex += ('0' + Math.floor(parseFloat(colorEncoded[i]) * 255).toString(16)).slice(-2);
	          }
	          return colorAsHex;
	        },
	        'getLineHeight': function getLineHeight() {
	          return activeFontSize * lineHeightProportion;
	        },
	        'write': function write(string1 /*, string2, string3, etc */) {
	          out(arguments.length === 1 ? string1 : Array.prototype.join.call(arguments, ' '));
	        },
	        'getCoordinateString': function getCoordinateString(value) {
	          return f2(value * k);
	        },
	        'getVerticalCoordinateString': function getVerticalCoordinateString(value) {
	          return f2((pageHeight - value) * k);
	        },
	        'collections': {},
	        'newObject': newObject,
	        'newAdditionalObject': newAdditionalObject,
	        'newObjectDeferred': newObjectDeferred,
	        'newObjectDeferredBegin': newObjectDeferredBegin,
	        'putStream': putStream,
	        'events': events,
	        // ratio that you use in multiplication of a given "size" number to arrive to 'point'
	        // units of measurement.
	        // scaleFactor is set at initialization of the document and calculated against the stated
	        // default measurement units for the document.
	        // If default is "mm", k is the number that will turn number in 'mm' into 'points' number.
	        // through multiplication.
	        'scaleFactor': k,
	        'pageSize': {
	          getWidth: function getWidth() {
	            return pageWidth;
	          },
	          getHeight: function getHeight() {
	            return pageHeight;
	          }
	        },
	        'output': function output(type, options) {
	          return _output(type, options);
	        },
	        'getNumberOfPages': function getNumberOfPages() {
	          return pages.length - 1;
	        },
	        'pages': pages,
	        'out': out,
	        'f2': f2,
	        'getPageInfo': function getPageInfo(pageNumberOneBased) {
	          var objId = (pageNumberOneBased - 1) * 2 + 3;
	          return {
	            objId: objId,
	            pageNumber: pageNumberOneBased,
	            pageContext: pagesContext[pageNumberOneBased]
	          };
	        },
	        'getCurrentPageInfo': function getCurrentPageInfo() {
	          var objId = (currentPage - 1) * 2 + 3;
	          return {
	            objId: objId,
	            pageNumber: currentPage,
	            pageContext: pagesContext[currentPage]
	          };
	        },
	        'getPDFVersion': function getPDFVersion() {
	          return pdfVersion;
	        },
	        'hasHotfix': hasHotfix //Expose the hasHotfix check so plugins can also check them.
	      };

	      /**
	       * Adds (and transfers the focus to) new page to the PDF document.
	       * @param format {String/Array} The format of the new page. Can be <ul><li>a0 - a10</li><li>b0 - b10</li><li>c0 - c10</li><li>c0 - c10</li><li>dl</li><li>letter</li><li>government-letter</li><li>legal</li><li>junior-legal</li><li>ledger</li><li>tabloid</li><li>credit-card</li></ul><br />
	       * Default is "a4". If you want to use your own format just pass instead of one of the above predefined formats the size as an number-array , e.g. [595.28, 841.89]
	       * @param orientation {String} Orientation of the new page. Possible values are "portrait" or "landscape" (or shortcuts "p" (Default), "l") 
	       * @function
	       * @returns {jsPDF}
	       *
	       * @methodOf jsPDF#
	       * @name addPage
	       */
	      API.addPage = function () {
	        _addPage.apply(this, arguments);
	        return this;
	      };
	      /**
	       * Adds (and transfers the focus to) new page to the PDF document.
	       * @function
	       * @returns {jsPDF}
	       *
	       * @methodOf jsPDF#
	       * @name setPage
	       * @param {Number} page Switch the active page to the page number specified
	       * @example
	       * doc = jsPDF()
	       * doc.addPage()
	       * doc.addPage()
	       * doc.text('I am on page 3', 10, 10)
	       * doc.setPage(1)
	       * doc.text('I am on page 1', 10, 10)
	       */
	      API.setPage = function () {
	        _setPage.apply(this, arguments);
	        return this;
	      };
	      API.insertPage = function (beforePage) {
	        this.addPage();
	        this.movePage(currentPage, beforePage);
	        return this;
	      };
	      API.movePage = function (targetPage, beforePage) {
	        if (targetPage > beforePage) {
	          var tmpPages = pages[targetPage];
	          var tmpPagedim = pagedim[targetPage];
	          var tmpPagesContext = pagesContext[targetPage];
	          for (var i = targetPage; i > beforePage; i--) {
	            pages[i] = pages[i - 1];
	            pagedim[i] = pagedim[i - 1];
	            pagesContext[i] = pagesContext[i - 1];
	          }
	          pages[beforePage] = tmpPages;
	          pagedim[beforePage] = tmpPagedim;
	          pagesContext[beforePage] = tmpPagesContext;
	          this.setPage(beforePage);
	        } else if (targetPage < beforePage) {
	          var tmpPages = pages[targetPage];
	          var tmpPagedim = pagedim[targetPage];
	          var tmpPagesContext = pagesContext[targetPage];
	          for (var i = targetPage; i < beforePage; i++) {
	            pages[i] = pages[i + 1];
	            pagedim[i] = pagedim[i + 1];
	            pagesContext[i] = pagesContext[i + 1];
	          }
	          pages[beforePage] = tmpPages;
	          pagedim[beforePage] = tmpPagedim;
	          pagesContext[beforePage] = tmpPagesContext;
	          this.setPage(beforePage);
	        }
	        return this;
	      };

	      API.deletePage = function () {
	        _deletePage.apply(this, arguments);
	        return this;
	      };

	      API.setCreationDate = function (date) {
	        setCreationDate(date);
	        return this;
	      };

	      API.getCreationDate = function (type) {
	        return getCreationDate(type);
	      };

	      API.setFileId = function (value) {
	        setFileId(value);
	        return this;
	      };

	      API.getFileId = function () {
	        return getFileId();
	      };

	      /**
	       * Set the display mode options of the page like zoom and layout.
	       *
	       * @param {integer|String} zoom   You can pass an integer or percentage as
	       * a string. 2 will scale the document up 2x, '200%' will scale up by the
	       * same amount. You can also set it to 'fullwidth', 'fullheight',
	       * 'fullpage', or 'original'.
	       *
	       * Only certain PDF readers support this, such as Adobe Acrobat
	       *
	       * @param {String} layout Layout mode can be: 'continuous' - this is the
	       * default continuous scroll. 'single' - the single page mode only shows one
	       * page at a time. 'twoleft' - two column left mode, first page starts on
	       * the left, and 'tworight' - pages are laid out in two columns, with the
	       * first page on the right. This would be used for books.
	       * @param {String} pmode 'UseOutlines' - it shows the
	       * outline of the document on the left. 'UseThumbs' - shows thumbnails along
	       * the left. 'FullScreen' - prompts the user to enter fullscreen mode.
	       *
	       * @function
	       * @returns {jsPDF}
	       * @name setDisplayMode
	       */
	      API.setDisplayMode = function (zoom, layout, pmode) {
	        zoomMode = zoom;
	        layoutMode = layout;
	        pageMode = pmode;

	        var validPageModes = [undefined, null, 'UseNone', 'UseOutlines', 'UseThumbs', 'FullScreen'];
	        if (validPageModes.indexOf(pmode) == -1) {
	          throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + pmode + '" is not recognized.');
	        }
	        return this;
	      };

	      /**
	       * Adds text to page. Supports adding multiline text when 'text' argument is an Array of Strings.
	       *
	       * @function
	       * @param {String|Array} text String or array of strings to be added to the page. Each line is shifted one line down per font, spacing settings declared before this call.
	       * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Object} options Collection of settings signalling how the text must be encoded. Defaults are sane. If you think you want to pass some flags, you likely can read the source.
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name text
	       */
	      API.text = function (text, x, y, options) {
	        /**
	         * Inserts something like this into PDF
	         *   BT
	         *    /F1 16 Tf  % Font name + size
	         *    16 TL % How many units down for next line in multiline text
	         *    0 g % color
	         *    28.35 813.54 Td % position
	         *    (line one) Tj
	         *    T* (line two) Tj
	         *    T* (line three) Tj
	         *   ET
	         */

	        var xtra = '';
	        var isHex = false;
	        var lineHeight = lineHeightProportion;

	        var scope = this;

	        function ESC(s) {
	          s = s.split("\t").join(Array(options.TabLen || 9).join(" "));
	          return pdfEscape(s, flags);
	        }

	        function transformTextToSpecialArray(text) {
	          //we don't want to destroy original text array, so cloning it
	          var sa = text.concat();
	          var da = [];
	          var len = sa.length;
	          var curDa;
	          //we do array.join('text that must not be PDFescaped")
	          //thus, pdfEscape each component separately
	          while (len--) {
	            curDa = sa.shift();
	            if (typeof curDa === "string") {
	              da.push(curDa);
	            } else {
	              if (Object.prototype.toString.call(text) === '[object Array]' && curDa.length === 1) {
	                da.push(curDa[0]);
	              } else {
	                da.push([curDa[0], curDa[1], curDa[2]]);
	              }
	            }
	          }
	          return da;
	        }

	        function processTextByFunction(text, processingFunction) {
	          var result;
	          if (typeof text === 'string') {
	            result = processingFunction(text)[0];
	          } else if (Object.prototype.toString.call(text) === '[object Array]') {
	            //we don't want to destroy original text array, so cloning it
	            var sa = text.concat();
	            var da = [];
	            var len = sa.length;
	            var curDa;
	            var tmpResult;
	            //we do array.join('text that must not be PDFescaped")
	            //thus, pdfEscape each component separately
	            while (len--) {
	              curDa = sa.shift();
	              if (typeof curDa === "string") {
	                da.push(processingFunction(curDa)[0]);
	              } else if (Object.prototype.toString.call(curDa) === '[object Array]' && curDa[0] === "string") {
	                tmpResult = processingFunction(curDa[0], curDa[1], curDa[2]);
	                da.push([tmpResult[0], tmpResult[1], tmpResult[2]]);
	              }
	            }
	            result = da;
	          }
	          return result;
	        }

	        //backwardsCompatibility
	        var tmp;

	        // Pre-August-2012 the order of arguments was function(x, y, text, flags)
	        // in effort to make all calls have similar signature like
	        //   function(data, coordinates... , miscellaneous)
	        // this method had its args flipped.
	        // code below allows backward compatibility with old arg order.
	        if (typeof text === 'number') {
	          tmp = y;
	          y = x;
	          x = text;
	          text = tmp;
	        }

	        var flags = arguments[3];
	        var angle = arguments[4];
	        var align = arguments[5];

	        if ((typeof flags === 'undefined' ? 'undefined' : _typeof(flags)) !== "object" || flags === null) {
	          if (typeof angle === 'string') {
	            align = angle;
	            angle = null;
	          }
	          if (typeof flags === 'string') {
	            align = flags;
	            flags = null;
	          }
	          if (typeof flags === 'number') {
	            angle = flags;
	            flags = null;
	          }
	          options = { flags: flags, angle: angle, align: align };
	        }

	        //Check if text is of type String
	        var textIsOfTypeString = false;
	        var tmpTextIsOfTypeString = true;

	        if (typeof text === 'string') {
	          textIsOfTypeString = true;
	        } else if (Object.prototype.toString.call(text) === '[object Array]') {
	          //we don't want to destroy original text array, so cloning it
	          var sa = text.concat();
	          var da = [];
	          var len = sa.length;
	          var curDa;
	          //we do array.join('text that must not be PDFescaped")
	          //thus, pdfEscape each component separately
	          while (len--) {
	            curDa = sa.shift();
	            if (typeof curDa !== "string" || Object.prototype.toString.call(curDa) === '[object Array]' && typeof curDa[0] !== "string") {
	              tmpTextIsOfTypeString = false;
	            }
	          }
	          textIsOfTypeString = tmpTextIsOfTypeString;
	        }
	        if (textIsOfTypeString === false) {
	          throw new Error('Type of text must be string or Array. "' + text + '" is not recognized.');
	        }

	        //Escaping 
	        var activeFontEncoding = fonts[activeFontKey].encoding;

	        if (activeFontEncoding === "WinAnsiEncoding" || activeFontEncoding === "StandardEncoding") {
	          text = processTextByFunction(text, function (text, posX, posY) {
	            return [ESC(text), posX, posY];
	          });
	        }
	        //If there are any newlines in text, we assume
	        //the user wanted to print multiple lines, so break the
	        //text up into an array. If the text is already an array,
	        //we assume the user knows what they are doing.
	        //Convert text into an array anyway to simplify
	        //later code.

	        if (typeof text === 'string') {
	          if (text.match(/[\r?\n]/)) {
	            text = text.split(/\r\n|\r|\n/g);
	          } else {
	            text = [text];
	          }
	        }

	        //multiline
	        var maxWidth = options.maxWidth || 0;

	        if (maxWidth > 0) {
	          if (typeof text === 'string') {
	            text = scope.splitTextToSize(text, maxWidth);
	          } else if (Object.prototype.toString.call(text) === '[object Array]') {
	            text = scope.splitTextToSize(text.join(" "), maxWidth);
	          }
	        }

	        //creating Payload-Object to make text byRef
	        var payload = {
	          text: text,
	          x: x,
	          y: y,
	          options: options,
	          mutex: {
	            pdfEscape: pdfEscape,
	            activeFontKey: activeFontKey,
	            fonts: fonts,
	            activeFontSize: activeFontSize
	          }
	        };
	        events.publish('preProcessText', payload);

	        text = payload.text;
	        options = payload.options;
	        //angle

	        var angle = options.angle;
	        var k = scope.internal.scaleFactor;
	        var curY = (scope.internal.pageSize.getHeight() - y) * k;
	        var transformationMatrix = [];

	        if (angle) {
	          angle *= Math.PI / 180;
	          var c = Math.cos(angle),
	              s = Math.sin(angle);
	          var f2 = function f2(number) {
	            return number.toFixed(2);
	          };
	          transformationMatrix = [f2(c), f2(s), f2(s * -1), f2(c)];
	        }

	        //charSpace

	        var charSpace = options.charSpace;

	        if (charSpace !== undefined) {
	          xtra += charSpace + " Tc\n";
	        }

	        //lang

	        var lang = options.lang;
	        var tmpRenderingMode = -1;
	        var parmRenderingMode = options.renderingMode || options.stroke;
	        var pageContext = scope.internal.getCurrentPageInfo().pageContext;

	        switch (parmRenderingMode) {
	          case 0:
	          case false:
	          case 'fill':
	            tmpRenderingMode = 0;
	            break;
	          case 1:
	          case true:
	          case 'stroke':
	            tmpRenderingMode = 1;
	            break;
	          case 2:
	          case 'fillThenStroke':
	            tmpRenderingMode = 2;
	            break;
	          case 3:
	          case 'invisible':
	            tmpRenderingMode = 3;
	            break;
	          case 4:
	          case 'fillAndAddForClipping':
	            tmpRenderingMode = 4;
	            break;
	          case 5:
	          case 'strokeAndAddPathForClipping':
	            tmpRenderingMode = 5;
	            break;
	          case 6:
	          case 'fillThenStrokeAndAddToPathForClipping':
	            tmpRenderingMode = 6;
	            break;
	          case 7:
	          case 'addToPathForClipping':
	            tmpRenderingMode = 7;
	            break;
	        }

	        var usedRenderingMode = pageContext.usedRenderingMode || -1;

	        //if the coder wrote it explicitly to use a specific 
	        //renderingMode, then use it
	        if (tmpRenderingMode !== -1) {
	          xtra += tmpRenderingMode + " Tr\n";
	          //otherwise check if we used the rendering Mode already
	          //if so then set the rendering Mode...
	        } else if (usedRenderingMode !== -1) {
	          xtra += "0 Tr\n";
	        }

	        if (tmpRenderingMode !== -1) {
	          pageContext.usedRenderingMode = tmpRenderingMode;
	        }

	        //align

	        var align = options.align || 'left';
	        var leading = activeFontSize * lineHeight;
	        var pageHeight = scope.internal.pageSize.getHeight();
	        var pageWidth = scope.internal.pageSize.getWidth();
	        var k = scope.internal.scaleFactor;
	        var activeFont = fonts[activeFontKey];
	        var charSpace = options.charSpace || activeCharSpace;
	        var maxWidth = options.maxWidth || 0;

	        var lineWidths;
	        var flags = {};
	        var wordSpacingPerLine = [];

	        if (Object.prototype.toString.call(text) === '[object Array]') {
	          var da = transformTextToSpecialArray(text);
	          var newY;
	          var maxLineLength;
	          var lineWidths;
	          if (align !== "left") {
	            lineWidths = da.map(function (v) {
	              return scope.getStringUnitWidth(v, { font: activeFont, charSpace: charSpace, fontSize: activeFontSize }) * activeFontSize / k;
	            });
	          }
	          var maxLineLength = Math.max.apply(Math, lineWidths);
	          //The first line uses the "main" Td setting,
	          //and the subsequent lines are offset by the
	          //previous line's x coordinate.
	          var prevWidth = 0;
	          var delta;
	          var newX;
	          if (align === "right") {
	            x -= lineWidths[0];
	            text = [];
	            for (var i = 0, len = da.length; i < len; i++) {
	              delta = maxLineLength - lineWidths[i];
	              if (i === 0) {
	                newX = x * k;
	                newY = (pageHeight - y) * k;
	              } else {
	                newX = (prevWidth - lineWidths[i]) * k;
	                newY = -leading;
	              }
	              text.push([da[i], newX, newY]);
	              prevWidth = lineWidths[i];
	            }
	          } else if (align === "center") {
	            x -= lineWidths[0] / 2;
	            text = [];
	            for (var i = 0, len = da.length; i < len; i++) {
	              delta = (maxLineLength - lineWidths[i]) / 2;
	              if (i === 0) {
	                newX = x * k;
	                newY = (pageHeight - y) * k;
	              } else {
	                newX = (prevWidth - lineWidths[i]) / 2 * k;
	                newY = -leading;
	              }
	              text.push([da[i], newX, newY]);
	              prevWidth = lineWidths[i];
	            }
	          } else if (align === "left") {
	            text = [];
	            for (var i = 0, len = da.length; i < len; i++) {
	              newY = i === 0 ? (pageHeight - y) * k : -leading;
	              newX = i === 0 ? x * k : 0;
	              //text.push([da[i], newX, newY]);
	              text.push(da[i]);
	            }
	          } else if (align === "justify") {
	            text = [];
	            var maxWidth = maxWidth !== 0 ? maxWidth : pageWidth;

	            for (var i = 0, len = da.length; i < len; i++) {
	              newY = i === 0 ? (pageHeight - y) * k : -leading;
	              newX = i === 0 ? x * k : 0;
	              if (i < len - 1) {
	                wordSpacingPerLine.push(((maxWidth - lineWidths[i]) / (da[i].split(" ").length - 1) * k).toFixed(2));
	              }
	              text.push([da[i], newX, newY]);
	            }
	          } else {
	            throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
	          }
	        }

	        //R2L
	        var doReversing = typeof options.R2L === "boolean" ? options.R2L : R2L;
	        if (doReversing === true) {
	          text = processTextByFunction(text, function (text, posX, posY) {
	            return [text.split("").reverse().join(""), posX, posY];
	          });
	        }

	        //creating Payload-Object to make text byRef
	        var payload = {
	          text: text,
	          x: x,
	          y: y,
	          options: options,
	          mutex: {
	            pdfEscape: pdfEscape,
	            activeFontKey: activeFontKey,
	            fonts: fonts,
	            activeFontSize: activeFontSize
	          }
	        };
	        events.publish('postProcessText', payload);

	        text = payload.text;
	        isHex = payload.mutex.isHex;

	        var da = transformTextToSpecialArray(text);

	        text = [];
	        var variant = 0;
	        var len = da.length;
	        var posX;
	        var posY;
	        var content;
	        var wordSpacing = '';

	        for (var i = 0; i < len; i++) {

	          wordSpacing = '';
	          if (Object.prototype.toString.call(da[i]) !== '[object Array]') {
	            posX = parseFloat(x * k).toFixed(2);
	            posY = parseFloat((pageHeight - y) * k).toFixed(2);
	            content = (isHex ? "<" : "(") + da[i] + (isHex ? ">" : ")");
	          } else if (Object.prototype.toString.call(da[i]) === '[object Array]') {
	            posX = parseFloat(da[i][1]).toFixed(2);
	            posY = parseFloat(da[i][2]).toFixed(2);
	            content = (isHex ? "<" : "(") + da[i][0] + (isHex ? ">" : ")");
	            variant = 1;
	          }
	          if (wordSpacingPerLine !== undefined && wordSpacingPerLine[i] !== undefined) {
	            wordSpacing = wordSpacingPerLine[i] + " Tw\n";
	          }
	          //TODO: Kind of a hack?
	          if (transformationMatrix.length !== 0 && i === 0) {
	            text.push(wordSpacing + transformationMatrix.join(" ") + " " + posX + " " + posY + " Tm\n" + content);
	          } else if (variant === 1 || variant === 0 && i === 0) {
	            text.push(wordSpacing + posX + " " + posY + " Td\n" + content);
	          } else {
	            text.push(wordSpacing + content);
	          }
	        }
	        if (variant === 0) {
	          text = text.join(" Tj\nT* ");
	        } else {
	          text = text.join(" Tj\n");
	        }

	        text += " Tj\n";

	        var result = 'BT\n/' + activeFontKey + ' ' + activeFontSize + ' Tf\n' + // font face, style, size
	        (activeFontSize * lineHeight).toFixed(2) + ' TL\n' + // line spacing
	        textColor + '\n';
	        result += xtra;
	        result += text;
	        result += "ET";

	        out(result);
	        return scope;
	      };

	      /**
	       * Letter spacing method to print text with gaps
	       *
	       * @function
	       * @param {String|Array} text String to be added to the page.
	       * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} spacing Spacing (in units declared at inception)
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name lstext
	       * @deprecated We'll be removing this function. It doesn't take character width into account.
	       */
	      API.lstext = function (text, x, y, spacing) {
	        console.warn('jsPDF.lstext is deprecated');
	        for (var i = 0, len = text.length; i < len; i++, x += spacing) {
	          this.text(text[i], x, y);
	        }return this;
	      };

	      API.line = function (x1, y1, x2, y2) {
	        return this.lines([[x2 - x1, y2 - y1]], x1, y1);
	      };

	      API.clip = function () {
	        // By patrick-roberts, github.com/MrRio/jsPDF/issues/328
	        // Call .clip() after calling .rect() with a style argument of null
	        out('W'); // clip
	        out('S'); // stroke path; necessary for clip to work
	      };

	      /**
	       * This fixes the previous function clip(). Perhaps the 'stroke path' hack was due to the missing 'n' instruction?
	       * We introduce the fixed version so as to not break API.
	       * @param fillRule
	       */
	      API.clip_fixed = function (fillRule) {
	        // Call .clip() after calling drawing ops with a style argument of null
	        // W is the PDF clipping op
	        if ('evenodd' === fillRule) {
	          out('W*');
	        } else {
	          out('W');
	        }
	        // End the path object without filling or stroking it.
	        // This operator is a path-painting no-op, used primarily for the side effect of changing the current clipping path
	        // (see Section 4.4.3, “Clipping Path Operators”)
	        out('n');
	      };

	      /**
	       * Adds series of curves (straight lines or cubic bezier curves) to canvas, starting at `x`, `y` coordinates.
	       * All data points in `lines` are relative to last line origin.
	       * `x`, `y` become x1,y1 for first line / curve in the set.
	       * For lines you only need to specify [x2, y2] - (ending point) vector against x1, y1 starting point.
	       * For bezier curves you need to specify [x2,y2,x3,y3,x4,y4] - vectors to control points 1, 2, ending point. All vectors are against the start of the curve - x1,y1.
	       *
	       * @example .lines([[2,2],[-2,2],[1,1,2,2,3,3],[2,1]], 212,110, 10) // line, line, bezier curve, line
	       * @param {Array} lines Array of *vector* shifts as pairs (lines) or sextets (cubic bezier curves).
	       * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} scale (Defaults to [1.0,1.0]) x,y Scaling factor for all vectors. Elements can be any floating number Sub-one makes drawing smaller. Over-one grows the drawing. Negative flips the direction.
	       * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
	       * @param {Boolean} closed If true, the path is closed with a straight line from the end of the last curve to the starting point.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name lines
	       */
	      API.lines = function (lines, x, y, scale, style, closed) {
	        var scalex, scaley, i, l, leg, x2, y2, x3, y3, x4, y4;

	        // Pre-August-2012 the order of arguments was function(x, y, lines, scale, style)
	        // in effort to make all calls have similar signature like
	        //   function(content, coordinateX, coordinateY , miscellaneous)
	        // this method had its args flipped.
	        // code below allows backward compatibility with old arg order.
	        if (typeof lines === 'number') {
	          tmp = y;
	          y = x;
	          x = lines;
	          lines = tmp;
	        }

	        scale = scale || [1, 1];

	        // starting point
	        out(f3(x * k) + ' ' + f3((pageHeight - y) * k) + ' m ');

	        scalex = scale[0];
	        scaley = scale[1];
	        l = lines.length;
	        //, x2, y2 // bezier only. In page default measurement "units", *after* scaling
	        //, x3, y3 // bezier only. In page default measurement "units", *after* scaling
	        // ending point for all, lines and bezier. . In page default measurement "units", *after* scaling
	        x4 = x; // last / ending point = starting point for first item.
	        y4 = y; // last / ending point = starting point for first item.

	        for (i = 0; i < l; i++) {
	          leg = lines[i];
	          if (leg.length === 2) {
	            // simple line
	            x4 = leg[0] * scalex + x4; // here last x4 was prior ending point
	            y4 = leg[1] * scaley + y4; // here last y4 was prior ending point
	            out(f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' l');
	          } else {
	            // bezier curve
	            x2 = leg[0] * scalex + x4; // here last x4 is prior ending point
	            y2 = leg[1] * scaley + y4; // here last y4 is prior ending point
	            x3 = leg[2] * scalex + x4; // here last x4 is prior ending point
	            y3 = leg[3] * scaley + y4; // here last y4 is prior ending point
	            x4 = leg[4] * scalex + x4; // here last x4 was prior ending point
	            y4 = leg[5] * scaley + y4; // here last y4 was prior ending point
	            out(f3(x2 * k) + ' ' + f3((pageHeight - y2) * k) + ' ' + f3(x3 * k) + ' ' + f3((pageHeight - y3) * k) + ' ' + f3(x4 * k) + ' ' + f3((pageHeight - y4) * k) + ' c');
	          }
	        }

	        if (closed) {
	          out(' h');
	        }

	        // stroking / filling / both the path
	        if (style !== null) {
	          out(getStyle(style));
	        }
	        return this;
	      };

	      /**
	       * Adds a rectangle to PDF
	       *
	       * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} w Width (in units declared at inception of PDF document)
	       * @param {Number} h Height (in units declared at inception of PDF document)
	       * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name rect
	       */
	      API.rect = function (x, y, w, h, style) {
	        var op = getStyle(style);
	        out([f2(x * k), f2((pageHeight - y) * k), f2(w * k), f2(-h * k), 're'].join(' '));

	        if (style !== null) {
	          out(getStyle(style));
	        }

	        return this;
	      };

	      /**
	       * Adds a triangle to PDF
	       *
	       * @param {Number} x1 Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y1 Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} x2 Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y2 Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} x3 Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y3 Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name triangle
	       */
	      API.triangle = function (x1, y1, x2, y2, x3, y3, style) {
	        this.lines([[x2 - x1, y2 - y1], // vector to point 2
	        [x3 - x2, y3 - y2], // vector to point 3
	        [x1 - x3, y1 - y3] // closing vector back to point 1
	        ], x1, y1, // start of path
	        [1, 1], style, true);
	        return this;
	      };

	      /**
	       * Adds a rectangle with rounded corners to PDF
	       *
	       * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} w Width (in units declared at inception of PDF document)
	       * @param {Number} h Height (in units declared at inception of PDF document)
	       * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
	       * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
	       * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name roundedRect
	       */
	      API.roundedRect = function (x, y, w, h, rx, ry, style) {
	        var MyArc = 4 / 3 * (Math.SQRT2 - 1);
	        this.lines([[w - 2 * rx, 0], [rx * MyArc, 0, rx, ry - ry * MyArc, rx, ry], [0, h - 2 * ry], [0, ry * MyArc, -(rx * MyArc), ry, -rx, ry], [-w + 2 * rx, 0], [-(rx * MyArc), 0, -rx, -(ry * MyArc), -rx, -ry], [0, -h + 2 * ry], [0, -(ry * MyArc), rx * MyArc, -ry, rx, -ry]], x + rx, y, // start of path
	        [1, 1], style);
	        return this;
	      };

	      /**
	       * Adds an ellipse to PDF
	       *
	       * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} rx Radius along x axis (in units declared at inception of PDF document)
	       * @param {Number} rx Radius along y axis (in units declared at inception of PDF document)
	       * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name ellipse
	       */
	      API.ellipse = function (x, y, rx, ry, style) {
	        var lx = 4 / 3 * (Math.SQRT2 - 1) * rx,
	            ly = 4 / 3 * (Math.SQRT2 - 1) * ry;

	        out([f2((x + rx) * k), f2((pageHeight - y) * k), 'm', f2((x + rx) * k), f2((pageHeight - (y - ly)) * k), f2((x + lx) * k), f2((pageHeight - (y - ry)) * k), f2(x * k), f2((pageHeight - (y - ry)) * k), 'c'].join(' '));
	        out([f2((x - lx) * k), f2((pageHeight - (y - ry)) * k), f2((x - rx) * k), f2((pageHeight - (y - ly)) * k), f2((x - rx) * k), f2((pageHeight - y) * k), 'c'].join(' '));
	        out([f2((x - rx) * k), f2((pageHeight - (y + ly)) * k), f2((x - lx) * k), f2((pageHeight - (y + ry)) * k), f2(x * k), f2((pageHeight - (y + ry)) * k), 'c'].join(' '));
	        out([f2((x + lx) * k), f2((pageHeight - (y + ry)) * k), f2((x + rx) * k), f2((pageHeight - (y + ly)) * k), f2((x + rx) * k), f2((pageHeight - y) * k), 'c'].join(' '));

	        if (style !== null) {
	          out(getStyle(style));
	        }

	        return this;
	      };

	      /**
	       * Adds an circle to PDF
	       *
	       * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	       * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	       * @param {Number} r Radius (in units declared at inception of PDF document)
	       * @param {String} style A string specifying the painting style or null.  Valid styles include: 'S' [default] - stroke, 'F' - fill,  and 'DF' (or 'FD') -  fill then stroke. A null value postpones setting the style so that a shape may be composed using multiple method calls. The last drawing method call used to define the shape should not have a null style argument.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name circle
	       */
	      API.circle = function (x, y, r, style) {
	        return this.ellipse(x, y, r, r, style);
	      };

	      /**
	       * Adds a properties to the PDF document
	       *
	       * @param {Object} A property_name-to-property_value object structure.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setProperties
	       */
	      API.setProperties = function (properties) {
	        // copying only those properties we can render.
	        for (var property in documentProperties) {
	          if (documentProperties.hasOwnProperty(property) && properties[property]) {
	            documentProperties[property] = properties[property];
	          }
	        }
	        return this;
	      };

	      /**
	       * Sets font size for upcoming text elements.
	       *
	       * @param {Number} size Font size in points.
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setFontSize
	       */
	      API.setFontSize = function (size) {
	        activeFontSize = size;
	        return this;
	      };

	      /**
	       * Sets text font face, variant for upcoming text elements.
	       * See output of jsPDF.getFontList() for possible font names, styles.
	       *
	       * @param {String} fontName Font name or family. Example: "times"
	       * @param {String} fontStyle Font style or variant. Example: "italic"
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setFont
	       */
	      API.setFont = function (fontName, fontStyle) {
	        activeFontKey = _getFont(fontName, fontStyle);
	        // if font is not found, the above line blows up and we never go further
	        return this;
	      };

	      /**
	       * Switches font style or variant for upcoming text elements,
	       * while keeping the font face or family same.
	       * See output of jsPDF.getFontList() for possible font names, styles.
	       *
	       * @param {String} style Font style or variant. Example: "italic"
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setFontStyle
	       */
	      API.setFontStyle = API.setFontType = function (style) {
	        activeFontKey = _getFont(undefined, style);
	        // if font is not found, the above line blows up and we never go further
	        return this;
	      };

	      /**
	       * Returns an object - a tree of fontName to fontStyle relationships available to
	       * active PDF document.
	       *
	       * @public
	       * @function
	       * @returns {Object} Like {'times':['normal', 'italic', ... ], 'arial':['normal', 'bold', ... ], ... }
	       * @methodOf jsPDF#
	       * @name getFontList
	       */
	      API.getFontList = function () {
	        // TODO: iterate over fonts array or return copy of fontmap instead in case more are ever added.
	        var list = {},
	            fontName,
	            fontStyle,
	            tmp;

	        for (fontName in fontmap) {
	          if (fontmap.hasOwnProperty(fontName)) {
	            list[fontName] = tmp = [];
	            for (fontStyle in fontmap[fontName]) {
	              if (fontmap[fontName].hasOwnProperty(fontStyle)) {
	                tmp.push(fontStyle);
	              }
	            }
	          }
	        }

	        return list;
	      };

	      /**
	       * Add a custom font.
	       *
	       * @param {String} Postscript name of the Font.  Example: "Menlo-Regular"
	       * @param {String} Name of font-family from @font-face definition.  Example: "Menlo Regular"
	       * @param {String} Font style.  Example: "normal"
	       * @function
	       * @returns the {fontKey} (same as the internal method)
	       * @methodOf jsPDF#
	       * @name addFont
	       */
	      API.addFont = function (postScriptName, fontName, fontStyle, encoding) {
	        encoding = encoding || 'Identity-H';
	        addFont(postScriptName, fontName, fontStyle, encoding);
	      };

	      /**
	       * Sets line width for upcoming lines.
	       *
	       * @param {Number} width Line width (in units declared at inception of PDF document)
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setLineWidth
	       */
	      API.setLineWidth = function (width) {
	        out((width * k).toFixed(2) + ' w');
	        return this;
	      };

	      /**
	       * Sets the stroke color for upcoming elements.
	       *
	       * Depending on the number of arguments given, Gray, RGB, or CMYK
	       * color space is implied.
	       *
	       * When only ch1 is given, "Gray" color space is implied and it
	       * must be a value in the range from 0.00 (solid black) to to 1.00 (white)
	       * if values are communicated as String types, or in range from 0 (black)
	       * to 255 (white) if communicated as Number type.
	       * The RGB-like 0-255 range is provided for backward compatibility.
	       *
	       * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
	       * value must be in the range from 0.00 (minimum intensity) to to 1.00
	       * (max intensity) if values are communicated as String types, or
	       * from 0 (min intensity) to to 255 (max intensity) if values are communicated
	       * as Number types.
	       * The RGB-like 0-255 range is provided for backward compatibility.
	       *
	       * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
	       * value must be a in the range from 0.00 (0% concentration) to to
	       * 1.00 (100% concentration)
	       *
	       * Because JavaScript treats fixed point numbers badly (rounds to
	       * floating point nearest to binary representation) it is highly advised to
	       * communicate the fractional numbers as String types, not JavaScript Number type.
	       *
	       * @param {Number|String} ch1 Color channel value or {String} ch1 color value in hexadecimal, example: '#FFFFFF'
	       * @param {Number|String} ch2 Color channel value
	       * @param {Number|String} ch3 Color channel value
	       * @param {Number|String} ch4 Color channel value
	       *
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setDrawColor
	       */
	      API.setDrawColor = function (ch1, ch2, ch3, ch4) {
	        var options = {
	          "ch1": ch1,
	          "ch2": ch2,
	          "ch3": ch3,
	          "ch4": ch4,
	          "pdfColorType": "draw",
	          "precision": 2
	        };

	        out(generateColorString(options));
	        return this;
	      };

	      /**
	       * Sets the fill color for upcoming elements.
	       *
	       * Depending on the number of arguments given, Gray, RGB, or CMYK
	       * color space is implied.
	       *
	       * When only ch1 is given, "Gray" color space is implied and it
	       * must be a value in the range from 0.00 (solid black) to to 1.00 (white)
	       * if values are communicated as String types, or in range from 0 (black)
	       * to 255 (white) if communicated as Number type.
	       * The RGB-like 0-255 range is provided for backward compatibility.
	       *
	       * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
	       * value must be in the range from 0.00 (minimum intensity) to to 1.00
	       * (max intensity) if values are communicated as String types, or
	       * from 0 (min intensity) to to 255 (max intensity) if values are communicated
	       * as Number types.
	       * The RGB-like 0-255 range is provided for backward compatibility.
	       *
	       * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
	       * value must be a in the range from 0.00 (0% concentration) to to
	       * 1.00 (100% concentration)
	       *
	       * Because JavaScript treats fixed point numbers badly (rounds to
	       * floating point nearest to binary representation) it is highly advised to
	       * communicate the fractional numbers as String types, not JavaScript Number type.
	       *
	       * @param {Number|String} ch1 Color channel value or {String} ch1 color value in hexadecimal, example: '#FFFFFF'
	       * @param {Number|String} ch2 Color channel value
	       * @param {Number|String} ch3 Color channel value
	       * @param {Number|String} ch4 Color channel value
	       *
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setFillColor
	       */

	      API.setFillColor = function (ch1, ch2, ch3, ch4) {
	        var options = {
	          "ch1": ch1,
	          "ch2": ch2,
	          "ch3": ch3,
	          "ch4": ch4,
	          "pdfColorType": "fill",
	          "precision": 2
	        };

	        out(generateColorString(options));
	        return this;
	      };

	      /**
	       * Sets the text color for upcoming elements.
	       *
	       * Depending on the number of arguments given, Gray, RGB, or CMYK
	       * color space is implied.
	       *
	       * When only ch1 is given, "Gray" color space is implied and it
	       * must be a value in the range from 0.00 (solid black) to to 1.00 (white)
	       * if values are communicated as String types, or in range from 0 (black)
	       * to 255 (white) if communicated as Number type.
	       * The RGB-like 0-255 range is provided for backward compatibility.
	       *
	       * When only ch1,ch2,ch3 are given, "RGB" color space is implied and each
	       * value must be in the range from 0.00 (minimum intensity) to to 1.00
	       * (max intensity) if values are communicated as String types, or
	       * from 0 (min intensity) to to 255 (max intensity) if values are communicated
	       * as Number types.
	       * The RGB-like 0-255 range is provided for backward compatibility.
	       *
	       * When ch1,ch2,ch3,ch4 are given, "CMYK" color space is implied and each
	       * value must be a in the range from 0.00 (0% concentration) to to
	       * 1.00 (100% concentration)
	       *
	       * Because JavaScript treats fixed point numbers badly (rounds to
	       * floating point nearest to binary representation) it is highly advised to
	       * communicate the fractional numbers as String types, not JavaScript Number type.
	       *
	       * @param {Number|String} ch1 Color channel value or {String} ch1 color value in hexadecimal, example: '#FFFFFF'
	       * @param {Number|String} ch2 Color channel value
	       * @param {Number|String} ch3 Color channel value
	       * @param {Number|String} ch4 Color channel value
	       *
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setTextColor
	       */
	      API.setTextColor = function (ch1, ch2, ch3, ch4) {
	        var options = {
	          "ch1": ch1,
	          "ch2": ch2,
	          "ch3": ch3,
	          "ch4": ch4,
	          "pdfColorType": "text",
	          "precision": 3
	        };
	        textColor = generateColorString(options);

	        return this;
	      };

	      /**
	       * Initializes the default character set that the user wants to be global..
	       *
	       * @param {Number} charSpace
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setCharSpace
	       */

	      API.setCharSpace = function (charSpace) {
	        activeCharSpace = charSpace;
	        return this;
	      };

	      /**
	       * Initializes the default character set that the user wants to be global..
	       *
	       * @param {Boolean} boolean
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setR2L
	       */

	      API.setR2L = function (boolean) {
	        R2L = boolean;
	        return this;
	      };

	      /**
	       * Is an Object providing a mapping from human-readable to
	       * integer flag values designating the varieties of line cap
	       * and join styles.
	       *
	       * @returns {Object}
	       * @fieldOf jsPDF#
	       * @name CapJoinStyles
	       */
	      API.CapJoinStyles = {
	        0: 0,
	        'butt': 0,
	        'but': 0,
	        'miter': 0,
	        1: 1,
	        'round': 1,
	        'rounded': 1,
	        'circle': 1,
	        2: 2,
	        'projecting': 2,
	        'project': 2,
	        'square': 2,
	        'bevel': 2
	      };

	      /**
	       * Sets the line cap styles
	       * See {jsPDF.CapJoinStyles} for variants
	       *
	       * @param {String|Number} style A string or number identifying the type of line cap
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setLineCap
	       */
	      API.setLineCap = function (style) {
	        var id = this.CapJoinStyles[style];
	        if (id === undefined) {
	          throw new Error("Line cap style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
	        }
	        lineCapID = id;
	        out(id + ' J');

	        return this;
	      };

	      /**
	       * Sets the line join styles
	       * See {jsPDF.CapJoinStyles} for variants
	       *
	       * @param {String|Number} style A string or number identifying the type of line join
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name setLineJoin
	       */
	      API.setLineJoin = function (style) {
	        var id = this.CapJoinStyles[style];
	        if (id === undefined) {
	          throw new Error("Line join style of '" + style + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
	        }
	        lineJoinID = id;
	        out(id + ' j');

	        return this;
	      };

	      // Output is both an internal (for plugins) and external function
	      API.output = _output;

	      /**
	       * Saves as PDF document. An alias of jsPDF.output('save', 'filename.pdf')
	       * @param  {String} filename The filename including extension.
	       *
	       * @function
	       * @returns {jsPDF}
	       * @methodOf jsPDF#
	       * @name save
	       */
	      API.save = function (filename) {
	        API.output('save', filename);
	      };

	      // applying plugins (more methods) ON TOP of built-in API.
	      // this is intentional as we allow plugins to override
	      // built-ins
	      for (var plugin in jsPDF.API) {
	        if (jsPDF.API.hasOwnProperty(plugin)) {
	          if (plugin === 'events' && jsPDF.API.events.length) {
	            (function (events, newEvents) {

	              // jsPDF.API.events is a JS Array of Arrays
	              // where each Array is a pair of event name, handler
	              // Events were added by plugins to the jsPDF instantiator.
	              // These are always added to the new instance and some ran
	              // during instantiation.
	              var eventname, handler_and_args, i;

	              for (i = newEvents.length - 1; i !== -1; i--) {
	                // subscribe takes 3 args: 'topic', function, runonce_flag
	                // if undefined, runonce is false.
	                // users can attach callback directly,
	                // or they can attach an array with [callback, runonce_flag]
	                // that's what the "apply" magic is for below.
	                eventname = newEvents[i][0];
	                handler_and_args = newEvents[i][1];
	                events.subscribe.apply(events, [eventname].concat(typeof handler_and_args === 'function' ? [handler_and_args] : handler_and_args));
	              }
	            })(events, jsPDF.API.events);
	          } else {
	            API[plugin] = jsPDF.API[plugin];
	          }
	        }
	      }

	      //////////////////////////////////////////////////////
	      // continuing initialization of jsPDF Document object
	      //////////////////////////////////////////////////////
	      // Add the first page automatically
	      addFonts();
	      activeFontKey = 'F1';
	      _addPage(format, orientation);

	      events.publish('initialized');
	      return API;
	    }

	    /**
	     * jsPDF.API is a STATIC property of jsPDF class.
	     * jsPDF.API is an object you can add methods and properties to.
	     * The methods / properties you add will show up in new jsPDF objects.
	     *
	     * One property is prepopulated. It is the 'events' Object. Plugin authors can add topics,
	     * callbacks to this object. These will be reassigned to all new instances of jsPDF.
	     * Examples:
	     * jsPDF.API.events['initialized'] = function(){ 'this' is API object }
	     * jsPDF.API.events['addFont'] = function(added_font_object){ 'this' is API object }
	     *
	     * @static
	     * @public
	     * @memberOf jsPDF
	     * @name API
	     *
	     * @example
	     * jsPDF.API.mymethod = function(){
	     *   // 'this' will be ref to internal API object. see jsPDF source
	     *   // , so you can refer to built-in methods like so:
	     *   //     this.line(....)
	     *   //     this.text(....)
	     * }
	     * var pdfdoc = new jsPDF()
	     * pdfdoc.mymethod() // <- !!!!!!
	     */
	    jsPDF.API = {
	      events: []
	    };
	    jsPDF.version = "0.0.0";

	    if (typeof define === 'function' && define.amd) {
	      define('jsPDF', function () {
	        return jsPDF;
	      });
	    } else if (typeof module !== 'undefined' && module.exports) {
	      module.exports = jsPDF;
	      module.exports.jsPDF = jsPDF;
	    } else {
	      global.jsPDF = jsPDF;
	    }
	    return jsPDF;
	  }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || typeof global !== "undefined" && global || Function('return typeof this === "object" && this.content')() || Function('return this')());
	  // `self` is undefined in Firefox for Android content script context
	  // while `this` is nsIContentFrameMessageManager
	  // with an attribute `content` that corresponds to the window
	  

	  /**
	   * jsPDF AcroForm Plugin Copyright (c) 2016 Alexander Weidt,
	   * https://github.com/BiggA94
	   * 
	   * Licensed under the MIT License. http://opensource.org/licenses/mit-license
	   */

	  (function (jsPDFAPI, globalObj) {

	    var scope;
	    var pageHeight;
	    var scaleFactor = 1;
	    var inherit = function inherit(child, parent) {
	      child.prototype = Object.create(parent.prototype);
	      child.prototype.constructor = child;
	    };
	    var scale = function scale(x) {
	      return x * (scaleFactor / 1); // 1 = (96 / 72)
	    };

	    var createFormXObject = function createFormXObject(formObject) {
	      var xobj = new AcroFormXObject();
	      var height = AcroFormAppearance.internal.getHeight(formObject) || 0;
	      var width = AcroFormAppearance.internal.getWidth(formObject) || 0;
	      xobj.BBox = [0, 0, width.toFixed(2), height.toFixed(2)];
	      return xobj;
	    };

	    var setBitPosition = function setBitPosition(variable, position, value) {
	      variable = variable || 0;
	      value = value || 1;

	      var bitMask = 1;
	      bitMask = bitMask << position - 1;

	      if (value == 1) {
	        // Set the Bit to 1
	        var variable = variable | bitMask;
	      } else {
	        // Set the Bit to 0
	        var variable = variable & ~bitMask;
	      }

	      return variable;
	    };

	    /**
	    * Calculating the Ff entry:
	    * 
	    * The Ff entry contains flags, that have to be set bitwise In the Following
	    * the number in the Comment is the BitPosition
	    */
	    var calculateFlagsOnOptions = function calculateFlagsOnOptions(flags, opts, PDFVersion) {
	      var PDFVersion = PDFVersion || 1.3;
	      var flags = flags || 0;

	      // 1, readOnly
	      if (opts.readOnly == true) {
	        flags = setBitPosition(flags, 1);
	      }

	      // 2, required
	      if (opts.required == true) {
	        flags = setBitPosition(flags, 2);
	      }

	      // 4, noExport
	      if (opts.noExport == true) {
	        flags = setBitPosition(flags, 3);
	      }

	      // 13, multiline
	      if (opts.multiline == true) {
	        flags = setBitPosition(flags, 13);
	      }

	      // 14, Password
	      if (opts.password) {
	        flags = setBitPosition(flags, 14);
	      }

	      // 15, NoToggleToOff (Radio buttons only
	      if (opts.noToggleToOff) {
	        flags = setBitPosition(flags, 15);
	      }

	      // 16, Radio
	      if (opts.radio) {
	        flags = setBitPosition(flags, 16);
	      }

	      // 17, Pushbutton
	      if (opts.pushbutton) {
	        flags = setBitPosition(flags, 17);
	      }

	      // 18, Combo (If not set, the choiceField is a listBox!!)
	      if (opts.combo) {
	        flags = setBitPosition(flags, 18);
	      }

	      // 19, Edit
	      if (opts.edit) {
	        flags = setBitPosition(flags, 19);
	      }

	      // 20, Sort
	      if (opts.sort) {
	        flags = setBitPosition(flags, 20);
	      }

	      // 21, FileSelect, PDF 1.4...
	      if (opts.fileSelect && PDFVersion >= 1.4) {
	        flags = setBitPosition(flags, 21);
	      }

	      // 22, MultiSelect (PDF 1.4)
	      if (opts.multiSelect && PDFVersion >= 1.4) {
	        flags = setBitPosition(flags, 22);
	      }

	      // 23, DoNotSpellCheck (PDF 1.4)
	      if (opts.doNotSpellCheck && PDFVersion >= 1.4) {
	        flags = setBitPosition(flags, 23);
	      }

	      // 24, DoNotScroll (PDF 1.4)
	      if (opts.doNotScroll == true && PDFVersion >= 1.4) {
	        flags = setBitPosition(flags, 24);
	      }

	      // 25, RichText (PDF 1.4)
	      if (opts.richText && PDFVersion >= 1.4) {
	        flags = setBitPosition(flags, 25);
	      }

	      return flags;
	    };

	    var calculateCoordinates = function calculateCoordinates(args) {
	      var x = args[0];
	      var y = args[1];
	      var w = args[2];
	      var h = args[3];

	      var coordinates = {};

	      if (Array.isArray(x)) {
	        x[0] = scale(x[0]);
	        x[1] = scale(x[1]);
	        x[2] = scale(x[2]);
	        x[3] = scale(x[3]);
	      } else {
	        x = scale(x);
	        y = scale(y);
	        w = scale(w);
	        h = scale(h);
	      }
	      coordinates.lowerLeft_X = x || 0;
	      coordinates.lowerLeft_Y = scale(pageHeight) - y - h || 0;
	      coordinates.upperRight_X = x + w || 0;
	      coordinates.upperRight_Y = scale(pageHeight) - y || 0;

	      return [coordinates.lowerLeft_X.toFixed(2), coordinates.lowerLeft_Y.toFixed(2), coordinates.upperRight_X.toFixed(2), coordinates.upperRight_Y.toFixed(2)];
	    };

	    var calculateAppearanceStream = function calculateAppearanceStream(formObject) {
	      if (formObject.appearanceStreamContent) {
	        // If appearanceStream is already set, use it
	        return formObject.appearanceStreamContent;
	      }

	      if (!formObject.V && !formObject.DV) {
	        return;
	      }

	      // else calculate it

	      var stream = [];
	      var text = formObject.V || formObject.DV;
	      var calcRes = calculateX(formObject, text);

	      stream.push('/Tx BMC');
	      stream.push('q');
	      stream.push('/F1 ' + calcRes.fontSize.toFixed(2) + ' Tf');
	      stream.push('1 0 0 1 0 0 Tm'); // Text Matrix

	      stream.push('BT'); // Begin Text
	      stream.push(calcRes.text);

	      stream.push('ET'); // End Text
	      stream.push('Q');
	      stream.push('EMC');

	      var appearanceStreamContent = new createFormXObject(formObject);
	      appearanceStreamContent.stream = stream.join("\n");

	      return appearanceStreamContent;
	    };

	    var calculateX = function calculateX(formObject, text, font, maxFontSize) {
	      var maxFontSize = maxFontSize || 12;
	      var font = font || "helvetica";
	      var returnValue = {
	        text: "",
	        fontSize: ""
	      };
	      // Remove Brackets
	      text = text.substr(0, 1) == '(' ? text.substr(1) : text;
	      text = text.substr(text.length - 1) == ')' ? text.substr(0, text.length - 1) : text;
	      // split into array of words
	      var textSplit = text.split(' ');
	      var fontSize = maxFontSize; // The Starting fontSize (The Maximum)
	      var lineSpacing = 2;
	      var borderPadding = 2;

	      var height = AcroFormAppearance.internal.getHeight(formObject) || 0;
	      height = height < 0 ? -height : height;
	      var width = AcroFormAppearance.internal.getWidth(formObject) || 0;
	      width = width < 0 ? -width : width;

	      var isSmallerThanWidth = function isSmallerThanWidth(i, lastLine, fontSize) {
	        if (i + 1 < textSplit.length) {
	          var tmp = lastLine + " " + textSplit[i + 1];
	          var TextWidth = calculateFontSpace(tmp, fontSize + "px", font).width;
	          var FieldWidth = width - 2 * borderPadding;
	          return TextWidth <= FieldWidth;
	        } else {
	          return false;
	        }
	      };

	      fontSize++;
	      FontSize: while (true) {
	        var text = "";
	        fontSize--;
	        var textHeight = calculateFontSpace("3", fontSize + "px", font).height;
	        var startY = formObject.multiline ? height - fontSize : (height - textHeight) / 2;
	        startY += lineSpacing;
	        var startX = -borderPadding;

	        var lastY = startY;
	        var firstWordInLine = 0,
	            lastWordInLine = 0;
	        var lastLength = 0;
	        if (fontSize <= 0) {
	          // In case, the Text doesn't fit at all
	          fontSize = 12;
	          text = "(...) Tj\n";
	          text += "% Width of Text: " + calculateFontSpace(text, "1px").width + ", FieldWidth:" + width + "\n";
	          break;
	        }

	        lastLength = calculateFontSpace(textSplit[0] + " ", fontSize + "px", font).width;

	        var lastLine = "";
	        var lineCount = 0;
	        Line: for (var i in textSplit) {
	          lastLine += textSplit[i] + " ";
	          // Remove last blank
	          lastLine = lastLine.substr(lastLine.length - 1) == " " ? lastLine.substr(0, lastLine.length - 1) : lastLine;
	          var key = parseInt(i);
	          lastLength = calculateFontSpace(lastLine + " ", fontSize + "px", font).width;
	          var nextLineIsSmaller = isSmallerThanWidth(key, lastLine, fontSize);
	          var isLastWord = i >= textSplit.length - 1;
	          if (nextLineIsSmaller && !isLastWord) {
	            lastLine += " ";
	            continue; // Line
	          } else if (!nextLineIsSmaller && !isLastWord) {
	            if (!formObject.multiline) {
	              continue FontSize;
	            } else {
	              if ((textHeight + lineSpacing) * (lineCount + 2) + lineSpacing > height) {
	                // If the Text is higher than the
	                // FieldObject
	                continue FontSize;
	              }
	              lastWordInLine = key;
	              // go on
	            }
	          } else if (isLastWord) {
	            lastWordInLine = key;
	          } else {
	            if (formObject.multiline && (textHeight + lineSpacing) * (lineCount + 2) + lineSpacing > height) {
	              // If the Text is higher than the FieldObject
	              continue FontSize;
	            }
	          }

	          var line = '';

	          for (var x = firstWordInLine; x <= lastWordInLine; x++) {
	            line += textSplit[x] + ' ';
	          }

	          // Remove last blank
	          line = line.substr(line.length - 1) == " " ? line.substr(0, line.length - 1) : line;
	          // lastLength -= blankSpace.width;
	          lastLength = calculateFontSpace(line, fontSize + "px", font).width;

	          // Calculate startX
	          switch (formObject.Q) {
	            case 2:
	              // Right justified
	              startX = width - lastLength - borderPadding;
	              break;
	            case 1:
	              // Q = 1 := Text-Alignment: Center
	              startX = (width - lastLength) / 2;
	              break;
	            case 0:
	            default:
	              startX = borderPadding;
	              break;
	          }
	          text += startX.toFixed(2) + ' ' + lastY.toFixed(2) + ' Td\n';
	          text += '(' + line + ') Tj\n';
	          // reset X in PDF
	          text += -startX.toFixed(2) + ' 0 Td\n';

	          // After a Line, adjust y position
	          lastY = -(fontSize + lineSpacing);

	          // Reset for next iteration step
	          lastLength = 0;
	          firstWordInLine = lastWordInLine + 1;
	          lineCount++;

	          lastLine = "";
	          continue Line;
	        }
	        break;
	      }

	      returnValue.text = text;
	      returnValue.fontSize = fontSize;

	      return returnValue;
	    };

	    /**
	    * small workaround for calculating the TextMetric approximately
	    * 
	    * @param text
	    * @param fontsize
	    * @returns {TextMetrics} (Has Height and Width)
	    */
	    var calculateFontSpace = function calculateFontSpace(text, fontSize, fontType) {
	      fontType = fontType || "helvetica";
	      var font = scope.internal.getFont(fontType);
	      var width = scope.getStringUnitWidth(text, { font: font, fontSize: parseFloat(fontSize), charSpace: 0 }) * parseFloat(fontSize);
	      var height = scope.getStringUnitWidth("3", { font: font, fontSize: parseFloat(fontSize), charSpace: 0 }) * parseFloat(fontSize) * 1.5;
	      var result = { height: height, width: width };
	      return result;
	    };

	    var acroformPluginTemplate = {
	      fields: [],
	      xForms: [],
	      /**
	      * acroFormDictionaryRoot contains information about the AcroForm
	      * Dictionary 0: The Event-Token, the AcroFormDictionaryCallback has
	      * 1: The Object ID of the Root
	      */
	      acroFormDictionaryRoot: null,
	      /**
	      * After the PDF gets evaluated, the reference to the root has to be
	      * reset, this indicates, whether the root has already been printed
	      * out
	      */
	      printedOut: false,
	      internal: null,
	      isInitialized: false
	    };

	    var annotReferenceCallback = function annotReferenceCallback() {
	      for (var i in scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields) {
	        var formObject = scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields[i];
	        // add Annot Reference!
	        if (formObject.hasAnnotation) {
	          // If theres an Annotation Widget in the Form Object, put the
	          // Reference in the /Annot array
	          createAnnotationReference.call(scope, formObject);
	        }
	      }
	    };

	    var putForm = function putForm(formObject) {
	      if (scope.internal.acroformPlugin.printedOut) {
	        scope.internal.acroformPlugin.printedOut = false;
	        scope.internal.acroformPlugin.acroFormDictionaryRoot = null;
	      }
	      if (!scope.internal.acroformPlugin.acroFormDictionaryRoot) {
	        initializeAcroForm.call(scope);
	      }
	      scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(formObject);
	    };
	    /**
	    * Create the Reference to the widgetAnnotation, so that it gets referenced
	    * in the Annot[] int the+ (Requires the Annotation Plugin)
	    */
	    var createAnnotationReference = function createAnnotationReference(object) {
	      var options = {
	        type: 'reference',
	        object: object
	      };
	      scope.annotationPlugin.annotations[scope.internal.getPageInfo(object.page).pageNumber].push(options);
	    };

	    // Callbacks

	    var putCatalogCallback = function putCatalogCallback() {
	      // Put reference to AcroForm to DocumentCatalog
	      if (typeof scope.internal.acroformPlugin.acroFormDictionaryRoot != 'undefined') {
	        // for safety, shouldn't normally be the case
	        scope.internal.write('/AcroForm ' + scope.internal.acroformPlugin.acroFormDictionaryRoot.objId + ' ' + 0 + ' R');
	      } else {
	        console.log('Root missing...');
	      }
	    };

	    /**
	    * Adds /Acroform X 0 R to Document Catalog, and creates the AcroForm
	    * Dictionary
	    */
	    var AcroFormDictionaryCallback = function AcroFormDictionaryCallback() {
	      // Remove event
	      scope.internal.events.unsubscribe(scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID);
	      delete scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID;
	      scope.internal.acroformPlugin.printedOut = true;
	    };

	    /**
	    * Creates the single Fields and writes them into the Document
	    * 
	    * If fieldArray is set, use the fields that are inside it instead of the
	    * fields from the AcroRoot (for the FormXObjects...)
	    */
	    var createFieldCallback = function createFieldCallback(fieldArray) {
	      var standardFields = !fieldArray;

	      if (!fieldArray) {
	        // in case there is no fieldArray specified, we want to print out
	        // the Fields of the AcroForm
	        // Print out Root
	        scope.internal.newObjectDeferredBegin(scope.internal.acroformPlugin.acroFormDictionaryRoot.objId);
	        scope.internal.out(scope.internal.acroformPlugin.acroFormDictionaryRoot.getString());
	      }

	      var fieldArray = fieldArray || scope.internal.acroformPlugin.acroFormDictionaryRoot.Kids;

	      for (var i in fieldArray) {
	        var form = fieldArray[i];

	        var oldRect = form.Rect;

	        if (form.Rect) {
	          form.Rect = calculateCoordinates.call(this, form.Rect);
	        }

	        // Start Writing the Object
	        scope.internal.newObjectDeferredBegin(form.objId);

	        var content = form.objId + " 0 obj\n<<\n";

	        if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) === "object" && typeof form.getContent === "function") {
	          content += form.getContent();
	        }

	        form.Rect = oldRect;

	        if (form.hasAppearanceStream && !form.appearanceStreamContent) {
	          // Calculate Appearance
	          var appearance = calculateAppearanceStream.call(this, form);
	          content += "/AP << /N " + appearance + " >>\n";

	          scope.internal.acroformPlugin.xForms.push(appearance);
	        }

	        // Assume AppearanceStreamContent is a Array with N,R,D (at least
	        // one of them!)
	        if (form.appearanceStreamContent) {
	          content += "/AP << ";
	          // Iterate over N,R and D
	          for (var k in form.appearanceStreamContent) {
	            var value = form.appearanceStreamContent[k];
	            content += "/" + k + " ";
	            content += "<< ";
	            if (Object.keys(value).length >= 1 || Array.isArray(value)) {
	              // appearanceStream is an Array or Object!
	              for (var i in value) {
	                var obj = value[i];
	                if (typeof obj === 'function') {
	                  // if Function is referenced, call it in order
	                  // to get the FormXObject
	                  obj = obj.call(this, form);
	                }
	                content += "/" + i + " " + obj + " ";

	                // In case the XForm is already used, e.g. OffState
	                // of CheckBoxes, don't add it
	                if (!(scope.internal.acroformPlugin.xForms.indexOf(obj) >= 0)) scope.internal.acroformPlugin.xForms.push(obj);
	              }
	            } else {
	              var obj = value;
	              if (typeof obj === 'function') {
	                // if Function is referenced, call it in order to
	                // get the FormXObject
	                obj = obj.call(this, form);
	              }
	              content += "/" + i + " " + obj + " \n";
	              if (!(scope.internal.acroformPlugin.xForms.indexOf(obj) >= 0)) scope.internal.acroformPlugin.xForms.push(obj);
	            }
	            content += " >>\n";
	          }

	          // appearance stream is a normal Object..
	          content += ">>\n";
	        }

	        content += ">>\nendobj\n";

	        scope.internal.out(content);
	      }
	      if (standardFields) {
	        createXFormObjectCallback.call(this, scope.internal.acroformPlugin.xForms);
	      }
	    };

	    var createXFormObjectCallback = function createXFormObjectCallback(fieldArray) {
	      for (var i in fieldArray) {
	        var key = i;
	        var form = fieldArray[i];
	        // Start Writing the Object
	        scope.internal.newObjectDeferredBegin(form && form.objId);

	        var content = "";
	        if ((typeof form === 'undefined' ? 'undefined' : _typeof(form)) === "object" && typeof form.getString === "function") {
	          content = form.getString();
	        }
	        scope.internal.out(content);

	        delete fieldArray[key];
	      }
	    };

	    var initializeAcroForm = function initializeAcroForm() {
	      if (this.internal !== undefined && (this.internal.acroformPlugin === undefined || this.internal.acroformPlugin.isInitialized === false)) {

	        scope = this;

	        AcroFormField.FieldNum = 0;
	        this.internal.acroformPlugin = JSON.parse(JSON.stringify(acroformPluginTemplate));
	        if (this.internal.acroformPlugin.acroFormDictionaryRoot) {
	          // return;
	          throw new Error("Exception while creating AcroformDictionary");
	        }
	        scaleFactor = scope.internal.scaleFactor;
	        pageHeight = scope.internal.pageSize.getHeight();

	        // The Object Number of the AcroForm Dictionary
	        scope.internal.acroformPlugin.acroFormDictionaryRoot = new AcroFormDictionary();

	        // add Callback for creating the AcroForm Dictionary
	        scope.internal.acroformPlugin.acroFormDictionaryRoot._eventID = scope.internal.events.subscribe('postPutResources', AcroFormDictionaryCallback);

	        scope.internal.events.subscribe('buildDocument', annotReferenceCallback); // buildDocument

	        // Register event, that is triggered when the DocumentCatalog is
	        // written, in order to add /AcroForm
	        scope.internal.events.subscribe('putCatalog', putCatalogCallback);

	        // Register event, that creates all Fields
	        scope.internal.events.subscribe('postPutPages', createFieldCallback);

	        scope.internal.acroformPlugin.isInitialized = true;
	      }
	    };

	    var arrayToPdfArray = function arrayToPdfArray(array) {
	      if (Array.isArray(array)) {
	        var content = ' [';
	        for (var i in array) {
	          var element = array[i].toString();
	          content += element;
	          content += i < array.length - 1 ? ' ' : '';
	        }
	        content += ']';

	        return content;
	      }
	    };

	    var toPdfString = function toPdfString(string) {
	      string = string || "";

	      // put Bracket at the Beginning of the String
	      if (string.indexOf('(') !== 0) {
	        string = '(' + string;
	      }

	      if (string.substring(string.length - 1) != ')') {
	        string += ')';
	      }
	      return string;
	    };

	    // ##########################
	    // Classes
	    // ##########################

	    var AcroFormPDFObject = function AcroFormPDFObject() {
	      // The Object ID in the PDF Object Model
	      // todo
	      var _objId;
	      Object.defineProperty(this, 'objId', {
	        get: function get$$1() {
	          if (!_objId) {
	            _objId = scope.internal.newObjectDeferred();
	          }
	          if (!_objId) {
	            console.log("Couldn't create Object ID");
	          }
	          return _objId;
	        },
	        configurable: false
	      });
	    };

	    AcroFormPDFObject.prototype.toString = function () {
	      return this.objId + " 0 R";
	    };

	    AcroFormPDFObject.prototype.getString = function () {
	      var res = this.objId + " 0 obj\n<<";
	      var content = this.getContent();

	      res += content + ">>\n";
	      if (this.stream) {
	        res += "stream\n";
	        res += this.stream;
	        res += "\nendstream\n";
	      }
	      res += "endobj\n";
	      return res;
	    };

	    AcroFormPDFObject.prototype.getContent = function () {
	      /**
	      * Prints out all enumerable Variables from the Object
	      * 
	      * @param fieldObject
	      * @returns {string}
	      */
	      var createContentFromFieldObject = function createContentFromFieldObject(fieldObject) {
	        var content = '';

	        var keys = Object.keys(fieldObject).filter(function (key) {
	          return key != 'content' && key != 'appearanceStreamContent' && key.substring(0, 1) != "_";
	        });

	        for (var i in keys) {
	          var key = keys[i];
	          var value = fieldObject[key];

	          /*
	          * if (key == 'Rect' && value) { value =
	          * AcroForm.internal.calculateCoordinates.call(jsPDF.API.acroformPlugin.internal,
	          * value); }
	          */

	          if (value) {
	            if (Array.isArray(value)) {
	              content += '/' + key + ' ' + arrayToPdfArray(value) + "\n";
	            } else if (value instanceof AcroFormPDFObject) {
	              // In case it is a reference to another PDFObject,
	              // take the referennce number
	              content += '/' + key + ' ' + value.objId + " 0 R" + "\n";
	            } else {
	              content += '/' + key + ' ' + value + '\n';
	            }
	          }
	        }
	        return content;
	      };

	      var object = "";

	      object += createContentFromFieldObject(this);
	      return object;
	    };

	    var AcroFormXObject = function AcroFormXObject() {
	      AcroFormPDFObject.call(this);
	      this.Type = "/XObject";
	      this.Subtype = "/Form";
	      this.FormType = 1;
	      this.BBox;
	      this.Matrix;
	      this.Resources = "2 0 R";
	      this.PieceInfo;
	      var _stream;
	      Object.defineProperty(this, 'Length', {
	        enumerable: true,
	        get: function get$$1() {
	          return _stream !== undefined ? _stream.length : 0;
	        }
	      });
	      Object.defineProperty(this, 'stream', {
	        enumerable: false,
	        set: function set$$1(val) {
	          _stream = val.trim();
	        },
	        get: function get$$1() {
	          if (_stream) {
	            return _stream;
	          } else {
	            return null;
	          }
	        }
	      });
	    };

	    inherit(AcroFormXObject, AcroFormPDFObject);
	    // ##### The Objects, the User can Create:

	    var AcroFormDictionary = function AcroFormDictionary() {
	      AcroFormPDFObject.call(this);
	      var _Kids = [];
	      Object.defineProperty(this, 'Kids', {
	        enumerable: false,
	        configurable: true,
	        get: function get$$1() {
	          if (_Kids.length > 0) {
	            return _Kids;
	          } else {
	            return;
	          }
	        }
	      });
	      Object.defineProperty(this, 'Fields', {
	        enumerable: true,
	        configurable: true,
	        get: function get$$1() {
	          return _Kids;
	        }
	      });
	      // Default Appearance
	      this.DA;
	    };

	    inherit(AcroFormDictionary, AcroFormPDFObject);

	    // The Field Object contains the Variables, that every Field needs
	    // Rectangle for Appearance: lower_left_X, lower_left_Y, width, height
	    var AcroFormField = function AcroFormField() {

	      AcroFormPDFObject.call(this);

	      var _Rect;
	      Object.defineProperty(this, 'Rect', {
	        enumerable: true,
	        configurable: false,
	        get: function get$$1() {
	          if (!_Rect) {
	            return;
	          }
	          var tmp = _Rect;
	          // var calculatedRes =
	          // AcroForm.internal.calculateCoordinates(_Rect); // do
	          // later!
	          return tmp;
	        },
	        set: function set$$1(val) {
	          _Rect = val;
	        }
	      });

	      var _FT = "";
	      Object.defineProperty(this, 'FT', {
	        enumerable: true,
	        set: function set$$1(val) {
	          _FT = val;
	        },
	        get: function get$$1() {
	          return _FT;
	        }
	      });
	      /**
	      * The Partial name of the Field Object. It has to be unique.
	      */
	      var _T;

	      Object.defineProperty(this, 'T', {
	        enumerable: true,
	        configurable: false,
	        set: function set$$1(val) {
	          _T = val;
	        },
	        get: function get$$1() {
	          if (!_T || _T.length < 1) {
	            if (this instanceof AcroFormChildClass) {
	              // In case of a Child from a Radio´Group, you don't
	              // need a FieldName!!!
	              return;
	            }
	            return "(FieldObject" + AcroFormField.FieldNum++ + ")";
	          }
	          if (_T.substring(0, 1) == "(" && _T.substring(_T.length - 1)) {
	            return _T;
	          }
	          return "(" + _T + ")";
	        }
	      });

	      var _DA;
	      // Defines the default appearance (Needed for variable Text)
	      Object.defineProperty(this, 'DA', {
	        enumerable: true,
	        get: function get$$1() {
	          if (!_DA) {
	            return;
	          }
	          return '(' + _DA + ')';
	        },
	        set: function set$$1(val) {
	          _DA = val;
	        }
	      });

	      var _DV;
	      // Defines the default value
	      Object.defineProperty(this, 'DV', {
	        enumerable: true,
	        configurable: true,
	        get: function get$$1() {
	          if (!_DV) {
	            return;
	          }
	          return _DV;
	        },
	        set: function set$$1(val) {
	          _DV = val;
	        }
	      });

	      var _V;
	      // Defines the default value
	      Object.defineProperty(this, 'V', {
	        enumerable: true,
	        configurable: true,
	        get: function get$$1() {
	          if (!_V) {
	            return;
	          }
	          return _V;
	        },
	        set: function set$$1(val) {
	          _V = val;
	        }
	      });

	      // this.Type = "/Annot";
	      // this.Subtype = "/Widget";
	      Object.defineProperty(this, 'Type', {
	        enumerable: true,
	        get: function get$$1() {
	          return this.hasAnnotation ? "/Annot" : null;
	        }
	      });

	      Object.defineProperty(this, 'Subtype', {
	        enumerable: true,
	        get: function get$$1() {
	          return this.hasAnnotation ? "/Widget" : null;
	        }
	      });

	      /**
	      * 
	      * @type {Array}
	      */
	      this.BG;

	      Object.defineProperty(this, 'hasAnnotation', {
	        enumerable: false,
	        get: function get$$1() {
	          if (this.Rect || this.BC || this.BG) {
	            return true;
	          }
	          return false;
	        }
	      });

	      Object.defineProperty(this, 'hasAppearanceStream', {
	        enumerable: false,
	        configurable: true,
	        writable: true
	      });

	      Object.defineProperty(this, 'page', {
	        enumerable: false,
	        configurable: true,
	        writable: true
	      });
	    };

	    inherit(AcroFormField, AcroFormPDFObject);

	    var AcroFormChoiceField = function AcroFormChoiceField() {
	      AcroFormField.call(this);
	      // Field Type = Choice Field
	      this.FT = "/Ch";
	      // options
	      this.Opt = [];
	      this.V = '()';
	      // Top Index
	      this.TI = 0;
	      /**
	      * Defines, whether the
	      * 
	      * @type {boolean}
	      */

	      var _combo = false;

	      Object.defineProperty(this, 'combo', {
	        enumerable: false,
	        get: function get$$1() {
	          return _combo;
	        },
	        set: function set$$1(val) {
	          _combo = val;
	        }
	      });
	      /**
	      * Defines, whether the Choice Field is an Edit Field. An Edit Field
	      * is automatically an Combo Field.
	      */
	      Object.defineProperty(this, 'edit', {
	        enumerable: true,
	        set: function set$$1(val) {
	          if (val == true) {
	            this._edit = true;
	            // ComboBox has to be true
	            this.combo = true;
	          } else {
	            this._edit = false;
	          }
	        },
	        get: function get$$1() {
	          if (!this._edit) {
	            return false;
	          }
	          return this._edit;
	        },
	        configurable: false
	      });
	      this.hasAppearanceStream = true;
	    };
	    inherit(AcroFormChoiceField, AcroFormField);

	    var AcroFormListBox = function AcroFormListBox() {
	      AcroFormChoiceField.call(this);
	      this.combo = false;
	    };
	    inherit(AcroFormListBox, AcroFormChoiceField);

	    var AcroFormComboBox = function AcroFormComboBox() {
	      AcroFormListBox.call(this);
	      this.combo = true;
	    };
	    inherit(AcroFormComboBox, AcroFormListBox);

	    var AcroFormEditBox = function AcroFormEditBox() {
	      AcroFormComboBox.call(this);
	      this.edit = true;
	    };
	    inherit(AcroFormEditBox, AcroFormComboBox);

	    var AcroFormButton = function AcroFormButton() {
	      AcroFormField.call(this);
	      this.FT = "/Btn";
	      // this.hasAnnotation = true;
	    };
	    inherit(AcroFormButton, AcroFormField);

	    var AcroFormPushButton = function AcroFormPushButton() {
	      AcroFormButton.call(this);

	      var _pushbutton = true;
	      Object.defineProperty(this, 'pushbutton', {
	        enumerable: false,
	        get: function get$$1() {
	          return _pushbutton;
	        },
	        set: function set$$1(val) {
	          _pushbutton = val;
	        }
	      });
	    };
	    inherit(AcroFormPushButton, AcroFormButton);

	    var AcroFormRadioButton = function AcroFormRadioButton() {
	      AcroFormButton.call(this);

	      var _radio = true;
	      Object.defineProperty(this, 'radio', {
	        enumerable: false,
	        get: function get$$1() {
	          return _radio;
	        },
	        set: function set$$1(val) {
	          _radio = val;
	        }
	      });

	      var _Kids = [];
	      Object.defineProperty(this, 'Kids', {
	        enumerable: true,
	        get: function get$$1() {
	          if (_Kids.length > 0) {
	            return _Kids;
	          }
	        }
	      });

	      Object.defineProperty(this, '__Kids', {
	        get: function get$$1() {
	          return _Kids;
	        }
	      });

	      var _noToggleToOff;

	      Object.defineProperty(this, 'noToggleToOff', {
	        enumerable: false,
	        get: function get$$1() {
	          return _noToggleToOff;
	        },
	        set: function set$$1(val) {
	          _noToggleToOff = val;
	        }
	      });

	      // this.hasAnnotation = false;
	    };
	    inherit(AcroFormRadioButton, AcroFormButton);

	    /*
	    * The Child classs of a RadioButton (the radioGroup) -> The single
	    * Buttons
	    */
	    var AcroFormChildClass = function AcroFormChildClass(parent, name) {
	      AcroFormField.call(this);
	      this.Parent = parent;

	      // todo: set AppearanceType as variable that can be set from the
	      // outside...
	      this._AppearanceType = AcroFormAppearance.RadioButton.Circle;
	      // The Default appearanceType is the Circle
	      this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(name);

	      // Set Print in the Annot Flag
	      this.F = setBitPosition(this.F, 3, 1);

	      // Set AppearanceCharacteristicsDictionary with default appearance
	      // if field is not interacting with user
	      this.MK = this._AppearanceType.createMK();
	      // (8) -> Cross, (1)->  Circle, ()-> nothing

	      // Default Appearance is Off
	      this.AS = "/Off"; // + name;

	      this._Name = name;
	    };
	    inherit(AcroFormChildClass, AcroFormField);

	    AcroFormRadioButton.prototype.setAppearance = function (appearance) {
	      if (!('createAppearanceStream' in appearance && 'createMK' in appearance)) {
	        console.log("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
	        return;
	      }
	      for (var i in this.__Kids) {
	        var child = this.__Kids[i];

	        child.appearanceStreamContent = appearance.createAppearanceStream(child._Name);
	        child.MK = appearance.createMK();
	      }
	    };

	    AcroFormRadioButton.prototype.createOption = function (name) {
	      var parent = this;
	      var kidCount = this.__Kids.length;

	      // Create new Child for RadioGroup
	      var child = new AcroFormChildClass(parent, name);
	      // Add to Parent
	      this.__Kids.push(child);

	      jsPDFAPI.addField(child);

	      return child;
	    };

	    var AcroFormCheckBox = function AcroFormCheckBox() {
	      AcroFormButton.call(this);
	      this.appearanceStreamContent = AcroFormAppearance.CheckBox.createAppearanceStream();
	      this.MK = AcroFormAppearance.CheckBox.createMK();
	      this.AS = "/On";
	      this.V = "/On";
	    };
	    inherit(AcroFormCheckBox, AcroFormButton);

	    var AcroFormTextField = function AcroFormTextField() {
	      AcroFormField.call(this);
	      this.DA = AcroFormAppearance.createDefaultAppearanceStream();
	      this.F = 4;
	      var _V;
	      Object.defineProperty(this, 'V', {
	        get: function get$$1() {
	          if (_V) {
	            return toPdfString(_V);
	          } else {
	            return _V;
	          }
	        },
	        enumerable: true,
	        set: function set$$1(val) {
	          _V = val;
	        }
	      });

	      var _DV;
	      Object.defineProperty(this, 'DV', {
	        get: function get$$1() {
	          if (_DV) {
	            return toPdfString(_DV);
	          } else {
	            return _DV;
	          }
	        },
	        enumerable: true,
	        set: function set$$1(val) {
	          _DV = val;
	        }
	      });

	      var _multiline = false;
	      Object.defineProperty(this, 'multiline', {
	        enumerable: false,
	        get: function get$$1() {
	          return _multiline;
	        },
	        set: function set$$1(val) {
	          _multiline = val;
	        }
	      });

	      /**
	      * For PDF 1.4
	      * 
	      * @type {boolean}
	      */
	      var _fileSelect = false;
	      Object.defineProperty(this, 'fileSelect', {
	        enumerable: false,
	        get: function get$$1() {
	          return _fileSelect;
	        },
	        set: function set$$1(val) {
	          _fileSelect = val;
	        }
	      });
	      /**
	      * For PDF 1.4
	      * 
	      * @type {boolean}
	      */
	      var _doNotSpellCheck = false;
	      Object.defineProperty(this, 'doNotSpellCheck', {
	        enumerable: false,
	        get: function get$$1() {
	          return _doNotSpellCheck;
	        },
	        set: function set$$1(val) {
	          _doNotSpellCheck = val;
	        }
	      });
	      /**
	      * For PDF 1.4
	      * 
	      * @type {boolean}
	      */
	      var _doNotScroll = false;
	      Object.defineProperty(this, 'doNotScroll', {
	        enumerable: false,
	        get: function get$$1() {
	          return _doNotScroll;
	        },
	        set: function set$$1(val) {
	          _doNotScroll = val;
	        }
	      });

	      var _MaxLen = false;
	      Object.defineProperty(this, 'MaxLen', {
	        enumerable: true,
	        get: function get$$1() {
	          return _MaxLen;
	        },
	        set: function set$$1(val) {
	          _MaxLen = val;
	        }
	      });

	      Object.defineProperty(this, 'hasAppearanceStream', {
	        enumerable: false,
	        get: function get$$1() {
	          return this.V || this.DV;
	        }
	      });
	    };
	    inherit(AcroFormTextField, AcroFormField);

	    var AcroFormPasswordField = function AcroFormPasswordField() {
	      AcroFormTextField.call(this);

	      var _password = true;
	      Object.defineProperty(this, 'password', {
	        enumerable: false,
	        get: function get$$1() {
	          return _password;
	        },
	        set: function set$$1(val) {
	          _password = val;
	        }
	      });
	    };
	    inherit(AcroFormPasswordField, AcroFormTextField);

	    // Contains Methods for creating standard appearances
	    var AcroFormAppearance = {
	      CheckBox: {
	        createAppearanceStream: function createAppearanceStream() {
	          var appearance = {
	            N: {
	              On: AcroFormAppearance.CheckBox.YesNormal
	            },
	            D: {
	              On: AcroFormAppearance.CheckBox.YesPushDown,
	              Off: AcroFormAppearance.CheckBox.OffPushDown
	            }
	          };

	          return appearance;
	        },
	        /**
	          * If any other icons are needed, the number between the
	          * brackets can be changed
	          * 
	          * @returns {string}
	          */
	        createMK: function createMK() {
	          return "<< /CA (3)>>";
	        },
	        /**
	          * Returns the standard On Appearance for a CheckBox
	          * 
	          * @returns {AcroFormXObject}
	          */
	        YesPushDown: function YesPushDown(formObject) {
	          var xobj = createFormXObject(formObject);
	          var stream = [];
	          var zapfDingbatsId = scope.internal.getFont("zapfdingbats", "normal").id;
	          formObject.Q = 1; // set text-alignment as centered
	          var calcRes = calculateX(formObject, "3", "ZapfDingbats", 50);
	          stream.push("0.749023 g");
	          stream.push("0 0 " + AcroFormAppearance.internal.getWidth(formObject).toFixed(2) + " " + AcroFormAppearance.internal.getHeight(formObject).toFixed(2) + " re");
	          stream.push("f");
	          stream.push("BMC");
	          stream.push("q");
	          stream.push("0 0 1 rg");
	          stream.push("/" + zapfDingbatsId + " " + calcRes.fontSize.toFixed(2) + " Tf 0 g");
	          stream.push("BT");
	          stream.push(calcRes.text);
	          stream.push("ET");
	          stream.push("Q");
	          stream.push("EMC");
	          xobj.stream = stream.join("\n");
	          return xobj;
	        },

	        YesNormal: function YesNormal(formObject) {
	          var xobj = createFormXObject(formObject);
	          var zapfDingbatsId = scope.internal.getFont("zapfdingbats", "normal").id;
	          var stream = [];
	          formObject.Q = 1; // set text-alignment as centered
	          var height = AcroFormAppearance.internal.getHeight(formObject);
	          var width = AcroFormAppearance.internal.getWidth(formObject);
	          var calcRes = calculateX(formObject, "3", "ZapfDingbats", height * 0.9);
	          stream.push("1 g");
	          stream.push("0 0 " + width.toFixed(2) + " " + height.toFixed(2) + " re");
	          stream.push("f");
	          stream.push("q");
	          stream.push("0 0 1 rg");
	          stream.push("0 0 " + (width - 1).toFixed(2) + " " + (height - 1).toFixed(2) + " re");
	          stream.push("W");
	          stream.push("n");
	          stream.push("0 g");
	          stream.push("BT");
	          stream.push("/" + zapfDingbatsId + " " + calcRes.fontSize.toFixed(2) + " Tf 0 g");
	          stream.push(calcRes.text);
	          stream.push("ET");
	          stream.push("Q");
	          xobj.stream = stream.join("\n");
	          return xobj;
	        },

	        /**
	          * Returns the standard Off Appearance for a CheckBox
	          * 
	          * @returns {AcroFormXObject}
	          */
	        OffPushDown: function OffPushDown(formObject) {
	          var xobj = createFormXObject(formObject);
	          var stream = [];
	          stream.push("0.749023 g");
	          stream.push("0 0 " + AcroFormAppearance.internal.getWidth(formObject).toFixed(2) + " " + AcroFormAppearance.internal.getHeight(formObject).toFixed(2) + " re");
	          stream.push("f");
	          xobj.stream = stream.join("\n");
	          return xobj;
	        }
	      },

	      RadioButton: {
	        Circle: {
	          createAppearanceStream: function createAppearanceStream(name) {
	            var appearanceStreamContent = {
	              D: {
	                'Off': AcroFormAppearance.RadioButton.Circle.OffPushDown
	              },
	              N: {}
	            };
	            appearanceStreamContent.N[name] = AcroFormAppearance.RadioButton.Circle.YesNormal;
	            appearanceStreamContent.D[name] = AcroFormAppearance.RadioButton.Circle.YesPushDown;
	            return appearanceStreamContent;
	          },
	          createMK: function createMK() {
	            return "<< /CA (l)>>";
	          },

	          YesNormal: function YesNormal(formObject) {
	            var xobj = createFormXObject(formObject);
	            var stream = [];
	            // Make the Radius of the Circle relative to min(height,
	            // width) of formObject
	            var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4;
	            // The Borderpadding...
	            DotRadius *= 0.9;
	            var c = AcroFormAppearance.internal.Bezier_C;
	            /*
	              * The Following is a Circle created with Bezier-Curves.
	              */
	            stream.push("q");
	            stream.push("1 0 0 1 " + AcroFormAppearance.internal.getWidth(formObject) / 2 + " " + AcroFormAppearance.internal.getHeight(formObject) / 2 + " cm");
	            stream.push(DotRadius + " 0 m");
	            stream.push(DotRadius + " " + DotRadius * c + " " + DotRadius * c + " " + DotRadius + " 0 " + DotRadius + " c");
	            stream.push("-" + DotRadius * c + " " + DotRadius + " -" + DotRadius + " " + DotRadius * c + " -" + DotRadius + " 0 c");
	            stream.push("-" + DotRadius + " -" + DotRadius * c + " -" + DotRadius * c + " -" + DotRadius + " 0 -" + DotRadius + " c");
	            stream.push(DotRadius * c + " -" + DotRadius + " " + DotRadius + " -" + DotRadius * c + " " + DotRadius + " 0 c");
	            stream.push("f");
	            stream.push("Q");
	            xobj.stream = stream.join("\n");
	            return xobj;
	          },
	          YesPushDown: function YesPushDown(formObject) {
	            var xobj = createFormXObject(formObject);
	            var stream = [];
	            var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4;
	            // The Borderpadding...
	            DotRadius *= 0.9;
	            // Save results for later use; no need to waste
	            // processor ticks on doing math
	            var k = DotRadius * 2;
	            // var c = AcroFormAppearance.internal.Bezier_C;
	            var kc = k * AcroFormAppearance.internal.Bezier_C;
	            var dc = DotRadius * AcroFormAppearance.internal.Bezier_C;

	            stream.push("0.749023 g");
	            stream.push("q");
	            stream.push("1 0 0 1 " + (AcroFormAppearance.internal.getWidth(formObject) / 2).toFixed(2) + " " + (AcroFormAppearance.internal.getHeight(formObject) / 2).toFixed(2) + " cm");
	            stream.push(k + " 0 m");
	            stream.push(k + " " + kc + " " + kc + " " + k + " 0 " + k + " c");
	            stream.push("-" + kc + " " + k + " -" + k + " " + kc + " -" + k + " 0 c");
	            stream.push("-" + k + " -" + kc + " -" + kc + " -" + k + " 0 -" + k + " c");
	            stream.push(kc + " -" + k + " " + k + " -" + kc + " " + k + " 0 c");
	            stream.push("f");
	            stream.push("Q");
	            stream.push("0 g");
	            stream.push("q");
	            stream.push("1 0 0 1 " + (AcroFormAppearance.internal.getWidth(formObject) / 2).toFixed(2) + " " + (AcroFormAppearance.internal.getHeight(formObject) / 2).toFixed(2) + " cm");
	            stream.push(DotRadius + " 0 m");
	            stream.push("" + DotRadius + " " + dc + " " + dc + " " + DotRadius + " 0 " + DotRadius + " c");
	            stream.push("-" + dc + " " + DotRadius + " -" + DotRadius + " " + dc + " -" + DotRadius + " 0 c");
	            stream.push("-" + DotRadius + " -" + dc + " -" + dc + " -" + DotRadius + " 0 -" + DotRadius + " c");
	            stream.push(dc + " -" + DotRadius + " " + DotRadius + " -" + dc + " " + DotRadius + " 0 c");
	            stream.push("f");
	            stream.push("Q");
	            xobj.stream = stream.join("\n");
	            return xobj;
	          },
	          OffPushDown: function OffPushDown(formObject) {
	            var xobj = createFormXObject(formObject);
	            var stream = [];
	            var DotRadius = AcroFormAppearance.internal.getWidth(formObject) <= AcroFormAppearance.internal.getHeight(formObject) ? AcroFormAppearance.internal.getWidth(formObject) / 4 : AcroFormAppearance.internal.getHeight(formObject) / 4;
	            // The Borderpadding...
	            DotRadius *= 0.9;
	            // Save results for later use; no need to waste
	            // processor ticks on doing math
	            var k = DotRadius * 2;
	            // var c = AcroFormAppearance.internal.Bezier_C;
	            var kc = k * AcroFormAppearance.internal.Bezier_C;

	            stream.push("0.749023 g");
	            stream.push("q");
	            stream.push("1 0 0 1 " + (AcroFormAppearance.internal.getWidth(formObject) / 2).toFixed(2) + " " + (AcroFormAppearance.internal.getHeight(formObject) / 2).toFixed(2) + " cm");
	            stream.push(k + " 0 m");
	            stream.push(k + " " + kc + " " + kc + " " + k + " 0 " + k + " c");
	            stream.push("-" + kc + " " + k + " -" + k + " " + kc + " -" + k + " 0 c");
	            stream.push("-" + k + " -" + kc + " -" + kc + " -" + k + " 0 -" + k + " c");
	            stream.push(kc + " -" + k + " " + k + " -" + kc + " " + k + " 0 c");
	            stream.push("f");
	            stream.push("Q");
	            xobj.stream = stream.join("\n");
	            return xobj;
	          }
	        },

	        Cross: {
	          /**
	            * Creates the Actual AppearanceDictionary-References
	            * 
	            * @param name
	            * @returns
	            */
	          createAppearanceStream: function createAppearanceStream(name) {
	            var appearanceStreamContent = {
	              D: {
	                'Off': AcroFormAppearance.RadioButton.Cross.OffPushDown
	              },
	              N: {}
	            };
	            appearanceStreamContent.N[name] = AcroFormAppearance.RadioButton.Cross.YesNormal;
	            appearanceStreamContent.D[name] = AcroFormAppearance.RadioButton.Cross.YesPushDown;
	            return appearanceStreamContent;
	          },
	          createMK: function createMK() {
	            return "<< /CA (8)>>";
	          },

	          YesNormal: function YesNormal(formObject) {
	            var xobj = createFormXObject(formObject);
	            var stream = [];
	            var cross = AcroFormAppearance.internal.calculateCross(formObject);
	            stream.push("q");
	            stream.push("1 1 " + (AcroFormAppearance.internal.getWidth(formObject) - 2).toFixed(2) + " " + (AcroFormAppearance.internal.getHeight(formObject) - 2).toFixed(2) + " re");
	            stream.push("W");
	            stream.push("n");
	            stream.push(cross.x1.x.toFixed(2) + " " + cross.x1.y.toFixed(2) + " m");
	            stream.push(cross.x2.x.toFixed(2) + " " + cross.x2.y.toFixed(2) + " l");
	            stream.push(cross.x4.x.toFixed(2) + " " + cross.x4.y.toFixed(2) + " m");
	            stream.push(cross.x3.x.toFixed(2) + " " + cross.x3.y.toFixed(2) + " l");
	            stream.push("s");
	            stream.push("Q");
	            xobj.stream = stream.join("\n");
	            return xobj;
	          },
	          YesPushDown: function YesPushDown(formObject) {
	            var xobj = createFormXObject(formObject);
	            var cross = AcroFormAppearance.internal.calculateCross(formObject);
	            var stream = [];
	            stream.push("0.749023 g");
	            stream.push("0 0 " + AcroFormAppearance.internal.getWidth(formObject).toFixed(2) + " " + AcroFormAppearance.internal.getHeight(formObject).toFixed(2) + " re");
	            stream.push("f");
	            stream.push("q");
	            stream.push("1 1 " + (AcroFormAppearance.internal.getWidth(formObject) - 2).toFixed(2) + " " + (AcroFormAppearance.internal.getHeight(formObject) - 2).toFixed(2) + " re");
	            stream.push("W");
	            stream.push("n");
	            stream.push(cross.x1.x.toFixed(2) + " " + cross.x1.y.toFixed(2) + " m");
	            stream.push(cross.x2.x.toFixed(2) + " " + cross.x2.y.toFixed(2) + " l");
	            stream.push(cross.x4.x.toFixed(2) + " " + cross.x4.y.toFixed(2) + " m");
	            stream.push(cross.x3.x.toFixed(2) + " " + cross.x3.y.toFixed(2) + " l");
	            stream.push("s");
	            stream.push("Q");
	            xobj.stream = stream.join("\n");
	            return xobj;
	          },
	          OffPushDown: function OffPushDown(formObject) {
	            var xobj = createFormXObject(formObject);
	            var stream = [];
	            stream.push("0.749023 g");
	            stream.push("0 0 " + AcroFormAppearance.internal.getWidth(formObject).toFixed(2) + " " + AcroFormAppearance.internal.getHeight(formObject).toFixed(2) + " re");
	            stream.push("f");
	            xobj.stream = stream.join("\n");
	            return xobj;
	          }
	        }
	      },

	      /**
	        * Returns the standard Appearance
	        * 
	        * @returns {AcroFormXObject}
	        */
	      createDefaultAppearanceStream: function createDefaultAppearanceStream(formObject) {
	        // Set Helvetica to Standard Font (size: auto)
	        // Color: Black
	        return "/F1 0 Tf 0 g";
	      }
	    };

	    AcroFormAppearance.internal = {
	      Bezier_C: 0.551915024494,

	      calculateCross: function calculateCross(formObject) {
	        var min = function min(x, y) {
	          return x > y ? y : x;
	        };

	        var width = AcroFormAppearance.internal.getWidth(formObject);
	        var height = AcroFormAppearance.internal.getHeight(formObject);
	        var a = min(width, height);


	        var cross = {
	          x1: { // upperLeft
	            x: (width - a) / 2,
	            y: (height - a) / 2 + a // height - borderPadding
	          },
	          x2: { // lowerRight
	            x: (width - a) / 2 + a,
	            y: (height - a) / 2 // borderPadding
	          },
	          x3: { // lowerLeft
	            x: (width - a) / 2,
	            y: (height - a) / 2 // borderPadding
	          },
	          x4: { // upperRight
	            x: (width - a) / 2 + a,
	            y: (height - a) / 2 + a // height - borderPadding
	          }
	        };

	        return cross;
	      }
	    };
	    AcroFormAppearance.internal.getWidth = function (formObject) {
	      var result = 0;
	      if ((typeof formObject === 'undefined' ? 'undefined' : _typeof(formObject)) === "object") {
	        result = scale(formObject.Rect[2]); // (formObject.Rect[2] -
	        // formObject.Rect[0]) || 0;
	      }
	      return result;
	    };
	    AcroFormAppearance.internal.getHeight = function (formObject) {
	      var result = 0;
	      if ((typeof formObject === 'undefined' ? 'undefined' : _typeof(formObject)) === "object") {
	        result = scale(formObject.Rect[3]); // (formObject.Rect[1] -
	        // formObject.Rect[3]) || 0;
	      }
	      return result;
	    };

	    // Public:

	    jsPDFAPI.addField = function (fieldObject) {
	      initializeAcroForm.call(this);
	      // var opt = parseOptions(fieldObject);
	      if (fieldObject instanceof AcroFormTextField) {
	        this.addTextField.call(this, fieldObject);
	      } else if (fieldObject instanceof AcroFormChoiceField) {
	        this.addChoiceField.call(this, fieldObject);
	      } else if (fieldObject instanceof AcroFormButton) {
	        this.addButton.call(this, fieldObject);
	      } else if (fieldObject instanceof AcroFormChildClass) {
	        putForm.call(this, fieldObject);
	      } else if (fieldObject) {
	        // try to put..
	        putForm.call(this, fieldObject);
	      }
	      fieldObject.page = scope.internal.getCurrentPageInfo().pageNumber;
	      return this;
	    };

	    /**
	    * Button FT = Btn
	    */
	    jsPDFAPI.addButton = function (opts) {
	      initializeAcroForm.call(this);
	      var options = opts || new AcroFormField();

	      options.FT = '/Btn';
	      options.Ff = calculateFlagsOnOptions(options.Ff, opts, scope.internal.getPDFVersion());

	      putForm.call(this, options);
	    };

	    jsPDFAPI.addTextField = function (opts) {
	      initializeAcroForm.call(this);
	      var options = opts || new AcroFormField();

	      options.FT = '/Tx';

	      options.Ff = calculateFlagsOnOptions(options.Ff, opts, scope.internal.getPDFVersion());

	      // Add field
	      putForm.call(this, options);
	    };

	    jsPDFAPI.addChoiceField = function (opts) {
	      initializeAcroForm.call(this);
	      var options = opts || new AcroFormField();

	      options.FT = '/Ch';

	      options.Ff = calculateFlagsOnOptions(options.Ff, opts, scope.internal.getPDFVersion());
	      // options.hasAnnotation = true;

	      // Add field
	      putForm.call(this, options);
	    };

	    if ((typeof globalObj === 'undefined' ? 'undefined' : _typeof(globalObj)) == "object") {
	      globalObj["ChoiceField"] = AcroFormChoiceField;
	      globalObj["ListBox"] = AcroFormListBox;
	      globalObj["ComboBox"] = AcroFormComboBox;
	      globalObj["EditBox"] = AcroFormEditBox;
	      globalObj["Button"] = AcroFormButton;
	      globalObj["PushButton"] = AcroFormPushButton;
	      globalObj["RadioButton"] = AcroFormRadioButton;
	      globalObj["CheckBox"] = AcroFormCheckBox;
	      globalObj["TextField"] = AcroFormTextField;
	      globalObj["PasswordField"] = AcroFormPasswordField;

	      // backwardsCompatibility
	      globalObj["AcroForm"] = { Appearance: AcroFormAppearance };
	    }

	    jsPDFAPI.AcroFormChoiceField = AcroFormChoiceField;
	    jsPDFAPI.AcroFormListBox = AcroFormListBox;
	    jsPDFAPI.AcroFormComboBox = AcroFormComboBox;
	    jsPDFAPI.AcroFormEditBox = AcroFormEditBox;
	    jsPDFAPI.AcroFormButton = AcroFormButton;
	    jsPDFAPI.AcroFormPushButton = AcroFormPushButton;
	    jsPDFAPI.AcroFormRadioButton = AcroFormRadioButton;
	    jsPDFAPI.AcroFormCheckBox = AcroFormCheckBox;
	    jsPDFAPI.AcroFormTextField = AcroFormTextField;
	    jsPDFAPI.AcroFormPasswordField = AcroFormPasswordField;

	    jsPDFAPI.AcroForm = {
	      ChoiceField: AcroFormChoiceField,
	      ListBox: AcroFormListBox,
	      ComboBox: AcroFormComboBox,
	      EditBox: AcroFormEditBox,
	      Button: AcroFormButton,
	      PushButton: AcroFormPushButton,
	      RadioButton: AcroFormRadioButton,
	      CheckBox: AcroFormCheckBox,
	      TextField: AcroFormTextField,
	      PasswordField: AcroFormPasswordField
	    };
	  })(jsPDF.API, typeof window !== "undefined" && window || typeof global !== "undefined" && global);

	  /**
	   * jsPDF addHTML PlugIn
	   * Copyright (c) 2014 Diego Casorran
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  (function (jsPDFAPI) {

	      /**
	       * Renders an HTML element to canvas object which added to the PDF
	       *
	       * This feature requires [html2canvas](https://github.com/niklasvh/html2canvas)
	       * or [rasterizeHTML](https://github.com/cburgmer/rasterizeHTML.js)
	       *
	       * @returns {jsPDF}
	       * @name addHTML
	       * @param element {Mixed} HTML Element, or anything supported by html2canvas.
	       * @param x {Number} starting X coordinate in jsPDF instance's declared units.
	       * @param y {Number} starting Y coordinate in jsPDF instance's declared units.
	       * @param options {Object} Additional options, check the code below.
	       * @param callback {Function} to call when the rendering has finished.
	       * NOTE: Every parameter is optional except 'element' and 'callback', in such
	       *       case the image is positioned at 0x0 covering the whole PDF document
	       *       size. Ie, to easily take screenshots of webpages saving them to PDF.
	       * @deprecated This is being replace with a vector-supporting API. See
	       * [this link](https://cdn.rawgit.com/MrRio/jsPDF/master/examples/html2pdf/showcase_supported_html.html)
	       */

	      jsPDFAPI.addHTML = function (element, x, y, options, callback) {

	          if (typeof html2canvas === 'undefined' && typeof rasterizeHTML === 'undefined') throw new Error('You need either ' + 'https://github.com/niklasvh/html2canvas' + ' or https://github.com/cburgmer/rasterizeHTML.js');

	          if (typeof x !== 'number') {
	              options = x;
	              callback = y;
	          }

	          if (typeof options === 'function') {
	              callback = options;
	              options = null;
	          }

	          if (typeof callback !== 'function') {
	              callback = function callback() {};
	          }

	          var I = this.internal,
	              K = I.scaleFactor,
	              W = I.pageSize.getWidth(),
	              H = I.pageSize.getHeight();

	          options = options || {};
	          options.onrendered = function (obj) {
	              x = parseInt(x) || 0;
	              y = parseInt(y) || 0;
	              var dim = options.dim || {};
	              var margin = Object.assign({ top: 0, right: 0, bottom: 0, left: 0, useFor: 'content' }, options.margin);
	              var h = dim.h || Math.min(H, obj.height / K);
	              var w = dim.w || Math.min(W, obj.width / K) - x;

	              var format = options.format || 'JPEG';
	              var imageCompression = options.imageCompression || 'SLOW';

	              var notFittingHeight = obj.height > H - margin.top - margin.bottom;

	              if (notFittingHeight && options.pagesplit) {
	                  var cropArea = function cropArea(parmObj, parmX, parmY, parmWidth, parmHeight) {
	                      var canvas = document.createElement('canvas');
	                      canvas.height = parmHeight;
	                      canvas.width = parmWidth;
	                      var ctx = canvas.getContext('2d');
	                      ctx.mozImageSmoothingEnabled = false;
	                      ctx.webkitImageSmoothingEnabled = false;
	                      ctx.msImageSmoothingEnabled = false;
	                      ctx.imageSmoothingEnabled = false;
	                      ctx.fillStyle = options.backgroundColor || '#ffffff';
	                      ctx.fillRect(0, 0, parmWidth, parmHeight);
	                      ctx.drawImage(parmObj, parmX, parmY, parmWidth, parmHeight, 0, 0, parmWidth, parmHeight);
	                      return canvas;
	                  };
	                  var crop = function () {
	                      var cy = 0;
	                      var cx = 0;
	                      var position = {};
	                      var isOverWide = false;
	                      var width;
	                      var height;
	                      while (1) {
	                          cx = 0;
	                          position.top = cy !== 0 ? margin.top : y;
	                          position.left = cy !== 0 ? margin.left : x;
	                          isOverWide = (W - margin.left - margin.right) * K < obj.width;
	                          if (margin.useFor === "content") {
	                              if (cy === 0) {
	                                  width = Math.min((W - margin.left) * K, obj.width);
	                                  height = Math.min((H - margin.top) * K, obj.height - cy);
	                              } else {
	                                  width = Math.min(W * K, obj.width);
	                                  height = Math.min(H * K, obj.height - cy);
	                                  position.top = 0;
	                              }
	                          } else {
	                              width = Math.min((W - margin.left - margin.right) * K, obj.width);
	                              height = Math.min((H - margin.bottom - margin.top) * K, obj.height - cy);
	                          }
	                          if (isOverWide) {
	                              while (1) {
	                                  if (margin.useFor === "content") {
	                                      if (cx === 0) {
	                                          width = Math.min((W - margin.left) * K, obj.width);
	                                      } else {
	                                          width = Math.min(W * K, obj.width - cx);
	                                          position.left = 0;
	                                      }
	                                  }
	                                  var canvas = cropArea(obj, cx, cy, width, height);
	                                  var args = [canvas, position.left, position.top, canvas.width / K, canvas.height / K, format, null, imageCompression];
	                                  this.addImage.apply(this, args);
	                                  cx += width;
	                                  if (cx >= obj.width) {
	                                      break;
	                                  }
	                                  this.addPage();
	                              }
	                          } else {
	                              var canvas = cropArea(obj, 0, cy, width, height);
	                              var args = [canvas, position.left, position.top, canvas.width / K, canvas.height / K, format, null, imageCompression];
	                              this.addImage.apply(this, args);
	                          }
	                          cy += height;
	                          if (cy >= obj.height) {
	                              break;
	                          }
	                          this.addPage();
	                      }
	                      callback(w, cy, null, args);
	                  }.bind(this);
	                  if (obj.nodeName === 'CANVAS') {
	                      var img = new Image();
	                      img.onload = crop;
	                      img.src = obj.toDataURL("image/png");
	                      obj = img;
	                  } else {
	                      crop();
	                  }
	              } else {
	                  var alias = Math.random().toString(35);
	                  var args = [obj, x, y, w, h, format, alias, imageCompression];

	                  this.addImage.apply(this, args);

	                  callback(w, h, alias, args);
	              }
	          }.bind(this);

	          if (typeof html2canvas !== 'undefined' && !options.rstz) {
	              return html2canvas(element, options);
	          }

	          if (typeof rasterizeHTML !== 'undefined') {
	              var meth = 'drawDocument';
	              if (typeof element === 'string') {
	                  meth = /^http/.test(element) ? 'drawURL' : 'drawHTML';
	              }
	              options.width = options.width || W * K;
	              return rasterizeHTML[meth](element, void 0, options).then(function (r) {
	                  options.onrendered(r.image);
	              }, function (e) {
	                  callback(null, e);
	              });
	          }

	          return null;
	      };
	  })(jsPDF.API);

	  /** @preserve
	   * jsPDF addImage plugin
	   * Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/
	   *               2013 Chris Dowling, https://github.com/gingerchris
	   *               2013 Trinh Ho, https://github.com/ineedfat
	   *               2013 Edwin Alejandro Perez, https://github.com/eaparango
	   *               2013 Norah Smith, https://github.com/burnburnrocket
	   *               2014 Diego Casorran, https://github.com/diegocr
	   *               2014 James Robb, https://github.com/jamesbrobb
	   *
	   * 
	   */
	  (function (jsPDFAPI) {

	  	var namespace = 'addImage_';

	  	var imageFileTypeHeaders = {
	  		PNG: [[0x89, 0x50, 0x4e, 0x47]],
	  		TIFF: [[0x4D, 0x4D, 0x00, 0x2A], //Motorola
	  		[0x49, 0x49, 0x2A, 0x00] //Intel
	  		],
	  		JPEG: [[0xFF, 0xD8, 0xFF, 0xE0, undefined, undefined, 0x4A, 0x46, 0x49, 0x46, 0x00], //JFIF
	  		[0xFF, 0xD8, 0xFF, 0xE1, undefined, undefined, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00] //Exif
	  		],
	  		JPEG2000: [[0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20]],
	  		GIF87a: [[0x47, 0x49, 0x46, 0x38, 0x37, 0x61]],
	  		GIF89a: [[0x47, 0x49, 0x46, 0x38, 0x39, 0x61]],
	  		BMP: [[0x42, 0x4D], //BM - Windows 3.1x, 95, NT, ... etc.
	  		[0x42, 0x41], //BA - OS/2 struct bitmap array
	  		[0x43, 0x49], //CI - OS/2 struct color icon
	  		[0x43, 0x50], //CP - OS/2 const color pointer
	  		[0x49, 0x43], //IC - OS/2 struct icon
	  		[0x50, 0x54] //PT - OS/2 pointer
	  		]
	  		/**
	    * Recognize filetype of Image by magic-bytes
	    * 
	    * https://en.wikipedia.org/wiki/List_of_file_signatures
	    *
	    * @name getImageFileTypeByImageData
	    * @public
	    * @function
	    * @param {String} imageData as base64 encoded DataUrl
	    * @param {String} format of file if filetype-recognition fails, e.g. 'JPEG'
	    * 
	    * @returns {String} filetype of Image
	    * @methodOf jsPDF#
	    */
	  	};jsPDFAPI.getImageFileTypeByImageData = function (imageData, fallbackFormat) {
	  		fallbackFormat = fallbackFormat || 'UNKNOWN';
	  		var i;
	  		var j;
	  		var result = 'UNKNOWN';
	  		var headerSchemata;
	  		var compareResult;
	  		var fileType;

	  		for (fileType in imageFileTypeHeaders) {
	  			headerSchemata = imageFileTypeHeaders[fileType];
	  			for (i = 0; i < headerSchemata.length; i += 1) {
	  				compareResult = true;
	  				for (j = 0; j < headerSchemata[i].length; j += 1) {
	  					if (headerSchemata[i][j] === undefined) {
	  						continue;
	  					}
	  					if (headerSchemata[i][j] !== imageData.charCodeAt(j)) {
	  						compareResult = false;
	  						break;
	  					}
	  				}
	  				if (compareResult === true) {
	  					result = fileType;
	  					break;
	  				}
	  			}
	  		}
	  		if (result === 'UNKOWN' && fallbackFormat !== 'UNKNOWN') {
	  			console.warn('FileType of Image not recognized. Processing image as "' + fallbackFormat + '".');
	  			result = fallbackFormat;
	  		}
	  		return result;
	  	};

	  	// Image functionality ported from pdf.js
	  	var putImage = function putImage(img) {

	  		var objectNumber = this.internal.newObject(),
	  		    out = this.internal.write,
	  		    putStream = this.internal.putStream;

	  		img['n'] = objectNumber;

	  		out('<</Type /XObject');
	  		out('/Subtype /Image');
	  		out('/Width ' + img['w']);
	  		out('/Height ' + img['h']);
	  		if (img['cs'] === this.color_spaces.INDEXED) {
	  			out('/ColorSpace [/Indexed /DeviceRGB '
	  			// if an indexed png defines more than one colour with transparency, we've created a smask
	  			+ (img['pal'].length / 3 - 1) + ' ' + ('smask' in img ? objectNumber + 2 : objectNumber + 1) + ' 0 R]');
	  		} else {
	  			out('/ColorSpace /' + img['cs']);
	  			if (img['cs'] === this.color_spaces.DEVICE_CMYK) {
	  				out('/Decode [1 0 1 0 1 0 1 0]');
	  			}
	  		}
	  		out('/BitsPerComponent ' + img['bpc']);
	  		if ('f' in img) {
	  			out('/Filter /' + img['f']);
	  		}
	  		if ('dp' in img) {
	  			out('/DecodeParms <<' + img['dp'] + '>>');
	  		}
	  		if ('trns' in img && img['trns'].constructor == Array) {
	  			var trns = '',
	  			    i = 0,
	  			    len = img['trns'].length;
	  			for (; i < len; i++) {
	  				trns += img['trns'][i] + ' ' + img['trns'][i] + ' ';
	  			}out('/Mask [' + trns + ']');
	  		}
	  		if ('smask' in img) {
	  			out('/SMask ' + (objectNumber + 1) + ' 0 R');
	  		}
	  		out('/Length ' + img['data'].length + '>>');

	  		putStream(img['data']);

	  		out('endobj');

	  		// Soft mask
	  		if ('smask' in img) {
	  			var dp = '/Predictor ' + img['p'] + ' /Colors 1 /BitsPerComponent ' + img['bpc'] + ' /Columns ' + img['w'];
	  			var smask = { 'w': img['w'], 'h': img['h'], 'cs': 'DeviceGray', 'bpc': img['bpc'], 'dp': dp, 'data': img['smask'] };
	  			if ('f' in img) smask.f = img['f'];
	  			putImage.call(this, smask);
	  		}

	  		//Palette
	  		if (img['cs'] === this.color_spaces.INDEXED) {

	  			this.internal.newObject();
	  			//out('<< /Filter / ' + img['f'] +' /Length ' + img['pal'].length + '>>');
	  			//putStream(zlib.compress(img['pal']));
	  			out('<< /Length ' + img['pal'].length + '>>');
	  			putStream(this.arrayBufferToBinaryString(new Uint8Array(img['pal'])));
	  			out('endobj');
	  		}
	  	},
	  	    putResourcesCallback = function putResourcesCallback() {
	  		var images = this.internal.collections[namespace + 'images'];
	  		for (var i in images) {
	  			putImage.call(this, images[i]);
	  		}
	  	},
	  	    putXObjectsDictCallback = function putXObjectsDictCallback() {
	  		var images = this.internal.collections[namespace + 'images'],
	  		    out = this.internal.write,
	  		    image;
	  		for (var i in images) {
	  			image = images[i];
	  			out('/I' + image['i'], image['n'], '0', 'R');
	  		}
	  	},
	  	    checkCompressValue = function checkCompressValue(value) {
	  		if (value && typeof value === 'string') value = value.toUpperCase();
	  		return value in jsPDFAPI.image_compression ? value : jsPDFAPI.image_compression.NONE;
	  	},
	  	    getImages = function getImages() {
	  		var images = this.internal.collections[namespace + 'images'];
	  		//first run, so initialise stuff
	  		if (!images) {
	  			this.internal.collections[namespace + 'images'] = images = {};
	  			this.internal.events.subscribe('putResources', putResourcesCallback);
	  			this.internal.events.subscribe('putXobjectDict', putXObjectsDictCallback);
	  		}

	  		return images;
	  	},
	  	    getImageIndex = function getImageIndex(images) {
	  		var imageIndex = 0;

	  		if (images) {
	  			// this is NOT the first time this method is ran on this instance of jsPDF object.
	  			imageIndex = Object.keys ? Object.keys(images).length : function (o) {
	  				var i = 0;
	  				for (var e in o) {
	  					if (o.hasOwnProperty(e)) {
	  						i++;
	  					}
	  				}
	  				return i;
	  			}(images);
	  		}

	  		return imageIndex;
	  	},
	  	    notDefined = function notDefined(value) {
	  		return typeof value === 'undefined' || value === null || value.length === 0;
	  	},
	  	    generateAliasFromData = function generateAliasFromData(data) {
	  		return typeof data === 'string' && jsPDFAPI.sHashCode(data);
	  	},
	  	    isImageTypeSupported = function isImageTypeSupported(type) {
	  		return typeof jsPDFAPI["process" + type.toUpperCase()] === "function";
	  	},
	  	    isDOMElement = function isDOMElement(object) {
	  		return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object.nodeType === 1;
	  	},
	  	    createDataURIFromElement = function createDataURIFromElement(element, format) {

	  		//if element is an image which uses data url definition, just return the dataurl
	  		if (element.nodeName === 'IMG' && element.hasAttribute('src')) {
	  			var src = '' + element.getAttribute('src');
	  			if (src.indexOf('data:image/') === 0) return src;

	  			// only if the user doesn't care about a format
	  			if (!format && /\.png(?:[?#].*)?$/i.test(src)) format = 'png';
	  		}

	  		if (element.nodeName === 'CANVAS') {
	  			var canvas = element;
	  		} else {
	  			var canvas = document.createElement('canvas');
	  			canvas.width = element.clientWidth || element.width;
	  			canvas.height = element.clientHeight || element.height;

	  			var ctx = canvas.getContext('2d');
	  			if (!ctx) {
	  				throw 'addImage requires canvas to be supported by browser.';
	  			}
	  			ctx.drawImage(element, 0, 0, canvas.width, canvas.height);
	  		}
	  		return canvas.toDataURL(('' + format).toLowerCase() == 'png' ? 'image/png' : 'image/jpeg');
	  	},
	  	    checkImagesForAlias = function checkImagesForAlias(alias, images) {
	  		var cached_info;
	  		if (images) {
	  			for (var e in images) {
	  				if (alias === images[e].alias) {
	  					cached_info = images[e];
	  					break;
	  				}
	  			}
	  		}
	  		return cached_info;
	  	},
	  	    determineWidthAndHeight = function determineWidthAndHeight(w, h, info) {
	  		if (!w && !h) {
	  			w = -96;
	  			h = -96;
	  		}
	  		if (w < 0) {
	  			w = -1 * info['w'] * 72 / w / this.internal.scaleFactor;
	  		}
	  		if (h < 0) {
	  			h = -1 * info['h'] * 72 / h / this.internal.scaleFactor;
	  		}
	  		if (w === 0) {
	  			w = h * info['w'] / info['h'];
	  		}
	  		if (h === 0) {
	  			h = w * info['h'] / info['w'];
	  		}

	  		return [w, h];
	  	},
	  	    writeImageToPDF = function writeImageToPDF(x, y, w, h, info, index, images, rotation) {
	  		var dims = determineWidthAndHeight.call(this, w, h, info),
	  		    coord = this.internal.getCoordinateString,
	  		    vcoord = this.internal.getVerticalCoordinateString;

	  		w = dims[0];
	  		h = dims[1];

	  		images[index] = info;

	  		if (rotation) {
	  			rotation *= Math.PI / 180;
	  			var c = Math.cos(rotation);
	  			var s = Math.sin(rotation);
	  			//like in pdf Reference do it 4 digits instead of 2
	  			var f4 = function f4(number) {
	  				return number.toFixed(4);
	  			};
	  			var rotationTransformationMatrix = [f4(c), f4(s), f4(s * -1), f4(c), 0, 0, 'cm'];
	  		}
	  		this.internal.write('q'); //Save graphics state
	  		if (rotation) {
	  			this.internal.write([1, '0', '0', 1, coord(x), vcoord(y + h), 'cm'].join(' ')); //Translate
	  			this.internal.write(rotationTransformationMatrix.join(' ')); //Rotate
	  			this.internal.write([coord(w), '0', '0', coord(h), '0', '0', 'cm'].join(' ')); //Scale
	  		} else {
	  			this.internal.write([coord(w), '0', '0', coord(h), coord(x), vcoord(y + h), 'cm'].join(' ')); //Translate and Scale
	  		}
	  		this.internal.write('/I' + info['i'] + ' Do'); //Paint Image
	  		this.internal.write('Q'); //Restore graphics state
	  	};

	  	/**
	    * COLOR SPACES
	    */
	  	jsPDFAPI.color_spaces = {
	  		DEVICE_RGB: 'DeviceRGB',
	  		DEVICE_GRAY: 'DeviceGray',
	  		DEVICE_CMYK: 'DeviceCMYK',
	  		CAL_GREY: 'CalGray',
	  		CAL_RGB: 'CalRGB',
	  		LAB: 'Lab',
	  		ICC_BASED: 'ICCBased',
	  		INDEXED: 'Indexed',
	  		PATTERN: 'Pattern',
	  		SEPARATION: 'Separation',
	  		DEVICE_N: 'DeviceN'
	  	};

	  	/**
	    * DECODE METHODS
	    */
	  	jsPDFAPI.decode = {
	  		DCT_DECODE: 'DCTDecode',
	  		FLATE_DECODE: 'FlateDecode',
	  		LZW_DECODE: 'LZWDecode',
	  		JPX_DECODE: 'JPXDecode',
	  		JBIG2_DECODE: 'JBIG2Decode',
	  		ASCII85_DECODE: 'ASCII85Decode',
	  		ASCII_HEX_DECODE: 'ASCIIHexDecode',
	  		RUN_LENGTH_DECODE: 'RunLengthDecode',
	  		CCITT_FAX_DECODE: 'CCITTFaxDecode'
	  	};

	  	/**
	    * IMAGE COMPRESSION TYPES
	    */
	  	jsPDFAPI.image_compression = {
	  		NONE: 'NONE',
	  		FAST: 'FAST',
	  		MEDIUM: 'MEDIUM',
	  		SLOW: 'SLOW'
	  	};

	  	jsPDFAPI.sHashCode = function (str) {
	  		str = str || "";
	  		return Array.prototype.reduce && str.split("").reduce(function (a, b) {
	  			a = (a << 5) - a + b.charCodeAt(0);return a & a;
	  		}, 0);
	  	};

	  	jsPDFAPI.isString = function (object) {
	  		return typeof object === 'string';
	  	};
	  	/**
	   * Validates if given String is a valid Base64-String
	   *
	   * @name validateStringAsBase64
	   * @public
	   * @function
	   * @param {String} possible Base64-String
	   * 
	   * @returns {boolean}
	   * @methodOf jsPDF#
	   */
	  	jsPDFAPI.validateStringAsBase64 = function (possibleBase64String) {
	  		possibleBase64String = possibleBase64String || '';

	  		var result = true;

	  		if (possibleBase64String.length % 4 !== 0) {
	  			result = false;
	  		}

	  		if (/[A-Za-z0-9\/]+/.test(possibleBase64String.substr(0, possibleBase64String.length - 2)) === false) {
	  			result = false;
	  		}

	  		if (/[A-Za-z0-9\/][A-Za-z0-9+\/]|[A-Za-z0-9+\/]=|==/.test(possibleBase64String.substr(-2)) === false) {
	  			result = false;
	  		}
	  		return result;
	  	};

	  	/**
	    * Strips out and returns info from a valid base64 data URI
	    * @param {String[dataURI]} a valid data URI of format 'data:[<MIME-type>][;base64],<data>'
	    * @returns an Array containing the following
	    * [0] the complete data URI
	    * [1] <MIME-type>
	    * [2] format - the second part of the mime-type i.e 'png' in 'image/png'
	    * [4] <data>
	    */
	  	jsPDFAPI.extractInfoFromBase64DataURI = function (dataURI) {
	  		return (/^data:([\w]+?\/([\w]+?));base64,(.+)$/g.exec(dataURI)
	  		);
	  	};

	  	/**
	    * Check to see if ArrayBuffer is supported
	    * 
	    * @returns {boolean}
	      * @methodOf jsPDF#
	    */
	  	jsPDFAPI.supportsArrayBuffer = function () {
	  		return typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined';
	  	};

	  	/**
	    * Tests supplied object to determine if ArrayBuffer
	    * @param {Object[object]}
	    * 
	    * @returns {boolean}
	    * @methodOf jsPDF#
	    */
	  	jsPDFAPI.isArrayBuffer = function (object) {
	  		if (!this.supportsArrayBuffer()) return false;
	  		return object instanceof ArrayBuffer;
	  	};

	  	/**
	    * Tests supplied object to determine if it implements the ArrayBufferView (TypedArray) interface
	    * @param {Object[object]}
	    */
	  	jsPDFAPI.isArrayBufferView = function (object) {
	  		if (!this.supportsArrayBuffer()) return false;
	  		if (typeof Uint32Array === 'undefined') return false;
	  		return object instanceof Int8Array || object instanceof Uint8Array || typeof Uint8ClampedArray !== 'undefined' && object instanceof Uint8ClampedArray || object instanceof Int16Array || object instanceof Uint16Array || object instanceof Int32Array || object instanceof Uint32Array || object instanceof Float32Array || object instanceof Float64Array;
	  	};

	  	/**
	   * Convert the Buffer to a Binary String
	   *
	   * @name binaryStringToUint8Array
	   * @public
	   * @function
	   * @param {ArrayBuffer} BinaryString with ImageData
	   * 
	   * @returns {Uint8Array}
	   */
	  	jsPDFAPI.binaryStringToUint8Array = function (binary_string) {
	  		/*
	     * not sure how efficient this will be will bigger files. Is there a native method?
	     */
	  		var len = binary_string.length;
	  		var bytes = new Uint8Array(len);
	  		for (var i = 0; i < len; i++) {
	  			bytes[i] = binary_string.charCodeAt(i);
	  		}
	  		return bytes;
	  	};

	  	/**
	   * Convert the Buffer to a Binary String
	   *
	   * @name arrayBufferToBinaryString
	   * @public
	   * @function
	   * @param {ArrayBuffer} ArrayBuffer with ImageData
	   * 
	   * @returns {String}
	   */
	  	jsPDFAPI.arrayBufferToBinaryString = function (buffer) {

	  		if (typeof atob === "function") {
	  			return atob(this.arrayBufferToBase64(buffer));
	  		}

	  		if (typeof TextDecoder === "function") {
	  			var decoder = new TextDecoder('ascii');
	  			// test if the encoding is supported
	  			if (decoder.encoding === 'ascii') {
	  				return decoder.decode(buffer);
	  			}
	  		}

	  		//Fallback-solution
	  		var data = this.isArrayBuffer(buffer) ? buffer : new Uint8Array(buffer);
	  		var chunkSizeForSlice = 0x5000;
	  		var binary_string = '';
	  		var slicesCount = Math.ceil(data.byteLength / chunkSizeForSlice);
	  		for (var i = 0; i < slicesCount; i++) {
	  			binary_string += String.fromCharCode.apply(null, data.slice(i * chunkSizeForSlice, i * chunkSizeForSlice + chunkSizeForSlice));
	  		}
	  		return binary_string;
	  	};

	  	/**
	      * Converts an ArrayBuffer directly to base64
	      *
	      * Taken from  http://jsperf.com/encoding-xhr-image-data/31
	      *
	      * Need to test if this is a better solution for larger files
	      *
	      * @name arrayBufferToBase64
	      * @public
	      * @function
	      * 
	      * @returns {String}
	      */
	  	jsPDFAPI.arrayBufferToBase64 = function (arrayBuffer) {
	  		var base64 = '';
	  		var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

	  		var bytes = new Uint8Array(arrayBuffer);
	  		var byteLength = bytes.byteLength;
	  		var byteRemainder = byteLength % 3;
	  		var mainLength = byteLength - byteRemainder;

	  		var a, b, c, d;
	  		var chunk;

	  		// Main loop deals with bytes in chunks of 3
	  		for (var i = 0; i < mainLength; i = i + 3) {
	  			// Combine the three bytes into a single integer
	  			chunk = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];

	  			// Use bitmasks to extract 6-bit segments from the triplet
	  			a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
	  			b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
	  			c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
	  			d = chunk & 63; // 63       = 2^6 - 1

	  			// Convert the raw binary segments to the appropriate ASCII encoding
	  			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
	  		}

	  		// Deal with the remaining bytes and padding
	  		if (byteRemainder == 1) {
	  			chunk = bytes[mainLength];

	  			a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

	  			// Set the 4 least significant bits to zero
	  			b = (chunk & 3) << 4; // 3   = 2^2 - 1

	  			base64 += encodings[a] + encodings[b] + '==';
	  		} else if (byteRemainder == 2) {
	  			chunk = bytes[mainLength] << 8 | bytes[mainLength + 1];

	  			a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
	  			b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4

	  			// Set the 2 least significant bits to zero
	  			c = (chunk & 15) << 2; // 15    = 2^4 - 1

	  			base64 += encodings[a] + encodings[b] + encodings[c] + '=';
	  		}

	  		return base64;
	  	};

	  	/**
	      * Converts an ArrayBuffer directly to base64
	      *
	      * Taken from  http://jsperf.com/encoding-xhr-image-data/31
	      *
	      * Need to test if this is a better solution for larger files
	      *
	      * @public
	      * @function
	      * 
	      * @returns {String}
	      */
	  	jsPDFAPI.createImageInfo = function (data, wd, ht, cs, bpc, f, imageIndex, alias, dp, trns, pal, smask, p) {
	  		var info = {
	  			alias: alias,
	  			w: wd,
	  			h: ht,
	  			cs: cs,
	  			bpc: bpc,
	  			i: imageIndex,
	  			data: data
	  			// n: objectNumber will be added by putImage code
	  		};

	  		if (f) info.f = f;
	  		if (dp) info.dp = dp;
	  		if (trns) info.trns = trns;
	  		if (pal) info.pal = pal;
	  		if (smask) info.smask = smask;
	  		if (p) info.p = p; // predictor parameter for PNG compression

	  		return info;
	  	};
	  	/**
	   * Adds an Image to the PDF.
	   *
	   * @name addImage
	   * @public
	   * @function
	   * @param {String/Image-Element/Canvas-Element/Uint8Array} imageData as base64 encoded DataUrl or Image-HTMLElement or Canvas-HTMLElement
	   * @param {String} format of file if filetype-recognition fails, e.g. 'JPEG'
	   * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	   * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	   * @param {Number} width of the image (in units declared at inception of PDF document)
	   * @param {Number} height of the Image (in units declared at inception of PDF document)
	   * @param {String} alias of the image (if used multiple times)
	   * @param {String} compression of the generated JPEG, can have the values 'NONE', 'FAST', 'MEDIUM' and 'SLOW'
	   * @param {Number} rotation of the image in degrees (0-359)
	   * 
	   * @returns jsPDF
	   * @methodOf jsPDF#
	   */
	  	jsPDFAPI.addImage = function (imageData, format, x, y, w, h, alias, compression, rotation) {

	  		var tmpImageData = '';

	  		if (typeof format !== 'string') {
	  			var tmp = h;
	  			h = w;
	  			w = y;
	  			y = x;
	  			x = format;
	  			format = tmp;
	  		}

	  		if ((typeof imageData === 'undefined' ? 'undefined' : _typeof(imageData)) === 'object' && !isDOMElement(imageData) && "imageData" in imageData) {
	  			var options = imageData;

	  			imageData = options.imageData;
	  			format = options.format || format;
	  			x = options.x || x || 0;
	  			y = options.y || y || 0;
	  			w = options.w || w;
	  			h = options.h || h;
	  			alias = options.alias || alias;
	  			compression = options.compression || compression;
	  			rotation = options.rotation || options.angle || rotation;
	  		}

	  		if (isNaN(x) || isNaN(y)) {
	  			console.error('jsPDF.addImage: Invalid coordinates', arguments);
	  			throw new Error('Invalid coordinates passed to jsPDF.addImage');
	  		}

	  		var images = getImages.call(this),
	  		    info;

	  		if (!(info = checkImagesForAlias(imageData, images))) {
	  			var dataAsBinaryString;

	  			if (isDOMElement(imageData)) imageData = createDataURIFromElement(imageData, format);

	  			if (notDefined(alias)) alias = generateAliasFromData(imageData);

	  			if (!(info = checkImagesForAlias(alias, images))) {
	  				if (this.isString(imageData)) {
	  					tmpImageData = this.convertStringToImageData(imageData);

	  					if (tmpImageData !== '') {
	  						imageData = tmpImageData;
	  					} else {
	  						tmpImageData = this.loadImageFile(imageData);
	  						if (tmpImageData !== undefined) {
	  							imageData = tmpImageData;
	  						}
	  					}
	  				}
	  				format = this.getImageFileTypeByImageData(imageData, format);

	  				if (!isImageTypeSupported(format)) throw new Error('addImage does not support files of type \'' + format + '\', please ensure that a plugin for \'' + format + '\' support is added.');

	  				/**
	       * need to test if it's more efficient to convert all binary strings
	       * to TypedArray - or should we just leave and process as string?
	       */
	  				if (this.supportsArrayBuffer()) {
	  					// no need to convert if imageData is already uint8array
	  					if (!(imageData instanceof Uint8Array)) {
	  						dataAsBinaryString = imageData;
	  						imageData = this.binaryStringToUint8Array(imageData);
	  					}
	  				}

	  				info = this['process' + format.toUpperCase()](imageData, getImageIndex(images), alias, checkCompressValue(compression), dataAsBinaryString);

	  				if (!info) throw new Error('An unkwown error occurred whilst processing the image');
	  			}
	  		}
	  		writeImageToPDF.call(this, x, y, w, h, info, info.i, images, rotation);

	  		return this;
	  	};

	  	jsPDFAPI.convertStringToImageData = function (stringData) {
	  		var base64Info;
	  		var imageData = '';
	  		if (this.isString(stringData)) {
	  			var base64Info = this.extractInfoFromBase64DataURI(stringData);

	  			if (base64Info !== null) {
	  				if (jsPDFAPI.validateStringAsBase64(base64Info[3])) {
	  					imageData = atob(base64Info[3]); //convert to binary string
	  				}
	  			} else if (jsPDFAPI.validateStringAsBase64(stringData)) {
	  				imageData = atob(stringData);
	  			}
	  		}
	  		return imageData;
	  	};
	  	/**
	    * JPEG SUPPORT
	    **/

	  	//takes a string imgData containing the raw bytes of
	  	//a jpeg image and returns [width, height]
	  	//Algorithm from: http://www.64lines.com/jpeg-width-height
	  	var getJpegSize = function getJpegSize(imgData) {

	  		var width, height, numcomponents;
	  		// Verify we have a valid jpeg header 0xff,0xd8,0xff,0xe0,?,?,'J','F','I','F',0x00
	  		if (!imgData.charCodeAt(0) === 0xff || !imgData.charCodeAt(1) === 0xd8 || !imgData.charCodeAt(2) === 0xff || !imgData.charCodeAt(3) === 0xe0 || !imgData.charCodeAt(6) === 'J'.charCodeAt(0) || !imgData.charCodeAt(7) === 'F'.charCodeAt(0) || !imgData.charCodeAt(8) === 'I'.charCodeAt(0) || !imgData.charCodeAt(9) === 'F'.charCodeAt(0) || !imgData.charCodeAt(10) === 0x00) {
	  			throw new Error('getJpegSize requires a binary string jpeg file');
	  		}
	  		var blockLength = imgData.charCodeAt(4) * 256 + imgData.charCodeAt(5);
	  		var i = 4,
	  		    len = imgData.length;
	  		while (i < len) {
	  			i += blockLength;
	  			if (imgData.charCodeAt(i) !== 0xff) {
	  				throw new Error('getJpegSize could not find the size of the image');
	  			}
	  			if (imgData.charCodeAt(i + 1) === 0xc0 || //(SOF) Huffman  - Baseline DCT
	  			imgData.charCodeAt(i + 1) === 0xc1 || //(SOF) Huffman  - Extended sequential DCT
	  			imgData.charCodeAt(i + 1) === 0xc2 || // Progressive DCT (SOF2)
	  			imgData.charCodeAt(i + 1) === 0xc3 || // Spatial (sequential) lossless (SOF3)
	  			imgData.charCodeAt(i + 1) === 0xc4 || // Differential sequential DCT (SOF5)
	  			imgData.charCodeAt(i + 1) === 0xc5 || // Differential progressive DCT (SOF6)
	  			imgData.charCodeAt(i + 1) === 0xc6 || // Differential spatial (SOF7)
	  			imgData.charCodeAt(i + 1) === 0xc7) {
	  				height = imgData.charCodeAt(i + 5) * 256 + imgData.charCodeAt(i + 6);
	  				width = imgData.charCodeAt(i + 7) * 256 + imgData.charCodeAt(i + 8);
	  				numcomponents = imgData.charCodeAt(i + 9);
	  				return [width, height, numcomponents];
	  			} else {
	  				i += 2;
	  				blockLength = imgData.charCodeAt(i) * 256 + imgData.charCodeAt(i + 1);
	  			}
	  		}
	  	},
	  	    getJpegSizeFromBytes = function getJpegSizeFromBytes(data) {

	  		var hdr = data[0] << 8 | data[1];

	  		if (hdr !== 0xFFD8) throw new Error('Supplied data is not a JPEG');

	  		var len = data.length,
	  		    block = (data[4] << 8) + data[5],
	  		    pos = 4,
	  		    bytes,
	  		    width,
	  		    height,
	  		    numcomponents;

	  		while (pos < len) {
	  			pos += block;
	  			bytes = readBytes(data, pos);
	  			block = (bytes[2] << 8) + bytes[3];
	  			if ((bytes[1] === 0xC0 || bytes[1] === 0xC2) && bytes[0] === 0xFF && block > 7) {
	  				bytes = readBytes(data, pos + 5);
	  				width = (bytes[2] << 8) + bytes[3];
	  				height = (bytes[0] << 8) + bytes[1];
	  				numcomponents = bytes[4];
	  				return { width: width, height: height, numcomponents: numcomponents };
	  			}

	  			pos += 2;
	  		}

	  		throw new Error('getJpegSizeFromBytes could not find the size of the image');
	  	},
	  	    readBytes = function readBytes(data, offset) {
	  		return data.subarray(offset, offset + 5);
	  	};

	  	jsPDFAPI.processJPEG = function (data, index, alias, compression, dataAsBinaryString, colorSpace) {

	  		var filter = this.decode.DCT_DECODE,
	  		    bpc = 8,
	  		    dims;

	  		if (!this.isString(data) && !this.isArrayBuffer(data) && !this.isArrayBufferView(data)) {
	  			return null;
	  		}

	  		if (this.isString(data)) {
	  			dims = getJpegSize(data);
	  		}

	  		if (this.isArrayBuffer(data)) {
	  			data = new Uint8Array(data);
	  		}
	  		if (this.isArrayBufferView(data)) {

	  			dims = getJpegSizeFromBytes(data);

	  			// if we already have a stored binary string rep use that
	  			data = dataAsBinaryString || this.arrayBufferToBinaryString(data);
	  		}

	  		if (colorSpace === undefined) {
	  			switch (dims.numcomponents) {
	  				case 1:
	  					colorSpace = this.color_spaces.DEVICE_GRAY;
	  					break;
	  				case 4:
	  					colorSpace = this.color_spaces.DEVICE_CMYK;
	  					break;
	  				default:
	  				case 3:
	  					colorSpace = this.color_spaces.DEVICE_RGB;
	  					break;
	  			}
	  		}

	  		return this.createImageInfo(data, dims.width, dims.height, colorSpace, bpc, filter, index, alias);
	  	};

	  	jsPDFAPI.processJPG = function () /*data, index, alias, compression, dataAsBinaryString*/{
	  		return this.processJPEG.apply(this, arguments);
	  	};

	  	jsPDFAPI.loadImageFile = function (path, sync, callback) {
	  		sync = sync || true;
	  		callback = callback || function () {};
	  		var isNode = Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';

	  		var xhrMethod = function xhrMethod(url, sync, callback) {
	  			var req = new XMLHttpRequest();
	  			var byteArray = [];
	  			var i = 0;

	  			var sanitizeUnicode = function sanitizeUnicode(data) {
	  				var dataLength = data.length;
	  				var StringFromCharCode = String.fromCharCode;

	  				//Transform Unicode to ASCII
	  				for (i = 0; i < dataLength; i += 1) {
	  					byteArray.push(StringFromCharCode(data.charCodeAt(i) & 0xff));
	  				}
	  				return byteArray.join("");
	  			};

	  			req.open('GET', url, !sync);
	  			// XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]
	  			req.overrideMimeType('text\/plain; charset=x-user-defined');

	  			if (sync === false) {
	  				req.onload = function () {
	  					return sanitizeUnicode(this.responseText);
	  				};
	  			}
	  			req.send(null);

	  			if (req.status !== 200) {
	  				console.warn('Unable to load file "' + url + '"');
	  				return;
	  			}

	  			if (sync) {
	  				return sanitizeUnicode(req.responseText);
	  			}
	  		};

	  		//we have a browser and probably no CORS-Problem
	  		if ((typeof window === 'undefined' ? 'undefined' : _typeof(window)) !== undefined && (typeof location === 'undefined' ? 'undefined' : _typeof(location)) === "object" && location.protocol.substr(0, 4) === "http") {
	  			return xhrMethod(path, sync, callback);
	  		}
	  	};

	  	jsPDFAPI.getImageProperties = function (imageData) {
	  		var info;
	  		var tmpImageData = '';
	  		var format;

	  		if (isDOMElement(imageData)) {
	  			imageData = createDataURIFromElement(imageData);
	  		}

	  		if (this.isString(imageData)) {
	  			tmpImageData = this.convertStringToImageData(imageData);

	  			if (tmpImageData !== '') {
	  				imageData = tmpImageData;
	  			} else {
	  				tmpImageData = this.loadImageFile(imageData);
	  				if (tmpImageData !== undefined) {
	  					imageData = tmpImageData;
	  				}
	  			}
	  		}
	  		format = this.getImageFileTypeByImageData(imageData);

	  		if (!isImageTypeSupported(format)) throw new Error('addImage does not support files of type \'' + format + '\', please ensure that a plugin for \'' + format + '\' support is added.');

	  		/**
	     * need to test if it's more efficient to convert all binary strings
	     * to TypedArray - or should we just leave and process as string?
	     */
	  		if (this.supportsArrayBuffer()) {
	  			// no need to convert if imageData is already uint8array
	  			if (!(imageData instanceof Uint8Array)) {
	  				imageData = this.binaryStringToUint8Array(imageData);
	  			}
	  		}

	  		info = this['process' + format.toUpperCase()](imageData);

	  		if (!info) {
	  			throw new Error('An unkwown error occurred whilst processing the image');
	  		}

	  		return {
	  			fileType: format,
	  			width: info.w,
	  			height: info.h,
	  			colorSpace: info.cs,
	  			compressionMode: info.f,
	  			bitsPerComponent: info.bpc
	  		};
	  	};
	  })(jsPDF.API);

	  /**
	   * jsPDF Annotations PlugIn
	   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  /**
	   * There are many types of annotations in a PDF document. Annotations are placed
	   * on a page at a particular location. They are not 'attached' to an object.
	   * <br />
	   * This plugin current supports <br />
	   * <li> Goto Page (set pageNumber and top in options)
	   * <li> Goto Name (set name and top in options)
	   * <li> Goto URL (set url in options)
	   * <p>
	   * 	The destination magnification factor can also be specified when goto is a page number or a named destination. (see documentation below)
	   *  (set magFactor in options).  XYZ is the default.
	   * </p>
	   * <p>
	   *  Links, Text, Popup, and FreeText are supported.
	   * </p>
	   * <p>
	   * Options In PDF spec Not Implemented Yet
	   * <li> link border
	   * <li> named target
	   * <li> page coordinates
	   * <li> destination page scaling and layout
	   * <li> actions other than URL and GotoPage
	   * <li> background / hover actions
	   * </p>
	   */

	  /*
	      Destination Magnification Factors
	      See PDF 1.3 Page 386 for meanings and options

	      [supported]
	  	XYZ (options; left top zoom)
	  	Fit (no options)
	  	FitH (options: top)
	  	FitV (options: left)

	  	[not supported]
	  	FitR
	  	FitB
	  	FitBH
	  	FitBV
	   */

	  (function (jsPDFAPI) {

	  	var annotationPlugin = {

	  		/**
	     * An array of arrays, indexed by <em>pageNumber</em>.
	     */
	  		annotations: [],

	  		f2: function f2(number) {
	  			return number.toFixed(2);
	  		},

	  		notEmpty: function notEmpty(obj) {
	  			if (typeof obj != 'undefined') {
	  				if (obj != '') {
	  					return true;
	  				}
	  			}
	  		}
	  	};

	  	jsPDF.API.annotationPlugin = annotationPlugin;

	  	jsPDF.API.events.push(['addPage', function (info) {
	  		this.annotationPlugin.annotations[info.pageNumber] = [];
	  	}]);

	  	jsPDFAPI.events.push(['putPage', function (info) {
	  		//TODO store annotations in pageContext so reorder/remove will not affect them.
	  		var pageAnnos = this.annotationPlugin.annotations[info.pageNumber];

	  		var found = false;
	  		for (var a = 0; a < pageAnnos.length && !found; a++) {
	  			var anno = pageAnnos[a];
	  			switch (anno.type) {
	  				case 'link':
	  					if (annotationPlugin.notEmpty(anno.options.url) || annotationPlugin.notEmpty(anno.options.pageNumber)) {
	  						found = true;
	  						break;
	  					}
	  				case 'reference':
	  				case 'text':
	  				case 'freetext':
	  					found = true;
	  					break;
	  			}
	  		}
	  		if (found == false) {
	  			return;
	  		}

	  		this.internal.write("/Annots [");
	  		var f2 = this.annotationPlugin.f2;
	  		var k = this.internal.scaleFactor;
	  		var pageHeight = this.internal.pageSize.getHeight();
	  		var pageInfo = this.internal.getPageInfo(info.pageNumber);
	  		for (var a = 0; a < pageAnnos.length; a++) {
	  			var anno = pageAnnos[a];

	  			switch (anno.type) {
	  				case 'reference':
	  					// References to Widget Anotations (for AcroForm Fields)
	  					this.internal.write(' ' + anno.object.objId + ' 0 R ');
	  					break;
	  				case 'text':
	  					// Create a an object for both the text and the popup
	  					var objText = this.internal.newAdditionalObject();
	  					var objPopup = this.internal.newAdditionalObject();

	  					var title = anno.title || 'Note';
	  					var rect = "/Rect [" + f2(anno.bounds.x * k) + " " + f2(pageHeight - (anno.bounds.y + anno.bounds.h) * k) + " " + f2((anno.bounds.x + anno.bounds.w) * k) + " " + f2((pageHeight - anno.bounds.y) * k) + "] ";
	  					line = '<</Type /Annot /Subtype /' + 'Text' + ' ' + rect + '/Contents (' + anno.contents + ')';
	  					line += ' /Popup ' + objPopup.objId + " 0 R";
	  					line += ' /P ' + pageInfo.objId + " 0 R";
	  					line += ' /T (' + title + ') >>';
	  					objText.content = line;

	  					var parent = objText.objId + ' 0 R';
	  					var popoff = 30;
	  					var rect = "/Rect [" + f2((anno.bounds.x + popoff) * k) + " " + f2(pageHeight - (anno.bounds.y + anno.bounds.h) * k) + " " + f2((anno.bounds.x + anno.bounds.w + popoff) * k) + " " + f2((pageHeight - anno.bounds.y) * k) + "] ";
	  					//var rect2 = "/Rect [" + f2(anno.bounds.x * k) + " " + f2((pageHeight - anno.bounds.y) * k) + " " + f2(anno.bounds.x + anno.bounds.w * k) + " " + f2(pageHeight - (anno.bounds.y + anno.bounds.h) * k) + "] ";
	  					line = '<</Type /Annot /Subtype /' + 'Popup' + ' ' + rect + ' /Parent ' + parent;
	  					if (anno.open) {
	  						line += ' /Open true';
	  					}
	  					line += ' >>';
	  					objPopup.content = line;

	  					this.internal.write(objText.objId, '0 R', objPopup.objId, '0 R');

	  					break;
	  				case 'freetext':
	  					var rect = "/Rect [" + f2(anno.bounds.x * k) + " " + f2((pageHeight - anno.bounds.y) * k) + " " + f2(anno.bounds.x + anno.bounds.w * k) + " " + f2(pageHeight - (anno.bounds.y + anno.bounds.h) * k) + "] ";
	  					var color = anno.color || '#000000';
	  					line = '<</Type /Annot /Subtype /' + 'FreeText' + ' ' + rect + '/Contents (' + anno.contents + ')';
	  					line += ' /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#' + color + ')';
	  					line += ' /Border [0 0 0]';
	  					line += ' >>';
	  					this.internal.write(line);
	  					break;
	  				case 'link':
	  					if (anno.options.name) {
	  						var loc = this.annotations._nameMap[anno.options.name];
	  						anno.options.pageNumber = loc.page;
	  						anno.options.top = loc.y;
	  					} else {
	  						if (!anno.options.top) {
	  							anno.options.top = 0;
	  						}
	  					}

	  					var rect = "/Rect [" + f2(anno.x * k) + " " + f2((pageHeight - anno.y) * k) + " " + f2((anno.x + anno.w) * k) + " " + f2((pageHeight - (anno.y + anno.h)) * k) + "] ";

	  					var line = '';
	  					if (anno.options.url) {
	  						line = '<</Type /Annot /Subtype /Link ' + rect + '/Border [0 0 0] /A <</S /URI /URI (' + anno.options.url + ') >>';
	  					} else if (anno.options.pageNumber) {
	  						// first page is 0
	  						var info = this.internal.getPageInfo(anno.options.pageNumber);
	  						line = '<</Type /Annot /Subtype /Link ' + rect + '/Border [0 0 0] /Dest [' + info.objId + " 0 R";
	  						anno.options.magFactor = anno.options.magFactor || "XYZ";
	  						switch (anno.options.magFactor) {
	  							case 'Fit':
	  								line += ' /Fit]';
	  								break;
	  							case 'FitH':
	  								//anno.options.top = anno.options.top || f2(pageHeight * k);
	  								line += ' /FitH ' + anno.options.top + ']';
	  								break;
	  							case 'FitV':
	  								anno.options.left = anno.options.left || 0;
	  								line += ' /FitV ' + anno.options.left + ']';
	  								break;
	  							case 'XYZ':
	  							default:
	  								var top = f2((pageHeight - anno.options.top) * k); // || f2(pageHeight * k);
	  								anno.options.left = anno.options.left || 0;
	  								// 0 or null zoom will not change zoom factor
	  								if (typeof anno.options.zoom === 'undefined') {
	  									anno.options.zoom = 0;
	  								}
	  								line += ' /XYZ ' + anno.options.left + ' ' + top + ' ' + anno.options.zoom + ']';
	  								break;
	  						}
	  					}
	  					if (line != '') {
	  						line += " >>";
	  						this.internal.write(line);
	  					}
	  					break;
	  			}
	  		}
	  		this.internal.write("]");
	  	}]);

	  	jsPDFAPI.createAnnotation = function (options) {
	  		switch (options.type) {
	  			case 'link':
	  				this.link(options.bounds.x, options.bounds.y, options.bounds.w, options.bounds.h, options);
	  				break;
	  			case 'text':
	  			case 'freetext':
	  				this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push(options);
	  				break;
	  		}
	  	};

	  	/**
	    * valid options
	    * <li> pageNumber or url [required]
	    * <p>If pageNumber is specified, top and zoom may also be specified</p>
	    */
	  	jsPDFAPI.link = function (x, y, w, h, options) {

	  		this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push({
	  			x: x,
	  			y: y,
	  			w: w,
	  			h: h,
	  			options: options,
	  			type: 'link'
	  		});
	  	};

	  	/**
	    * Currently only supports single line text.
	    * Returns the width of the text/link
	    */
	  	jsPDFAPI.textWithLink = function (text, x, y, options) {

	  		var width = this.getTextWidth(text);
	  		var height = this.internal.getLineHeight() / this.internal.scaleFactor;
	  		this.text(text, x, y);
	  		//TODO We really need the text baseline height to do this correctly.
	  		// Or ability to draw text on top, bottom, center, or baseline.
	  		y += height * .2;
	  		this.link(x, y - height, width, height, options);
	  		return width;
	  	};

	  	//TODO move into external library
	  	jsPDFAPI.getTextWidth = function (text) {

	  		var fontSize = this.internal.getFontSize();
	  		var txtWidth = this.getStringUnitWidth(text) * fontSize / this.internal.scaleFactor;
	  		return txtWidth;
	  	};

	  	//TODO move into external library
	  	jsPDFAPI.getLineHeight = function () {
	  		return this.internal.getLineHeight();
	  	};

	  	return this;
	  })(jsPDF.API);

	  (function (jsPDFAPI) {

	      var arLangCodes = {
	          "ar": "Arabic (Standard)",
	          "ar-DZ": "Arabic (Algeria)",
	          "ar-BH": "Arabic (Bahrain)",
	          "ar-EG": "Arabic (Egypt)",
	          "ar-IQ": "Arabic (Iraq)",
	          "ar-JO": "Arabic (Jordan)",
	          "ar-KW": "Arabic (Kuwait)",
	          "ar-LB": "Arabic (Lebanon)",
	          "ar-LY": "Arabic (Libya)",
	          "ar-MA": "Arabic (Morocco)",
	          "ar-OM": "Arabic (Oman)",
	          "ar-QA": "Arabic (Qatar)",
	          "ar-SA": "Arabic (Saudi Arabia)",
	          "ar-SY": "Arabic (Syria)",
	          "ar-TN": "Arabic (Tunisia)",
	          "ar-AE": "Arabic (U.A.E.)",
	          "ar-YE": "Arabic (Yemen)",
	          "fa": "Persian",
	          "fa-IR": "Persian/Iran",
	          "ur": "Urdu"
	      };

	      var arLangCodesKeys = Object.keys(arLangCodes);

	      /**
	       * Arabic shape substitutions: char code => (isolated, final, initial, medial).
	       */
	      var arabicSubst = {
	          1569: [65152],
	          1570: [65153, 65154, 65153, 65154],
	          1571: [65155, 65156, 65155, 65156],
	          1572: [65157, 65158],
	          1573: [65159, 65160, 65159, 65160],
	          1574: [65161, 65162, 65163, 65164],
	          1575: [65165, 65166, 65165, 65166],
	          1576: [65167, 65168, 65169, 65170],
	          1577: [65171, 65172],
	          1578: [65173, 65174, 65175, 65176],
	          1579: [65177, 65178, 65179, 65180],
	          1580: [65181, 65182, 65183, 65184],
	          1581: [65185, 65186, 65187, 65188],
	          1582: [65189, 65190, 65191, 65192],
	          1583: [65193, 65194, 65193],
	          1584: [65195, 65196, 65195],
	          1585: [65197, 65198, 65197],
	          1586: [65199, 65200, 65199],
	          1587: [65201, 65202, 65203, 65204],
	          1588: [65205, 65206, 65207, 65208],
	          1589: [65209, 65210, 65211, 65212],
	          1590: [65213, 65214, 65215, 65216],
	          1591: [65217, 65218, 65219, 65220],
	          1592: [65221, 65222, 65223, 65224],
	          1593: [65225, 65226, 65227, 65228],
	          1594: [65229, 65230, 65231, 65232],
	          1601: [65233, 65234, 65235, 65236],
	          1602: [65237, 65238, 65239, 65240],
	          1603: [65241, 65242, 65243, 65244],
	          1604: [65245, 65246, 65247, 65248],
	          1605: [65249, 65250, 65251, 65252],
	          1606: [65253, 65254, 65255, 65256],
	          1607: [65257, 65258, 65259, 65260],
	          1608: [65261, 65262, 65261],
	          1609: [65263, 65264, 64488, 64489],
	          1610: [65265, 65266, 65267, 65268],
	          1649: [64336, 64337],
	          1655: [64477],
	          1657: [64358, 64359, 64360, 64361],
	          1658: [64350, 64351, 64352, 64353],
	          1659: [64338, 64339, 64340, 64341],
	          1662: [64342, 64343, 64344, 64345],
	          1663: [64354, 64355, 64356, 64357],
	          1664: [64346, 64347, 64348, 64349],
	          1667: [64374, 64375, 64376, 64377],
	          1668: [64370, 64371, 64372, 64373],
	          1670: [64378, 64379, 64380, 64381],
	          1671: [64382, 64383, 64384, 64385],
	          1672: [64392, 64393],
	          1676: [64388, 64389],
	          1677: [64386, 64387],
	          1678: [64390, 64391],
	          1681: [64396, 64397],
	          1688: [64394, 64395, 64394],
	          1700: [64362, 64363, 64364, 64365],
	          1702: [64366, 64367, 64368, 64369],
	          1705: [64398, 64399, 64400, 64401],
	          1709: [64467, 64468, 64469, 64470],
	          1711: [64402, 64403, 64404, 64405],
	          1713: [64410, 64411, 64412, 64413],
	          1715: [64406, 64407, 64408, 64409],
	          1722: [64414, 64415],
	          1723: [64416, 64417, 64418, 64419],
	          1726: [64426, 64427, 64428, 64429],
	          1728: [64420, 64421],
	          1729: [64422, 64423, 64424, 64425],
	          1733: [64480, 64481],
	          1734: [64473, 64474],
	          1735: [64471, 64472],
	          1736: [64475, 64476],
	          1737: [64482, 64483],
	          1739: [64478, 64479],
	          1740: [64508, 64509, 64510, 64511],
	          1744: [64484, 64485, 64486, 64487],
	          1746: [64430, 64431],
	          1747: [64432, 64433]
	      };
	      var arabiclaasubst = {
	          1570: [65269, 65270, 65269, 65270],
	          1571: [65271, 65272, 65271, 65272],
	          1573: [65273, 65274, 65273, 65274],
	          1575: [65275, 65276, 65275, 65276]
	      };
	      var arabicorigsubst = {
	          1570: [65153, 65154, 65153, 65154],
	          1571: [65155, 65156, 65155, 65156],
	          1573: [65159, 65160, 65159, 65160],
	          1575: [65165, 65166, 65165, 65166]
	      };
	      var arabic_diacritics = {
	          1612: 64606, // Shadda + Dammatan
	          1613: 64607, // Shadda + Kasratan
	          1614: 64608, // Shadda + Fatha
	          1615: 64609, // Shadda + Damma
	          1616: 64610 // Shadda + Kasra
	      };

	      var alfletter = [1570, 1571, 1573, 1575];
	      var endedletter = [1569, 1570, 1571, 1572, 1573, 1575, 1577, 1583, 1584, 1585, 1586, 1608, 1688];

	      var isolatedForm = 0;
	      var finalForm = 1;
	      var initialForm = 2;
	      var medialForm = 3;

	      //private
	      function isArabicLetter(letter) {
	          return letter !== undefined && arabicSubst[letter.charCodeAt(0)] !== undefined;
	      }

	      function isArabicEndLetter(letter) {
	          return letter !== undefined && endedletter.indexOf(letter.charCodeAt(0)) >= 0;
	      }

	      function isArabicAlfLetter(letter) {
	          return letter !== undefined && alfletter.indexOf(letter.charCodeAt(0)) >= 0;
	      }

	      function arabicLetterHasFinalForm(letter) {
	          return isArabicLetter(letter) && arabicSubst[letter.charCodeAt(0)].length >= 2;
	      }

	      function arabicLetterHasMedialForm(letter) {
	          return isArabicLetter(letter) && arabicSubst[letter.charCodeAt(0)].length == 4;
	      }

	      function isArabicDiacritic(letter) {
	          return letter !== undefined && arabic_diacritics[letter.charCodeAt(0)] !== undefined;
	      }

	      function getCorrectForm(currentChar, beforeChar, nextChar, arabicSubstition) {
	          if (!isArabicLetter(currentChar)) {
	              return -1;
	          }

	          arabicSubstition = arabicSubstition || {};
	          arabicSubst = Object.assign(arabicSubst, arabicSubstition);

	          if (!arabicLetterHasFinalForm(currentChar) || !isArabicLetter(beforeChar) && !isArabicLetter(nextChar) || !isArabicLetter(nextChar) && isArabicEndLetter(beforeChar) || isArabicEndLetter(currentChar) && !isArabicLetter(beforeChar) || isArabicEndLetter(currentChar) && isArabicAlfLetter(beforeChar) || isArabicEndLetter(currentChar) && isArabicEndLetter(beforeChar)) {
	              arabicSubst = Object.assign(arabicSubst, arabicorigsubst);
	              return isolatedForm;
	          }

	          if (arabicLetterHasMedialForm(currentChar) && isArabicLetter(beforeChar) && !isArabicEndLetter(beforeChar) && isArabicLetter(nextChar) && arabicLetterHasFinalForm(nextChar)) {
	              arabicSubst = Object.assign(arabicSubst, arabicorigsubst);
	              return medialForm;
	          }

	          if (isArabicEndLetter(currentChar) || !isArabicLetter(nextChar)) {
	              arabicSubst = Object.assign(arabicSubst, arabicorigsubst);
	              return finalForm;
	          }

	          arabicSubst = Object.assign(arabicSubst, arabicorigsubst);
	          return initialForm;
	      }

	      var commonSubstition = function commonSubstition(character) {
	          var replacementTable = {
	              '(': ')',
	              ')': '('
	          };
	          return replacementTable[character] || character;
	      };

	      var processArabic = jsPDFAPI.processArabic = function (text, reverse) {
	          text = text || "";
	          reverse = reverse || false;

	          var result = "";
	          var i = 0;
	          var position = 0;
	          var currentLetter = "";
	          var prevLetter = "";
	          var nextLetter = "";
	          var resultingLetter;

	          var localPrevLetter;
	          var localCurrentLetter;
	          var localNextLetter;

	          for (i = 0; i < text.length; i += 1) {
	              currentLetter = text[i];
	              prevLetter = text[i - 1];
	              nextLetter = text[i + 1];
	              if (!isArabicLetter(currentLetter)) {
	                  result += reverse ? commonSubstition(currentLetter) : currentLetter;
	              } else {
	                  if (prevLetter !== undefined && prevLetter.charCodeAt(0) === 1604 && isArabicAlfLetter(currentLetter)) {
	                      localPrevLetter = text[i - 2];
	                      localCurrentLetter = currentLetter;
	                      localNextLetter = text[i + 1];
	                      position = getCorrectForm(localCurrentLetter, localPrevLetter, localNextLetter, arabiclaasubst);
	                      resultingLetter = String.fromCharCode(arabiclaasubst[currentLetter.charCodeAt(0)][position]);
	                      result = result.substr(0, result.length - 1) + resultingLetter;
	                  } else if (prevLetter !== undefined && prevLetter.charCodeAt(0) === 1617 && isArabicDiacritic(currentLetter)) {
	                      localPrevLetter = text[i - 2];
	                      localCurrentLetter = currentLetter;
	                      localNextLetter = text[i + 1];
	                      position = getCorrectForm(localCurrentLetter, localPrevLetter, localNextLetter, arabicorigsubst);
	                      resultingLetter = String.fromCharCode(arabic_diacritics[currentLetter.charCodeAt(0)][position]);
	                      result = result.substr(0, result.length - 1) + resultingLetter;
	                  } else {
	                      position = getCorrectForm(currentLetter, prevLetter, nextLetter, arabicorigsubst);
	                      result += String.fromCharCode(arabicSubst[currentLetter.charCodeAt(0)][position]);
	                  }
	              }
	          }
	          return reverse ? result.split("").reverse().join("") : result;
	      };

	      var arabicParserFunction = function arabicParserFunction(args) {
	          var text = args.text;
	          var x = args.x;
	          var y = args.y;
	          var options = args.options || {};
	          var mutex = args.mutex || {};
	          var lang = options.lang;
	          var tmpText = [];

	          if (arLangCodesKeys.indexOf(lang) >= 0) {
	              if (Object.prototype.toString.call(text) === '[object Array]') {
	                  var i = 0;
	                  tmpText = [];
	                  for (i = 0; i < text.length; i += 1) {
	                      if (Object.prototype.toString.call(text[i]) === '[object Array]') {
	                          tmpText.push([processArabic(text[i][0], true), text[i][1], text[i][2]]);
	                      } else {
	                          tmpText.push([processArabic(text[i], true)]);
	                      }
	                  }
	                  args.text = tmpText;
	              } else {
	                  args.text = processArabic(text, true);
	              }
	              //force charSpace if not given.
	              if (options.charSpace === undefined) {
	                  args.options.charSpace = 0;
	              }
	              //if R2L is true, set it false.
	              if (options.R2L === true) {
	                  args.options.R2L = false;
	              }
	          }
	      };

	      jsPDFAPI.events.push(['preProcessText', arabicParserFunction]);
	  })(jsPDF.API);

	  /**
	   * jsPDF Autoprint Plugin
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  /**
	  * Makes the PDF automatically print. This works in Chrome, Firefox, Acrobat
	  * Reader.
	  *
	  * @returns {jsPDF}
	  * @name autoPrint
	  * @example
	  * var doc = new jsPDF()
	  * doc.text(10, 10, 'This is a test')
	  * doc.autoPrint()
	  * doc.save('autoprint.pdf')
	  */

	  (function (jsPDFAPI) {

	    jsPDFAPI.autoPrint = function (options) {

	      var refAutoPrintTag;
	      options = options || {};
	      options.variant = options.variant || 'non-conform';

	      switch (options.variant) {
	        case 'javascript':
	          //https://github.com/Rob--W/pdf.js/commit/c676ecb5a0f54677b9f3340c3ef2cf42225453bb
	          this.addJS('print({});');
	          break;
	        case 'non-conform':
	        default:
	          this.internal.events.subscribe('postPutResources', function () {
	            refAutoPrintTag = this.internal.newObject();
	            this.internal.out("<<");
	            this.internal.out("/S /Named");
	            this.internal.out("/Type /Action");
	            this.internal.out("/N /Print");
	            this.internal.out(">>");
	            this.internal.out("endobj");
	          });

	          this.internal.events.subscribe("putCatalog", function () {
	            this.internal.out("/OpenAction " + refAutoPrintTag + " 0 R");
	          });
	          break;
	      }
	      return this;
	    };
	  })(jsPDF.API);

	  /**
	   * jsPDF Canvas PlugIn
	   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  /**
	   * This plugin mimics the HTML5 Canvas
	   * 
	   * The goal is to provide a way for current canvas users to print directly to a PDF.
	   */

	  (function (jsPDFAPI) {

	  	jsPDFAPI.events.push(['initialized', function () {
	  		this.canvas.pdf = this;
	  	}]);

	  	jsPDFAPI.canvas = {
	  		getContext: function getContext(name) {
	  			this.pdf.context2d._canvas = this;
	  			return this.pdf.context2d;
	  		},
	  		childNodes: []
	  	};

	  	Object.defineProperty(jsPDFAPI.canvas, 'width', {
	  		get: function get() {
	  			return this._width;
	  		},
	  		set: function set(value) {
	  			this._width = value;
	  			this.getContext('2d').pageWrapX = value + 1;
	  		}
	  	});

	  	Object.defineProperty(jsPDFAPI.canvas, 'height', {
	  		get: function get() {
	  			return this._height;
	  		},
	  		set: function set(value) {
	  			this._height = value;
	  			this.getContext('2d').pageWrapY = value + 1;
	  		}
	  	});

	  	return this;
	  })(jsPDF.API);

	  /** ====================================================================
	   * jsPDF Cell plugin
	   * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
	   *               2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
	   *               2013 Lee Driscoll, https://github.com/lsdriscoll
	   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
	   *               2014 James Hall, james@parall.ax
	   *               2014 Diego Casorran, https://github.com/diegocr
	   *
	   * 
	   * ====================================================================
	   */

	  (function (jsPDFAPI) {
	      /*jslint browser:true */
	      /*global document: false, jsPDF */

	      var fontName,
	          fontSize,
	          fontStyle,
	          padding = 3,
	          margin = 13,
	          headerFunction,
	          lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined },
	          pages = 1,
	          setLastCellPosition = function setLastCellPosition(x, y, w, h, ln) {
	          lastCellPos = { 'x': x, 'y': y, 'w': w, 'h': h, 'ln': ln };
	      },
	          getLastCellPosition = function getLastCellPosition() {
	          return lastCellPos;
	      },
	          NO_MARGINS = { left: 0, top: 0, bottom: 0 };

	      jsPDFAPI.setHeaderFunction = function (func) {
	          headerFunction = func;
	      };

	      jsPDFAPI.getTextDimensions = function (txt) {
	          fontName = this.internal.getFont().fontName;
	          fontSize = this.table_font_size || this.internal.getFontSize();
	          fontStyle = this.internal.getFont().fontStyle;
	          // 1 pixel = 0.264583 mm and 1 mm = 72/25.4 point
	          var px2pt = 0.264583 * 72 / 25.4,
	              dimensions,
	              text;

	          text = document.createElement('font');
	          text.id = "jsPDFCell";

	          try {
	              text.style.fontStyle = fontStyle;
	          } catch (e) {
	              text.style.fontWeight = fontStyle;
	          }

	          text.style.fontSize = fontSize + 'pt';
	          text.style.fontFamily = fontName;
	          try {
	              text.textContent = txt;
	          } catch (e) {
	              text.innerText = txt;
	          }

	          document.body.appendChild(text);

	          dimensions = { w: (text.offsetWidth + 1) * px2pt, h: (text.offsetHeight + 1) * px2pt };

	          document.body.removeChild(text);

	          return dimensions;
	      };

	      jsPDFAPI.cellAddPage = function () {
	          var margins = this.margins || NO_MARGINS;

	          this.addPage();

	          setLastCellPosition(margins.left, margins.top, undefined, undefined);
	          //setLastCellPosition(undefined, undefined, undefined, undefined, undefined);
	          pages += 1;
	      };

	      jsPDFAPI.cellInitialize = function () {
	          lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined };
	          pages = 1;
	      };

	      jsPDFAPI.cell = function (x, y, w, h, txt, ln, align) {
	          var curCell = getLastCellPosition();
	          var pgAdded = false;

	          // If this is not the first cell, we must change its position
	          if (curCell.ln !== undefined) {
	              if (curCell.ln === ln) {
	                  //Same line
	                  x = curCell.x + curCell.w;
	                  y = curCell.y;
	              } else {
	                  //New line
	                  var margins = this.margins || NO_MARGINS;
	                  if (curCell.y + curCell.h + h + margin >= this.internal.pageSize.getHeight() - margins.bottom) {
	                      this.cellAddPage();
	                      pgAdded = true;
	                      if (this.printHeaders && this.tableHeaderRow) {
	                          this.printHeaderRow(ln, true);
	                      }
	                  }
	                  //We ignore the passed y: the lines may have different heights
	                  y = getLastCellPosition().y + getLastCellPosition().h;
	                  if (pgAdded) y = margin + 10;
	              }
	          }

	          if (txt[0] !== undefined) {
	              if (this.printingHeaderRow) {
	                  this.rect(x, y, w, h, 'FD');
	              } else {
	                  this.rect(x, y, w, h);
	              }
	              if (align === 'right') {
	                  if (!(txt instanceof Array)) {
	                      txt = [txt];
	                  }
	                  for (var i = 0; i < txt.length; i++) {
	                      var currentLine = txt[i];
	                      var textSize = this.getStringUnitWidth(currentLine) * this.internal.getFontSize();
	                      this.text(currentLine, x + w - textSize - padding, y + this.internal.getLineHeight() * (i + 1));
	                  }
	              } else {
	                  this.text(txt, x + padding, y + this.internal.getLineHeight());
	              }
	          }
	          setLastCellPosition(x, y, w, h, ln);
	          return this;
	      };

	      /**
	       * Return the maximum value from an array
	       * @param array
	       * @param comparisonFn
	       * @returns {*}
	       */
	      jsPDFAPI.arrayMax = function (array, comparisonFn) {
	          var max = array[0],
	              i,
	              ln,
	              item;

	          for (i = 0, ln = array.length; i < ln; i += 1) {
	              item = array[i];

	              if (comparisonFn) {
	                  if (comparisonFn(max, item) === -1) {
	                      max = item;
	                  }
	              } else {
	                  if (item > max) {
	                      max = item;
	                  }
	              }
	          }

	          return max;
	      };

	      /**
	       * Create a table from a set of data.
	       * @param {Integer} [x] : left-position for top-left corner of table
	       * @param {Integer} [y] top-position for top-left corner of table
	       * @param {Object[]} [data] As array of objects containing key-value pairs corresponding to a row of data.
	       * @param {String[]} [headers] Omit or null to auto-generate headers at a performance cost
	        * @param {Object} [config.printHeaders] True to print column headers at the top of every page
	       * @param {Object} [config.autoSize] True to dynamically set the column widths to match the widest cell value
	       * @param {Object} [config.margins] margin values for left, top, bottom, and width
	       * @param {Object} [config.fontSize] Integer fontSize to use (optional)
	       */

	      jsPDFAPI.table = function (x, y, data, headers, config) {
	          if (!data) {
	              throw 'No data for PDF table';
	          }

	          var headerNames = [],
	              headerPrompts = [],
	              header,
	              i,
	              ln,
	              cln,
	              columnMatrix = {},
	              columnWidths = {},
	              columnData,
	              column,
	              columnMinWidths = [],
	              j,
	              tableHeaderConfigs = [],
	              model,
	              jln,
	              func,


	          //set up defaults. If a value is provided in config, defaults will be overwritten:
	          autoSize = false,
	              printHeaders = true,
	              fontSize = 12,
	              margins = NO_MARGINS;

	          margins.width = this.internal.pageSize.getWidth();

	          if (config) {
	              //override config defaults if the user has specified non-default behavior:
	              if (config.autoSize === true) {
	                  autoSize = true;
	              }
	              if (config.printHeaders === false) {
	                  printHeaders = false;
	              }
	              if (config.fontSize) {
	                  fontSize = config.fontSize;
	              }
	              if (config.css && typeof config.css['font-size'] !== "undefined") {
	                  fontSize = config.css['font-size'] * 16;
	              }
	              if (config.margins) {
	                  margins = config.margins;
	              }
	          }

	          /**
	           * @property {Number} lnMod
	           * Keep track of the current line number modifier used when creating cells
	           */
	          this.lnMod = 0;
	          lastCellPos = { x: undefined, y: undefined, w: undefined, h: undefined, ln: undefined }, pages = 1;

	          this.printHeaders = printHeaders;
	          this.margins = margins;
	          this.setFontSize(fontSize);
	          this.table_font_size = fontSize;

	          // Set header values
	          if (headers === undefined || headers === null) {
	              // No headers defined so we derive from data
	              headerNames = Object.keys(data[0]);
	          } else if (headers[0] && typeof headers[0] !== 'string') {
	              var px2pt = 0.264583 * 72 / 25.4;

	              // Split header configs into names and prompts
	              for (i = 0, ln = headers.length; i < ln; i += 1) {
	                  header = headers[i];
	                  headerNames.push(header.name);
	                  headerPrompts.push(header.prompt);
	                  columnWidths[header.name] = header.width * px2pt;
	              }
	          } else {
	              headerNames = headers;
	          }

	          if (autoSize) {
	              // Create a matrix of columns e.g., {column_title: [row1_Record, row2_Record]}
	              func = function func(rec) {
	                  return rec[header];
	              };

	              for (i = 0, ln = headerNames.length; i < ln; i += 1) {
	                  header = headerNames[i];

	                  columnMatrix[header] = data.map(func);

	                  // get header width
	                  columnMinWidths.push(this.getTextDimensions(headerPrompts[i] || header).w);
	                  column = columnMatrix[header];

	                  // get cell widths
	                  for (j = 0, cln = column.length; j < cln; j += 1) {
	                      columnData = column[j];
	                      columnMinWidths.push(this.getTextDimensions(columnData).w);
	                  }

	                  // get final column width
	                  columnWidths[header] = jsPDFAPI.arrayMax(columnMinWidths);

	                  //have to reset
	                  columnMinWidths = [];
	              }
	          }

	          // -- Construct the table

	          if (printHeaders) {
	              var lineHeight = this.calculateLineHeight(headerNames, columnWidths, headerPrompts.length ? headerPrompts : headerNames);

	              // Construct the header row
	              for (i = 0, ln = headerNames.length; i < ln; i += 1) {
	                  header = headerNames[i];
	                  tableHeaderConfigs.push([x, y, columnWidths[header], lineHeight, String(headerPrompts.length ? headerPrompts[i] : header)]);
	              }

	              // Store the table header config
	              this.setTableHeaderRow(tableHeaderConfigs);

	              // Print the header for the start of the table
	              this.printHeaderRow(1, false);
	          }

	          // Construct the data rows
	          for (i = 0, ln = data.length; i < ln; i += 1) {
	              var lineHeight;
	              model = data[i];
	              lineHeight = this.calculateLineHeight(headerNames, columnWidths, model);

	              for (j = 0, jln = headerNames.length; j < jln; j += 1) {
	                  header = headerNames[j];
	                  this.cell(x, y, columnWidths[header], lineHeight, model[header], i + 2, header.align);
	              }
	          }
	          this.lastCellPos = lastCellPos;
	          this.table_x = x;
	          this.table_y = y;
	          return this;
	      };
	      /**
	       * Calculate the height for containing the highest column
	       * @param {String[]} headerNames is the header, used as keys to the data
	       * @param {Integer[]} columnWidths is size of each column
	       * @param {Object[]} model is the line of data we want to calculate the height of
	       */
	      jsPDFAPI.calculateLineHeight = function (headerNames, columnWidths, model) {
	          var header,
	              lineHeight = 0;
	          for (var j = 0; j < headerNames.length; j++) {
	              header = headerNames[j];
	              model[header] = this.splitTextToSize(String(model[header]), columnWidths[header] - padding);
	              var h = this.internal.getLineHeight() * model[header].length + padding;
	              if (h > lineHeight) lineHeight = h;
	          }
	          return lineHeight;
	      };

	      /**
	       * Store the config for outputting a table header
	       * @param {Object[]} config
	       * An array of cell configs that would define a header row: Each config matches the config used by jsPDFAPI.cell
	       * except the ln parameter is excluded
	       */
	      jsPDFAPI.setTableHeaderRow = function (config) {
	          this.tableHeaderRow = config;
	      };

	      /**
	       * Output the store header row
	       * @param lineNumber The line number to output the header at
	       */
	      jsPDFAPI.printHeaderRow = function (lineNumber, new_page) {
	          if (!this.tableHeaderRow) {
	              throw 'Property tableHeaderRow does not exist.';
	          }

	          var tableHeaderCell, tmpArray, i, ln;

	          this.printingHeaderRow = true;
	          if (headerFunction !== undefined) {
	              var position = headerFunction(this, pages);
	              setLastCellPosition(position[0], position[1], position[2], position[3], -1);
	          }
	          this.setFontStyle('bold');
	          var tempHeaderConf = [];
	          for (i = 0, ln = this.tableHeaderRow.length; i < ln; i += 1) {
	              this.setFillColor(200, 200, 200);

	              tableHeaderCell = this.tableHeaderRow[i];
	              if (new_page) {
	                  this.margins.top = margin;
	                  tableHeaderCell[1] = this.margins && this.margins.top || 0;
	                  tempHeaderConf.push(tableHeaderCell);
	              }
	              tmpArray = [].concat(tableHeaderCell);
	              this.cell.apply(this, tmpArray.concat(lineNumber));
	          }
	          if (tempHeaderConf.length > 0) {
	              this.setTableHeaderRow(tempHeaderConf);
	          }
	          this.setFontStyle('normal');
	          this.printingHeaderRow = false;
	      };
	  })(jsPDF.API);

	  /**
	   * jsPDF Context2D PlugIn Copyright (c) 2014 Steven Spungin (TwelveTone LLC) steven@twelvetone.tv
	   *
	   * Licensed under the MIT License. http://opensource.org/licenses/mit-license
	   */

	  /**
	   * This plugin mimics the HTML5 Canvas's context2d.
	   *
	   * The goal is to provide a way for current canvas implementations to print directly to a PDF.
	   */

	  /**
	   * TODO implement stroke opacity (refactor from fill() method )
	   * TODO transform angle and radii parameters
	   */

	  /**
	   * require('jspdf.js'); require('lib/css_colors.js');
	   */

	  (function (jsPDFAPI) {

	      jsPDFAPI.events.push(['initialized', function () {
	          this.context2d.pdf = this;
	          this.context2d.internal.pdf = this;
	          this.context2d.ctx = new context();
	          this.context2d.ctxStack = [];
	          this.context2d.path = [];
	      }]);

	      jsPDFAPI.context2d = {
	          pageWrapXEnabled: false,
	          pageWrapYEnabled: false,
	          pageWrapX: 9999999,
	          pageWrapY: 9999999,
	          ctx: new context(),
	          f2: function f2(number) {
	              return number.toFixed(2);
	          },

	          fillRect: function fillRect(x, y, w, h) {
	              if (this._isFillTransparent()) {
	                  return;
	              }
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xRect = this._matrix_map_rect(this.ctx._transform, { x: x, y: y, w: w, h: h });
	              this.pdf.rect(xRect.x, xRect.y, xRect.w, xRect.h, "f");
	          },

	          strokeRect: function strokeRect(x, y, w, h) {
	              if (this._isStrokeTransparent()) {
	                  return;
	              }
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xRect = this._matrix_map_rect(this.ctx._transform, { x: x, y: y, w: w, h: h });
	              this.pdf.rect(xRect.x, xRect.y, xRect.w, xRect.h, "s");
	          },

	          /**
	           * We cannot clear PDF commands that were already written to PDF, so we use white instead. <br />
	           * As a special case, read a special flag (ignoreClearRect) and do nothing if it is set.
	           * This results in all calls to clearRect() to do nothing, and keep the canvas transparent.
	           * This flag is stored in the save/restore context and is managed the same way as other drawing states.
	           * @param x
	           * @param y
	           * @param w
	           * @param h
	           */
	          clearRect: function clearRect(x, y, w, h) {
	              if (this.ctx.ignoreClearRect) {
	                  return;
	              }

	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xRect = this._matrix_map_rect(this.ctx._transform, { x: x, y: y, w: w, h: h });
	              this.save();
	              this.setFillStyle('#ffffff');
	              //TODO This is hack to fill with white.
	              this.pdf.rect(xRect.x, xRect.y, xRect.w, xRect.h, "f");
	              this.restore();
	          },

	          save: function save() {
	              this.ctx._fontSize = this.pdf.internal.getFontSize();
	              var ctx = new context();
	              ctx.copy(this.ctx);
	              this.ctxStack.push(this.ctx);
	              this.ctx = ctx;
	          },

	          restore: function restore() {
	              this.ctx = this.ctxStack.pop();
	              this.setFillStyle(this.ctx.fillStyle);
	              this.setStrokeStyle(this.ctx.strokeStyle);
	              this.setFont(this.ctx.font);
	              this.pdf.setFontSize(this.ctx._fontSize);
	              this.setLineCap(this.ctx.lineCap);
	              this.setLineWidth(this.ctx.lineWidth);
	              this.setLineJoin(this.ctx.lineJoin);
	          },

	          rect: function rect(x, y, w, h) {
	              this.moveTo(x, y);
	              this.lineTo(x + w, y);
	              this.lineTo(x + w, y + h);
	              this.lineTo(x, y + h);
	              this.lineTo(x, y); //TODO not needed
	              this.closePath();
	          },

	          beginPath: function beginPath() {
	              this.path = [];
	          },

	          closePath: function closePath() {
	              this.path.push({
	                  type: 'close'
	              });
	          },

	          _getRGBA: function _getRGBA(style) {
	              // get the decimal values of r, g, and b;
	              var r, g, b, a;
	              var rgbColor = new RGBColor(style);

	              if (!style) {
	                  return { r: 0, g: 0, b: 0, a: 0, style: style };
	              }

	              if (this.internal.rxTransparent.test(style)) {
	                  r = 0;
	                  g = 0;
	                  b = 0;
	                  a = 0;
	              } else {
	                  var m = this.internal.rxRgb.exec(style);
	                  if (m != null) {
	                      r = parseInt(m[1]);
	                      g = parseInt(m[2]);
	                      b = parseInt(m[3]);
	                      a = 1;
	                  } else {
	                      m = this.internal.rxRgba.exec(style);
	                      if (m != null) {
	                          r = parseInt(m[1]);
	                          g = parseInt(m[2]);
	                          b = parseInt(m[3]);
	                          a = parseFloat(m[4]);
	                      } else {
	                          a = 1;
	                          if (style.charAt(0) != '#') {
	                              if (rgbColor.ok) {
	                                  style = rgbColor.toHex();
	                              } else {
	                                  style = '#000000';
	                              }
	                          }

	                          if (style.length === 4) {
	                              r = style.substring(1, 2);
	                              r += r;
	                              g = style.substring(2, 3);
	                              g += g;
	                              b = style.substring(3, 4);
	                              b += b;
	                          } else {
	                              r = style.substring(1, 3);
	                              g = style.substring(3, 5);
	                              b = style.substring(5, 7);
	                          }
	                          r = parseInt(r, 16);
	                          g = parseInt(g, 16);
	                          b = parseInt(b, 16);
	                      }
	                  }
	              }
	              return { r: r, g: g, b: b, a: a, style: style };
	          },

	          setFillStyle: function setFillStyle(style) {
	              var rgba = this._getRGBA(style);

	              this.ctx.fillStyle = style;
	              this.ctx._isFillTransparent = rgba.a === 0;
	              this.ctx._fillOpacity = rgba.a;

	              this.pdf.setFillColor(rgba.r, rgba.g, rgba.b, {
	                  a: rgba.a
	              });
	              this.pdf.setTextColor(rgba.r, rgba.g, rgba.b, {
	                  a: rgba.a
	              });
	          },

	          setStrokeStyle: function setStrokeStyle(style) {
	              var rgba = this._getRGBA(style);

	              this.ctx.strokeStyle = rgba.style;
	              this.ctx._isStrokeTransparent = rgba.a === 0;
	              this.ctx._strokeOpacity = rgba.a;

	              //TODO jsPDF to handle rgba
	              if (rgba.a === 0) {
	                  this.pdf.setDrawColor(255, 255, 255);
	              } else if (rgba.a === 1) {
	                  this.pdf.setDrawColor(rgba.r, rgba.g, rgba.b);
	              } else {
	                  //this.pdf.setDrawColor(rgba.r, rgba.g, rgba.b, {a: rgba.a});
	                  this.pdf.setDrawColor(rgba.r, rgba.g, rgba.b);
	              }
	          },

	          fillText: function fillText(text, x, y, maxWidth) {
	              if (this._isFillTransparent()) {
	                  return;
	              }
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xpt = this._matrix_map_point(this.ctx._transform, [x, y]);
	              x = xpt[0];
	              y = xpt[1];
	              var rads = this._matrix_rotation(this.ctx._transform);
	              var degs = rads * 57.2958;

	              //TODO only push the clip if it has not been applied to the current PDF context
	              if (this.ctx._clip_path.length > 0) {
	                  var lines;
	                  if (window.outIntercept) {
	                      lines = window.outIntercept.type === 'group' ? window.outIntercept.stream : window.outIntercept;
	                  } else {
	                      lines = this.internal.getCurrentPage();
	                  }
	                  lines.push("q");
	                  var origPath = this.path;
	                  this.path = this.ctx._clip_path;
	                  this.ctx._clip_path = [];
	                  this._fill(null, true);
	                  this.ctx._clip_path = this.path;
	                  this.path = origPath;
	              }

	              // We only use X axis as scale hint 
	              var scale = 1;
	              try {
	                  scale = this._matrix_decompose(this._getTransform()).scale[0];
	              } catch (e) {
	                  console.warn(e);
	              }

	              // In some cases the transform was very small (5.715760606202283e-17).  Most likely a canvg rounding error.
	              if (scale < 0.01) {
	                  this.pdf.text(text, x, this._getBaseline(y), null, degs);
	              } else {
	                  var oldSize = this.pdf.internal.getFontSize();
	                  this.pdf.setFontSize(oldSize * scale);
	                  this.pdf.text(text, x, this._getBaseline(y), null, degs);
	                  this.pdf.setFontSize(oldSize);
	              }

	              if (this.ctx._clip_path.length > 0) {
	                  lines.push('Q');
	              }
	          },

	          strokeText: function strokeText(text, x, y, maxWidth) {
	              if (this._isStrokeTransparent()) {
	                  return;
	              }
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xpt = this._matrix_map_point(this.ctx._transform, [x, y]);
	              x = xpt[0];
	              y = xpt[1];
	              var rads = this._matrix_rotation(this.ctx._transform);
	              var degs = rads * 57.2958;

	              //TODO only push the clip if it has not been applied to the current PDF context
	              if (this.ctx._clip_path.length > 0) {
	                  var lines;
	                  if (window.outIntercept) {
	                      lines = window.outIntercept.type === 'group' ? window.outIntercept.stream : window.outIntercept;
	                  } else {
	                      lines = this.internal.getCurrentPage();
	                  }
	                  lines.push("q");
	                  var origPath = this.path;
	                  this.path = this.ctx._clip_path;
	                  this.ctx._clip_path = [];
	                  this._fill(null, true);
	                  this.ctx._clip_path = this.path;
	                  this.path = origPath;
	              }

	              var scale = 1;
	              // We only use the X axis as scale hint 
	              try {
	                  scale = this._matrix_decompose(this._getTransform()).scale[0];
	              } catch (e) {
	                  console.warn(e);
	              }

	              if (scale === 1) {
	                  this.pdf.text(text, x, this._getBaseline(y), {
	                      stroke: true
	                  }, degs);
	              } else {
	                  var oldSize = this.pdf.internal.getFontSize();
	                  this.pdf.setFontSize(oldSize * scale);
	                  this.pdf.text(text, x, this._getBaseline(y), {
	                      stroke: true
	                  }, degs);
	                  this.pdf.setFontSize(oldSize);
	              }

	              if (this.ctx._clip_path.length > 0) {
	                  lines.push('Q');
	              }
	          },

	          setFont: function setFont(font) {
	              this.ctx.font = font;

	              //var rx = /\s*(\w+)\s+(\w+)\s+(\w+)\s+([\d\.]+)(px|pt|em)\s+["']?(\w+)['"]?/;
	              var rx = /\s*(\w+)\s+(\w+)\s+(\w+)\s+([\d\.]+)(px|pt|em)\s+(.*)?/;
	              m = rx.exec(font);
	              if (m != null) {
	                  var fontStyle = m[1];
	                  var fontVariant = m[2];
	                  var fontWeight = m[3];
	                  var fontSize = m[4];
	                  var fontSizeUnit = m[5];
	                  var fontFamily = m[6];

	                  if ('px' === fontSizeUnit) {
	                      fontSize = Math.floor(parseFloat(fontSize));
	                      // fontSize = fontSize * 1.25;
	                  } else if ('em' === fontSizeUnit) {
	                      fontSize = Math.floor(parseFloat(fontSize) * this.pdf.getFontSize());
	                  } else {
	                      fontSize = Math.floor(parseFloat(fontSize));
	                  }

	                  this.pdf.setFontSize(fontSize);

	                  if (fontWeight === 'bold' || fontWeight === '700') {
	                      this.pdf.setFontStyle('bold');
	                  } else {
	                      if (fontStyle === 'italic') {
	                          this.pdf.setFontStyle('italic');
	                      } else {
	                          this.pdf.setFontStyle('normal');
	                      }
	                  }
	                  var style;
	                  if ('bold' === fontWeight || fontWeight === '700') {
	                      style = fontStyle === 'italic' ? 'bolditalic' : 'bold';
	                  } else if (fontStyle === 'italic') {
	                      style = 'italic';
	                  } else {
	                      style = 'normal';
	                  }

	                  var parts = fontFamily.toLowerCase().split(/\s*,\s*/);
	                  var jsPdfFontName = 'Times';

	                  for (var i = 0; i < parts.length; i++) {
	                      if (this.pdf.internal.getFont(parts[i], style, { noFallback: true, disableWarning: true }) !== undefined) {
	                          jsPdfFontName = parts[i];
	                          break;
	                      } else if (style === 'bolditalic' && this.pdf.internal.getFont(parts[i], 'bold', { noFallback: true, disableWarning: true }) !== undefined) {
	                          jsPdfFontName = parts[i];
	                          style = 'bold';
	                      } else if (this.pdf.internal.getFont(parts[i], 'normal', { noFallback: true, disableWarning: true }) !== undefined) {
	                          jsPdfFontName = parts[i];
	                          style = 'normal';
	                          break;
	                      }
	                  }

	                  this.pdf.setFont(jsPdfFontName, style);
	              } else {
	                  var rx = /\s*(\d+)(pt|px|em)\s+([\w "]+)\s*([\w "]+)?/;
	                  var m = rx.exec(font);
	                  if (m != null) {
	                      var size = m[1];
	                      var unit = m[2];
	                      var name = m[3];
	                      var style = m[4];
	                      if (!style) {
	                          style = 'normal';
	                      }
	                      if ('em' === fontSizeUnit) {
	                          size = Math.floor(parseFloat(fontSize) * this.pdf.getFontSize());
	                      } else {
	                          size = Math.floor(parseFloat(size));
	                      }
	                      this.pdf.setFontSize(size);
	                      this.pdf.setFont(name, style);
	                  }
	              }
	          },

	          setTextBaseline: function setTextBaseline(baseline) {
	              this.ctx.textBaseline = baseline;
	          },

	          getTextBaseline: function getTextBaseline() {
	              return this.ctx.textBaseline;
	          },

	          //TODO implement textAlign
	          setTextAlign: function setTextAlign(align) {
	              this.ctx.textAlign = align;
	          },

	          getTextAlign: function getTextAlign() {
	              return this.ctx.textAlign;
	          },

	          setLineWidth: function setLineWidth(width) {
	              this.ctx.lineWidth = width;
	              this.pdf.setLineWidth(width);
	          },

	          setLineCap: function setLineCap(style) {
	              this.ctx.lineCap = style;
	              this.pdf.setLineCap(style);
	          },

	          setLineJoin: function setLineJoin(style) {
	              this.ctx.lineJoin = style;
	              this.pdf.setLineJoin(style);
	          },

	          moveTo: function moveTo(x, y) {
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xpt = this._matrix_map_point(this.ctx._transform, [x, y]);
	              x = xpt[0];
	              y = xpt[1];

	              var obj = {
	                  type: 'mt',
	                  x: x,
	                  y: y
	              };
	              this.path.push(obj);
	          },

	          _wrapX: function _wrapX(x) {
	              if (this.pageWrapXEnabled) {
	                  return x % this.pageWrapX;
	              } else {
	                  return x;
	              }
	          },

	          _wrapY: function _wrapY(y) {
	              if (this.pageWrapYEnabled) {
	                  this._gotoPage(this._page(y));
	                  return (y - this.lastBreak) % this.pageWrapY;
	              } else {
	                  return y;
	              }
	          },

	          transform: function transform(a, b, c, d, e, f) {
	              this.ctx._transform = this._matrix_multiply(this.ctx._transform, [a, b, c, d, e, f]);
	          },

	          setTransform: function setTransform(a, b, c, d, e, f) {
	              this.ctx._transform = [a, b, c, d, e, f];
	          },

	          _getTransform: function _getTransform() {
	              return this.ctx._transform;
	          },

	          lastBreak: 0,
	          // Y Position of page breaks.
	          pageBreaks: [],
	          // returns: One-based Page Number
	          // Should only be used if pageWrapYEnabled is true
	          _page: function _page(y) {
	              if (this.pageWrapYEnabled) {
	                  this.lastBreak = 0;
	                  var manualBreaks = 0;
	                  var autoBreaks = 0;
	                  for (var i = 0; i < this.pageBreaks.length; i++) {
	                      if (y >= this.pageBreaks[i]) {
	                          manualBreaks++;
	                          if (this.lastBreak === 0) {
	                              autoBreaks++;
	                          }
	                          var spaceBetweenLastBreak = this.pageBreaks[i] - this.lastBreak;
	                          this.lastBreak = this.pageBreaks[i];
	                          var pagesSinceLastBreak = Math.floor(spaceBetweenLastBreak / this.pageWrapY);
	                          autoBreaks += pagesSinceLastBreak;
	                      }
	                  }
	                  if (this.lastBreak === 0) {
	                      var pagesSinceLastBreak = Math.floor(y / this.pageWrapY) + 1;
	                      autoBreaks += pagesSinceLastBreak;
	                  }
	                  return autoBreaks + manualBreaks;
	              } else {
	                  return this.pdf.internal.getCurrentPageInfo().pageNumber;
	              }
	          },

	          _gotoPage: function _gotoPage(pageOneBased) {
	              // This is a stub to be overriden if needed
	          },

	          lineTo: function lineTo(x, y) {
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xpt = this._matrix_map_point(this.ctx._transform, [x, y]);
	              x = xpt[0];
	              y = xpt[1];

	              var obj = {
	                  type: 'lt',
	                  x: x,
	                  y: y
	              };
	              this.path.push(obj);
	          },

	          bezierCurveTo: function bezierCurveTo(x1, y1, x2, y2, x, y) {
	              x1 = this._wrapX(x1);
	              y1 = this._wrapY(y1);
	              x2 = this._wrapX(x2);
	              y2 = this._wrapY(y2);
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xpt;
	              xpt = this._matrix_map_point(this.ctx._transform, [x, y]);
	              x = xpt[0];
	              y = xpt[1];
	              xpt = this._matrix_map_point(this.ctx._transform, [x1, y1]);
	              x1 = xpt[0];
	              y1 = xpt[1];
	              xpt = this._matrix_map_point(this.ctx._transform, [x2, y2]);
	              x2 = xpt[0];
	              y2 = xpt[1];

	              var obj = {
	                  type: 'bct',
	                  x1: x1,
	                  y1: y1,
	                  x2: x2,
	                  y2: y2,
	                  x: x,
	                  y: y
	              };
	              this.path.push(obj);
	          },

	          quadraticCurveTo: function quadraticCurveTo(x1, y1, x, y) {
	              x1 = this._wrapX(x1);
	              y1 = this._wrapY(y1);
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xpt;
	              xpt = this._matrix_map_point(this.ctx._transform, [x, y]);
	              x = xpt[0];
	              y = xpt[1];
	              xpt = this._matrix_map_point(this.ctx._transform, [x1, y1]);
	              x1 = xpt[0];
	              y1 = xpt[1];

	              var obj = {
	                  type: 'qct',
	                  x1: x1,
	                  y1: y1,
	                  x: x,
	                  y: y
	              };
	              this.path.push(obj);
	          },

	          arc: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              if (!this._matrix_is_identity(this.ctx._transform)) {
	                  var xpt = this._matrix_map_point(this.ctx._transform, [x, y]);
	                  x = xpt[0];
	                  y = xpt[1];

	                  var x_radPt0 = this._matrix_map_point(this.ctx._transform, [0, 0]);
	                  var x_radPt = this._matrix_map_point(this.ctx._transform, [0, radius]);
	                  radius = Math.sqrt(Math.pow(x_radPt[0] - x_radPt0[0], 2) + Math.pow(x_radPt[1] - x_radPt0[1], 2));

	                  //TODO angles need to be transformed
	              }

	              var obj = {
	                  type: 'arc',
	                  x: x,
	                  y: y,
	                  radius: radius,
	                  startAngle: startAngle,
	                  endAngle: endAngle,
	                  anticlockwise: anticlockwise
	              };
	              this.path.push(obj);
	          },

	          drawImage: function drawImage(img, x, y, w, h, x2, y2, w2, h2) {
	              if (x2 !== undefined) {
	                  x = x2;
	                  y = y2;
	                  w = w2;
	                  h = h2;
	              }
	              x = this._wrapX(x);
	              y = this._wrapY(y);

	              var xRect = this._matrix_map_rect(this.ctx._transform, { x: x, y: y, w: w, h: h });
	              var xRect2 = this._matrix_map_rect(this.ctx._transform, { x: x2, y: y2, w: w2, h: h2 });

	              // TODO implement source clipping and image scaling
	              var format;
	              var rx = /data:image\/(\w+).*/i;
	              var m = rx.exec(img);
	              if (m != null) {
	                  format = m[1];
	              } else {
	                  // format = "jpeg";
	                  format = "png";
	              }

	              this.pdf.addImage(img, format, xRect.x, xRect.y, xRect.w, xRect.h);
	          },

	          /**
	           * Multiply the first matrix by the second
	           * @param m1
	           * @param m2
	           * @returns {*[]}
	           * @private
	           */
	          _matrix_multiply: function _matrix_multiply(m2, m1) {
	              var sx = m1[0];
	              var shy = m1[1];
	              var shx = m1[2];
	              var sy = m1[3];
	              var tx = m1[4];
	              var ty = m1[5];

	              var t0 = sx * m2[0] + shy * m2[2];
	              var t2 = shx * m2[0] + sy * m2[2];
	              var t4 = tx * m2[0] + ty * m2[2] + m2[4];
	              shy = sx * m2[1] + shy * m2[3];
	              sy = shx * m2[1] + sy * m2[3];
	              ty = tx * m2[1] + ty * m2[3] + m2[5];
	              sx = t0;
	              shx = t2;
	              tx = t4;

	              return [sx, shy, shx, sy, tx, ty];
	          },

	          _matrix_rotation: function _matrix_rotation(m) {
	              return Math.atan2(m[2], m[0]);
	          },

	          _matrix_decompose: function _matrix_decompose(matrix) {

	              var a = matrix[0];
	              var b = matrix[1];
	              var c = matrix[2];
	              var d = matrix[3];

	              var scaleX = Math.sqrt(a * a + b * b);
	              a /= scaleX;
	              b /= scaleX;

	              var shear = a * c + b * d;
	              c -= a * shear;
	              d -= b * shear;

	              var scaleY = Math.sqrt(c * c + d * d);
	              c /= scaleY;
	              d /= scaleY;
	              shear /= scaleY;

	              if (a * d < b * c) {
	                  a = -a;
	                  b = -b;
	                  shear = -shear;
	                  scaleX = -scaleX;
	              }

	              return {
	                  scale: [scaleX, 0, 0, scaleY, 0, 0],
	                  translate: [1, 0, 0, 1, matrix[4], matrix[5]],
	                  rotate: [a, b, -b, a, 0, 0],
	                  skew: [1, 0, shear, 1, 0, 0]
	              };
	          },

	          _matrix_map_point: function _matrix_map_point(m1, pt) {
	              var sx = m1[0];
	              var shy = m1[1];
	              var shx = m1[2];
	              var sy = m1[3];
	              var tx = m1[4];
	              var ty = m1[5];

	              var px = pt[0];
	              var py = pt[1];

	              var x = px * sx + py * shx + tx;
	              var y = px * shy + py * sy + ty;
	              return [x, y];
	          },

	          _matrix_map_point_obj: function _matrix_map_point_obj(m1, pt) {
	              var xpt = this._matrix_map_point(m1, [pt.x, pt.y]);
	              return { x: xpt[0], y: xpt[1] };
	          },

	          _matrix_map_rect: function _matrix_map_rect(m1, rect) {
	              var p1 = this._matrix_map_point(m1, [rect.x, rect.y]);
	              var p2 = this._matrix_map_point(m1, [rect.x + rect.w, rect.y + rect.h]);
	              return { x: p1[0], y: p1[1], w: p2[0] - p1[0], h: p2[1] - p1[1] };
	          },

	          _matrix_is_identity: function _matrix_is_identity(m1) {
	              if (m1[0] != 1) {
	                  return false;
	              }
	              if (m1[1] != 0) {
	                  return false;
	              }
	              if (m1[2] != 0) {
	                  return false;
	              }
	              if (m1[3] != 1) {
	                  return false;
	              }
	              if (m1[4] != 0) {
	                  return false;
	              }
	              if (m1[5] != 0) {
	                  return false;
	              }
	              return true;
	          },

	          rotate: function rotate(angle) {
	              var matrix = [Math.cos(angle), Math.sin(angle), -Math.sin(angle), Math.cos(angle), 0.0, 0.0];
	              this.ctx._transform = this._matrix_multiply(this.ctx._transform, matrix);
	          },

	          scale: function scale(sx, sy) {
	              var matrix = [sx, 0.0, 0.0, sy, 0.0, 0.0];
	              this.ctx._transform = this._matrix_multiply(this.ctx._transform, matrix);
	          },

	          translate: function translate(x, y) {
	              var matrix = [1.0, 0.0, 0.0, 1.0, x, y];
	              this.ctx._transform = this._matrix_multiply(this.ctx._transform, matrix);
	          },

	          stroke: function stroke() {
	              if (this.ctx._clip_path.length > 0) {

	                  var lines;
	                  if (window.outIntercept) {
	                      lines = window.outIntercept.type === 'group' ? window.outIntercept.stream : window.outIntercept;
	                  } else {
	                      lines = this.internal.getCurrentPage();
	                  }
	                  lines.push("q");

	                  var origPath = this.path;
	                  this.path = this.ctx._clip_path;
	                  this.ctx._clip_path = [];
	                  this._stroke(true);

	                  this.ctx._clip_path = this.path;
	                  this.path = origPath;
	                  this._stroke(false);

	                  lines.push("Q");
	              } else {
	                  this._stroke(false);
	              }
	          },

	          _stroke: function _stroke(isClip) {
	              if (!isClip && this._isStrokeTransparent()) {
	                  return;
	              }

	              //TODO opacity

	              var moves = [];

	              var xPath = this.path;

	              for (var i = 0; i < xPath.length; i++) {
	                  var pt = xPath[i];
	                  switch (pt.type) {
	                      case 'mt':
	                          moves.push({ start: pt, deltas: [], abs: [] });
	                          break;
	                      case 'lt':
	                          var delta = [pt.x - xPath[i - 1].x, pt.y - xPath[i - 1].y];
	                          moves[moves.length - 1].deltas.push(delta);
	                          moves[moves.length - 1].abs.push(pt);
	                          break;
	                      case 'bct':
	                          var delta = [pt.x1 - xPath[i - 1].x, pt.y1 - xPath[i - 1].y, pt.x2 - xPath[i - 1].x, pt.y2 - xPath[i - 1].y, pt.x - xPath[i - 1].x, pt.y - xPath[i - 1].y];
	                          moves[moves.length - 1].deltas.push(delta);
	                          break;
	                      case 'qct':
	                          // convert to bezier
	                          var x1 = xPath[i - 1].x + 2.0 / 3.0 * (pt.x1 - xPath[i - 1].x);
	                          var y1 = xPath[i - 1].y + 2.0 / 3.0 * (pt.y1 - xPath[i - 1].y);
	                          var x2 = pt.x + 2.0 / 3.0 * (pt.x1 - pt.x);
	                          var y2 = pt.y + 2.0 / 3.0 * (pt.y1 - pt.y);
	                          var x3 = pt.x;
	                          var y3 = pt.y;
	                          var delta = [x1 - xPath[i - 1].x, y1 - xPath[i - 1].y, x2 - xPath[i - 1].x, y2 - xPath[i - 1].y, x3 - xPath[i - 1].x, y3 - xPath[i - 1].y];
	                          moves[moves.length - 1].deltas.push(delta);
	                          break;
	                      case 'arc':
	                          //TODO this was hack to avoid out-of-bounds issue
	                          // No move-to before drawing the arc
	                          if (moves.length == 0) {
	                              moves.push({ start: { x: 0, y: 0 }, deltas: [], abs: [] });
	                          }
	                          moves[moves.length - 1].arc = true;
	                          if (Array.isArray(moves[moves.length - 1].abs)) {
	                              moves[moves.length - 1].abs.push(pt);
	                          }
	                          break;
	                      case 'close':
	                          break;
	                  }
	              }

	              for (var i = 0; i < moves.length; i++) {
	                  var style;
	                  if (i == moves.length - 1) {
	                      style = 's';
	                  } else {
	                      style = null;
	                  }
	                  if (moves[i].arc) {
	                      var arcs = moves[i].abs;
	                      for (var ii = 0; ii < arcs.length; ii++) {
	                          var arc = arcs[ii];
	                          var start = arc.startAngle * 360 / (2 * Math.PI);
	                          var end = arc.endAngle * 360 / (2 * Math.PI);
	                          var x = arc.x;
	                          var y = arc.y;
	                          this.internal.arc2(this, x, y, arc.radius, start, end, arc.anticlockwise, style, isClip);
	                      }
	                  } else {
	                      var x = moves[i].start.x;
	                      var y = moves[i].start.y;
	                      if (!isClip) {
	                          this.pdf.lines(moves[i].deltas, x, y, null, style);
	                      } else {
	                          this.pdf.lines(moves[i].deltas, x, y, null, null);
	                          this.pdf.clip_fixed();
	                      }
	                  }
	              }
	          },

	          _isFillTransparent: function _isFillTransparent() {
	              return this.ctx._isFillTransparent || this.globalAlpha == 0;
	          },

	          _isStrokeTransparent: function _isStrokeTransparent() {
	              return this.ctx._isStrokeTransparent || this.globalAlpha == 0;
	          },

	          fill: function fill(fillRule) {
	              //evenodd or nonzero (default)
	              if (this.ctx._clip_path.length > 0) {

	                  var lines;
	                  if (window.outIntercept) {
	                      lines = window.outIntercept.type === 'group' ? window.outIntercept.stream : window.outIntercept;
	                  } else {
	                      lines = this.internal.getCurrentPage();
	                  }
	                  lines.push("q");

	                  var origPath = this.path;
	                  this.path = this.ctx._clip_path;
	                  this.ctx._clip_path = [];
	                  this._fill(fillRule, true);

	                  this.ctx._clip_path = this.path;
	                  this.path = origPath;
	                  this._fill(fillRule, false);

	                  lines.push('Q');
	              } else {
	                  this._fill(fillRule, false);
	              }
	          },

	          _fill: function _fill(fillRule, isClip) {
	              if (this._isFillTransparent()) {
	                  return;
	              }
	              var v2Support = typeof this.pdf.internal.newObject2 === 'function';

	              var lines;
	              if (window.outIntercept) {
	                  lines = window.outIntercept.type === 'group' ? window.outIntercept.stream : window.outIntercept;
	              } else {
	                  lines = this.internal.getCurrentPage();
	              }

	              // if (this.ctx._clip_path.length > 0) {
	              //     lines.push('q');
	              //     var oldPath = this.path;
	              //     this.path = this.ctx._clip_path;
	              //     this.ctx._clip_path = [];
	              //     this._fill(fillRule, true);
	              //     this.ctx._clip_path = this.path;
	              //     this.path = oldPath;
	              //     lines.push('Q');
	              // }

	              var moves = [];
	              var outInterceptOld = window.outIntercept;

	              if (v2Support) {
	                  // Blend and Mask
	                  switch (this.ctx.globalCompositeOperation) {
	                      case 'normal':
	                      case 'source-over':
	                          break;
	                      case 'destination-in':
	                      case 'destination-out':
	                          //TODO this need to be added to the current group or page
	                          // define a mask stream
	                          var obj = this.pdf.internal.newStreamObject();

	                          // define a mask state
	                          var obj2 = this.pdf.internal.newObject2();
	                          obj2.push('<</Type /ExtGState');
	                          obj2.push('/SMask <</S /Alpha /G ' + obj.objId + ' 0 R>>'); // /S /Luminosity will need to define color space
	                          obj2.push('>>');

	                          // add mask to page resources
	                          var gsName = 'MASK' + obj2.objId;
	                          this.pdf.internal.addGraphicsState(gsName, obj2.objId);

	                          var instruction = '/' + gsName + ' gs';
	                          // add mask to page, group, or stream
	                          lines.splice(0, 0, 'q');
	                          lines.splice(1, 0, instruction);
	                          lines.push('Q');

	                          window.outIntercept = obj;
	                          break;
	                      default:
	                          var dictionaryEntry = '/' + this.pdf.internal.blendModeMap[this.ctx.globalCompositeOperation.toUpperCase()];
	                          if (dictionaryEntry) {
	                              this.pdf.internal.out(dictionaryEntry + ' gs');
	                          }
	                          break;
	                  }
	              }

	              var alpha = this.ctx.globalAlpha;
	              if (this.ctx._fillOpacity < 1) {
	                  // TODO combine this with global opacity
	                  alpha = this.ctx._fillOpacity;
	              }

	              //TODO check for an opacity graphics state that was already created
	              //TODO do not set opacity if current value is already active
	              if (v2Support) {
	                  var objOpac = this.pdf.internal.newObject2();
	                  objOpac.push('<</Type /ExtGState');
	                  //objOpac.push(this.ctx.globalAlpha + " CA"); // Stroke
	                  //objOpac.push(this.ctx.globalAlpha + " ca"); // Not Stroke
	                  objOpac.push('/CA ' + alpha); // Stroke
	                  objOpac.push('/ca ' + alpha); // Not Stroke
	                  objOpac.push('>>');
	                  var gsName = 'GS_O_' + objOpac.objId;
	                  this.pdf.internal.addGraphicsState(gsName, objOpac.objId);
	                  this.pdf.internal.out('/' + gsName + ' gs');
	              }

	              var xPath = this.path;

	              for (var i = 0; i < xPath.length; i++) {
	                  var pt = xPath[i];
	                  switch (pt.type) {
	                      case 'mt':
	                          moves.push({ start: pt, deltas: [], abs: [] });
	                          break;
	                      case 'lt':
	                          var delta = [pt.x - xPath[i - 1].x, pt.y - xPath[i - 1].y];
	                          moves[moves.length - 1].deltas.push(delta);
	                          moves[moves.length - 1].abs.push(pt);
	                          break;
	                      case 'bct':
	                          var delta = [pt.x1 - xPath[i - 1].x, pt.y1 - xPath[i - 1].y, pt.x2 - xPath[i - 1].x, pt.y2 - xPath[i - 1].y, pt.x - xPath[i - 1].x, pt.y - xPath[i - 1].y];
	                          moves[moves.length - 1].deltas.push(delta);
	                          break;
	                      case 'qct':
	                          // convert to bezier
	                          var x1 = xPath[i - 1].x + 2.0 / 3.0 * (pt.x1 - xPath[i - 1].x);
	                          var y1 = xPath[i - 1].y + 2.0 / 3.0 * (pt.y1 - xPath[i - 1].y);
	                          var x2 = pt.x + 2.0 / 3.0 * (pt.x1 - pt.x);
	                          var y2 = pt.y + 2.0 / 3.0 * (pt.y1 - pt.y);
	                          var x3 = pt.x;
	                          var y3 = pt.y;
	                          var delta = [x1 - xPath[i - 1].x, y1 - xPath[i - 1].y, x2 - xPath[i - 1].x, y2 - xPath[i - 1].y, x3 - xPath[i - 1].x, y3 - xPath[i - 1].y];
	                          moves[moves.length - 1].deltas.push(delta);
	                          break;
	                      case 'arc':
	                          //TODO this was hack to avoid out-of-bounds issue when drawing circle
	                          // No move-to before drawing the arc
	                          if (moves.length === 0) {
	                              moves.push({ deltas: [], abs: [] });
	                          }
	                          moves[moves.length - 1].arc = true;
	                          if (Array.isArray(moves[moves.length - 1].abs)) {
	                              moves[moves.length - 1].abs.push(pt);
	                          }
	                          break;
	                      case 'close':
	                          moves.push({ close: true });
	                          break;
	                  }
	              }

	              for (var i = 0; i < moves.length; i++) {
	                  var style;
	                  if (i == moves.length - 1) {
	                      style = 'f';
	                      if (fillRule === 'evenodd') {
	                          style += '*';
	                      }
	                  } else {
	                      style = null;
	                  }

	                  if (moves[i].close) {
	                      this.pdf.internal.out('h');
	                      if (style) {
	                          // only fill at final path move
	                          this.pdf.internal.out(style);
	                      }
	                  } else if (moves[i].arc) {
	                      if (moves[i].start) {
	                          this.internal.move2(this, moves[i].start.x, moves[i].start.y);
	                      }
	                      var arcs = moves[i].abs;
	                      for (var ii = 0; ii < arcs.length; ii++) {
	                          var arc = arcs[ii];
	                          //TODO lines deltas were getting in here
	                          if (typeof arc.startAngle !== 'undefined') {
	                              var start = arc.startAngle * 360 / (2 * Math.PI);
	                              var end = arc.endAngle * 360 / (2 * Math.PI);
	                              var x = arc.x;
	                              var y = arc.y;
	                              if (ii === 0) {
	                                  this.internal.move2(this, x, y);
	                              }
	                              this.internal.arc2(this, x, y, arc.radius, start, end, arc.anticlockwise, null, isClip);
	                              if (ii === arcs.length - 1) {
	                                  // The original arc move did not occur because of the algorithm
	                                  if (moves[i].start) {
	                                      var x = moves[i].start.x;
	                                      var y = moves[i].start.y;
	                                      this.internal.line2(c2d, x, y);
	                                  }
	                              }
	                          } else {
	                              this.internal.line2(c2d, arc.x, arc.y);
	                          }
	                      }
	                  } else {
	                      var x = moves[i].start.x;
	                      var y = moves[i].start.y;
	                      if (!isClip) {
	                          this.pdf.lines(moves[i].deltas, x, y, null, style);
	                      } else {
	                          this.pdf.lines(moves[i].deltas, x, y, null, null);
	                          this.pdf.clip_fixed();
	                      }
	                  }
	              }

	              window.outIntercept = outInterceptOld;

	              // if (this.ctx._clip_path.length > 0) {
	              //     lines.push('Q');
	              // }
	          },

	          pushMask: function pushMask() {
	              var v2Support = typeof this.pdf.internal.newObject2 === 'function';

	              if (!v2Support) {
	                  console.log('jsPDF v2 not enabled');
	                  return;
	              }

	              // define a mask stream
	              var obj = this.pdf.internal.newStreamObject();

	              // define a mask state
	              var obj2 = this.pdf.internal.newObject2();
	              obj2.push('<</Type /ExtGState');
	              obj2.push('/SMask <</S /Alpha /G ' + obj.objId + ' 0 R>>'); // /S /Luminosity will need to define color space
	              obj2.push('>>');

	              // add mask to page resources
	              var gsName = 'MASK' + obj2.objId;
	              this.pdf.internal.addGraphicsState(gsName, obj2.objId);

	              var instruction = '/' + gsName + ' gs';
	              this.pdf.internal.out(instruction);
	          },

	          clip: function clip() {
	              //TODO do we reset the path, or just copy it?
	              if (this.ctx._clip_path.length > 0) {
	                  for (var i = 0; i < this.path.length; i++) {
	                      this.ctx._clip_path.push(this.path[i]);
	                  }
	              } else {
	                  this.ctx._clip_path = this.path;
	              }
	              this.path = [];
	          },

	          measureText: function measureText(text) {
	              var pdf = this.pdf;
	              return {
	                  getWidth: function getWidth() {
	                      var fontSize = pdf.internal.getFontSize();
	                      var txtWidth = pdf.getStringUnitWidth(text) * fontSize / pdf.internal.scaleFactor;
	                      // Convert points to pixels
	                      txtWidth *= 1.3333;
	                      return txtWidth;
	                  },

	                  get width() {
	                      return this.getWidth(text);
	                  }
	              };
	          },
	          _getBaseline: function _getBaseline(y) {
	              var height = parseInt(this.pdf.internal.getFontSize());
	              // TODO Get descent from font descriptor
	              var descent = height * 0.25;
	              switch (this.ctx.textBaseline) {
	                  case 'bottom':
	                      return y - descent;
	                  case 'top':
	                      return y + height;
	                  case 'hanging':
	                      return y + height - descent;
	                  case 'middle':
	                      return y + height / 2 - descent;
	                  case 'ideographic':
	                      // TODO not implemented
	                      return y;
	                  case 'alphabetic':
	                  default:
	                      return y;
	              }
	          }
	      };

	      var c2d = jsPDFAPI.context2d;

	      // accessor methods
	      Object.defineProperty(c2d, 'fillStyle', {
	          set: function set(value) {
	              this.setFillStyle(value);
	          },
	          get: function get() {
	              return this.ctx.fillStyle;
	          }
	      });
	      Object.defineProperty(c2d, 'strokeStyle', {
	          set: function set(value) {
	              this.setStrokeStyle(value);
	          },
	          get: function get() {
	              return this.ctx.strokeStyle;
	          }
	      });
	      Object.defineProperty(c2d, 'lineWidth', {
	          set: function set(value) {
	              this.setLineWidth(value);
	          },
	          get: function get() {
	              return this.ctx.lineWidth;
	          }
	      });
	      Object.defineProperty(c2d, 'lineCap', {
	          set: function set(val) {
	              this.setLineCap(val);
	          },
	          get: function get() {
	              return this.ctx.lineCap;
	          }
	      });
	      Object.defineProperty(c2d, 'lineJoin', {
	          set: function set(val) {
	              this.setLineJoin(val);
	          },
	          get: function get() {
	              return this.ctx.lineJoin;
	          }
	      });
	      Object.defineProperty(c2d, 'miterLimit', {
	          set: function set(val) {
	              this.ctx.miterLimit = val;
	          },
	          get: function get() {
	              return this.ctx.miterLimit;
	          }
	      });
	      Object.defineProperty(c2d, 'textBaseline', {
	          set: function set(value) {
	              this.setTextBaseline(value);
	          },
	          get: function get() {
	              return this.getTextBaseline();
	          }
	      });
	      Object.defineProperty(c2d, 'textAlign', {
	          set: function set(value) {
	              this.setTextAlign(value);
	          },
	          get: function get() {
	              return this.getTextAlign();
	          }
	      });
	      Object.defineProperty(c2d, 'font', {
	          set: function set(value) {
	              this.setFont(value);
	          },
	          get: function get() {
	              return this.ctx.font;
	          }
	      });
	      Object.defineProperty(c2d, 'globalCompositeOperation', {
	          set: function set(value) {
	              this.ctx.globalCompositeOperation = value;
	          },
	          get: function get() {
	              return this.ctx.globalCompositeOperation;
	          }
	      });
	      Object.defineProperty(c2d, 'globalAlpha', {
	          set: function set(value) {
	              this.ctx.globalAlpha = value;
	          },
	          get: function get() {
	              return this.ctx.globalAlpha;
	          }
	      });
	      Object.defineProperty(c2d, 'canvas', {
	          get: function get() {
	              return { parentNode: false, style: false };
	          }
	      });
	      // Not HTML API
	      Object.defineProperty(c2d, 'ignoreClearRect', {
	          set: function set(value) {
	              this.ctx.ignoreClearRect = value;
	          },
	          get: function get() {
	              return this.ctx.ignoreClearRect;
	          }
	      });
	      // End Not HTML API

	      c2d.internal = {};

	      c2d.internal.rxRgb = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/;
	      c2d.internal.rxRgba = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/;
	      c2d.internal.rxTransparent = /transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/;

	      // http://hansmuller-flex.blogspot.com/2011/10/more-about-approximating-circular-arcs.html
	      c2d.internal.arc = function (c2d, xc, yc, r, a1, a2, anticlockwise, style) {

	          var k = this.pdf.internal.scaleFactor;
	          var pageHeight = this.pdf.internal.pageSize.getHeight();
	          var f2 = this.pdf.internal.f2;

	          var a1r = a1 * (Math.PI / 180);
	          var a2r = a2 * (Math.PI / 180);
	          var curves = this.createArc(r, a1r, a2r, anticlockwise);

	          for (var i = 0; i < curves.length; i++) {
	              var curve = curves[i];
	              if (i === 0) {
	                  this.pdf.internal.out([f2((curve.x1 + xc) * k), f2((pageHeight - (curve.y1 + yc)) * k), 'm', f2((curve.x2 + xc) * k), f2((pageHeight - (curve.y2 + yc)) * k), f2((curve.x3 + xc) * k), f2((pageHeight - (curve.y3 + yc)) * k), f2((curve.x4 + xc) * k), f2((pageHeight - (curve.y4 + yc)) * k), 'c'].join(' '));
	              } else {
	                  this.pdf.internal.out([f2((curve.x2 + xc) * k), f2((pageHeight - (curve.y2 + yc)) * k), f2((curve.x3 + xc) * k), f2((pageHeight - (curve.y3 + yc)) * k), f2((curve.x4 + xc) * k), f2((pageHeight - (curve.y4 + yc)) * k), 'c'].join(' '));
	              }

	              //c2d._lastPoint = {x: curve.x1 + xc, y: curve.y1 + yc};
	              c2d._lastPoint = { x: xc, y: yc };
	              // f2((curve.x1 + xc) * k), f2((pageHeight - (curve.y1 + yc)) * k), 'm', f2((curve.x2 + xc) * k), f2((pageHeight - (curve.y2 + yc)) * k), f2((curve.x3 + xc) * k), f2((pageHeight - (curve.y3 + yc)) * k), f2((curve.x4 + xc) * k), f2((pageHeight - (curve.y4 + yc)) * k), 'c'
	          }

	          if (style !== null) {
	              this.pdf.internal.out(this.pdf.internal.getStyle(style));
	          }
	      };

	      /**
	       *
	       * @param x Edge point X
	       * @param y Edge point Y
	       * @param r Radius
	       * @param a1 start angle
	       * @param a2 end angle
	       * @param anticlockwise
	       * @param style
	       * @param isClip
	       */
	      c2d.internal.arc2 = function (c2d, x, y, r, a1, a2, anticlockwise, style, isClip) {
	          // we need to convert from cartesian to polar here methinks.
	          var centerX = x; // + r;
	          var centerY = y;

	          if (!isClip) {
	              this.arc(c2d, centerX, centerY, r, a1, a2, anticlockwise, style);
	          } else {
	              this.arc(c2d, centerX, centerY, r, a1, a2, anticlockwise, null);
	              this.pdf.clip_fixed();
	          }
	      };

	      c2d.internal.move2 = function (c2d, x, y) {
	          var k = this.pdf.internal.scaleFactor;
	          var pageHeight = this.pdf.internal.pageSize.getHeight();
	          var f2 = this.pdf.internal.f2;

	          this.pdf.internal.out([f2(x * k), f2((pageHeight - y) * k), 'm'].join(' '));
	          c2d._lastPoint = { x: x, y: y };
	      };

	      c2d.internal.line2 = function (c2d, dx, dy) {
	          var k = this.pdf.internal.scaleFactor;
	          var pageHeight = this.pdf.internal.pageSize.getHeight();
	          var f2 = this.pdf.internal.f2;

	          //var pt = {x: c2d._lastPoint.x + dx, y: c2d._lastPoint.y + dy};
	          var pt = { x: dx, y: dy };

	          this.pdf.internal.out([f2(pt.x * k), f2((pageHeight - pt.y) * k), 'l'].join(' '));
	          //this.pdf.internal.out('f');
	          c2d._lastPoint = pt;
	      };

	      /**
	       * Return a array of objects that represent bezier curves which approximate the circular arc centered at the origin, from startAngle to endAngle (radians) with the specified radius.
	       *
	       * Each bezier curve is an object with four points, where x1,y1 and x4,y4 are the arc's end points and x2,y2 and x3,y3 are the cubic bezier's control points.
	       */

	      c2d.internal.createArc = function (radius, startAngle, endAngle, anticlockwise) {
	          var EPSILON = 0.00001; // Roughly 1/1000th of a degree, see below
	          var twoPI = Math.PI * 2;
	          var piOverTwo = Math.PI / 2.0;

	          // normalize startAngle, endAngle to [0, 2PI]
	          var startAngleN = startAngle;
	          if (startAngleN < twoPI || startAngleN > twoPI) {
	              startAngleN = startAngleN % twoPI;
	          }
	          if (startAngleN < 0) {
	              startAngleN = twoPI + startAngleN;
	          }

	          while (startAngle > endAngle) {
	              startAngle = startAngle - twoPI;
	          }
	          var totalAngle = Math.abs(endAngle - startAngle);
	          if (totalAngle < twoPI) {
	              if (anticlockwise) {
	                  totalAngle = twoPI - totalAngle;
	              }
	          }

	          // Compute the sequence of arc curves, up to PI/2 at a time.
	          var curves = [];
	          var sgn = anticlockwise ? -1 : +1;

	          var a1 = startAngleN;
	          for (; totalAngle > EPSILON;) {
	              var remain = sgn * Math.min(totalAngle, piOverTwo);
	              var a2 = a1 + remain;
	              curves.push(this.createSmallArc(radius, a1, a2));
	              totalAngle -= Math.abs(a2 - a1);
	              a1 = a2;
	          }

	          return curves;
	      };

	      c2d.internal.getCurrentPage = function () {
	          return this.pdf.internal.pages[this.pdf.internal.getCurrentPageInfo().pageNumber];
	      };

	      /**
	       * Cubic bezier approximation of a circular arc centered at the origin, from (radians) a1 to a2, where a2-a1 < pi/2. The arc's radius is r.
	       *
	       * Returns an object with four points, where x1,y1 and x4,y4 are the arc's end points and x2,y2 and x3,y3 are the cubic bezier's control points.
	       *
	       * This algorithm is based on the approach described in: A. Riškus, "Approximation of a Cubic Bezier Curve by Circular Arcs and Vice Versa," Information Technology and Control, 35(4), 2006 pp. 371-378.
	       */

	      c2d.internal.createSmallArc = function (r, a1, a2) {
	          // Compute all four points for an arc that subtends the same total angle
	          // but is centered on the X-axis

	          var a = (a2 - a1) / 2.0;

	          var x4 = r * Math.cos(a);
	          var y4 = r * Math.sin(a);
	          var x1 = x4;
	          var y1 = -y4;

	          var q1 = x1 * x1 + y1 * y1;
	          var q2 = q1 + x1 * x4 + y1 * y4;
	          var k2 = 4 / 3 * (Math.sqrt(2 * q1 * q2) - q2) / (x1 * y4 - y1 * x4);

	          var x2 = x1 - k2 * y1;
	          var y2 = y1 + k2 * x1;
	          var x3 = x2;
	          var y3 = -y2;

	          // Find the arc points' actual locations by computing x1,y1 and x4,y4
	          // and rotating the control points by a + a1

	          var ar = a + a1;
	          var cos_ar = Math.cos(ar);
	          var sin_ar = Math.sin(ar);

	          return {
	              x1: r * Math.cos(a1),
	              y1: r * Math.sin(a1),
	              x2: x2 * cos_ar - y2 * sin_ar,
	              y2: x2 * sin_ar + y2 * cos_ar,
	              x3: x3 * cos_ar - y3 * sin_ar,
	              y3: x3 * sin_ar + y3 * cos_ar,
	              x4: r * Math.cos(a2),
	              y4: r * Math.sin(a2)
	          };
	      };

	      function context() {
	          this._isStrokeTransparent = false;
	          this._strokeOpacity = 1;
	          this.strokeStyle = '#000000';
	          this.fillStyle = '#000000';
	          this._isFillTransparent = false;
	          this._fillOpacity = 1;
	          this.font = "12pt times";
	          this.textBaseline = 'alphabetic'; // top,bottom,middle,ideographic,alphabetic,hanging
	          this.textAlign = 'start';
	          this.lineWidth = 1;
	          this.lineJoin = 'miter'; // round, bevel, miter
	          this.lineCap = 'butt'; // butt, round, square
	          this._transform = [1, 0, 0, 1, 0, 0]; // sx, shy, shx, sy, tx, ty
	          this.globalCompositeOperation = 'normal';
	          this.globalAlpha = 1.0;
	          this._clip_path = [];

	          // TODO miter limit //default 10

	          // Not HTML API
	          this.ignoreClearRect = false;

	          this.copy = function (ctx) {
	              this._isStrokeTransparent = ctx._isStrokeTransparent;
	              this._strokeOpacity = ctx._strokeOpacity;
	              this.strokeStyle = ctx.strokeStyle;
	              this._isFillTransparent = ctx._isFillTransparent;
	              this._fillOpacity = ctx._fillOpacity;
	              this.fillStyle = ctx.fillStyle;
	              this.font = ctx.font;
	              this.lineWidth = ctx.lineWidth;
	              this.lineJoin = ctx.lineJoin;
	              this.lineCap = ctx.lineCap;
	              this.textBaseline = ctx.textBaseline;
	              this.textAlign = ctx.textAlign;
	              this._fontSize = ctx._fontSize;
	              this._transform = ctx._transform.slice(0);
	              this.globalCompositeOperation = ctx.globalCompositeOperation;
	              this.globalAlpha = ctx.globalAlpha;
	              this._clip_path = ctx._clip_path.slice(0); //TODO deep copy?

	              // Not HTML API
	              this.ignoreClearRect = ctx.ignoreClearRect;
	          };
	      }

	      return this;
	  })(jsPDF.API, typeof self !== "undefined" && self || typeof window !== "undefined" && window || typeof global !== "undefined" && global || Function('return typeof this === "object" && this.content')() || Function('return this')());

	  /** @preserve
	   * jsPDF fromHTML plugin. BETA stage. API subject to change. Needs browser
	   * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
	   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
	   *               2014 Diego Casorran, https://github.com/diegocr
	   *               2014 Daniel Husar, https://github.com/danielhusar
	   *               2014 Wolfgang Gassler, https://github.com/woolfg
	   *               2014 Steven Spungin, https://github.com/flamenco
	   *
	   * 
	   * ====================================================================
	   */

	  (function (jsPDFAPI) {
	  	var clone, _DrillForContent, FontNameDB, FontStyleMap, TextAlignMap, FontWeightMap, FloatMap, ClearMap, GetCSS, PurgeWhiteSpace, Renderer, ResolveFont, ResolveUnitedNumber, UnitedNumberMap, elementHandledElsewhere, images, loadImgs, checkForFooter, process, tableToJson;
	  	clone = function () {
	  		return function (obj) {
	  			Clone.prototype = obj;
	  			return new Clone();
	  		};
	  		function Clone() {}
	  	}();
	  	PurgeWhiteSpace = function PurgeWhiteSpace(array) {
	  		var fragment, i, l, lTrimmed, r, rTrimmed, trailingSpace;
	  		i = 0;
	  		l = array.length;
	  		fragment = void 0;
	  		lTrimmed = false;
	  		rTrimmed = false;
	  		while (!lTrimmed && i !== l) {
	  			fragment = array[i] = array[i].trimLeft();
	  			if (fragment) {
	  				lTrimmed = true;
	  			}
	  			i++;
	  		}
	  		i = l - 1;
	  		while (l && !rTrimmed && i !== -1) {
	  			fragment = array[i] = array[i].trimRight();
	  			if (fragment) {
	  				rTrimmed = true;
	  			}
	  			i--;
	  		}
	  		r = /\s+$/g;
	  		trailingSpace = true;
	  		i = 0;
	  		while (i !== l) {
	  			// Leave the line breaks intact
	  			if (array[i] != "\u2028") {
	  				fragment = array[i].replace(/\s+/g, " ");
	  				if (trailingSpace) {
	  					fragment = fragment.trimLeft();
	  				}
	  				if (fragment) {
	  					trailingSpace = r.test(fragment);
	  				}
	  				array[i] = fragment;
	  			}
	  			i++;
	  		}
	  		return array;
	  	};
	  	Renderer = function Renderer(pdf, x, y, settings) {
	  		this.pdf = pdf;
	  		this.x = x;
	  		this.y = y;
	  		this.settings = settings;
	  		//list of functions which are called after each element-rendering process
	  		this.watchFunctions = [];
	  		this.init();
	  		return this;
	  	};
	  	ResolveFont = function ResolveFont(css_font_family_string) {
	  		var name, part, parts;
	  		name = void 0;
	  		parts = css_font_family_string.split(",");
	  		part = parts.shift();
	  		while (!name && part) {
	  			name = FontNameDB[part.trim().toLowerCase()];
	  			part = parts.shift();
	  		}
	  		return name;
	  	};
	  	ResolveUnitedNumber = function ResolveUnitedNumber(css_line_height_string) {

	  		//IE8 issues
	  		css_line_height_string = css_line_height_string === "auto" ? "0px" : css_line_height_string;
	  		if (css_line_height_string.indexOf("em") > -1 && !isNaN(Number(css_line_height_string.replace("em", "")))) {
	  			css_line_height_string = Number(css_line_height_string.replace("em", "")) * 18.719 + "px";
	  		}
	  		if (css_line_height_string.indexOf("pt") > -1 && !isNaN(Number(css_line_height_string.replace("pt", "")))) {
	  			css_line_height_string = Number(css_line_height_string.replace("pt", "")) * 1.333 + "px";
	  		}

	  		var normal, undef, value;
	  		undef = void 0;
	  		normal = 16.00;
	  		value = UnitedNumberMap[css_line_height_string];
	  		if (value) {
	  			return value;
	  		}
	  		value = {
	  			"xx-small": 9,
	  			"x-small": 11,
	  			small: 13,
	  			medium: 16,
	  			large: 19,
	  			"x-large": 23,
	  			"xx-large": 28,
	  			auto: 0
	  		}[css_line_height_string];

	  		if (value !== undef) {
	  			return UnitedNumberMap[css_line_height_string] = value / normal;
	  		}
	  		if (value = parseFloat(css_line_height_string)) {
	  			return UnitedNumberMap[css_line_height_string] = value / normal;
	  		}
	  		value = css_line_height_string.match(/([\d\.]+)(px)/);
	  		if (Array.isArray(value) && value.length === 3) {
	  			return UnitedNumberMap[css_line_height_string] = parseFloat(value[1]) / normal;
	  		}
	  		return UnitedNumberMap[css_line_height_string] = 1;
	  	};
	  	GetCSS = function GetCSS(element) {
	  		var css, tmp, computedCSSElement;
	  		computedCSSElement = function (el) {
	  			var compCSS;
	  			compCSS = function (el) {
	  				if (document.defaultView && document.defaultView.getComputedStyle) {
	  					return document.defaultView.getComputedStyle(el, null);
	  				} else if (el.currentStyle) {
	  					return el.currentStyle;
	  				} else {
	  					return el.style;
	  				}
	  			}(el);
	  			return function (prop) {
	  				prop = prop.replace(/-\D/g, function (match) {
	  					return match.charAt(1).toUpperCase();
	  				});
	  				return compCSS[prop];
	  			};
	  		}(element);
	  		css = {};
	  		tmp = void 0;
	  		css["font-family"] = ResolveFont(computedCSSElement("font-family")) || "times";
	  		css["font-style"] = FontStyleMap[computedCSSElement("font-style")] || "normal";
	  		css["text-align"] = TextAlignMap[computedCSSElement("text-align")] || "left";
	  		tmp = FontWeightMap[computedCSSElement("font-weight")] || "normal";
	  		if (tmp === "bold") {
	  			if (css["font-style"] === "normal") {
	  				css["font-style"] = tmp;
	  			} else {
	  				css["font-style"] = tmp + css["font-style"];
	  			}
	  		}
	  		css["font-size"] = ResolveUnitedNumber(computedCSSElement("font-size")) || 1;
	  		css["line-height"] = ResolveUnitedNumber(computedCSSElement("line-height")) || 1;
	  		css["display"] = computedCSSElement("display") === "inline" ? "inline" : "block";

	  		tmp = css["display"] === "block";
	  		css["margin-top"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-top")) || 0;
	  		css["margin-bottom"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-bottom")) || 0;
	  		css["padding-top"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-top")) || 0;
	  		css["padding-bottom"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-bottom")) || 0;
	  		css["margin-left"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-left")) || 0;
	  		css["margin-right"] = tmp && ResolveUnitedNumber(computedCSSElement("margin-right")) || 0;
	  		css["padding-left"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-left")) || 0;
	  		css["padding-right"] = tmp && ResolveUnitedNumber(computedCSSElement("padding-right")) || 0;

	  		css["page-break-before"] = computedCSSElement("page-break-before") || "auto";

	  		//float and clearing of floats
	  		css["float"] = FloatMap[computedCSSElement("cssFloat")] || "none";
	  		css["clear"] = ClearMap[computedCSSElement("clear")] || "none";

	  		css["color"] = computedCSSElement("color");

	  		return css;
	  	};
	  	elementHandledElsewhere = function elementHandledElsewhere(element, renderer, elementHandlers) {
	  		var handlers, i, isHandledElsewhere, l, classNames;
	  		isHandledElsewhere = false;
	  		i = void 0;
	  		l = void 0;
	  		handlers = elementHandlers["#" + element.id];
	  		if (handlers) {
	  			if (typeof handlers === "function") {
	  				isHandledElsewhere = handlers(element, renderer);
	  			} else {
	  				i = 0;
	  				l = handlers.length;
	  				while (!isHandledElsewhere && i !== l) {
	  					isHandledElsewhere = handlers[i](element, renderer);
	  					i++;
	  				}
	  			}
	  		}
	  		handlers = elementHandlers[element.nodeName];
	  		if (!isHandledElsewhere && handlers) {
	  			if (typeof handlers === "function") {
	  				isHandledElsewhere = handlers(element, renderer);
	  			} else {
	  				i = 0;
	  				l = handlers.length;
	  				while (!isHandledElsewhere && i !== l) {
	  					isHandledElsewhere = handlers[i](element, renderer);
	  					i++;
	  				}
	  			}
	  		}

	  		// Try class names
	  		classNames = typeof element.className === 'string' ? element.className.split(' ') : [];
	  		for (i = 0; i < classNames.length; i++) {
	  			handlers = elementHandlers['.' + classNames[i]];
	  			if (!isHandledElsewhere && handlers) {
	  				if (typeof handlers === "function") {
	  					isHandledElsewhere = handlers(element, renderer);
	  				} else {
	  					i = 0;
	  					l = handlers.length;
	  					while (!isHandledElsewhere && i !== l) {
	  						isHandledElsewhere = handlers[i](element, renderer);
	  						i++;
	  					}
	  				}
	  			}
	  		}

	  		return isHandledElsewhere;
	  	};
	  	tableToJson = function tableToJson(table, renderer) {
	  		var data, headers, i, j, rowData, tableRow, table_obj, table_with, cell, l;
	  		data = [];
	  		headers = [];
	  		i = 0;
	  		l = table.rows[0].cells.length;
	  		table_with = table.clientWidth;
	  		while (i < l) {
	  			cell = table.rows[0].cells[i];
	  			headers[i] = {
	  				name: cell.textContent.toLowerCase().replace(/\s+/g, ''),
	  				prompt: cell.textContent.replace(/\r?\n/g, ''),
	  				width: cell.clientWidth / table_with * renderer.pdf.internal.pageSize.getWidth()
	  			};
	  			i++;
	  		}
	  		i = 1;
	  		while (i < table.rows.length) {
	  			tableRow = table.rows[i];
	  			rowData = {};
	  			j = 0;
	  			while (j < tableRow.cells.length) {
	  				rowData[headers[j].name] = tableRow.cells[j].textContent.replace(/\r?\n/g, '');
	  				j++;
	  			}
	  			data.push(rowData);
	  			i++;
	  		}
	  		return table_obj = {
	  			rows: data,
	  			headers: headers
	  		};
	  	};
	  	var SkipNode = {
	  		SCRIPT: 1,
	  		STYLE: 1,
	  		NOSCRIPT: 1,
	  		OBJECT: 1,
	  		EMBED: 1,
	  		SELECT: 1
	  	};
	  	var listCount = 1;
	  	_DrillForContent = function DrillForContent(element, renderer, elementHandlers) {
	  		var cn, cns, fragmentCSS, i, isBlock, l, table2json, cb;
	  		cns = element.childNodes;
	  		cn = void 0;
	  		fragmentCSS = GetCSS(element);
	  		isBlock = fragmentCSS.display === "block";
	  		if (isBlock) {
	  			renderer.setBlockBoundary();
	  			renderer.setBlockStyle(fragmentCSS);
	  		}
	  		i = 0;
	  		l = cns.length;
	  		while (i < l) {
	  			cn = cns[i];
	  			if ((typeof cn === "undefined" ? "undefined" : _typeof(cn)) === "object") {

	  				//execute all watcher functions to e.g. reset floating
	  				renderer.executeWatchFunctions(cn);

	  				/*** HEADER rendering **/
	  				if (cn.nodeType === 1 && cn.nodeName === 'HEADER') {
	  					var header = cn;
	  					//store old top margin
	  					var oldMarginTop = renderer.pdf.margins_doc.top;
	  					//subscribe for new page event and render header first on every page
	  					renderer.pdf.internal.events.subscribe('addPage', function (pageInfo) {
	  						//set current y position to old margin
	  						renderer.y = oldMarginTop;
	  						//render all child nodes of the header element
	  						_DrillForContent(header, renderer, elementHandlers);
	  						//set margin to old margin + rendered header + 10 space to prevent overlapping
	  						//important for other plugins (e.g. table) to start rendering at correct position after header
	  						renderer.pdf.margins_doc.top = renderer.y + 10;
	  						renderer.y += 10;
	  					}, false);
	  				}

	  				if (cn.nodeType === 8 && cn.nodeName === "#comment") {
	  					if (~cn.textContent.indexOf("ADD_PAGE")) {
	  						renderer.pdf.addPage();
	  						renderer.y = renderer.pdf.margins_doc.top;
	  					}
	  				} else if (cn.nodeType === 1 && !SkipNode[cn.nodeName]) {
	  					/*** IMAGE RENDERING ***/
	  					var cached_image;
	  					if (cn.nodeName === "IMG") {
	  						var url = cn.getAttribute("src");
	  						cached_image = images[renderer.pdf.sHashCode(url) || url];
	  					}
	  					if (cached_image) {
	  						if (renderer.pdf.internal.pageSize.getHeight() - renderer.pdf.margins_doc.bottom < renderer.y + cn.height && renderer.y > renderer.pdf.margins_doc.top) {
	  							renderer.pdf.addPage();
	  							renderer.y = renderer.pdf.margins_doc.top;
	  							//check if we have to set back some values due to e.g. header rendering for new page
	  							renderer.executeWatchFunctions(cn);
	  						}

	  						var imagesCSS = GetCSS(cn);
	  						var imageX = renderer.x;
	  						var fontToUnitRatio = 12 / renderer.pdf.internal.scaleFactor;

	  						//define additional paddings, margins which have to be taken into account for margin calculations
	  						var additionalSpaceLeft = (imagesCSS["margin-left"] + imagesCSS["padding-left"]) * fontToUnitRatio;
	  						var additionalSpaceRight = (imagesCSS["margin-right"] + imagesCSS["padding-right"]) * fontToUnitRatio;
	  						var additionalSpaceTop = (imagesCSS["margin-top"] + imagesCSS["padding-top"]) * fontToUnitRatio;
	  						var additionalSpaceBottom = (imagesCSS["margin-bottom"] + imagesCSS["padding-bottom"]) * fontToUnitRatio;

	  						//if float is set to right, move the image to the right border
	  						//add space if margin is set
	  						if (imagesCSS['float'] !== undefined && imagesCSS['float'] === 'right') {
	  							imageX += renderer.settings.width - cn.width - additionalSpaceRight;
	  						} else {
	  							imageX += additionalSpaceLeft;
	  						}

	  						renderer.pdf.addImage(cached_image, imageX, renderer.y + additionalSpaceTop, cn.width, cn.height);
	  						cached_image = undefined;
	  						//if the float prop is specified we have to float the text around the image
	  						if (imagesCSS['float'] === 'right' || imagesCSS['float'] === 'left') {
	  							//add functiont to set back coordinates after image rendering
	  							renderer.watchFunctions.push(function (diffX, thresholdY, diffWidth, el) {
	  								//undo drawing box adaptions which were set by floating
	  								if (renderer.y >= thresholdY) {
	  									renderer.x += diffX;
	  									renderer.settings.width += diffWidth;
	  									return true;
	  								} else if (el && el.nodeType === 1 && !SkipNode[el.nodeName] && renderer.x + el.width > renderer.pdf.margins_doc.left + renderer.pdf.margins_doc.width) {
	  									renderer.x += diffX;
	  									renderer.y = thresholdY;
	  									renderer.settings.width += diffWidth;
	  									return true;
	  								} else {
	  									return false;
	  								}
	  							}.bind(this, imagesCSS['float'] === 'left' ? -cn.width - additionalSpaceLeft - additionalSpaceRight : 0, renderer.y + cn.height + additionalSpaceTop + additionalSpaceBottom, cn.width));
	  							//reset floating by clear:both divs
	  							//just set cursorY after the floating element
	  							renderer.watchFunctions.push(function (yPositionAfterFloating, pages, el) {
	  								if (renderer.y < yPositionAfterFloating && pages === renderer.pdf.internal.getNumberOfPages()) {
	  									if (el.nodeType === 1 && GetCSS(el).clear === 'both') {
	  										renderer.y = yPositionAfterFloating;
	  										return true;
	  									} else {
	  										return false;
	  									}
	  								} else {
	  									return true;
	  								}
	  							}.bind(this, renderer.y + cn.height, renderer.pdf.internal.getNumberOfPages()));

	  							//if floating is set we decrease the available width by the image width
	  							renderer.settings.width -= cn.width + additionalSpaceLeft + additionalSpaceRight;
	  							//if left just add the image width to the X coordinate
	  							if (imagesCSS['float'] === 'left') {
	  								renderer.x += cn.width + additionalSpaceLeft + additionalSpaceRight;
	  							}
	  						} else {
	  							//if no floating is set, move the rendering cursor after the image height
	  							renderer.y += cn.height + additionalSpaceTop + additionalSpaceBottom;
	  						}

	  						/*** TABLE RENDERING ***/
	  					} else if (cn.nodeName === "TABLE") {
	  						table2json = tableToJson(cn, renderer);
	  						renderer.y += 10;
	  						renderer.pdf.table(renderer.x, renderer.y, table2json.rows, table2json.headers, {
	  							autoSize: false,
	  							printHeaders: elementHandlers.printHeaders,
	  							margins: renderer.pdf.margins_doc,
	  							css: GetCSS(cn)
	  						});
	  						renderer.y = renderer.pdf.lastCellPos.y + renderer.pdf.lastCellPos.h + 20;
	  					} else if (cn.nodeName === "OL" || cn.nodeName === "UL") {
	  						listCount = 1;
	  						if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {
	  							_DrillForContent(cn, renderer, elementHandlers);
	  						}
	  						renderer.y += 10;
	  					} else if (cn.nodeName === "LI") {
	  						var temp = renderer.x;
	  						renderer.x += 20 / renderer.pdf.internal.scaleFactor;
	  						renderer.y += 3;
	  						if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {
	  							_DrillForContent(cn, renderer, elementHandlers);
	  						}
	  						renderer.x = temp;
	  					} else if (cn.nodeName === "BR") {
	  						renderer.y += fragmentCSS["font-size"] * renderer.pdf.internal.scaleFactor;
	  						renderer.addText("\u2028", clone(fragmentCSS));
	  					} else {
	  						if (!elementHandledElsewhere(cn, renderer, elementHandlers)) {
	  							_DrillForContent(cn, renderer, elementHandlers);
	  						}
	  					}
	  				} else if (cn.nodeType === 3) {
	  					var value = cn.nodeValue;
	  					if (cn.nodeValue && cn.parentNode.nodeName === "LI") {
	  						if (cn.parentNode.parentNode.nodeName === "OL") {
	  							value = listCount++ + '. ' + value;
	  						} else {
	  							var fontSize = fragmentCSS["font-size"];
	  							var offsetX = (3 - fontSize * 0.75) * renderer.pdf.internal.scaleFactor;
	  							var offsetY = fontSize * 0.75 * renderer.pdf.internal.scaleFactor;
	  							var radius = fontSize * 1.74 / renderer.pdf.internal.scaleFactor;
	  							cb = function cb(x, y) {
	  								this.pdf.circle(x + offsetX, y + offsetY, radius, 'FD');
	  							};
	  						}
	  					}
	  					// Only add the text if the text node is in the body element
	  					// Add compatibility with IE11
	  					if (!!(cn.ownerDocument.body.compareDocumentPosition(cn) & 16)) {
	  						renderer.addText(value, fragmentCSS);
	  					}
	  				} else if (typeof cn === "string") {
	  					renderer.addText(cn, fragmentCSS);
	  				}
	  			}
	  			i++;
	  		}
	  		elementHandlers.outY = renderer.y;

	  		if (isBlock) {
	  			return renderer.setBlockBoundary(cb);
	  		}
	  	};
	  	images = {};
	  	loadImgs = function loadImgs(element, renderer, elementHandlers, cb) {
	  		var imgs = element.getElementsByTagName('img'),
	  		    l = imgs.length,
	  		    found_images,
	  		    x = 0;
	  		function done() {
	  			renderer.pdf.internal.events.publish('imagesLoaded');
	  			cb(found_images);
	  		}
	  		function loadImage(url, width, height) {
	  			if (!url) return;
	  			var img = new Image();
	  			found_images = ++x;
	  			img.crossOrigin = '';
	  			img.onerror = img.onload = function () {
	  				if (img.complete) {
	  					//to support data urls in images, set width and height
	  					//as those values are not recognized automatically
	  					if (img.src.indexOf('data:image/') === 0) {
	  						img.width = width || img.width || 0;
	  						img.height = height || img.height || 0;
	  					}
	  					//if valid image add to known images array
	  					if (img.width + img.height) {
	  						var hash = renderer.pdf.sHashCode(url) || url;
	  						images[hash] = images[hash] || img;
	  					}
	  				}
	  				if (! --x) {
	  					done();
	  				}
	  			};
	  			img.src = url;
	  		}
	  		while (l--) {
	  			loadImage(imgs[l].getAttribute("src"), imgs[l].width, imgs[l].height);
	  		}return x || done();
	  	};
	  	checkForFooter = function checkForFooter(elem, renderer, elementHandlers) {
	  		//check if we can found a <footer> element
	  		var footer = elem.getElementsByTagName("footer");
	  		if (footer.length > 0) {

	  			footer = footer[0];

	  			//bad hack to get height of footer
	  			//creat dummy out and check new y after fake rendering
	  			var oldOut = renderer.pdf.internal.write;
	  			var oldY = renderer.y;
	  			renderer.pdf.internal.write = function () {};
	  			_DrillForContent(footer, renderer, elementHandlers);
	  			var footerHeight = Math.ceil(renderer.y - oldY) + 5;
	  			renderer.y = oldY;
	  			renderer.pdf.internal.write = oldOut;

	  			//add 20% to prevent overlapping
	  			renderer.pdf.margins_doc.bottom += footerHeight;

	  			//Create function render header on every page
	  			var renderFooter = function renderFooter(pageInfo) {
	  				var pageNumber = pageInfo !== undefined ? pageInfo.pageNumber : 1;
	  				//set current y position to old margin
	  				var oldPosition = renderer.y;
	  				//render all child nodes of the header element
	  				renderer.y = renderer.pdf.internal.pageSize.getHeight() - renderer.pdf.margins_doc.bottom;
	  				renderer.pdf.margins_doc.bottom -= footerHeight;

	  				//check if we have to add page numbers
	  				var spans = footer.getElementsByTagName('span');
	  				for (var i = 0; i < spans.length; ++i) {
	  					//if we find some span element with class pageCounter, set the page
	  					if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" pageCounter ") > -1) {
	  						spans[i].innerHTML = pageNumber;
	  					}
	  					//if we find some span element with class totalPages, set a variable which is replaced after rendering of all pages
	  					if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1) {
	  						spans[i].innerHTML = '###jsPDFVarTotalPages###';
	  					}
	  				}

	  				//render footer content
	  				_DrillForContent(footer, renderer, elementHandlers);
	  				//set bottom margin to previous height including the footer height
	  				renderer.pdf.margins_doc.bottom += footerHeight;
	  				//important for other plugins (e.g. table) to start rendering at correct position after header
	  				renderer.y = oldPosition;
	  			};

	  			//check if footer contains totalPages which should be replace at the disoposal of the document
	  			var spans = footer.getElementsByTagName('span');
	  			for (var i = 0; i < spans.length; ++i) {
	  				if ((" " + spans[i].className + " ").replace(/[\n\t]/g, " ").indexOf(" totalPages ") > -1) {
	  					renderer.pdf.internal.events.subscribe('htmlRenderingFinished', renderer.pdf.putTotalPages.bind(renderer.pdf, '###jsPDFVarTotalPages###'), true);
	  				}
	  			}

	  			//register event to render footer on every new page
	  			renderer.pdf.internal.events.subscribe('addPage', renderFooter, false);
	  			//render footer on first page
	  			renderFooter();

	  			//prevent footer rendering
	  			SkipNode['FOOTER'] = 1;
	  		}
	  	};
	  	process = function process(pdf, element, x, y, settings, callback) {
	  		if (!element) return false;
	  		if (typeof element !== "string" && !element.parentNode) element = '' + element.innerHTML;
	  		if (typeof element === "string") {
	  			element = function (element) {
	  				var $frame, $hiddendiv, framename, visuallyhidden;
	  				framename = "jsPDFhtmlText" + Date.now().toString() + (Math.random() * 1000).toFixed(0);
	  				visuallyhidden = "position: absolute !important;" + "clip: rect(1px 1px 1px 1px); /* IE6, IE7 */" + "clip: rect(1px, 1px, 1px, 1px);" + "padding:0 !important;" + "border:0 !important;" + "height: 1px !important;" + "width: 1px !important; " + "top:auto;" + "left:-100px;" + "overflow: hidden;";
	  				$hiddendiv = document.createElement('div');
	  				$hiddendiv.style.cssText = visuallyhidden;
	  				$hiddendiv.innerHTML = "<iframe style=\"height:1px;width:1px\" name=\"" + framename + "\" />";
	  				document.body.appendChild($hiddendiv);
	  				$frame = window.frames[framename];
	  				$frame.document.open();
	  				$frame.document.writeln(element);
	  				$frame.document.close();
	  				return $frame.document.body;
	  			}(element.replace(/<\/?script[^>]*?>/gi, ''));
	  		}
	  		var r = new Renderer(pdf, x, y, settings),
	  		    out;

	  		// 1. load images
	  		// 2. prepare optional footer elements
	  		// 3. render content
	  		loadImgs.call(this, element, r, settings.elementHandlers, function (found_images) {
	  			checkForFooter(element, r, settings.elementHandlers);
	  			_DrillForContent(element, r, settings.elementHandlers);
	  			//send event dispose for final taks (e.g. footer totalpage replacement)
	  			r.pdf.internal.events.publish('htmlRenderingFinished');
	  			out = r.dispose();
	  			if (typeof callback === 'function') callback(out);else if (found_images) console.error('jsPDF Warning: rendering issues? provide a callback to fromHTML!');
	  		});
	  		return out || { x: r.x, y: r.y };
	  	};
	  	Renderer.prototype.init = function () {
	  		this.paragraph = {
	  			text: [],
	  			style: []
	  		};
	  		return this.pdf.internal.write("q");
	  	};
	  	Renderer.prototype.dispose = function () {
	  		this.pdf.internal.write("Q");
	  		return {
	  			x: this.x,
	  			y: this.y,
	  			ready: true
	  		};
	  	};

	  	//Checks if we have to execute some watcher functions
	  	//e.g. to end text floating around an image
	  	Renderer.prototype.executeWatchFunctions = function (el) {
	  		var ret = false;
	  		var narray = [];
	  		if (this.watchFunctions.length > 0) {
	  			for (var i = 0; i < this.watchFunctions.length; ++i) {
	  				if (this.watchFunctions[i](el) === true) {
	  					ret = true;
	  				} else {
	  					narray.push(this.watchFunctions[i]);
	  				}
	  			}
	  			this.watchFunctions = narray;
	  		}
	  		return ret;
	  	};

	  	Renderer.prototype.splitFragmentsIntoLines = function (fragments, styles) {
	  		var currentLineLength, defaultFontSize, ff, fontMetrics, fontMetricsCache, fragment, fragmentChopped, fragmentLength, fragmentSpecificMetrics, fs, k, line, lines, maxLineLength, style;
	  		defaultFontSize = 12;
	  		k = this.pdf.internal.scaleFactor;
	  		fontMetricsCache = {};
	  		ff = void 0;
	  		fs = void 0;
	  		fontMetrics = void 0;
	  		fragment = void 0;
	  		style = void 0;
	  		fragmentSpecificMetrics = void 0;
	  		fragmentLength = void 0;
	  		fragmentChopped = void 0;
	  		line = [];
	  		lines = [line];
	  		currentLineLength = 0;
	  		maxLineLength = this.settings.width;
	  		while (fragments.length) {
	  			fragment = fragments.shift();
	  			style = styles.shift();
	  			if (fragment) {
	  				ff = style["font-family"];
	  				fs = style["font-style"];
	  				fontMetrics = fontMetricsCache[ff + fs];
	  				if (!fontMetrics) {
	  					fontMetrics = this.pdf.internal.getFont(ff, fs).metadata.Unicode;
	  					fontMetricsCache[ff + fs] = fontMetrics;
	  				}
	  				fragmentSpecificMetrics = {
	  					widths: fontMetrics.widths,
	  					kerning: fontMetrics.kerning,
	  					fontSize: style["font-size"] * defaultFontSize,
	  					textIndent: currentLineLength
	  				};
	  				fragmentLength = this.pdf.getStringUnitWidth(fragment, fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
	  				if (fragment == "\u2028") {
	  					line = [];
	  					lines.push(line);
	  				} else if (currentLineLength + fragmentLength > maxLineLength) {
	  					fragmentChopped = this.pdf.splitTextToSize(fragment, maxLineLength, fragmentSpecificMetrics);
	  					line.push([fragmentChopped.shift(), style]);
	  					while (fragmentChopped.length) {
	  						line = [[fragmentChopped.shift(), style]];
	  						lines.push(line);
	  					}
	  					currentLineLength = this.pdf.getStringUnitWidth(line[0][0], fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
	  				} else {
	  					line.push([fragment, style]);
	  					currentLineLength += fragmentLength;
	  				}
	  			}
	  		}

	  		//if text alignment was set, set margin/indent of each line
	  		if (style['text-align'] !== undefined && (style['text-align'] === 'center' || style['text-align'] === 'right' || style['text-align'] === 'justify')) {
	  			for (var i = 0; i < lines.length; ++i) {
	  				var length = this.pdf.getStringUnitWidth(lines[i][0][0], fragmentSpecificMetrics) * fragmentSpecificMetrics.fontSize / k;
	  				//if there is more than on line we have to clone the style object as all lines hold a reference on this object
	  				if (i > 0) {
	  					lines[i][0][1] = clone(lines[i][0][1]);
	  				}
	  				var space = maxLineLength - length;

	  				if (style['text-align'] === 'right') {
	  					lines[i][0][1]['margin-left'] = space;
	  					//if alignment is not right, it has to be center so split the space to the left and the right
	  				} else if (style['text-align'] === 'center') {
	  					lines[i][0][1]['margin-left'] = space / 2;
	  					//if justify was set, calculate the word spacing and define in by using the css property
	  				} else if (style['text-align'] === 'justify') {
	  					var countSpaces = lines[i][0][0].split(' ').length - 1;
	  					lines[i][0][1]['word-spacing'] = space / countSpaces;
	  					//ignore the last line in justify mode
	  					if (i === lines.length - 1) {
	  						lines[i][0][1]['word-spacing'] = 0;
	  					}
	  				}
	  			}
	  		}

	  		return lines;
	  	};
	  	Renderer.prototype.RenderTextFragment = function (text, style) {
	  		var defaultFontSize, font, maxLineHeight;

	  		maxLineHeight = 0;
	  		defaultFontSize = 12;

	  		if (this.pdf.internal.pageSize.getHeight() - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize()) {
	  			this.pdf.internal.write("ET", "Q");
	  			this.pdf.addPage();
	  			this.y = this.pdf.margins_doc.top;
	  			this.pdf.internal.write("q", "BT", this.getPdfColor(style.color), this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
	  			//move cursor by one line on new page
	  			maxLineHeight = Math.max(maxLineHeight, style["line-height"], style["font-size"]);
	  			this.pdf.internal.write(0, (-1 * defaultFontSize * maxLineHeight).toFixed(2), "Td");
	  		}

	  		font = this.pdf.internal.getFont(style["font-family"], style["font-style"]);

	  		// text color
	  		var pdfTextColor = this.getPdfColor(style["color"]);
	  		if (pdfTextColor !== this.lastTextColor) {
	  			this.pdf.internal.write(pdfTextColor);
	  			this.lastTextColor = pdfTextColor;
	  		}

	  		//set the word spacing for e.g. justify style
	  		if (style['word-spacing'] !== undefined && style['word-spacing'] > 0) {
	  			this.pdf.internal.write(style['word-spacing'].toFixed(2), "Tw");
	  		}

	  		this.pdf.internal.write("/" + font.id, (defaultFontSize * style["font-size"]).toFixed(2), "Tf", "(" + this.pdf.internal.pdfEscape(text) + ") Tj");

	  		//set the word spacing back to neutral => 0
	  		if (style['word-spacing'] !== undefined) {
	  			this.pdf.internal.write(0, "Tw");
	  		}
	  	};

	  	// Accepts #FFFFFF, rgb(int,int,int), or CSS Color Name
	  	Renderer.prototype.getPdfColor = function (style) {
	  		var textColor;
	  		var r, g, b;

	  		var rgbColor = new RGBColor(style);
	  		var rx = /rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+\s*)\)/;
	  		var m = rx.exec(style);
	  		if (m != null) {
	  			r = parseInt(m[1]);
	  			g = parseInt(m[2]);
	  			b = parseInt(m[3]);
	  		} else {
	  			if (style.charAt(0) != '#') {
	  				if (rgbColor.ok) {
	  					style = rgbColor.toHex();
	  				} else {
	  					style = '#000000';
	  				}
	  			}
	  			r = style.substring(1, 3);
	  			r = parseInt(r, 16);
	  			g = style.substring(3, 5);
	  			g = parseInt(g, 16);
	  			b = style.substring(5, 7);
	  			b = parseInt(b, 16);
	  		}

	  		if (typeof r === 'string' && /^#[0-9A-Fa-f]{6}$/.test(r)) {
	  			var hex = parseInt(r.substr(1), 16);
	  			r = hex >> 16 & 255;
	  			g = hex >> 8 & 255;
	  			b = hex & 255;
	  		}

	  		var f3 = this.f3;
	  		if (r === 0 && g === 0 && b === 0 || typeof g === 'undefined') {
	  			textColor = f3(r / 255) + ' g';
	  		} else {
	  			textColor = [f3(r / 255), f3(g / 255), f3(b / 255), 'rg'].join(' ');
	  		}
	  		return textColor;
	  	};

	  	Renderer.prototype.f3 = function (number) {
	  		return number.toFixed(3); // Ie, %.3f
	  	}, Renderer.prototype.renderParagraph = function (cb) {
	  		var blockstyle, defaultFontSize, fontToUnitRatio, fragments, i, l, line, lines, maxLineHeight, out, paragraphspacing_after, paragraphspacing_before, priorblockstyle, styles, fontSize;
	  		fragments = PurgeWhiteSpace(this.paragraph.text);
	  		styles = this.paragraph.style;
	  		blockstyle = this.paragraph.blockstyle;
	  		priorblockstyle = this.paragraph.priorblockstyle || {};
	  		this.paragraph = {
	  			text: [],
	  			style: [],
	  			blockstyle: {},
	  			priorblockstyle: blockstyle
	  		};
	  		if (!fragments.join("").trim()) {
	  			return;
	  		}
	  		lines = this.splitFragmentsIntoLines(fragments, styles);
	  		line = void 0;
	  		maxLineHeight = void 0;
	  		defaultFontSize = 12;
	  		fontToUnitRatio = defaultFontSize / this.pdf.internal.scaleFactor;
	  		this.priorMarginBottom = this.priorMarginBottom || 0;
	  		paragraphspacing_before = (Math.max((blockstyle["margin-top"] || 0) - this.priorMarginBottom, 0) + (blockstyle["padding-top"] || 0)) * fontToUnitRatio;
	  		paragraphspacing_after = ((blockstyle["margin-bottom"] || 0) + (blockstyle["padding-bottom"] || 0)) * fontToUnitRatio;
	  		this.priorMarginBottom = blockstyle["margin-bottom"] || 0;

	  		if (blockstyle['page-break-before'] === 'always') {
	  			this.pdf.addPage();
	  			this.y = 0;
	  			paragraphspacing_before = ((blockstyle["margin-top"] || 0) + (blockstyle["padding-top"] || 0)) * fontToUnitRatio;
	  		}

	  		out = this.pdf.internal.write;
	  		i = void 0;
	  		l = void 0;
	  		this.y += paragraphspacing_before;
	  		out("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");

	  		//stores the current indent of cursor position
	  		var currentIndent = 0;

	  		while (lines.length) {
	  			line = lines.shift();
	  			maxLineHeight = 0;
	  			i = 0;
	  			l = line.length;
	  			while (i !== l) {
	  				if (line[i][0].trim()) {
	  					maxLineHeight = Math.max(maxLineHeight, line[i][1]["line-height"], line[i][1]["font-size"]);
	  					fontSize = line[i][1]["font-size"] * 7;
	  				}
	  				i++;
	  			}
	  			//if we have to move the cursor to adapt the indent
	  			var indentMove = 0;
	  			var wantedIndent = 0;
	  			//if a margin was added (by e.g. a text-alignment), move the cursor
	  			if (line[0][1]["margin-left"] !== undefined && line[0][1]["margin-left"] > 0) {
	  				wantedIndent = this.pdf.internal.getCoordinateString(line[0][1]["margin-left"]);
	  				indentMove = wantedIndent - currentIndent;
	  				currentIndent = wantedIndent;
	  			}
	  			var indentMore = Math.max(blockstyle["margin-left"] || 0, 0) * fontToUnitRatio;
	  			//move the cursor
	  			out(indentMove + indentMore, (-1 * defaultFontSize * maxLineHeight).toFixed(2), "Td");
	  			i = 0;
	  			l = line.length;
	  			while (i !== l) {
	  				if (line[i][0]) {
	  					this.RenderTextFragment(line[i][0], line[i][1]);
	  				}
	  				i++;
	  			}
	  			this.y += maxLineHeight * fontToUnitRatio;

	  			//if some watcher function was executed successful, so e.g. margin and widths were changed,
	  			//reset line drawing and calculate position and lines again
	  			//e.g. to stop text floating around an image
	  			if (this.executeWatchFunctions(line[0][1]) && lines.length > 0) {
	  				var localFragments = [];
	  				var localStyles = [];
	  				//create fragment array of
	  				lines.forEach(function (localLine) {
	  					var i = 0;
	  					var l = localLine.length;
	  					while (i !== l) {
	  						if (localLine[i][0]) {
	  							localFragments.push(localLine[i][0] + ' ');
	  							localStyles.push(localLine[i][1]);
	  						}
	  						++i;
	  					}
	  				});
	  				//split lines again due to possible coordinate changes
	  				lines = this.splitFragmentsIntoLines(PurgeWhiteSpace(localFragments), localStyles);
	  				//reposition the current cursor
	  				out("ET", "Q");
	  				out("q", "BT 0 g", this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), "Td");
	  			}
	  		}
	  		if (cb && typeof cb === "function") {
	  			cb.call(this, this.x - 9, this.y - fontSize / 2);
	  		}
	  		out("ET", "Q");
	  		return this.y += paragraphspacing_after;
	  	};
	  	Renderer.prototype.setBlockBoundary = function (cb) {
	  		return this.renderParagraph(cb);
	  	};
	  	Renderer.prototype.setBlockStyle = function (css) {
	  		return this.paragraph.blockstyle = css;
	  	};
	  	Renderer.prototype.addText = function (text, css) {
	  		this.paragraph.text.push(text);
	  		return this.paragraph.style.push(css);
	  	};
	  	FontNameDB = {
	  		helvetica: "helvetica",
	  		"sans-serif": "helvetica",
	  		"times new roman": "times",
	  		serif: "times",
	  		times: "times",
	  		monospace: "courier",
	  		courier: "courier"
	  	};
	  	FontWeightMap = {
	  		100: "normal",
	  		200: "normal",
	  		300: "normal",
	  		400: "normal",
	  		500: "bold",
	  		600: "bold",
	  		700: "bold",
	  		800: "bold",
	  		900: "bold",
	  		normal: "normal",
	  		bold: "bold",
	  		bolder: "bold",
	  		lighter: "normal"
	  	};
	  	FontStyleMap = {
	  		normal: "normal",
	  		italic: "italic",
	  		oblique: "italic"
	  	};
	  	TextAlignMap = {
	  		left: "left",
	  		right: "right",
	  		center: "center",
	  		justify: "justify"
	  	};
	  	FloatMap = {
	  		none: 'none',
	  		right: 'right',
	  		left: 'left'
	  	};
	  	ClearMap = {
	  		none: 'none',
	  		both: 'both'
	  	};
	  	UnitedNumberMap = {
	  		normal: 1
	  	};
	  	/**
	    * Converts HTML-formatted text into formatted PDF text.
	    *
	    * Notes:
	    * 2012-07-18
	    * Plugin relies on having browser, DOM around. The HTML is pushed into dom and traversed.
	    * Plugin relies on jQuery for CSS extraction.
	    * Targeting HTML output from Markdown templating, which is a very simple
	    * markup - div, span, em, strong, p. No br-based paragraph separation supported explicitly (but still may work.)
	    * Images, tables are NOT supported.
	    *
	    * @public
	    * @function
	    * @param HTML {String or DOM Element} HTML-formatted text, or pointer to DOM element that is to be rendered into PDF.
	    * @param x {Number} starting X coordinate in jsPDF instance's declared units.
	    * @param y {Number} starting Y coordinate in jsPDF instance's declared units.
	    * @param settings {Object} Additional / optional variables controlling parsing, rendering.
	    * @returns {Object} jsPDF instance
	    */
	  	jsPDFAPI.fromHTML = function (HTML, x, y, settings, callback, margins) {

	  		this.margins_doc = margins || {
	  			top: 0,
	  			bottom: 0
	  		};
	  		if (!settings) settings = {};
	  		if (!settings.elementHandlers) settings.elementHandlers = {};

	  		return process(this, HTML, isNaN(x) ? 4 : x, isNaN(y) ? 4 : y, settings, callback);
	  	};
	  })(jsPDF.API);

	  /** ==================================================================== 
	   * jsPDF JavaScript plugin
	   * Copyright (c) 2013 Youssef Beddad, youssef.beddad@gmail.com
	   * 
	   * 
	   * ====================================================================
	   */

	  /*global jsPDF */

	  (function (jsPDFAPI) {

	      var jsNamesObj, jsJsObj, text;
	      jsPDFAPI.addJS = function (txt) {
	          text = txt;
	          this.internal.events.subscribe('postPutResources', function (txt) {
	              jsNamesObj = this.internal.newObject();
	              this.internal.out('<<');
	              this.internal.out('/Names [(EmbeddedJS) ' + (jsNamesObj + 1) + ' 0 R]');
	              this.internal.out('>>');
	              this.internal.out('endobj');

	              jsJsObj = this.internal.newObject();
	              this.internal.out('<<');
	              this.internal.out('/S /JavaScript');
	              this.internal.out('/JS (' + text + ')');
	              this.internal.out('>>');
	              this.internal.out('endobj');
	          });
	          this.internal.events.subscribe('putCatalog', function () {
	              if (jsNamesObj !== undefined && jsJsObj !== undefined) {
	                  this.internal.out('/Names <</JavaScript ' + jsNamesObj + ' 0 R>>');
	              }
	          });
	          return this;
	      };
	  })(jsPDF.API);

	  /**
	   * jsPDF Outline PlugIn
	   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */
	  (function (jsPDFAPI) {

	  	jsPDFAPI.events.push(['postPutResources', function () {
	  		var pdf = this;
	  		var rx = /^(\d+) 0 obj$/;

	  		// Write action goto objects for each page
	  		// this.outline.destsGoto = [];
	  		// for (var i = 0; i < totalPages; i++) {
	  		// var id = pdf.internal.newObject();
	  		// this.outline.destsGoto.push(id);
	  		// pdf.internal.write("<</D[" + (i * 2 + 3) + " 0 R /XYZ null
	  		// null null]/S/GoTo>> endobj");
	  		// }
	  		//
	  		// for (var i = 0; i < dests.length; i++) {
	  		// pdf.internal.write("(page_" + (i + 1) + ")" + dests[i] + " 0
	  		// R");
	  		// }
	  		//				
	  		if (this.outline.root.children.length > 0) {
	  			var lines = pdf.outline.render().split(/\r\n/);
	  			for (var i = 0; i < lines.length; i++) {
	  				var line = lines[i];
	  				var m = rx.exec(line);
	  				if (m != null) {
	  					var oid = m[1];
	  					pdf.internal.newObjectDeferredBegin(oid);
	  				}
	  				pdf.internal.write(line);
	  			}
	  		}

	  		// This code will write named destination for each page reference
	  		// (page_1, etc)
	  		if (this.outline.createNamedDestinations) {
	  			var totalPages = this.internal.pages.length;
	  			// WARNING: this assumes jsPDF starts on page 3 and pageIDs
	  			// follow 5, 7, 9, etc
	  			// Write destination objects for each page
	  			var dests = [];
	  			for (var i = 0; i < totalPages; i++) {
	  				var id = pdf.internal.newObject();
	  				dests.push(id);
	  				var info = pdf.internal.getPageInfo(i + 1);
	  				pdf.internal.write("<< /D[" + info.objId + " 0 R /XYZ null null null]>> endobj");
	  			}

	  			// assign a name for each destination
	  			var names2Oid = pdf.internal.newObject();
	  			pdf.internal.write('<< /Names [ ');
	  			for (var i = 0; i < dests.length; i++) {
	  				pdf.internal.write("(page_" + (i + 1) + ")" + dests[i] + " 0 R");
	  			}
	  			pdf.internal.write(' ] >>', 'endobj');

	  			// var kids = pdf.internal.newObject();
	  			// pdf.internal.write('<< /Kids [ ' + names2Oid + ' 0 R');
	  			// pdf.internal.write(' ] >>', 'endobj');

	  			var namesOid = pdf.internal.newObject();
	  			pdf.internal.write('<< /Dests ' + names2Oid + " 0 R");
	  			pdf.internal.write('>>', 'endobj');
	  		}
	  	}]);

	  	jsPDFAPI.events.push(['putCatalog', function () {
	  		var pdf = this;
	  		if (pdf.outline.root.children.length > 0) {
	  			pdf.internal.write("/Outlines", this.outline.makeRef(this.outline.root));
	  			if (this.outline.createNamedDestinations) {
	  				pdf.internal.write("/Names " + namesOid + " 0 R");
	  			}
	  			// Open with Bookmarks showing
	  			// pdf.internal.write("/PageMode /UseOutlines");
	  		}
	  	}]);

	  	jsPDFAPI.events.push(['initialized', function () {
	  		var pdf = this;

	  		pdf.outline = {
	  			createNamedDestinations: false,
	  			root: {
	  				children: []
	  			}
	  		};

	  		/**
	     * Options: pageNumber
	     */
	  		pdf.outline.add = function (parent, title, options) {
	  			var item = {
	  				title: title,
	  				options: options,
	  				children: []
	  			};
	  			if (parent == null) {
	  				parent = this.root;
	  			}
	  			parent.children.push(item);
	  			return item;
	  		};

	  		pdf.outline.render = function () {
	  			this.ctx = {};
	  			this.ctx.val = '';
	  			this.ctx.pdf = pdf;

	  			this.genIds_r(this.root);
	  			this.renderRoot(this.root);
	  			this.renderItems(this.root);

	  			return this.ctx.val;
	  		};

	  		pdf.outline.genIds_r = function (node) {
	  			node.id = pdf.internal.newObjectDeferred();
	  			for (var i = 0; i < node.children.length; i++) {
	  				this.genIds_r(node.children[i]);
	  			}
	  		};

	  		pdf.outline.renderRoot = function (node) {
	  			this.objStart(node);
	  			this.line('/Type /Outlines');
	  			if (node.children.length > 0) {
	  				this.line('/First ' + this.makeRef(node.children[0]));
	  				this.line('/Last ' + this.makeRef(node.children[node.children.length - 1]));
	  			}
	  			this.line('/Count ' + this.count_r({
	  				count: 0
	  			}, node));
	  			this.objEnd();
	  		};

	  		pdf.outline.renderItems = function (node) {
	  			for (var i = 0; i < node.children.length; i++) {
	  				var item = node.children[i];
	  				this.objStart(item);

	  				this.line('/Title ' + this.makeString(item.title));

	  				this.line('/Parent ' + this.makeRef(node));
	  				if (i > 0) {
	  					this.line('/Prev ' + this.makeRef(node.children[i - 1]));
	  				}
	  				if (i < node.children.length - 1) {
	  					this.line('/Next ' + this.makeRef(node.children[i + 1]));
	  				}
	  				if (item.children.length > 0) {
	  					this.line('/First ' + this.makeRef(item.children[0]));
	  					this.line('/Last ' + this.makeRef(item.children[item.children.length - 1]));
	  				}

	  				var count = this.count = this.count_r({
	  					count: 0
	  				}, item);
	  				if (count > 0) {
	  					this.line('/Count ' + count);
	  				}

	  				if (item.options) {
	  					if (item.options.pageNumber) {
	  						// Explicit Destination
	  						//WARNING this assumes page ids are 3,5,7, etc.
	  						var info = pdf.internal.getPageInfo(item.options.pageNumber);
	  						this.line('/Dest ' + '[' + info.objId + ' 0 R /XYZ 0 ' + this.ctx.pdf.internal.pageSize.getHeight() * this.ctx.pdf.internal.scaleFactor + ' 0]');
	  						// this line does not work on all clients (pageNumber instead of page ref)
	  						//this.line('/Dest ' + '[' + (item.options.pageNumber - 1) + ' /XYZ 0 ' + this.ctx.pdf.internal.pageSize.getHeight() + ' 0]');

	  						// Named Destination
	  						// this.line('/Dest (page_' + (item.options.pageNumber) + ')');

	  						// Action Destination
	  						// var id = pdf.internal.newObject();
	  						// pdf.internal.write('<</D[' + (item.options.pageNumber - 1) + ' /XYZ null null null]/S/GoTo>> endobj');
	  						// this.line('/A ' + id + ' 0 R' );
	  					}
	  				}
	  				this.objEnd();
	  			}
	  			for (var i = 0; i < node.children.length; i++) {
	  				var item = node.children[i];
	  				this.renderItems(item);
	  			}
	  		};

	  		pdf.outline.line = function (text) {
	  			this.ctx.val += text + '\r\n';
	  		};

	  		pdf.outline.makeRef = function (node) {
	  			return node.id + ' 0 R';
	  		};

	  		pdf.outline.makeString = function (val) {
	  			return '(' + pdf.internal.pdfEscape(val) + ')';
	  		};

	  		pdf.outline.objStart = function (node) {
	  			this.ctx.val += '\r\n' + node.id + ' 0 obj' + '\r\n<<\r\n';
	  		};

	  		pdf.outline.objEnd = function (node) {
	  			this.ctx.val += '>> \r\n' + 'endobj' + '\r\n';
	  		};

	  		pdf.outline.count_r = function (ctx, node) {
	  			for (var i = 0; i < node.children.length; i++) {
	  				ctx.count++;
	  				this.count_r(ctx, node.children[i]);
	  			}
	  			return ctx.count;
	  		};
	  	}]);

	  	return this;
	  })(jsPDF.API);

	  /**@preserve
	   *  ====================================================================
	   * jsPDF PNG PlugIn
	   * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
	   *
	   * 
	   * ====================================================================
	   */

	  (function (jsPDFAPI) {

	  	/*
	    * @see http://www.w3.org/TR/PNG-Chunks.html
	    *
	    Color    Allowed      Interpretation
	    Type     Bit Depths
	   	   0       1,2,4,8,16  Each pixel is a grayscale sample.
	   	   2       8,16        Each pixel is an R,G,B triple.
	   	   3       1,2,4,8     Each pixel is a palette index;
	                          a PLTE chunk must appear.
	   	   4       8,16        Each pixel is a grayscale sample,
	                          followed by an alpha sample.
	   	   6       8,16        Each pixel is an R,G,B triple,
	                          followed by an alpha sample.
	   */

	  	/*
	    * PNG filter method types
	    *
	    * @see http://www.w3.org/TR/PNG-Filters.html
	    * @see http://www.libpng.org/pub/png/book/chapter09.html
	    *
	    * This is what the value 'Predictor' in decode params relates to
	    *
	    * 15 is "optimal prediction", which means the prediction algorithm can change from line to line.
	    * In that case, you actually have to read the first byte off each line for the prediction algorthim (which should be 0-4, corresponding to PDF 10-14) and select the appropriate unprediction algorithm based on that byte.
	    *
	      0       None
	      1       Sub
	      2       Up
	      3       Average
	      4       Paeth
	    */

	  	var doesNotHavePngJS = function doesNotHavePngJS() {
	  		return typeof PNG !== 'function' || typeof FlateStream !== 'function';
	  	},
	  	    canCompress = function canCompress(value) {
	  		return value !== jsPDFAPI.image_compression.NONE && hasCompressionJS();
	  	},
	  	    hasCompressionJS = function hasCompressionJS() {
	  		var inst = typeof Deflater === 'function';
	  		if (!inst) throw new Error("requires deflate.js for compression");
	  		return inst;
	  	},
	  	    compressBytes = function compressBytes(bytes, lineLength, colorsPerPixel, compression) {

	  		var level = 5,
	  		    filter_method = filterUp;

	  		switch (compression) {

	  			case jsPDFAPI.image_compression.FAST:

	  				level = 3;
	  				filter_method = filterSub;
	  				break;

	  			case jsPDFAPI.image_compression.MEDIUM:

	  				level = 6;
	  				filter_method = filterAverage;
	  				break;

	  			case jsPDFAPI.image_compression.SLOW:

	  				level = 9;
	  				filter_method = filterPaeth; //uses to sum to choose best filter for each line
	  				break;
	  		}

	  		bytes = applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method);

	  		var header = new Uint8Array(createZlibHeader(level));
	  		var checksum = adler32(bytes);

	  		var deflate = new Deflater(level);
	  		var a = deflate.append(bytes);
	  		var cBytes = deflate.flush();

	  		var len = header.length + a.length + cBytes.length;

	  		var cmpd = new Uint8Array(len + 4);
	  		cmpd.set(header);
	  		cmpd.set(a, header.length);
	  		cmpd.set(cBytes, header.length + a.length);

	  		cmpd[len++] = checksum >>> 24 & 0xff;
	  		cmpd[len++] = checksum >>> 16 & 0xff;
	  		cmpd[len++] = checksum >>> 8 & 0xff;
	  		cmpd[len++] = checksum & 0xff;

	  		return jsPDFAPI.arrayBufferToBinaryString(cmpd);
	  	},
	  	    createZlibHeader = function createZlibHeader(bytes, level) {
	  		/*
	     * @see http://www.ietf.org/rfc/rfc1950.txt for zlib header
	     */
	  		var cm = 8;
	  		var cinfo = Math.LOG2E * Math.log(0x8000) - 8;
	  		var cmf = cinfo << 4 | cm;

	  		var hdr = cmf << 8;
	  		var flevel = Math.min(3, (level - 1 & 0xff) >> 1);

	  		hdr |= flevel << 6;
	  		hdr |= 0; //FDICT
	  		hdr += 31 - hdr % 31;

	  		return [cmf, hdr & 0xff & 0xff];
	  	},
	  	    adler32 = function adler32(array, param) {
	  		var adler = 1;
	  		var s1 = adler & 0xffff,
	  		    s2 = adler >>> 16 & 0xffff;
	  		var len = array.length;
	  		var tlen;
	  		var i = 0;

	  		while (len > 0) {
	  			tlen = len > param ? param : len;
	  			len -= tlen;
	  			do {
	  				s1 += array[i++];
	  				s2 += s1;
	  			} while (--tlen);

	  			s1 %= 65521;
	  			s2 %= 65521;
	  		}

	  		return (s2 << 16 | s1) >>> 0;
	  	},
	  	    applyPngFilterMethod = function applyPngFilterMethod(bytes, lineLength, colorsPerPixel, filter_method) {
	  		var lines = bytes.length / lineLength,
	  		    result = new Uint8Array(bytes.length + lines),
	  		    filter_methods = getFilterMethods(),
	  		    i = 0,
	  		    line,
	  		    prevLine,
	  		    offset;

	  		for (; i < lines; i++) {
	  			offset = i * lineLength;
	  			line = bytes.subarray(offset, offset + lineLength);

	  			if (filter_method) {
	  				result.set(filter_method(line, colorsPerPixel, prevLine), offset + i);
	  			} else {

	  				var j = 0,
	  				    len = filter_methods.length,
	  				    results = [];

	  				for (; j < len; j++) {
	  					results[j] = filter_methods[j](line, colorsPerPixel, prevLine);
	  				}var ind = getIndexOfSmallestSum(results.concat());

	  				result.set(results[ind], offset + i);
	  			}

	  			prevLine = line;
	  		}

	  		return result;
	  	},
	  	    filterNone = function filterNone(line, colorsPerPixel, prevLine) {
	  		/*var result = new Uint8Array(line.length + 1);
	    result[0] = 0;
	    result.set(line, 1);*/

	  		var result = Array.apply([], line);
	  		result.unshift(0);

	  		return result;
	  	},
	  	    filterSub = function filterSub(line, colorsPerPixel, prevLine) {
	  		var result = [],
	  		    i = 0,
	  		    len = line.length,
	  		    left;

	  		result[0] = 1;

	  		for (; i < len; i++) {
	  			left = line[i - colorsPerPixel] || 0;
	  			result[i + 1] = line[i] - left + 0x0100 & 0xff;
	  		}

	  		return result;
	  	},
	  	    filterUp = function filterUp(line, colorsPerPixel, prevLine) {
	  		var result = [],
	  		    i = 0,
	  		    len = line.length,
	  		    up;

	  		result[0] = 2;

	  		for (; i < len; i++) {
	  			up = prevLine && prevLine[i] || 0;
	  			result[i + 1] = line[i] - up + 0x0100 & 0xff;
	  		}

	  		return result;
	  	},
	  	    filterAverage = function filterAverage(line, colorsPerPixel, prevLine) {
	  		var result = [],
	  		    i = 0,
	  		    len = line.length,
	  		    left,
	  		    up;

	  		result[0] = 3;

	  		for (; i < len; i++) {
	  			left = line[i - colorsPerPixel] || 0;
	  			up = prevLine && prevLine[i] || 0;
	  			result[i + 1] = line[i] + 0x0100 - (left + up >>> 1) & 0xff;
	  		}

	  		return result;
	  	},
	  	    filterPaeth = function filterPaeth(line, colorsPerPixel, prevLine) {
	  		var result = [],
	  		    i = 0,
	  		    len = line.length,
	  		    left,
	  		    up,
	  		    upLeft,
	  		    paeth;

	  		result[0] = 4;

	  		for (; i < len; i++) {
	  			left = line[i - colorsPerPixel] || 0;
	  			up = prevLine && prevLine[i] || 0;
	  			upLeft = prevLine && prevLine[i - colorsPerPixel] || 0;
	  			paeth = paethPredictor(left, up, upLeft);
	  			result[i + 1] = line[i] - paeth + 0x0100 & 0xff;
	  		}

	  		return result;
	  	},
	  	    paethPredictor = function paethPredictor(left, up, upLeft) {

	  		var p = left + up - upLeft,
	  		    pLeft = Math.abs(p - left),
	  		    pUp = Math.abs(p - up),
	  		    pUpLeft = Math.abs(p - upLeft);

	  		return pLeft <= pUp && pLeft <= pUpLeft ? left : pUp <= pUpLeft ? up : upLeft;
	  	},
	  	    getFilterMethods = function getFilterMethods() {
	  		return [filterNone, filterSub, filterUp, filterAverage, filterPaeth];
	  	},
	  	    getIndexOfSmallestSum = function getIndexOfSmallestSum(arrays) {
	  		var i = 0,
	  		    len = arrays.length,
	  		    sum,
	  		    min,
	  		    ind;

	  		while (i < len) {
	  			sum = absSum(arrays[i].slice(1));

	  			if (sum < min || !min) {
	  				min = sum;
	  				ind = i;
	  			}

	  			i++;
	  		}

	  		return ind;
	  	},
	  	    absSum = function absSum(array) {
	  		var i = 0,
	  		    len = array.length,
	  		    sum = 0;

	  		while (i < len) {
	  			sum += Math.abs(array[i++]);
	  		}return sum;
	  	},
	  	    getPredictorFromCompression = function getPredictorFromCompression(compression) {
	  		var predictor;
	  		switch (compression) {
	  			case jsPDFAPI.image_compression.FAST:
	  				predictor = 11;
	  				break;

	  			case jsPDFAPI.image_compression.MEDIUM:
	  				predictor = 13;
	  				break;

	  			case jsPDFAPI.image_compression.SLOW:
	  				predictor = 14;
	  				break;

	  			default:
	  				predictor = 12;
	  				break;
	  		}
	  		return predictor;
	  	};

	  	jsPDFAPI.processPNG = function (imageData, imageIndex, alias, compression, dataAsBinaryString) {

	  		var colorSpace = this.color_spaces.DEVICE_RGB,
	  		    decode = this.decode.FLATE_DECODE,
	  		    bpc = 8,
	  		    img,
	  		    dp,
	  		    trns,
	  		    colors,
	  		    pal,
	  		    smask;

	  		/*	if(this.isString(imageData)) {
	    		}*/

	  		if (this.isArrayBuffer(imageData)) imageData = new Uint8Array(imageData);

	  		if (this.isArrayBufferView(imageData)) {

	  			if (doesNotHavePngJS()) throw new Error("PNG support requires png.js and zlib.js");

	  			img = new PNG(imageData);
	  			imageData = img.imgData;
	  			bpc = img.bits;
	  			colorSpace = img.colorSpace;
	  			colors = img.colors;

	  			//logImg(img);

	  			/*
	      * colorType 6 - Each pixel is an R,G,B triple, followed by an alpha sample.
	      *
	      * colorType 4 - Each pixel is a grayscale sample, followed by an alpha sample.
	      *
	      * Extract alpha to create two separate images, using the alpha as a sMask
	      */
	  			if ([4, 6].indexOf(img.colorType) !== -1) {

	  				/*
	       * processes 8 bit RGBA and grayscale + alpha images
	       */
	  				if (img.bits === 8) {

	  					var pixels = img.pixelBitlength == 32 ? new Uint32Array(img.decodePixels().buffer) : img.pixelBitlength == 16 ? new Uint16Array(img.decodePixels().buffer) : new Uint8Array(img.decodePixels().buffer),
	  					    len = pixels.length,
	  					    imgData = new Uint8Array(len * img.colors),
	  					    alphaData = new Uint8Array(len),
	  					    pDiff = img.pixelBitlength - img.bits,
	  					    i = 0,
	  					    n = 0,
	  					    pixel,
	  					    pbl;

	  					for (; i < len; i++) {
	  						pixel = pixels[i];
	  						pbl = 0;

	  						while (pbl < pDiff) {

	  							imgData[n++] = pixel >>> pbl & 0xff;
	  							pbl = pbl + img.bits;
	  						}

	  						alphaData[i] = pixel >>> pbl & 0xff;
	  					}
	  				}

	  				/*
	       * processes 16 bit RGBA and grayscale + alpha images
	       */
	  				if (img.bits === 16) {

	  					var pixels = new Uint32Array(img.decodePixels().buffer),
	  					    len = pixels.length,
	  					    imgData = new Uint8Array(len * (32 / img.pixelBitlength) * img.colors),
	  					    alphaData = new Uint8Array(len * (32 / img.pixelBitlength)),
	  					    hasColors = img.colors > 1,
	  					    i = 0,
	  					    n = 0,
	  					    a = 0,
	  					    pixel;

	  					while (i < len) {
	  						pixel = pixels[i++];

	  						imgData[n++] = pixel >>> 0 & 0xFF;

	  						if (hasColors) {
	  							imgData[n++] = pixel >>> 16 & 0xFF;

	  							pixel = pixels[i++];
	  							imgData[n++] = pixel >>> 0 & 0xFF;
	  						}

	  						alphaData[a++] = pixel >>> 16 & 0xFF;
	  					}

	  					bpc = 8;
	  				}

	  				if (canCompress(compression)) {

	  					imageData = compressBytes(imgData, img.width * img.colors, img.colors, compression);
	  					smask = compressBytes(alphaData, img.width, 1, compression);
	  				} else {

	  					imageData = imgData;
	  					smask = alphaData;
	  					decode = null;
	  				}
	  			}

	  			/*
	      * Indexed png. Each pixel is a palette index.
	      */
	  			if (img.colorType === 3) {

	  				colorSpace = this.color_spaces.INDEXED;
	  				pal = img.palette;

	  				if (img.transparency.indexed) {

	  					var trans = img.transparency.indexed;

	  					var total = 0,
	  					    i = 0,
	  					    len = trans.length;

	  					for (; i < len; ++i) {
	  						total += trans[i];
	  					}total = total / 255;

	  					/*
	        * a single color is specified as 100% transparent (0),
	        * so we set trns to use a /Mask with that index
	        */
	  					if (total === len - 1 && trans.indexOf(0) !== -1) {
	  						trns = [trans.indexOf(0)];

	  						/*
	         * there's more than one colour within the palette that specifies
	         * a transparency value less than 255, so we unroll the pixels to create an image sMask
	         */
	  					} else if (total !== len) {

	  						var pixels = img.decodePixels(),
	  						    alphaData = new Uint8Array(pixels.length),
	  						    i = 0,
	  						    len = pixels.length;

	  						for (; i < len; i++) {
	  							alphaData[i] = trans[pixels[i]];
	  						}smask = compressBytes(alphaData, img.width, 1);
	  					}
	  				}
	  			}

	  			var predictor = getPredictorFromCompression(compression);

	  			if (decode === this.decode.FLATE_DECODE) dp = '/Predictor ' + predictor + ' /Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;else
	  				//remove 'Predictor' as it applies to the type of png filter applied to its IDAT - we only apply with compression
	  				dp = '/Colors ' + colors + ' /BitsPerComponent ' + bpc + ' /Columns ' + img.width;

	  			if (this.isArrayBuffer(imageData) || this.isArrayBufferView(imageData)) imageData = this.arrayBufferToBinaryString(imageData);

	  			if (smask && this.isArrayBuffer(smask) || this.isArrayBufferView(smask)) smask = this.arrayBufferToBinaryString(smask);

	  			return this.createImageInfo(imageData, img.width, img.height, colorSpace, bpc, decode, imageIndex, alias, dp, trns, pal, smask, predictor);
	  		}

	  		throw new Error("Unsupported PNG image data, try using JPEG instead.");
	  	};
	  })(jsPDF.API);

	  /**
	   * jsPDF gif Support PlugIn
	   * Copyright (c) 2017 Aras Abbasi 
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  (function (jsPDFAPI) {

	  	jsPDFAPI.processGIF89A = function (imageData, imageIndex, alias, compression, dataAsBinaryString) {
	  		var reader = new GifReader(imageData);
	  		var width = reader.width,
	  		    height = reader.height;
	  		var qu = 100;
	  		var pixels = [];

	  		reader.decodeAndBlitFrameRGBA(0, pixels);
	  		var rawImageData = {
	  			data: pixels,
	  			width: width,
	  			height: height
	  		};

	  		var encoder = new JPEGEncoder(qu);
	  		var data = encoder.encode(rawImageData, qu);
	  		return jsPDFAPI.processJPEG.call(this, data, imageIndex, alias, compression);
	  	};

	  	jsPDFAPI.processGIF87A = jsPDFAPI.processGIF89A;
	  })(jsPDF.API);

	  /**
	   * jsPDF bmp Support PlugIn
	   * Copyright (c) 2018 Aras Abbasi 
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  (function (jsPDFAPI) {

	  	jsPDFAPI.processBMP = function (imageData, imageIndex, alias, compression, dataAsBinaryString) {
	  		var reader = new BmpDecoder(imageData, false);
	  		var width = reader.width,
	  		    height = reader.height;
	  		var qu = 100;
	  		var pixels = reader.getData();

	  		var rawImageData = {
	  			data: pixels,
	  			width: width,
	  			height: height
	  		};

	  		var encoder = new JPEGEncoder(qu);
	  		var data = encoder.encode(rawImageData, qu);
	  		return jsPDFAPI.processJPEG.call(this, data, imageIndex, alias, compression);
	  	};
	  })(jsPDF.API);

	  /**
	   * jsPDF setLanguage Plugin
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  (function (jsPDFAPI) {

	      /**
	      * Add Language Tag to PDF
	      *
	      * @returns {jsPDF}
	      * @name setLanguage
	      * @example
	      * var doc = new jsPDF()
	      * doc.text(10, 10, 'This is a test')
	      * doc.setLanguage("en-US")
	      * doc.save('english.pdf')
	      */

	      jsPDFAPI.setLanguage = function (langCode) {

	          var langCodes = {
	              "af": "Afrikaans",
	              "sq": "Albanian",
	              "ar": "Arabic (Standard)",
	              "ar-DZ": "Arabic (Algeria)",
	              "ar-BH": "Arabic (Bahrain)",
	              "ar-EG": "Arabic (Egypt)",
	              "ar-IQ": "Arabic (Iraq)",
	              "ar-JO": "Arabic (Jordan)",
	              "ar-KW": "Arabic (Kuwait)",
	              "ar-LB": "Arabic (Lebanon)",
	              "ar-LY": "Arabic (Libya)",
	              "ar-MA": "Arabic (Morocco)",
	              "ar-OM": "Arabic (Oman)",
	              "ar-QA": "Arabic (Qatar)",
	              "ar-SA": "Arabic (Saudi Arabia)",
	              "ar-SY": "Arabic (Syria)",
	              "ar-TN": "Arabic (Tunisia)",
	              "ar-AE": "Arabic (U.A.E.)",
	              "ar-YE": "Arabic (Yemen)",
	              "an": "Aragonese",
	              "hy": "Armenian",
	              "as": "Assamese",
	              "ast": "Asturian",
	              "az": "Azerbaijani",
	              "eu": "Basque",
	              "be": "Belarusian",
	              "bn": "Bengali",
	              "bs": "Bosnian",
	              "br": "Breton",
	              "bg": "Bulgarian",
	              "my": "Burmese",
	              "ca": "Catalan",
	              "ch": "Chamorro",
	              "ce": "Chechen",
	              "zh": "Chinese",
	              "zh-HK": "Chinese (Hong Kong)",
	              "zh-CN": "Chinese (PRC)",
	              "zh-SG": "Chinese (Singapore)",
	              "zh-TW": "Chinese (Taiwan)",
	              "cv": "Chuvash",
	              "co": "Corsican",
	              "cr": "Cree",
	              "hr": "Croatian",
	              "cs": "Czech",
	              "da": "Danish",
	              "nl": "Dutch (Standard)",
	              "nl-BE": "Dutch (Belgian)",
	              "en": "English",
	              "en-AU": "English (Australia)",
	              "en-BZ": "English (Belize)",
	              "en-CA": "English (Canada)",
	              "en-IE": "English (Ireland)",
	              "en-JM": "English (Jamaica)",
	              "en-NZ": "English (New Zealand)",
	              "en-PH": "English (Philippines)",
	              "en-ZA": "English (South Africa)",
	              "en-TT": "English (Trinidad & Tobago)",
	              "en-GB": "English (United Kingdom)",
	              "en-US": "English (United States)",
	              "en-ZW": "English (Zimbabwe)",
	              "eo": "Esperanto",
	              "et": "Estonian",
	              "fo": "Faeroese",
	              "fj": "Fijian",
	              "fi": "Finnish",
	              "fr": "French (Standard)",
	              "fr-BE": "French (Belgium)",
	              "fr-CA": "French (Canada)",
	              "fr-FR": "French (France)",
	              "fr-LU": "French (Luxembourg)",
	              "fr-MC": "French (Monaco)",
	              "fr-CH": "French (Switzerland)",
	              "fy": "Frisian",
	              "fur": "Friulian",
	              "gd": "Gaelic (Scots)",
	              "gd-IE": "Gaelic (Irish)",
	              "gl": "Galacian",
	              "ka": "Georgian",
	              "de": "German (Standard)",
	              "de-AT": "German (Austria)",
	              "de-DE": "German (Germany)",
	              "de-LI": "German (Liechtenstein)",
	              "de-LU": "German (Luxembourg)",
	              "de-CH": "German (Switzerland)",
	              "el": "Greek",
	              "gu": "Gujurati",
	              "ht": "Haitian",
	              "he": "Hebrew",
	              "hi": "Hindi",
	              "hu": "Hungarian",
	              "is": "Icelandic",
	              "id": "Indonesian",
	              "iu": "Inuktitut",
	              "ga": "Irish",
	              "it": "Italian (Standard)",
	              "it-CH": "Italian (Switzerland)",
	              "ja": "Japanese",
	              "kn": "Kannada",
	              "ks": "Kashmiri",
	              "kk": "Kazakh",
	              "km": "Khmer",
	              "ky": "Kirghiz",
	              "tlh": "Klingon",
	              "ko": "Korean",
	              "ko-KP": "Korean (North Korea)",
	              "ko-KR": "Korean (South Korea)",
	              "la": "Latin",
	              "lv": "Latvian",
	              "lt": "Lithuanian",
	              "lb": "Luxembourgish",
	              "mk": "FYRO Macedonian",
	              "ms": "Malay",
	              "ml": "Malayalam",
	              "mt": "Maltese",
	              "mi": "Maori",
	              "mr": "Marathi",
	              "mo": "Moldavian",
	              "nv": "Navajo",
	              "ng": "Ndonga",
	              "ne": "Nepali",
	              "no": "Norwegian",
	              "nb": "Norwegian (Bokmal)",
	              "nn": "Norwegian (Nynorsk)",
	              "oc": "Occitan",
	              "or": "Oriya",
	              "om": "Oromo",
	              "fa": "Persian",
	              "fa-IR": "Persian/Iran",
	              "pl": "Polish",
	              "pt": "Portuguese",
	              "pt-BR": "Portuguese (Brazil)",
	              "pa": "Punjabi",
	              "pa-IN": "Punjabi (India)",
	              "pa-PK": "Punjabi (Pakistan)",
	              "qu": "Quechua",
	              "rm": "Rhaeto-Romanic",
	              "ro": "Romanian",
	              "ro-MO": "Romanian (Moldavia)",
	              "ru": "Russian",
	              "ru-MO": "Russian (Moldavia)",
	              "sz": "Sami (Lappish)",
	              "sg": "Sango",
	              "sa": "Sanskrit",
	              "sc": "Sardinian",
	              "sd": "Sindhi",
	              "si": "Singhalese",
	              "sr": "Serbian",
	              "sk": "Slovak",
	              "sl": "Slovenian",
	              "so": "Somani",
	              "sb": "Sorbian",
	              "es": "Spanish",
	              "es-AR": "Spanish (Argentina)",
	              "es-BO": "Spanish (Bolivia)",
	              "es-CL": "Spanish (Chile)",
	              "es-CO": "Spanish (Colombia)",
	              "es-CR": "Spanish (Costa Rica)",
	              "es-DO": "Spanish (Dominican Republic)",
	              "es-EC": "Spanish (Ecuador)",
	              "es-SV": "Spanish (El Salvador)",
	              "es-GT": "Spanish (Guatemala)",
	              "es-HN": "Spanish (Honduras)",
	              "es-MX": "Spanish (Mexico)",
	              "es-NI": "Spanish (Nicaragua)",
	              "es-PA": "Spanish (Panama)",
	              "es-PY": "Spanish (Paraguay)",
	              "es-PE": "Spanish (Peru)",
	              "es-PR": "Spanish (Puerto Rico)",
	              "es-ES": "Spanish (Spain)",
	              "es-UY": "Spanish (Uruguay)",
	              "es-VE": "Spanish (Venezuela)",
	              "sx": "Sutu",
	              "sw": "Swahili",
	              "sv": "Swedish",
	              "sv-FI": "Swedish (Finland)",
	              "sv-SV": "Swedish (Sweden)",
	              "ta": "Tamil",
	              "tt": "Tatar",
	              "te": "Teluga",
	              "th": "Thai",
	              "tig": "Tigre",
	              "ts": "Tsonga",
	              "tn": "Tswana",
	              "tr": "Turkish",
	              "tk": "Turkmen",
	              "uk": "Ukrainian",
	              "hsb": "Upper Sorbian",
	              "ur": "Urdu",
	              "ve": "Venda",
	              "vi": "Vietnamese",
	              "vo": "Volapuk",
	              "wa": "Walloon",
	              "cy": "Welsh",
	              "xh": "Xhosa",
	              "ji": "Yiddish",
	              "zu": "Zulu"
	          };

	          if (this.internal.languageSettings === undefined) {
	              this.internal.languageSettings = {};
	              this.internal.languageSettings.isSubscribed = false;
	          }

	          if (langCodes[langCode] !== undefined) {
	              this.internal.languageSettings.languageCode = langCode;
	              if (this.internal.languageSettings.isSubscribed === false) {
	                  this.internal.events.subscribe("putCatalog", function () {
	                      this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
	                  });
	                  this.internal.languageSettings.isSubscribed = true;
	              }
	          }
	          return this;
	      };
	  })(jsPDF.API);

	  /** @preserve
	   * jsPDF split_text_to_size plugin - MIT license.
	   * Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
	   *               2014 Diego Casorran, https://github.com/diegocr
	   */
	  /**
	   * 
	   * ====================================================================
	   */

	  (function (API) {
	    /**
	     * Returns an array of length matching length of the 'word' string, with each
	     * cell occupied by the width of the char in that position.
	     * 
	     * @function
	     * @param word {String}
	     * @param widths {Object}
	     * @param kerning {Object}
	     * @returns {Array}
	     */

	    var getCharWidthsArray = API.getCharWidthsArray = function (text, options) {
	      options = options || {};

	      var activeFont = options.font || this.internal.getFont();
	      var fontSize = options.fontSize || this.internal.getFontSize();
	      var charSpace = options.charSpace || this.internal.getCharSpace();

	      var widths = options.widths ? options.widths : activeFont.metadata.Unicode.widths;
	      var widthsFractionOf = widths.fof ? widths.fof : 1;
	      var kerning = options.kerning ? options.kerning : activeFont.metadata.Unicode.kerning;
	      var kerningFractionOf = kerning.fof ? kerning.fof : 1;

	      var i;
	      var l;
	      var char_code;
	      var prior_char_code = 0; //for kerning
	      var default_char_width = widths[0] || widthsFractionOf;
	      var output = [];

	      for (i = 0, l = text.length; i < l; i++) {
	        char_code = text.charCodeAt(i);

	        if (typeof activeFont.metadata.widthOfString === "function") {
	          output.push((activeFont.metadata.widthOfGlyph(activeFont.metadata.characterToGlyph(char_code)) + charSpace * (1000 / fontSize) || 0) / 1000);
	        } else {
	          output.push((widths[char_code] || default_char_width) / widthsFractionOf + (kerning[char_code] && kerning[char_code][prior_char_code] || 0) / kerningFractionOf);
	        }
	        prior_char_code = char_code;
	      }

	      return output;
	    };

	    /**
	     * Calculate the sum of a number-array
	     * 
	     * @name getArraySum
	     * @public
	     * @function
	     * @param {array} array of numbers
	     * @returns {Number}
	     */
	    var getArraySum = API.getArraySum = function (array) {
	      var i = array.length,
	          output = 0;
	      while (i) {
	        i--;
	        output += array[i];
	      }
	      return output;
	    };
	    /**
	    Returns a widths of string in a given font, if the font size is set as 1 point.
	     In other words, this is "proportional" value. For 1 unit of font size, the length
	    of the string will be that much.
	     Multiply by font size to get actual width in *points*
	    Then divide by 72 to get inches or divide by (72/25.6) to get 'mm' etc.
	     @public
	    @function
	    @param
	    @returns {Type}
	    */
	    var getStringUnitWidth = API.getStringUnitWidth = function (text, options) {
	      options = options || {};

	      var fontSize = options.fontSize || this.internal.getFontSize();
	      var font = options.font || this.internal.getFont();
	      var charSpace = options.charSpace || this.internal.getCharSpace();
	      var result = 0;
	      if (typeof font.metadata.widthOfString === "function") {
	        result = font.metadata.widthOfString(text, fontSize, charSpace) / fontSize;
	      } else {
	        result = getArraySum(getCharWidthsArray.apply(this, arguments));
	      }
	      return result;
	    };

	    /**
	    returns array of lines
	    */
	    var splitLongWord = function splitLongWord(word, widths_array, firstLineMaxLen, maxLen) {
	      var answer = [];

	      // 1st, chop off the piece that can fit on the hanging line.
	      var i = 0,
	          l = word.length,
	          workingLen = 0;
	      while (i !== l && workingLen + widths_array[i] < firstLineMaxLen) {
	        workingLen += widths_array[i];
	        i++;
	      }
	      // this is first line.
	      answer.push(word.slice(0, i));

	      // 2nd. Split the rest into maxLen pieces.
	      var startOfLine = i;
	      workingLen = 0;
	      while (i !== l) {
	        if (workingLen + widths_array[i] > maxLen) {
	          answer.push(word.slice(startOfLine, i));
	          workingLen = 0;
	          startOfLine = i;
	        }
	        workingLen += widths_array[i];
	        i++;
	      }
	      if (startOfLine !== i) {
	        answer.push(word.slice(startOfLine, i));
	      }

	      return answer;
	    };

	    // Note, all sizing inputs for this function must be in "font measurement units"
	    // By default, for PDF, it's "point".
	    var splitParagraphIntoLines = function splitParagraphIntoLines(text, maxlen, options) {
	      // at this time works only on Western scripts, ones with space char
	      // separating the words. Feel free to expand.

	      if (!options) {
	        options = {};
	      }

	      var line = [],
	          lines = [line],
	          line_length = options.textIndent || 0,
	          separator_length = 0,
	          current_word_length = 0,
	          word,
	          widths_array,
	          words = text.split(' '),
	          spaceCharWidth = getCharWidthsArray.apply(this, [' ', options])[0],
	          i,
	          l,
	          tmp,
	          lineIndent;

	      if (options.lineIndent === -1) {
	        lineIndent = words[0].length + 2;
	      } else {
	        lineIndent = options.lineIndent || 0;
	      }
	      if (lineIndent) {
	        var pad = Array(lineIndent).join(" "),
	            wrds = [];
	        words.map(function (wrd) {
	          wrd = wrd.split(/\s*\n/);
	          if (wrd.length > 1) {
	            wrds = wrds.concat(wrd.map(function (wrd, idx) {
	              return (idx && wrd.length ? "\n" : "") + wrd;
	            }));
	          } else {
	            wrds.push(wrd[0]);
	          }
	        });
	        words = wrds;
	        lineIndent = getStringUnitWidth.apply(this, [pad, options]);
	      }

	      for (i = 0, l = words.length; i < l; i++) {
	        var force = 0;

	        word = words[i];
	        if (lineIndent && word[0] == "\n") {
	          word = word.substr(1);
	          force = 1;
	        }
	        widths_array = getCharWidthsArray.apply(this, [word, options]);
	        current_word_length = getArraySum(widths_array);

	        if (line_length + separator_length + current_word_length > maxlen || force) {
	          if (current_word_length > maxlen) {
	            // this happens when you have space-less long URLs for example.
	            // we just chop these to size. We do NOT insert hiphens
	            tmp = splitLongWord.apply(this, [word, widths_array, maxlen - (line_length + separator_length), maxlen]);
	            // first line we add to existing line object
	            line.push(tmp.shift()); // it's ok to have extra space indicator there
	            // last line we make into new line object
	            line = [tmp.pop()];
	            // lines in the middle we apped to lines object as whole lines
	            while (tmp.length) {
	              lines.push([tmp.shift()]); // single fragment occupies whole line
	            }
	            current_word_length = getArraySum(widths_array.slice(word.length - (line[0] ? line[0].length : 0)));
	          } else {
	            // just put it on a new line
	            line = [word];
	          }

	          // now we attach new line to lines
	          lines.push(line);
	          line_length = current_word_length + lineIndent;
	          separator_length = spaceCharWidth;
	        } else {
	          line.push(word);

	          line_length += separator_length + current_word_length;
	          separator_length = spaceCharWidth;
	        }
	      }

	      if (lineIndent) {
	        var postProcess = function postProcess(ln, idx) {
	          return (idx ? pad : '') + ln.join(" ");
	        };
	      } else {
	        var postProcess = function postProcess(ln) {
	          return ln.join(" ");
	        };
	      }

	      return lines.map(postProcess);
	    };

	    /**
	    Splits a given string into an array of strings. Uses 'size' value
	    (in measurement units declared as default for the jsPDF instance)
	    and the font's "widths" and "Kerning" tables, where available, to
	    determine display length of a given string for a given font.
	     We use character's 100% of unit size (height) as width when Width
	    table or other default width is not available.
	     @public
	    @function
	    @param text {String} Unencoded, regular JavaScript (Unicode, UTF-16 / UCS-2) string.
	    @param size {Number} Nominal number, measured in units default to this instance of jsPDF.
	    @param options {Object} Optional flags needed for chopper to do the right thing.
	    @returns {Array} with strings chopped to size.
	    */
	    API.splitTextToSize = function (text, maxlen, options) {

	      options = options || {};

	      var fsize = options.fontSize || this.internal.getFontSize(),
	          newOptions = function (options) {
	        var widths = {
	          0: 1
	        },
	            kerning = {};

	        if (!options.widths || !options.kerning) {
	          var f = this.internal.getFont(options.fontName, options.fontStyle),
	              encoding = 'Unicode';
	          // NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE
	          // Actual JavaScript-native String's 16bit char codes used.
	          // no multi-byte logic here

	          if (f.metadata[encoding]) {
	            return {
	              widths: f.metadata[encoding].widths || widths,
	              kerning: f.metadata[encoding].kerning || kerning
	            };
	          } else {
	            return {
	              font: f.metadata,
	              fontSize: this.internal.getFontSize(),
	              charSpace: this.internal.getCharSpace()
	            };
	          }
	        } else {
	          return {
	            widths: options.widths,
	            kerning: options.kerning
	          };
	        }

	        // then use default values
	        return {
	          widths: widths,
	          kerning: kerning
	        };
	      }.call(this, options);

	      // first we split on end-of-line chars
	      var paragraphs;
	      if (Array.isArray(text)) {
	        paragraphs = text;
	      } else {
	        paragraphs = text.split(/\r?\n/);
	      }

	      // now we convert size (max length of line) into "font size units"
	      // at present time, the "font size unit" is always 'point'
	      // 'proportional' means, "in proportion to font size"
	      var fontUnit_maxLen = 1.0 * this.internal.scaleFactor * maxlen / fsize;
	      // at this time, fsize is always in "points" regardless of the default measurement unit of the doc.
	      // this may change in the future?
	      // until then, proportional_maxlen is likely to be in 'points'

	      // If first line is to be indented (shorter or longer) than maxLen
	      // we indicate that by using CSS-style "text-indent" option.
	      // here it's in font units too (which is likely 'points')
	      // it can be negative (which makes the first line longer than maxLen)
	      newOptions.textIndent = options.textIndent ? options.textIndent * 1.0 * this.internal.scaleFactor / fsize : 0;
	      newOptions.lineIndent = options.lineIndent;

	      var i,
	          l,
	          output = [];
	      for (i = 0, l = paragraphs.length; i < l; i++) {
	        output = output.concat(splitParagraphIntoLines.apply(this, [paragraphs[i], fontUnit_maxLen, newOptions]));
	      }

	      return output;
	    };
	  })(jsPDF.API);

	  /** @preserve 
	  jsPDF standard_fonts_metrics plugin
	  Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
	  MIT license.
	  */
	  (function (API) {

	  	/*
	   # reference (Python) versions of 'compress' and 'uncompress'
	   # only 'uncompress' function is featured lower as JavaScript
	   # if you want to unit test "roundtrip", just transcribe the reference
	   # 'compress' function from Python into JavaScript
	   
	   def compress(data):
	   
	   	keys =   '0123456789abcdef'
	   	values = 'klmnopqrstuvwxyz'
	   	mapping = dict(zip(keys, values))
	   	vals = []
	   	for key in data.keys():
	   		value = data[key]
	   		try:
	   			keystring = hex(key)[2:]
	   			keystring = keystring[:-1] + mapping[keystring[-1:]]
	   		except:
	   			keystring = key.join(["'","'"])
	   			#print('Keystring is %s' % keystring)
	   
	   		try:
	   			if value < 0:
	   				valuestring = hex(value)[3:]
	   				numberprefix = '-'
	   			else:
	   				valuestring = hex(value)[2:]
	   				numberprefix = ''
	   			valuestring = numberprefix + valuestring[:-1] + mapping[valuestring[-1:]]
	   		except:
	   			if type(value) == dict:
	   				valuestring = compress(value)
	   			else:
	   				raise Exception("Don't know what to do with value type %s" % type(value))
	   
	   		vals.append(keystring+valuestring)
	   	
	   	return '{' + ''.join(vals) + '}'
	   
	   def uncompress(data):
	   
	   	decoded = '0123456789abcdef'
	   	encoded = 'klmnopqrstuvwxyz'
	   	mapping = dict(zip(encoded, decoded))
	   
	   	sign = +1
	   	stringmode = False
	   	stringparts = []
	   
	   	output = {}
	   
	   	activeobject = output
	   	parentchain = []
	   
	   	keyparts = ''
	   	valueparts = ''
	   
	   	key = None
	   
	   	ending = set(encoded)
	   
	   	i = 1
	   	l = len(data) - 1 # stripping starting, ending {}
	   	while i != l: # stripping {}
	   		# -, {, }, ' are special.
	   
	   		ch = data[i]
	   		i += 1
	   
	   		if ch == "'":
	   			if stringmode:
	   				# end of string mode
	   				stringmode = False
	   				key = ''.join(stringparts)
	   			else:
	   				# start of string mode
	   				stringmode = True
	   				stringparts = []
	   		elif stringmode == True:
	   			#print("Adding %s to stringpart" % ch)
	   			stringparts.append(ch)
	   
	   		elif ch == '{':
	   			# start of object
	   			parentchain.append( [activeobject, key] )
	   			activeobject = {}
	   			key = None
	   			#DEBUG = True
	   		elif ch == '}':
	   			# end of object
	   			parent, key = parentchain.pop()
	   			parent[key] = activeobject
	   			key = None
	   			activeobject = parent
	   			#DEBUG = False
	   
	   		elif ch == '-':
	   			sign = -1
	   		else:
	   			# must be number
	   			if key == None:
	   				#debug("In Key. It is '%s', ch is '%s'" % (keyparts, ch))
	   				if ch in ending:
	   					#debug("End of key")
	   					keyparts += mapping[ch]
	   					key = int(keyparts, 16) * sign
	   					sign = +1
	   					keyparts = ''
	   				else:
	   					keyparts += ch
	   			else:
	   				#debug("In value. It is '%s', ch is '%s'" % (valueparts, ch))
	   				if ch in ending:
	   					#debug("End of value")
	   					valueparts += mapping[ch]
	   					activeobject[key] = int(valueparts, 16) * sign
	   					sign = +1
	   					key = None
	   					valueparts = ''
	   				else:
	   					valueparts += ch
	   
	   			#debug(activeobject)
	   
	   	return output
	   
	   */

	  	/**
	   Uncompresses data compressed into custom, base16-like format. 
	   @public
	   @function
	   @param
	   @returns {Type}
	   */

	  	var uncompress = function uncompress(data) {

	  		var decoded = '0123456789abcdef',
	  		    encoded = 'klmnopqrstuvwxyz',
	  		    mapping = {};

	  		for (var i = 0; i < encoded.length; i++) {
	  			mapping[encoded[i]] = decoded[i];
	  		}

	  		var undef,
	  		    output = {},
	  		    sign = 1,
	  		    stringparts // undef. will be [] in string mode

	  		,
	  		    activeobject = output,
	  		    parentchain = [],
	  		    parent_key_pair,
	  		    keyparts = '',
	  		    valueparts = '',
	  		    key // undef. will be Truthy when Key is resolved.
	  		,
	  		    datalen = data.length - 1 // stripping ending }
	  		,
	  		    ch;

	  		i = 1; // stripping starting {

	  		while (i != datalen) {
	  			// - { } ' are special.

	  			ch = data[i];
	  			i += 1;

	  			if (ch == "'") {
	  				if (stringparts) {
	  					// end of string mode
	  					key = stringparts.join('');
	  					stringparts = undef;
	  				} else {
	  					// start of string mode
	  					stringparts = [];
	  				}
	  			} else if (stringparts) {
	  				stringparts.push(ch);
	  			} else if (ch == '{') {
	  				// start of object
	  				parentchain.push([activeobject, key]);
	  				activeobject = {};
	  				key = undef;
	  			} else if (ch == '}') {
	  				// end of object
	  				parent_key_pair = parentchain.pop();
	  				parent_key_pair[0][parent_key_pair[1]] = activeobject;
	  				key = undef;
	  				activeobject = parent_key_pair[0];
	  			} else if (ch == '-') {
	  				sign = -1;
	  			} else {
	  				// must be number
	  				if (key === undef) {
	  					if (mapping.hasOwnProperty(ch)) {
	  						keyparts += mapping[ch];
	  						key = parseInt(keyparts, 16) * sign;
	  						sign = +1;
	  						keyparts = '';
	  					} else {
	  						keyparts += ch;
	  					}
	  				} else {
	  					if (mapping.hasOwnProperty(ch)) {
	  						valueparts += mapping[ch];
	  						activeobject[key] = parseInt(valueparts, 16) * sign;
	  						sign = +1;
	  						key = undef;
	  						valueparts = '';
	  					} else {
	  						valueparts += ch;
	  					}
	  				}
	  			}
	  		} // end while

	  		return output;
	  	};

	  	// encoding = 'Unicode' 
	  	// NOT UTF8, NOT UTF16BE/LE, NOT UCS2BE/LE. NO clever BOM behavior
	  	// Actual 16bit char codes used.
	  	// no multi-byte logic here

	  	// Unicode characters to WinAnsiEncoding:
	  	// {402: 131, 8211: 150, 8212: 151, 8216: 145, 8217: 146, 8218: 130, 8220: 147, 8221: 148, 8222: 132, 8224: 134, 8225: 135, 8226: 149, 8230: 133, 8364: 128, 8240:137, 8249: 139, 8250: 155, 710: 136, 8482: 153, 338: 140, 339: 156, 732: 152, 352: 138, 353: 154, 376: 159, 381: 142, 382: 158}
	  	// as you can see, all Unicode chars are outside of 0-255 range. No char code conflicts.
	  	// this means that you can give Win cp1252 encoded strings to jsPDF for rendering directly
	  	// as well as give strings with some (supported by these fonts) Unicode characters and 
	  	// these will be mapped to win cp1252 
	  	// for example, you can send char code (cp1252) 0x80 or (unicode) 0x20AC, getting "Euro" glyph displayed in both cases.

	  	var encodingBlock = {
	  		'codePages': ['WinAnsiEncoding'],
	  		'WinAnsiEncoding': uncompress("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}")
	  	},
	  	    encodings = { 'Unicode': {
	  			'Courier': encodingBlock,
	  			'Courier-Bold': encodingBlock,
	  			'Courier-BoldOblique': encodingBlock,
	  			'Courier-Oblique': encodingBlock,
	  			'Helvetica': encodingBlock,
	  			'Helvetica-Bold': encodingBlock,
	  			'Helvetica-BoldOblique': encodingBlock,
	  			'Helvetica-Oblique': encodingBlock,
	  			'Times-Roman': encodingBlock,
	  			'Times-Bold': encodingBlock,
	  			'Times-BoldItalic': encodingBlock,
	  			'Times-Italic': encodingBlock
	  			//	, 'Symbol'
	  			//	, 'ZapfDingbats'
	  		}
	  		/** 
	    Resources:
	    Font metrics data is reprocessed derivative of contents of
	    "Font Metrics for PDF Core 14 Fonts" package, which exhibits the following copyright and license:
	    
	    Copyright (c) 1989, 1990, 1991, 1992, 1993, 1997 Adobe Systems Incorporated. All Rights Reserved.
	    
	    This file and the 14 PostScript(R) AFM files it accompanies may be used,
	    copied, and distributed for any purpose and without charge, with or without
	    modification, provided that all copyright notices are retained; that the AFM
	    files are not distributed without this file; that all modifications to this
	    file or any of the AFM files are prominently noted in the modified file(s);
	    and that this paragraph is not modified. Adobe Systems has no responsibility
	    or obligation to support the use of the AFM files.
	    
	    */
	  	},
	  	    fontMetrics = { 'Unicode': {
	  			// all sizing numbers are n/fontMetricsFractionOf = one font size unit
	  			// this means that if fontMetricsFractionOf = 1000, and letter A's width is 476, it's
	  			// width is 476/1000 or 47.6% of its height (regardless of font size)
	  			// At this time this value applies to "widths" and "kerning" numbers.

	  			// char code 0 represents "default" (average) width - use it for chars missing in this table.
	  			// key 'fof' represents the "fontMetricsFractionOf" value

	  			'Courier-Oblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
	  			'Times-BoldItalic': uncompress("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"),
	  			'Helvetica-Bold': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
	  			'Courier': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
	  			'Courier-BoldOblique': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
	  			'Times-Bold': uncompress("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"),
	  			'Symbol': uncompress("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"),
	  			'Helvetica': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"),
	  			'Helvetica-BoldOblique': uncompress("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"),
	  			'ZapfDingbats': uncompress("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"),
	  			'Courier-Bold': uncompress("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"),
	  			'Times-Italic': uncompress("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"),
	  			'Times-Roman': uncompress("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"),
	  			'Helvetica-Oblique': uncompress("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")
	  		} };

	  	/*
	   This event handler is fired when a new jsPDF object is initialized
	   This event handler appends metrics data to standard fonts within
	   that jsPDF instance. The metrics are mapped over Unicode character
	   codes, NOT CIDs or other codes matching the StandardEncoding table of the
	   standard PDF fonts.
	   Future:
	   Also included is the encoding maping table, converting Unicode (UCS-2, UTF-16)
	   char codes to StandardEncoding character codes. The encoding table is to be used
	   somewhere around "pdfEscape" call.
	   */

	  	API.events.push(['addFont', function (font) {
	  		var metrics,
	  		    unicode_section,
	  		    encoding = 'Unicode',
	  		    encodingBlock;

	  		metrics = fontMetrics[encoding][font.postScriptName];
	  		if (metrics) {
	  			if (font.metadata[encoding]) {
	  				unicode_section = font.metadata[encoding];
	  			} else {
	  				unicode_section = font.metadata[encoding] = {};
	  			}

	  			unicode_section.widths = metrics.widths;
	  			unicode_section.kerning = metrics.kerning;
	  		}

	  		encodingBlock = encodings[encoding][font.postScriptName];
	  		if (encodingBlock) {
	  			if (font.metadata[encoding]) {
	  				unicode_section = font.metadata[encoding];
	  			} else {
	  				unicode_section = font.metadata[encoding] = {};
	  			}

	  			unicode_section.encoding = encodingBlock;
	  			if (encodingBlock.codePages && encodingBlock.codePages.length) {
	  				font.encoding = encodingBlock.codePages[0];
	  			}
	  		}
	  	}]); // end of adding event handler
	  })(jsPDF.API);

	  /**
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */
	  (function (jsPDF, global) {

	      jsPDF.API.events.push(['addFont', function (font) {
	          if (jsPDF.API.existsFileInVFS(font.postScriptName)) {
	              font.metadata = jsPDF.API.TTFFont.open(font.postScriptName, font.fontName, jsPDF.API.getFileFromVFS(font.postScriptName), font.encoding);
	              font.metadata.Unicode = font.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] };
	          } else if (font.id.slice(1) > 14) {
	              console.error("Font does not exist in FileInVFS, import fonts or remove declaration doc.addFont('" + font.postScriptName + "').");
	          }
	      }]); // end of adding event handler
	  })(jsPDF, typeof self !== "undefined" && self || typeof global !== "undefined" && global || typeof window !== "undefined" && window || Function("return this")());

	  /** @preserve
	  jsPDF SVG plugin
	  Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
	  */
	  (function (jsPDFAPI) {

	      /**
	      * Parses SVG XML and converts only some of the SVG elements into
	      * PDF elements.
	      *
	      * Supports:
	      * paths
	      * 
	      * @name addSvg
	      * @public
	      * @function
	      * @param {String} SVG-Data as Text
	      * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	      * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	      * @param {Number} width of SVG (in units declared at inception of PDF document)
	      * @param {Number} height of SVG (in units declared at inception of PDF document)
	      * @returns {Object} jsPDF-instance
	      */

	      jsPDFAPI.addSvg = function (svgtext, x, y, w, h) {
	          // 'this' is _jsPDF object returned when jsPDF is inited (new jsPDF())

	          var undef;

	          if (x === undef || y === undef) {
	              throw new Error("addSVG needs values for 'x' and 'y'");
	          }

	          function InjectCSS(cssbody, document) {
	              var styletag = document.createElement('style');
	              styletag.type = 'text/css';
	              if (styletag.styleSheet) {
	                  // ie
	                  styletag.styleSheet.cssText = cssbody;
	              } else {
	                  // others
	                  styletag.appendChild(document.createTextNode(cssbody));
	              }
	              document.getElementsByTagName("head")[0].appendChild(styletag);
	          }

	          function createWorkerNode(document) {

	              var frameID = 'childframe' // Date.now().toString() + '_' + (Math.random() * 100).toString()
	              ,
	                  frame = document.createElement('iframe');

	              InjectCSS('.jsPDF_sillysvg_iframe {display:none;position:absolute;}', document);

	              frame.name = frameID;
	              frame.setAttribute("width", 0);
	              frame.setAttribute("height", 0);
	              frame.setAttribute("frameborder", "0");
	              frame.setAttribute("scrolling", "no");
	              frame.setAttribute("seamless", "seamless");
	              frame.setAttribute("class", "jsPDF_sillysvg_iframe");

	              document.body.appendChild(frame);

	              return frame;
	          }

	          function attachSVGToWorkerNode(svgtext, frame) {
	              var framedoc = (frame.contentWindow || frame.contentDocument).document;
	              framedoc.write(svgtext);
	              framedoc.close();
	              return framedoc.getElementsByTagName('svg')[0];
	          }

	          function convertPathToPDFLinesArgs(path) {
	              // we will use 'lines' method call. it needs:
	              // - starting coordinate pair
	              // - array of arrays of vector shifts (2-len for line, 6 len for bezier)
	              // - scale array [horizontal, vertical] ratios
	              // - style (stroke, fill, both)

	              var x = parseFloat(path[1]),
	                  y = parseFloat(path[2]),
	                  vectors = [],
	                  position = 3,
	                  len = path.length;

	              while (position < len) {
	                  if (path[position] === 'c') {
	                      vectors.push([parseFloat(path[position + 1]), parseFloat(path[position + 2]), parseFloat(path[position + 3]), parseFloat(path[position + 4]), parseFloat(path[position + 5]), parseFloat(path[position + 6])]);
	                      position += 7;
	                  } else if (path[position] === 'l') {
	                      vectors.push([parseFloat(path[position + 1]), parseFloat(path[position + 2])]);
	                      position += 3;
	                  } else {
	                      position += 1;
	                  }
	              }
	              return [x, y, vectors];
	          }

	          var workernode = createWorkerNode(document),
	              svgnode = attachSVGToWorkerNode(svgtext, workernode),
	              scale = [1, 1],
	              svgw = parseFloat(svgnode.getAttribute('width')),
	              svgh = parseFloat(svgnode.getAttribute('height'));

	          if (svgw && svgh) {
	              // setting both w and h makes image stretch to size.
	              // this may distort the image, but fits your demanded size
	              if (w && h) {
	                  scale = [w / svgw, h / svgh];
	              }
	              // if only one is set, that value is set as max and SVG
	              // is scaled proportionately.
	              else if (w) {
	                      scale = [w / svgw, w / svgw];
	                  } else if (h) {
	                      scale = [h / svgh, h / svgh];
	                  }
	          }

	          var i,
	              l,
	              tmp,
	              linesargs,
	              items = svgnode.childNodes;
	          for (i = 0, l = items.length; i < l; i++) {
	              tmp = items[i];
	              if (tmp.tagName && tmp.tagName.toUpperCase() === 'PATH') {
	                  linesargs = convertPathToPDFLinesArgs(tmp.getAttribute("d").split(' '));
	                  // path start x coordinate
	                  linesargs[0] = linesargs[0] * scale[0] + x; // where x is upper left X of image
	                  // path start y coordinate
	                  linesargs[1] = linesargs[1] * scale[1] + y; // where y is upper left Y of image
	                  // the rest of lines are vectors. these will adjust with scale value auto.
	                  this.lines.call(this, linesargs[2] // lines
	                  , linesargs[0] // starting x
	                  , linesargs[1] // starting y
	                  , scale);
	              }
	          }

	          // clean up
	          // workernode.parentNode.removeChild(workernode)

	          return this;
	      };

	      //fallback
	      jsPDFAPI.addSVG = jsPDFAPI.addSvg;

	      /**
	      * Parses SVG XML and saves it as image into the PDF.
	      *
	      * Depends on canvas-element and canvg
	      *
	      * @name addSvgAsImage
	      * @public
	      * @function
	      * @param {String} SVG-Data as Text
	      * @param {Number} x Coordinate (in units declared at inception of PDF document) against left edge of the page
	      * @param {Number} y Coordinate (in units declared at inception of PDF document) against upper edge of the page
	      * @param {Number} width of SVG-Image (in units declared at inception of PDF document)
	      * @param {Number} height of SVG-Image (in units declared at inception of PDF document)
	      * @param {String} alias of SVG-Image (if used multiple times)
	      * @param {String} compression of the generated JPEG, can have the values 'NONE', 'FAST', 'MEDIUM' and 'SLOW'
	      * @param {Number} rotation of the image in degrees (0-359)
	      * 
	      * @returns jsPDF
	      * @methodOf jsPDF#
	      */
	      jsPDFAPI.addSvgAsImage = function (svg, x, y, w, h, alias, compression, rotation) {

	          if (isNaN(x) || isNaN(y)) {
	              console.error('jsPDF.addSvgAsImage: Invalid coordinates', arguments);
	              throw new Error('Invalid coordinates passed to jsPDF.addSvgAsImage');
	          }

	          if (isNaN(w) || isNaN(h)) {
	              console.error('jsPDF.addSvgAsImage: Invalid measurements', arguments);
	              throw new Error('Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage');
	          }

	          var canvas = document.createElement('canvas');
	          canvas.width = w;
	          canvas.height = h;
	          var ctx = canvas.getContext('2d');
	          ctx.fillStyle = '#fff'; /// set white fill style
	          ctx.fillRect(0, 0, canvas.width, canvas.height);

	          //load a svg snippet in the canvas with id = 'drawingArea'
	          canvg(canvas, svg, {
	              ignoreMouse: true,
	              ignoreAnimation: true,
	              ignoreDimensions: true,
	              ignoreClear: true
	          });

	          this.addImage(canvas.toDataURL("image/jpeg", 1.0), x, y, w, h, compression, rotation);
	          return this;
	      };
	  })(jsPDF.API);

	  /** ==================================================================== 
	   * jsPDF total_pages plugin
	   * Copyright (c) 2013 Eduardo Menezes de Morais, eduardo.morais@usp.br
	   * 
	   * 
	   * ====================================================================
	   */

	  (function (jsPDFAPI) {

	    jsPDFAPI.putTotalPages = function (pageExpression) {

	      var replaceExpression = new RegExp(pageExpression, 'g');
	      for (var n = 1; n <= this.internal.getNumberOfPages(); n++) {
	        for (var i = 0; i < this.internal.pages[n].length; i++) {
	          this.internal.pages[n][i] = this.internal.pages[n][i].replace(replaceExpression, this.internal.getNumberOfPages());
	        }
	      }
	      return this;
	    };
	  })(jsPDF.API);

	  /**
	   * jsPDF viewerPreferences Plugin
	   * @author Aras Abbasi (github.com/arasabbasi)
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  /**
	  * Adds the ability to set ViewerPreferences and by thus
	  * controlling the way the document is to be presented on the
	  * screen or in print.
	  */

	  (function (jsPDFAPI) {
	      /**
	       * Set the ViewerPreferences of the generated PDF
	       *
	       * @param {Object} options Array with the ViewerPreferences<br />
	       * Example: doc.viewerPreferences({"FitWindow":true});<br />
	       * <br />
	       * You can set following preferences:<br />
	       * <br/>
	       * <b>HideToolbar</b> <i>(boolean)</i><br />
	       * Default value: false<br />
	       * <br />
	       * <b>HideMenubar</b> <i>(boolean)</i><br />
	       * Default value: false.<br />
	       * <br />
	       * <b>HideWindowUI</b> <i>(boolean)</i><br />
	       * Default value: false.<br />
	       * <br />
	       * <b>FitWindow</b> <i>(boolean)</i><br />
	       * Default value: false.<br />
	       * <br />
	       * <b>CenterWindow</b> <i>(boolean)</i><br />
	       * Default value: false<br />
	       * <br />
	       * <b>DisplayDocTitle</b> <i>(boolean)</i><br />
	       * Default value: false.<br />
	       * <br />
	       * <b>NonFullScreenPageMode</b> <i>(String)</i><br />
	       * Possible values: UseNone, UseOutlines, UseThumbs, UseOC<br />
	       * Default value: UseNone<br/>
	       * <br />
	       * <b>Direction</b> <i>(String)</i><br />
	       * Possible values: L2R, R2L<br />
	       * Default value: L2R.<br />
	       * <br />
	       * <b>ViewArea</b> <i>(String)</i><br />
	       * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />
	       * Default value: CropBox.<br />
	       * <br />
	       * <b>ViewClip</b> <i>(String)</i><br />
	       * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />
	       * Default value: CropBox<br />
	       * <br />
	       * <b>PrintArea</b> <i>(String)</i><br />
	       * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />
	       * Default value: CropBox<br />
	       * <br />
	       * <b>PrintClip</b> <i>(String)</i><br />
	       * Possible values: MediaBox, CropBox, TrimBox, BleedBox, ArtBox<br />
	       * Default value: CropBox.<br />
	       * <br />
	       * <b>PrintScaling</b> <i>(String)</i><br />
	       * Possible values: AppDefault, None<br />
	       * Default value: AppDefault.<br />
	       * <br />
	       * <b>Duplex</b> <i>(String)</i><br />
	       * Possible values: Simplex, DuplexFlipLongEdge, DuplexFlipShortEdge
	       * Default value: none<br />
	       * <br />
	       * <b>PickTrayByPDFSize</b> <i>(boolean)</i><br />
	       * Default value: false<br />
	       * <br />
	       * <b>PrintPageRange</b> <i>(Array)</i><br />
	       * Example: [[1,5], [7,9]]<br />
	       * Default value: as defined by PDF viewer application<br />
	       * <br />
	       * <b>NumCopies</b> <i>(Number)</i><br />
	       * Possible values: 1, 2, 3, 4, 5<br />
	       * Default value: 1<br />
	       * <br />
	       * For more information see the PDF Reference, sixth edition on Page 577
	       * @param {boolean} doReset True to reset the settings
	       * @function
	       * @returns jsPDF
	       * @methodOf jsPDF#
	       * @example
	       * var doc = new jsPDF()
	       * doc.text('This is a test', 10, 10)
	       * doc.viewerPreferences({'FitWindow': true}, true)
	       * doc.save("viewerPreferences.pdf")
	       *
	       * // Example printing 10 copies, using cropbox, and hiding UI.
	       * doc.viewerPreferences({
	       *   'HideWindowUI': true,
	       *   'PrintArea': 'CropBox',
	       *   'NumCopies': 10
	       * })
	       * @name viewerPreferences
	       */

	      jsPDFAPI.viewerPreferences = function (options, doReset) {
	          options = options || {};
	          doReset = doReset || false;

	          var configuration;
	          var configurationTemplate = {
	              "HideToolbar": { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 },
	              "HideMenubar": { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 },
	              "HideWindowUI": { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 },
	              "FitWindow": { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 },
	              "CenterWindow": { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 },
	              "DisplayDocTitle": { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 },
	              "NonFullScreenPageMode": { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 },
	              "Direction": { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 },
	              "ViewArea": { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 },
	              "ViewClip": { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 },
	              "PrintArea": { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 },
	              "PrintClip": { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 },
	              "PrintScaling": { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 },
	              "Duplex": { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 },
	              "PickTrayByPDFSize": { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 },
	              "PrintPageRange": { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 },
	              "NumCopies": { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 }
	          };

	          var configurationKeys = Object.keys(configurationTemplate);

	          var rangeArray = [];
	          var i = 0;
	          var j = 0;
	          var k = 0;
	          var isValid = true;

	          var method;
	          var value;

	          function arrayContainsElement(array, element) {
	              var iterator;
	              var result = false;

	              for (iterator = 0; iterator < array.length; iterator += 1) {
	                  if (array[iterator] === element) {
	                      result = true;
	                  }
	              }
	              return result;
	          }

	          if (this.internal.viewerpreferences === undefined) {
	              this.internal.viewerpreferences = {};
	              this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(configurationTemplate));
	              this.internal.viewerpreferences.isSubscribed = false;
	          }
	          configuration = this.internal.viewerpreferences.configuration;

	          if (options === "reset" || doReset === true) {
	              var len = configurationKeys.length;

	              for (k = 0; k < len; k += 1) {
	                  configuration[configurationKeys[k]].value = configuration[configurationKeys[k]].defaultValue;
	                  configuration[configurationKeys[k]].explicitSet = false;
	              }
	          }

	          if ((typeof options === "undefined" ? "undefined" : _typeof(options)) === "object") {
	              for (method in options) {
	                  value = options[method];
	                  if (arrayContainsElement(configurationKeys, method) && value !== undefined) {

	                      if (configuration[method].type === "boolean" && typeof value === "boolean") {
	                          configuration[method].value = value;
	                      } else if (configuration[method].type === "name" && arrayContainsElement(configuration[method].valueSet, value)) {
	                          configuration[method].value = value;
	                      } else if (configuration[method].type === "integer" && Number.isInteger(value)) {
	                          configuration[method].value = value;
	                      } else if (configuration[method].type === "array") {

	                          for (i = 0; i < value.length; i += 1) {
	                              isValid = true;
	                              if (value[i].length === 1 && typeof value[i][0] === "number") {
	                                  rangeArray.push(String(value[i]));
	                              } else if (value[i].length > 1) {
	                                  for (j = 0; j < value[i].length; j += 1) {
	                                      if (typeof value[i][j] !== "number") {
	                                          isValid = false;
	                                      }
	                                  }
	                                  if (isValid === true) {
	                                      rangeArray.push(String(value[i].join("-")));
	                                  }
	                              }
	                          }
	                          configuration[method].value = String(rangeArray);
	                      } else {
	                          configuration[method].value = configuration[method].defaultValue;
	                      }

	                      configuration[method].explicitSet = true;
	                  }
	              }
	          }

	          if (this.internal.viewerpreferences.isSubscribed === false) {
	              this.internal.events.subscribe("putCatalog", function () {
	                  var pdfDict = [];
	                  var vPref;
	                  for (vPref in configuration) {
	                      if (configuration[vPref].explicitSet === true) {
	                          if (configuration[vPref].type === "name") {
	                              pdfDict.push("/" + vPref + " /" + configuration[vPref].value);
	                          } else {
	                              pdfDict.push("/" + vPref + " " + configuration[vPref].value);
	                          }
	                      }
	                  }
	                  if (pdfDict.length !== 0) {
	                      this.internal.write("/ViewerPreferences\n<<\n" + pdfDict.join("\n") + "\n>>");
	                  }
	              });
	              this.internal.viewerpreferences.isSubscribed = true;
	          }

	          this.internal.viewerpreferences.configuration = configuration;
	          return this;
	      };
	  })(jsPDF.API);

	  /** ==================================================================== 
	   * jsPDF XMP metadata plugin
	   * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
	   * 
	   * 
	   * ====================================================================
	   */

	  /*global jsPDF */

	  /**
	  * Adds XMP formatted metadata to PDF
	  *
	  * @param {String} metadata The actual metadata to be added. The metadata shall be stored as XMP simple value. Note that if the metadata string contains XML markup characters "<", ">" or "&", those characters should be written using XML entities.
	  * @param {String} namespaceuri Sets the namespace URI for the metadata. Last character should be slash or hash.
	  * @function
	  * @returns {jsPDF}
	  * @methodOf jsPDF#
	  * @name addMetadata
	  */

	  (function (jsPDFAPI) {

	      var xmpmetadata = "";
	      var xmpnamespaceuri = "";
	      var metadata_object_number = "";

	      jsPDFAPI.addMetadata = function (metadata, namespaceuri) {
	          xmpnamespaceuri = namespaceuri || "http://jspdf.default.namespaceuri/"; //The namespace URI for an XMP name shall not be empty
	          xmpmetadata = metadata;
	          this.internal.events.subscribe('postPutResources', function () {
	              if (!xmpmetadata) {
	                  metadata_object_number = "";
	              } else {
	                  var xmpmeta_beginning = '<x:xmpmeta xmlns:x="adobe:ns:meta/">';
	                  var rdf_beginning = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + xmpnamespaceuri + '"><jspdf:metadata>';
	                  var rdf_ending = '</jspdf:metadata></rdf:Description></rdf:RDF>';
	                  var xmpmeta_ending = '</x:xmpmeta>';
	                  var utf8_xmpmeta_beginning = unescape(encodeURIComponent(xmpmeta_beginning));
	                  var utf8_rdf_beginning = unescape(encodeURIComponent(rdf_beginning));
	                  var utf8_metadata = unescape(encodeURIComponent(xmpmetadata));
	                  var utf8_rdf_ending = unescape(encodeURIComponent(rdf_ending));
	                  var utf8_xmpmeta_ending = unescape(encodeURIComponent(xmpmeta_ending));

	                  var total_len = utf8_rdf_beginning.length + utf8_metadata.length + utf8_rdf_ending.length + utf8_xmpmeta_beginning.length + utf8_xmpmeta_ending.length;

	                  metadata_object_number = this.internal.newObject();
	                  this.internal.write('<< /Type /Metadata /Subtype /XML /Length ' + total_len + ' >>');
	                  this.internal.write('stream');
	                  this.internal.write(utf8_xmpmeta_beginning + utf8_rdf_beginning + utf8_metadata + utf8_rdf_ending + utf8_xmpmeta_ending);
	                  this.internal.write('endstream');
	                  this.internal.write('endobj');
	              }
	          });
	          this.internal.events.subscribe('putCatalog', function () {
	              if (metadata_object_number) {
	                  this.internal.write('/Metadata ' + metadata_object_number + ' 0 R');
	              }
	          });
	          return this;
	      };
	  })(jsPDF.API);

	  (function (jsPDF, global) {

	      var jsPDFAPI = jsPDF.API;

	      var glyID = [0];
	      /**************************************************/
	      /* function : toHex                               */
	      /* comment : Replace str with a hex string.       */
	      /**************************************************/
	      function toHex(str) {
	          var hex = '';
	          for (var i = 0; i < str.length; i++) {
	              hex += '' + str.charCodeAt(i).toString(16);
	          }
	          return hex;
	      }

	      /***************************************************************************************************/
	      /* function : pdfEscape16                                                                          */
	      /* comment : The character id of a 2-byte string is converted to a hexadecimal number by obtaining */
	      /*   the corresponding glyph id and width, and then adding padding to the string.                  */
	      /***************************************************************************************************/
	      var pdfEscape16 = function pdfEscape16(text, font) {
	          var widths = font.metadata.Unicode.widths;        var padz = ["", "0", "00", "000", "0000"];
	          var ar = [""];
	          for (var i = 0, l = text.length, t; i < l; ++i) {
	              t = font.metadata.characterToGlyph(text.charCodeAt(i));
	              glyID.push(t);
	              if (widths.indexOf(t) == -1) {
	                  widths.push(t);
	                  widths.push([parseInt(font.metadata.widthOfGlyph(t), 10)]);
	              }
	              if (t == '0') {
	                  //Spaces are not allowed in cmap.
	                  return ar.join("");
	              } else {
	                  t = t.toString(16);
	                  ar.push(padz[4 - t.length], t);
	              }
	          }
	          return ar.join("");
	      };

	      var identityHFunction = function identityHFunction(font, out, newObject) {

	          if (font.metadata instanceof jsPDF.API.TTFFont && font.encoding === 'Identity-H') {
	              //Tag with Identity-H
	              var widths = font.metadata.Unicode.widths;
	              var data = font.metadata.subset.encode(glyID);
	              var pdfOutput = data;
	              var pdfOutput2 = "";
	              for (var i = 0; i < pdfOutput.length; i++) {
	                  pdfOutput2 += String.fromCharCode(pdfOutput[i]);
	              }
	              var fontTable = newObject();
	              out('<<');
	              out('/Length ' + pdfOutput2.length);
	              out('/Length1 ' + pdfOutput2.length);
	              out('>>');

	              out('stream');
	              out(pdfOutput2);
	              out('endstream');
	              out('endobj');

	              var fontDescriptor = newObject();
	              out('<<');
	              out('/Type /FontDescriptor');
	              out('/FontName /' + font.fontName);
	              out('/FontFile2 ' + fontTable + ' 0 R');
	              out('/FontBBox ' + jsPDF.API.PDFObject.convert(font.metadata.bbox));
	              out('/Flags ' + font.metadata.flags);
	              out('/StemV ' + font.metadata.stemV);
	              out('/ItalicAngle ' + font.metadata.italicAngle);
	              out('/Ascent ' + font.metadata.ascender);
	              out('/Descent ' + font.metadata.decender);
	              out('/CapHeight ' + font.metadata.capHeight);
	              out('>>');
	              out('endobj');

	              var DescendantFont = newObject();
	              out('<<');
	              out('/Type /Font');
	              out('/BaseFont /' + font.fontName);
	              out('/FontDescriptor ' + fontDescriptor + ' 0 R');
	              out('/W ' + jsPDF.API.PDFObject.convert(widths));
	              out('/CIDToGIDMap /Identity');
	              out('/DW 1000');
	              out('/Subtype /CIDFontType2');
	              out('/CIDSystemInfo');
	              out('<<');
	              out('/Supplement 0');
	              out('/Registry (Adobe)');
	              out('/Ordering (' + font.encoding + ')');
	              out('>>');
	              out('>>');
	              out('endobj');

	              font.objectNumber = newObject();
	              out('<<');
	              out('/Type /Font');
	              out('/Subtype /Type0');
	              out('/BaseFont /' + font.fontName);
	              out('/Encoding /' + font.encoding);
	              out('/DescendantFonts [' + DescendantFont + ' 0 R]');
	              out('>>');
	              out('endobj');

	              font.isAlreadyPutted = true;
	          }
	      };

	      jsPDFAPI.events.push(['putFont', function (args) {
	          identityHFunction(args.font, args.out, args.newObject);
	      }]);

	      var winAnsiEncodingFunction = function winAnsiEncodingFunction(font, out, newObject) {

	          if (font.metadata instanceof jsPDF.API.TTFFont && font.encoding === 'WinAnsiEncoding') {
	              //Tag with WinAnsi encoding
	              var widths = font.metadata.Unicode.widths;
	              var data = font.metadata.rawData;
	              var pdfOutput = data;
	              var pdfOutput2 = "";
	              for (var i = 0; i < pdfOutput.length; i++) {
	                  pdfOutput2 += String.fromCharCode(pdfOutput[i]);
	              }
	              var fontTable = newObject();
	              out('<<');
	              out('/Length ' + pdfOutput2.length);
	              out('/Length1 ' + pdfOutput2.length);
	              out('>>');
	              out('stream');
	              out(pdfOutput2);
	              out('endstream');
	              out('endobj');
	              var fontDescriptor = newObject();
	              out('<<');
	              out('/Descent ' + font.metadata.decender);
	              out('/CapHeight ' + font.metadata.capHeight);
	              out('/StemV ' + font.metadata.stemV);
	              out('/Type /FontDescriptor');
	              out('/FontFile2 ' + fontTable + ' 0 R');
	              out('/Flags 96');
	              out('/FontBBox ' + jsPDF.API.PDFObject.convert(font.metadata.bbox));
	              out('/FontName /' + font.fontName);
	              out('/ItalicAngle ' + font.metadata.italicAngle);
	              out('/Ascent ' + font.metadata.ascender);
	              out('>>');
	              out('endobj');
	              font.objectNumber = newObject();
	              for (var i = 0; i < font.metadata.hmtx.widths.length; i++) {
	                  font.metadata.hmtx.widths[i] = parseInt(font.metadata.hmtx.widths[i] * (1000 / font.metadata.head.unitsPerEm)); //Change the width of Em units to Point units.
	              }
	              out('<</Subtype/TrueType/Type/Font/BaseFont/' + font.fontName + '/FontDescriptor ' + fontDescriptor + ' 0 R' + '/Encoding/' + font.encoding + ' /FirstChar 29 /LastChar 255 /Widths ' + jsPDF.API.PDFObject.convert(font.metadata.hmtx.widths) + '>>');
	              out('endobj');
	              font.isAlreadyPutted = true;
	          }
	      };

	      jsPDFAPI.events.push(['putFont', function (args) {
	          winAnsiEncodingFunction(args.font, args.out, args.newObject);
	      }]);

	      var utf8TextFunction = function utf8TextFunction(args) {
	          var text = args.text || '';
	          var x = args.x;
	          var y = args.y;
	          var options = args.options || {};
	          var mutex = args.mutex || {};

	          var pdfEscape = mutex.pdfEscape;
	          var activeFontKey = mutex.activeFontKey;
	          var fonts = mutex.fonts;
	          var key,
	              fontSize = mutex.activeFontSize;

	          var str = '',
	              s = 0,
	              cmapConfirm;
	          var strText = '';
	          var attr;
	          var key = activeFontKey;
	          var encoding = fonts[key].encoding;

	          if (fonts[key].encoding !== 'Identity-H') {
	              return {
	                  text: text,
	                  x: x,
	                  y: y,
	                  options: options,
	                  mutex: mutex
	              };
	          }
	          strText = text;

	          key = attr ? getFont(attr.font, attr.fontStyle) : activeFontKey;
	          if (Object.prototype.toString.call(text) === '[object Array]') {
	              strText = text[0];
	          }
	          for (s = 0; s < strText.length; s += 1) {
	              if (fonts[key].metadata.hasOwnProperty('cmap')) {
	                  cmapConfirm = fonts[key].metadata.cmap.unicode.codeMap[strText[s].charCodeAt(0)];
	                  /*
	                  if (Object.prototype.toString.call(text) === '[object Array]') {
	                             var i = 0;
	                            // for (i = 0; i < text.length; i += 1) {
	                                 if (Object.prototype.toString.call(text[s]) === '[object Array]') {
	                  	cmapConfirm = fonts[key].metadata.cmap.unicode.codeMap[strText[s][0].charCodeAt(0)]; //Make sure the cmap has the corresponding glyph id
	                                 } else {
	                                     
	                                 }
	                             //}
	                  
	                         } else {
	                  cmapConfirm = fonts[key].metadata.cmap.unicode.codeMap[strText[s].charCodeAt(0)]; //Make sure the cmap has the corresponding glyph id
	                         }*/
	              }
	              if (!cmapConfirm) {
	                  if (strText[s].charCodeAt(0) < 256 && fonts[key].metadata.hasOwnProperty('Unicode')) {
	                      str += strText[s];
	                  } else {
	                      str += '';
	                  }
	              } else {
	                  str += strText[s];
	              }
	          }
	          var result = '';
	          if (parseInt(key.slice(1)) < 14 || encoding === 'WinAnsiEncoding') {
	              //For the default 13 font
	              result = toHex(pdfEscape(str, key));
	          } else if (encoding === 'Identity-H') {
	              result = pdfEscape16(str, fonts[key]);
	          }
	          mutex.isHex = true;

	          return {
	              text: result,
	              x: x,
	              y: y,
	              options: options,
	              mutex: mutex
	          };
	      };

	      var utf8EscapeFunction = function utf8EscapeFunction(parms) {
	          var text = parms.text || '',
	              x = parms.x,
	              y = parms.y,
	              options = parms.options,
	              mutex = parms.mutex;
	          var lang = options.lang;
	          var tmpText = [];
	          var args = {
	              text: text,
	              x: x,
	              y: y,
	              options: options,
	              mutex: mutex
	          };

	          if (Object.prototype.toString.call(text) === '[object Array]') {
	              var i = 0;
	              for (i = 0; i < text.length; i += 1) {
	                  if (Object.prototype.toString.call(text[i]) === '[object Array]') {
	                      if (text[i].length === 3) {
	                          tmpText.push([utf8TextFunction(Object.assign({}, args, { text: text[i][0] })).text, text[i][1], text[i][2]]);
	                      } else {
	                          tmpText.push(utf8TextFunction(Object.assign({}, args, { text: text[i] })).text);
	                      }
	                  } else {
	                      tmpText.push(utf8TextFunction(Object.assign({}, args, { text: text[i] })).text);
	                  }
	              }
	              parms.text = tmpText;
	          } else {
	              parms.text = utf8TextFunction(Object.assign({}, args, { text: text })).text;
	          }
	      };

	      jsPDFAPI.events.push(['postProcessText', utf8EscapeFunction]);
	  })(jsPDF, typeof self !== "undefined" && self || typeof global !== "undefined" && global || typeof window !== "undefined" && window || Function("return this")());

	  /**
	   * jsPDF virtual FileSystem functionality
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  /**
	  * Use the vFS to handle files
	  */

	  (function (jsPDFAPI) {

	      var vFS = {};

	      /* Check if the file exists in the vFS
	      * @returns {boolean}
	      * @name existsFileInVFS
	      * @example
	      * doc.existsFileInVFS("someFile.txt");
	      */
	      jsPDFAPI.existsFileInVFS = function (filename) {
	          return vFS.hasOwnProperty(filename);
	      };

	      /* Add a file to the vFS
	      * @returns {jsPDF}
	      * @name addFileToVFS
	      * @example
	      * doc.addFileToVFS("someFile.txt", "BADFACE1");
	      */
	      jsPDFAPI.addFileToVFS = function (filename, filecontent) {
	          vFS[filename] = filecontent;
	          return this;
	      };

	      /* Get the file from the vFS
	      * @returns {string}
	      * @name addFileToVFS
	      * @example
	      * doc.getFileFromVFS("someFile.txt");
	      */
	      jsPDFAPI.getFileFromVFS = function (filename) {
	          if (vFS.hasOwnProperty(filename)) {
	              return vFS[filename];
	          }
	          return null;
	      };
	  })(jsPDF.API);

	  /* Blob.js
	   * A Blob implementation.
	   * 2014-07-24
	   *
	   * By Eli Grey, http://eligrey.com
	   * By Devin Samarin, https://github.com/dsamarin
	   * License: X11/MIT
	   *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
	   */

	  /*global self, unescape */
	  /*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
	    plusplus: true */

	  /*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

	  (function (view) {

	  	view.URL = view.URL || view.webkitURL;

	  	if (view.Blob && view.URL) {
	  		try {
	  			new Blob;
	  			return;
	  		} catch (e) {}
	  	}

	  	// Internally we use a BlobBuilder implementation to base Blob off of
	  	// in order to support older browsers that only have BlobBuilder
	  	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function(view) {
	  		var
	  			  get_class = function(object) {
	  				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
	  			}
	  			, FakeBlobBuilder = function BlobBuilder() {
	  				this.data = [];
	  			}
	  			, FakeBlob = function Blob(data, type, encoding) {
	  				this.data = data;
	  				this.size = data.length;
	  				this.type = type;
	  				this.encoding = encoding;
	  			}
	  			, FBB_proto = FakeBlobBuilder.prototype
	  			, FB_proto = FakeBlob.prototype
	  			, FileReaderSync = view.FileReaderSync
	  			, FileException = function(type) {
	  				this.code = this[this.name = type];
	  			}
	  			, file_ex_codes = (
	  				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
	  				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
	  			).split(" ")
	  			, file_ex_code = file_ex_codes.length
	  			, real_URL = view.URL || view.webkitURL || view
	  			, real_create_object_URL = real_URL.createObjectURL
	  			, real_revoke_object_URL = real_URL.revokeObjectURL
	  			, URL = real_URL
	  			, btoa = view.btoa
	  			, atob = view.atob

	  			, ArrayBuffer = view.ArrayBuffer
	  			, Uint8Array = view.Uint8Array

	  			, origin = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/
	  		;
	  		FakeBlob.fake = FB_proto.fake = true;
	  		while (file_ex_code--) {
	  			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
	  		}
	  		// Polyfill URL
	  		if (!real_URL.createObjectURL) {
	  			URL = view.URL = function(uri) {
	  				var
	  					  uri_info = document.createElementNS("http://www.w3.org/1999/xhtml", "a")
	  					, uri_origin
	  				;
	  				uri_info.href = uri;
	  				if (!("origin" in uri_info)) {
	  					if (uri_info.protocol.toLowerCase() === "data:") {
	  						uri_info.origin = null;
	  					} else {
	  						uri_origin = uri.match(origin);
	  						uri_info.origin = uri_origin && uri_origin[1];
	  					}
	  				}
	  				return uri_info;
	  			};
	  		}
	  		URL.createObjectURL = function(blob) {
	  			var
	  				  type = blob.type
	  				, data_URI_header
	  			;
	  			if (type === null) {
	  				type = "application/octet-stream";
	  			}
	  			if (blob instanceof FakeBlob) {
	  				data_URI_header = "data:" + type;
	  				if (blob.encoding === "base64") {
	  					return data_URI_header + ";base64," + blob.data;
	  				} else if (blob.encoding === "URI") {
	  					return data_URI_header + "," + decodeURIComponent(blob.data);
	  				} if (btoa) {
	  					return data_URI_header + ";base64," + btoa(blob.data);
	  				} else {
	  					return data_URI_header + "," + encodeURIComponent(blob.data);
	  				}
	  			} else if (real_create_object_URL) {
	  				return real_create_object_URL.call(real_URL, blob);
	  			}
	  		};
	  		URL.revokeObjectURL = function(object_URL) {
	  			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
	  				real_revoke_object_URL.call(real_URL, object_URL);
	  			}
	  		};
	  		FBB_proto.append = function(data/*, endings*/) {
	  			var bb = this.data;
	  			// decode data to a binary string
	  			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
	  				var
	  					  str = ""
	  					, buf = new Uint8Array(data)
	  					, i = 0
	  					, buf_len = buf.length
	  				;
	  				for (; i < buf_len; i++) {
	  					str += String.fromCharCode(buf[i]);
	  				}
	  				bb.push(str);
	  			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
	  				if (FileReaderSync) {
	  					var fr = new FileReaderSync;
	  					bb.push(fr.readAsBinaryString(data));
	  				} else {
	  					// async FileReader won't work as BlobBuilder is sync
	  					throw new FileException("NOT_READABLE_ERR");
	  				}
	  			} else if (data instanceof FakeBlob) {
	  				if (data.encoding === "base64" && atob) {
	  					bb.push(atob(data.data));
	  				} else if (data.encoding === "URI") {
	  					bb.push(decodeURIComponent(data.data));
	  				} else if (data.encoding === "raw") {
	  					bb.push(data.data);
	  				}
	  			} else {
	  				if (typeof data !== "string") {
	  					data += ""; // convert unsupported types to strings
	  				}
	  				// decode UTF-16 to binary string
	  				bb.push(unescape(encodeURIComponent(data)));
	  			}
	  		};
	  		FBB_proto.getBlob = function(type) {
	  			if (!arguments.length) {
	  				type = null;
	  			}
	  			return new FakeBlob(this.data.join(""), type, "raw");
	  		};
	  		FBB_proto.toString = function() {
	  			return "[object BlobBuilder]";
	  		};
	  		FB_proto.slice = function(start, end, type) {
	  			var args = arguments.length;
	  			if (args < 3) {
	  				type = null;
	  			}
	  			return new FakeBlob(
	  				  this.data.slice(start, args > 1 ? end : this.data.length)
	  				, type
	  				, this.encoding
	  			);
	  		};
	  		FB_proto.toString = function() {
	  			return "[object Blob]";
	  		};
	  		FB_proto.close = function() {
	  			this.size = 0;
	  			delete this.data;
	  		};
	  		return FakeBlobBuilder;
	  	}(view));

	  	view.Blob = function(blobParts, options) {
	  		var type = options ? (options.type || "") : "";
	  		var builder = new BlobBuilder();
	  		if (blobParts) {
	  			for (var i = 0, len = blobParts.length; i < len; i++) {
	  				if (Uint8Array && blobParts[i] instanceof Uint8Array) {
	  					builder.append(blobParts[i].buffer);
	  				}
	  				else {
	  					builder.append(blobParts[i]);
	  				}
	  			}
	  		}
	  		var blob = builder.getBlob(type);
	  		if (!blob.slice && blob.webkitSlice) {
	  			blob.slice = blob.webkitSlice;
	  		}
	  		return blob;
	  	};

	  	var getPrototypeOf = Object.getPrototypeOf || function(object) {
	  		return object.__proto__;
	  	};
	  	view.Blob.prototype = getPrototypeOf(new view.Blob());
	  }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || window.content || window));

	  /* FileSaver.js
	   * A saveAs() FileSaver implementation.
	   * 1.3.2
	   * 2016-06-16 18:25:19
	   *
	   * By Eli Grey, http://eligrey.com
	   * License: MIT
	   *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md
	   */

	  /*global self */
	  /*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

	  /*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

	  var saveAs = saveAs || (function(view) {
	  	// IE <10 is explicitly unsupported
	  	if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
	  		return;
	  	}
	  	var
	  		  doc = view.document
	  		  // only get URL when necessary in case Blob.js hasn't overridden it yet
	  		, get_URL = function() {
	  			return view.URL || view.webkitURL || view;
	  		}
	  		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
	  		, can_use_save_link = "download" in save_link
	  		, click = function(node) {
	  			var event = new MouseEvent("click");
	  			node.dispatchEvent(event);
	  		}
	  		, is_safari = /constructor/i.test(view.HTMLElement) || view.safari
	  		, is_chrome_ios =/CriOS\/[\d]+/.test(navigator.userAgent)
	  		, throw_outside = function(ex) {
	  			(view.setImmediate || view.setTimeout)(function() {
	  				throw ex;
	  			}, 0);
	  		}
	  		, force_saveable_type = "application/octet-stream"
	  		// the Blob API is fundamentally broken as there is no "downloadfinished" event to subscribe to
	  		, arbitrary_revoke_timeout = 1000 * 40 // in ms
	  		, revoke = function(file) {
	  			var revoker = function() {
	  				if (typeof file === "string") { // file is an object URL
	  					get_URL().revokeObjectURL(file);
	  				} else { // file is a File
	  					file.remove();
	  				}
	  			};
	  			setTimeout(revoker, arbitrary_revoke_timeout);
	  		}
	  		, dispatch = function(filesaver, event_types, event) {
	  			event_types = [].concat(event_types);
	  			var i = event_types.length;
	  			while (i--) {
	  				var listener = filesaver["on" + event_types[i]];
	  				if (typeof listener === "function") {
	  					try {
	  						listener.call(filesaver, event || filesaver);
	  					} catch (ex) {
	  						throw_outside(ex);
	  					}
	  				}
	  			}
	  		}
	  		, auto_bom = function(blob) {
	  			// prepend BOM for UTF-8 XML and text/* types (including HTML)
	  			// note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF
	  			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
	  				return new Blob([String.fromCharCode(0xFEFF), blob], {type: blob.type});
	  			}
	  			return blob;
	  		}
	  		, FileSaver = function(blob, name, no_auto_bom) {
	  			if (!no_auto_bom) {
	  				blob = auto_bom(blob);
	  			}
	  			// First try a.download, then web filesystem, then object URLs
	  			var
	  				  filesaver = this
	  				, type = blob.type
	  				, force = type === force_saveable_type
	  				, object_url
	  				, dispatch_all = function() {
	  					dispatch(filesaver, "writestart progress write writeend".split(" "));
	  				}
	  				// on any filesys errors revert to saving with object URLs
	  				, fs_error = function() {
	  					if ((is_chrome_ios || (force && is_safari)) && view.FileReader) {
	  						// Safari doesn't allow downloading of blob urls
	  						var reader = new FileReader();
	  						reader.onloadend = function() {
	  							var url = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, 'data:attachment/file;');
	  							var popup = view.open(url, '_blank');
	  							if(!popup) view.location.href = url;
	  							url=undefined; // release reference before dispatching
	  							filesaver.readyState = filesaver.DONE;
	  							dispatch_all();
	  						};
	  						reader.readAsDataURL(blob);
	  						filesaver.readyState = filesaver.INIT;
	  						return;
	  					}
	  					// don't create more object URLs than needed
	  					if (!object_url) {
	  						object_url = get_URL().createObjectURL(blob);
	  					}
	  					if (force) {
	  						view.location.href = object_url;
	  					} else {
	  						var opened = view.open(object_url, "_blank");
	  						if (!opened) {
	  							// Apple does not allow window.open, see https://developer.apple.com/library/safari/documentation/Tools/Conceptual/SafariExtensionGuide/WorkingwithWindowsandTabs/WorkingwithWindowsandTabs.html
	  							view.location.href = object_url;
	  						}
	  					}
	  					filesaver.readyState = filesaver.DONE;
	  					dispatch_all();
	  					revoke(object_url);
	  				}
	  			;
	  			filesaver.readyState = filesaver.INIT;

	  			if (can_use_save_link) {
	  				object_url = get_URL().createObjectURL(blob);
	  				setTimeout(function() {
	  					save_link.href = object_url;
	  					save_link.download = name;
	  					click(save_link);
	  					dispatch_all();
	  					revoke(object_url);
	  					filesaver.readyState = filesaver.DONE;
	  				});
	  				return;
	  			}

	  			fs_error();
	  		}
	  		, FS_proto = FileSaver.prototype
	  		, saveAs = function(blob, name, no_auto_bom) {
	  			return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
	  		}
	  	;
	  	// IE 10+ (native saveAs)
	  	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
	  		return function(blob, name, no_auto_bom) {
	  			name = name || blob.name || "download";

	  			if (!no_auto_bom) {
	  				blob = auto_bom(blob);
	  			}
	  			return navigator.msSaveOrOpenBlob(blob, name);
	  		};
	  	}

	  	FS_proto.abort = function(){};
	  	FS_proto.readyState = FS_proto.INIT = 0;
	  	FS_proto.WRITING = 1;
	  	FS_proto.DONE = 2;

	  	FS_proto.error =
	  	FS_proto.onwritestart =
	  	FS_proto.onprogress =
	  	FS_proto.onwrite =
	  	FS_proto.onabort =
	  	FS_proto.onerror =
	  	FS_proto.onwriteend =
	  		null;

	  	return saveAs;
	  }(
	  	   typeof self !== "undefined" && self
	  	|| typeof window !== "undefined" && window
	  	|| window.content
	  ));
	  // `self` is undefined in Firefox for Android content script context
	  // while `this` is nsIContentFrameMessageManager
	  // with an attribute `content` that corresponds to the window

	  if (typeof module !== "undefined" && module.exports) {
	    module.exports.saveAs = saveAs;
	  } else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
	    define("FileSaver.js", function() {
	      return saveAs;
	    });
	  }

	  /*
	   * Copyright (c) 2012 chick307 <chick307@gmail.com>
	   *
	   * Licensed under the MIT License.
	   * http://opensource.org/licenses/mit-license
	   */

	  (function(jsPDF, callback) {
	    jsPDF.API.adler32cs = callback();
	  })(jsPDF, function() {
	    var _hasArrayBuffer = typeof ArrayBuffer === 'function' &&
	      typeof Uint8Array === 'function';

	    var _Buffer = null, _isBuffer = (function() {
	      if (!_hasArrayBuffer)
	        return function _isBuffer() { return false };

	      try {
	        var buffer = {};
	        if (typeof buffer.Buffer === 'function')
	          _Buffer = buffer.Buffer;
	      } catch (error) {}

	      return function _isBuffer(value) {
	        return value instanceof ArrayBuffer ||
	          _Buffer !== null && value instanceof _Buffer;
	      };
	    }());

	    var _utf8ToBinary = (function() {
	      if (_Buffer !== null) {
	        return function _utf8ToBinary(utf8String) {
	          return new _Buffer(utf8String, 'utf8').toString('binary');
	        };
	      } else {
	        return function _utf8ToBinary(utf8String) {
	          return unescape(encodeURIComponent(utf8String));
	        };
	      }
	    }());

	    var MOD = 65521;

	    var _update = function _update(checksum, binaryString) {
	      var a = checksum & 0xFFFF, b = checksum >>> 16;
	      for (var i = 0, length = binaryString.length; i < length; i++) {
	        a = (a + (binaryString.charCodeAt(i) & 0xFF)) % MOD;
	        b = (b + a) % MOD;
	      }
	      return (b << 16 | a) >>> 0;
	    };

	    var _updateUint8Array = function _updateUint8Array(checksum, uint8Array) {
	      var a = checksum & 0xFFFF, b = checksum >>> 16;
	      for (var i = 0, length = uint8Array.length; i < length; i++) {
	        a = (a + uint8Array[i]) % MOD;
	        b = (b + a) % MOD;
	      }
	      return (b << 16 | a) >>> 0
	    };

	    var exports = {};

	    var Adler32 = exports.Adler32 = (function() {
	      var ctor = function Adler32(checksum) {
	        if (!(this instanceof ctor)) {
	          throw new TypeError(
	            'Constructor cannot called be as a function.');
	        }
	        if (!isFinite(checksum = checksum == null ? 1 : +checksum)) {
	          throw new Error(
	            'First arguments needs to be a finite number.');
	        }
	        this.checksum = checksum >>> 0;
	      };

	      var proto = ctor.prototype = {};
	      proto.constructor = ctor;

	      ctor.from = function(from) {
	        from.prototype = proto;
	        return from;
	      }(function from(binaryString) {
	        if (!(this instanceof ctor)) {
	          throw new TypeError(
	            'Constructor cannot called be as a function.');
	        }
	        if (binaryString == null)
	          throw new Error('First argument needs to be a string.');
	        this.checksum = _update(1, binaryString.toString());
	      });

	      ctor.fromUtf8 = function(fromUtf8) {
	        fromUtf8.prototype = proto;
	        return fromUtf8;
	      }(function fromUtf8(utf8String) {
	        if (!(this instanceof ctor)) {
	          throw new TypeError(
	            'Constructor cannot called be as a function.');
	        }
	        if (utf8String == null)
	          throw new Error('First argument needs to be a string.');
	        var binaryString = _utf8ToBinary(utf8String.toString());
	        this.checksum = _update(1, binaryString);
	      });

	      if (_hasArrayBuffer) {
	        ctor.fromBuffer = function(fromBuffer) {
	          fromBuffer.prototype = proto;
	          return fromBuffer;
	        }(function fromBuffer(buffer) {
	          if (!(this instanceof ctor)) {
	            throw new TypeError(
	              'Constructor cannot called be as a function.');
	          }
	          if (!_isBuffer(buffer))
	            throw new Error('First argument needs to be ArrayBuffer.');
	          var array = new Uint8Array(buffer);
	          return this.checksum = _updateUint8Array(1, array);
	        });
	      }

	      proto.update = function update(binaryString) {
	        if (binaryString == null)
	          throw new Error('First argument needs to be a string.');
	        binaryString = binaryString.toString();
	        return this.checksum = _update(this.checksum, binaryString);
	      };

	      proto.updateUtf8 = function updateUtf8(utf8String) {
	        if (utf8String == null)
	          throw new Error('First argument needs to be a string.');
	        var binaryString = _utf8ToBinary(utf8String.toString());
	        return this.checksum = _update(this.checksum, binaryString);
	      };

	      if (_hasArrayBuffer) {
	        proto.updateBuffer = function updateBuffer(buffer) {
	          if (!_isBuffer(buffer))
	            throw new Error('First argument needs to be ArrayBuffer.');
	          var array = new Uint8Array(buffer);
	          return this.checksum = _updateUint8Array(this.checksum, array);
	        };
	      }

	      proto.clone = function clone() {
	        return new Adler32(this.checksum);
	      };

	      return ctor;
	    }());

	    exports.from = function from(binaryString) {
	      if (binaryString == null)
	        throw new Error('First argument needs to be a string.');
	      return _update(1, binaryString.toString());
	    };

	    exports.fromUtf8 = function fromUtf8(utf8String) {
	      if (utf8String == null)
	        throw new Error('First argument needs to be a string.');
	      var binaryString = _utf8ToBinary(utf8String.toString());
	      return _update(1, binaryString);
	    };

	    if (_hasArrayBuffer) {
	      exports.fromBuffer = function fromBuffer(buffer) {
	        if (!_isBuffer(buffer))
	          throw new Error('First argument need to be ArrayBuffer.');
	        var array = new Uint8Array(buffer);
	        return _updateUint8Array(1, array);
	      };
	    }

	    return exports;
	  });

	  // (c) Dean McNamee <dean@gmail.com>, 2013.
	  //
	  // https://github.com/deanm/omggif
	  //
	  // 
	  //
	  // omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
	  // including animation and compression.  It does not rely on any specific
	  // underlying system, so should run in the browser, Node, or Plask.

	  function GifWriter(buf, width, height, gopts) {
	    var p = 0;

	    var gopts = gopts === undefined ? { } : gopts;
	    var loop_count = gopts.loop === undefined ? null : gopts.loop;
	    var global_palette = gopts.palette === undefined ? null : gopts.palette;

	    if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
	      throw "Width/Height invalid."

	    function check_palette_and_num_colors(palette) {
	      var num_colors = palette.length;
	      if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1))
	        throw "Invalid code/color length, must be power of 2 and 2 .. 256.";
	      return num_colors;
	    }

	    // - Header.
	    buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
	    buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

	    // Handling of Global Color Table (palette) and background index.
	    var gp_num_colors_pow2 = 0;
	    var background = 0;
	    if (global_palette !== null) {
	      var gp_num_colors = check_palette_and_num_colors(global_palette);
	      while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
	      gp_num_colors = 1 << gp_num_colors_pow2;
	      --gp_num_colors_pow2;
	      if (gopts.background !== undefined) {
	        background = gopts.background;
	        if (background >= gp_num_colors) throw "Background index out of range.";
	        // The GIF spec states that a background index of 0 should be ignored, so
	        // this is probably a mistake and you really want to set it to another
	        // slot in the palette.  But actually in the end most browsers, etc end
	        // up ignoring this almost completely (including for dispose background).
	        if (background === 0)
	          throw "Background index explicitly passed as 0.";
	      }
	    }

	    // - Logical Screen Descriptor.
	    // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
	    buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
	    buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
	    // NOTE: Indicates 0-bpp original color resolution (unused?).
	    buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
	               gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
	    buf[p++] = background;  // Background Color Index.
	    buf[p++] = 0;  // Pixel aspect ratio (unused?).

	    // - Global Color Table
	    if (global_palette !== null) {
	      for (var i = 0, il = global_palette.length; i < il; ++i) {
	        var rgb = global_palette[i];
	        buf[p++] = rgb >> 16 & 0xff;
	        buf[p++] = rgb >> 8 & 0xff;
	        buf[p++] = rgb & 0xff;
	      }
	    }

	    if (loop_count !== null) {  // Netscape block for looping.
	      if (loop_count < 0 || loop_count > 65535)
	        throw "Loop count invalid."
	      // Extension code, label, and length.
	      buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
	      // NETSCAPE2.0
	      buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
	      buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
	      buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
	      // Sub-block
	      buf[p++] = 0x03; buf[p++] = 0x01;
	      buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
	      buf[p++] = 0x00;  // Terminator.
	    }


	    var ended = false;

	    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
	      if (ended === true) { --p; ended = false; }  // Un-end.

	      opts = opts === undefined ? { } : opts;

	      // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
	      // canvas width/height, I imagine?
	      if (x < 0 || y < 0 || x > 65535 || y > 65535)
	        throw "x/y invalid."

	      if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
	        throw "Width/Height invalid."

	      if (indexed_pixels.length < w * h)
	        throw "Not enough pixels for the frame size.";

	      var using_local_palette = true;
	      var palette = opts.palette;
	      if (palette === undefined || palette === null) {
	        using_local_palette = false;
	        palette = global_palette;
	      }

	      if (palette === undefined || palette === null)
	        throw "Must supply either a local or global palette.";

	      var num_colors = check_palette_and_num_colors(palette);

	      // Compute the min_code_size (power of 2), destroying num_colors.
	      var min_code_size = 0;
	      while (num_colors >>= 1) ++min_code_size;
	      num_colors = 1 << min_code_size;  // Now we can easily get it back.

	      var delay = opts.delay === undefined ? 0 : opts.delay;

	      // From the spec:
	      //     0 -   No disposal specified. The decoder is
	      //           not required to take any action.
	      //     1 -   Do not dispose. The graphic is to be left
	      //           in place.
	      //     2 -   Restore to background color. The area used by the
	      //           graphic must be restored to the background color.
	      //     3 -   Restore to previous. The decoder is required to
	      //           restore the area overwritten by the graphic with
	      //           what was there prior to rendering the graphic.
	      //  4-7 -    To be defined.
	      // NOTE(deanm): Dispose background doesn't really work, apparently most
	      // browsers ignore the background palette index and clear to transparency.
	      var disposal = opts.disposal === undefined ? 0 : opts.disposal;
	      if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
	        throw "Disposal out of range.";

	      var use_transparency = false;
	      var transparent_index = 0;
	      if (opts.transparent !== undefined && opts.transparent !== null) {
	        use_transparency = true;
	        transparent_index = opts.transparent;
	        if (transparent_index < 0 || transparent_index >= num_colors)
	          throw "Transparent color index.";
	      }

	      if (disposal !== 0 || use_transparency || delay !== 0) {
	        // - Graphics Control Extension
	        buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
	        buf[p++] = 4;  // Byte size.

	        buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
	        buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
	        buf[p++] = transparent_index;  // Transparent color index.
	        buf[p++] = 0;  // Block Terminator.
	      }

	      // - Image Descriptor
	      buf[p++] = 0x2c;  // Image Seperator.
	      buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
	      buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
	      buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
	      buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
	      // NOTE: No sort flag (unused?).
	      // TODO(deanm): Support interlace.
	      buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

	      // - Local Color Table
	      if (using_local_palette === true) {
	        for (var i = 0, il = palette.length; i < il; ++i) {
	          var rgb = palette[i];
	          buf[p++] = rgb >> 16 & 0xff;
	          buf[p++] = rgb >> 8 & 0xff;
	          buf[p++] = rgb & 0xff;
	        }
	      }

	      p = GifWriterOutputLZWCodeStream(
	              buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
	    };

	    this.end = function() {
	      if (ended === false) {
	        buf[p++] = 0x3b;  // Trailer.
	        ended = true;
	      }
	      return p;
	    };
	  }

	  // Main compression routine, palette indexes -> LZW code stream.
	  // |index_stream| must have at least one entry.
	  function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
	    buf[p++] = min_code_size;
	    var cur_subblock = p++;  // Pointing at the length field.

	    var clear_code = 1 << min_code_size;
	    var code_mask = clear_code - 1;
	    var eoi_code = clear_code + 1;
	    var next_code = eoi_code + 1;

	    var cur_code_size = min_code_size + 1;  // Number of bits per code.
	    var cur_shift = 0;
	    // We have at most 12-bit codes, so we should have to hold a max of 19
	    // bits here (and then we would write out).
	    var cur = 0;

	    function emit_bytes_to_buffer(bit_block_size) {
	      while (cur_shift >= bit_block_size) {
	        buf[p++] = cur & 0xff;
	        cur >>= 8; cur_shift -= 8;
	        if (p === cur_subblock + 256) {  // Finished a subblock.
	          buf[cur_subblock] = 255;
	          cur_subblock = p++;
	        }
	      }
	    }

	    function emit_code(c) {
	      cur |= c << cur_shift;
	      cur_shift += cur_code_size;
	      emit_bytes_to_buffer(8);
	    }

	    // I am not an expert on the topic, and I don't want to write a thesis.
	    // However, it is good to outline here the basic algorithm and the few data
	    // structures and optimizations here that make this implementation fast.
	    // The basic idea behind LZW is to build a table of previously seen runs
	    // addressed by a short id (herein called output code).  All data is
	    // referenced by a code, which represents one or more values from the
	    // original input stream.  All input bytes can be referenced as the same
	    // value as an output code.  So if you didn't want any compression, you
	    // could more or less just output the original bytes as codes (there are
	    // some details to this, but it is the idea).  In order to achieve
	    // compression, values greater then the input range (codes can be up to
	    // 12-bit while input only 8-bit) represent a sequence of previously seen
	    // inputs.  The decompressor is able to build the same mapping while
	    // decoding, so there is always a shared common knowledge between the
	    // encoding and decoder, which is also important for "timing" aspects like
	    // how to handle variable bit width code encoding.
	    //
	    // One obvious but very important consequence of the table system is there
	    // is always a unique id (at most 12-bits) to map the runs.  'A' might be
	    // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
	    // can be used for an effecient lookup strategy for the code mapping.  We
	    // need to know if a run has been seen before, and be able to map that run
	    // to the output code.  Since we start with known unique ids (input bytes),
	    // and then from those build more unique ids (table entries), we can
	    // continue this chain (almost like a linked list) to always have small
	    // integer values that represent the current byte chains in the encoder.
	    // This means instead of tracking the input bytes (AAAABCD) to know our
	    // current state, we can track the table entry for AAAABC (it is guaranteed
	    // to exist by the nature of the algorithm) and the next character D.
	    // Therefor the tuple of (table_entry, byte) is guaranteed to also be
	    // unique.  This allows us to create a simple lookup key for mapping input
	    // sequences to codes (table indices) without having to store or search
	    // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
	    // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
	    // key.  This leads to a integer value at most 20-bits, which can always
	    // fit in an SMI value and be used as a fast sparse array / object key.

	    // Output code for the current contents of the index buffer.
	    var ib_code = index_stream[0] & code_mask;  // Load first input index.
	    var code_table = { };  // Key'd on our 20-bit "tuple".

	    emit_code(clear_code);  // Spec says first code should be a clear code.

	    // First index already loaded, process the rest of the stream.
	    for (var i = 1, il = index_stream.length; i < il; ++i) {
	      var k = index_stream[i] & code_mask;
	      var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
	      var cur_code = code_table[cur_key];  // buffer + k.

	      // Check if we have to create a new code table entry.
	      if (cur_code === undefined) {  // We don't have buffer + k.
	        // Emit index buffer (without k).
	        // This is an inline version of emit_code, because this is the core
	        // writing routine of the compressor (and V8 cannot inline emit_code
	        // because it is a closure here in a different context).  Additionally
	        // we can call emit_byte_to_buffer less often, because we can have
	        // 30-bits (from our 31-bit signed SMI), and we know our codes will only
	        // be 12-bits, so can safely have 18-bits there without overflow.
	        // emit_code(ib_code);
	        cur |= ib_code << cur_shift;
	        cur_shift += cur_code_size;
	        while (cur_shift >= 8) {
	          buf[p++] = cur & 0xff;
	          cur >>= 8; cur_shift -= 8;
	          if (p === cur_subblock + 256) {  // Finished a subblock.
	            buf[cur_subblock] = 255;
	            cur_subblock = p++;
	          }
	        }

	        if (next_code === 4096) {  // Table full, need a clear.
	          emit_code(clear_code);
	          next_code = eoi_code + 1;
	          cur_code_size = min_code_size + 1;
	          code_table = { };
	        } else {  // Table not full, insert a new entry.
	          // Increase our variable bit code sizes if necessary.  This is a bit
	          // tricky as it is based on "timing" between the encoding and
	          // decoder.  From the encoders perspective this should happen after
	          // we've already emitted the index buffer and are about to create the
	          // first table entry that would overflow our current code bit size.
	          if (next_code >= (1 << cur_code_size)) ++cur_code_size;
	          code_table[cur_key] = next_code++;  // Insert into code table.
	        }

	        ib_code = k;  // Index buffer to single input k.
	      } else {
	        ib_code = cur_code;  // Index buffer to sequence in code table.
	      }
	    }

	    emit_code(ib_code);  // There will still be something in the index buffer.
	    emit_code(eoi_code);  // End Of Information.

	    // Flush / finalize the sub-blocks stream to the buffer.
	    emit_bytes_to_buffer(1);

	    // Finish the sub-blocks, writing out any unfinished lengths and
	    // terminating with a sub-block of length 0.  If we have already started
	    // but not yet used a sub-block it can just become the terminator.
	    if (cur_subblock + 1 === p) {  // Started but unused.
	      buf[cur_subblock] = 0;
	    } else {  // Started and used, write length and additional terminator block.
	      buf[cur_subblock] = p - cur_subblock - 1;
	      buf[p++] = 0;
	    }
	    return p;
	  }

	  function GifReader(buf) {
	    var p = 0;

	    // - Header (GIF87a or GIF89a).
	    if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
	        buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
	      throw "Invalid GIF 87a/89a header.";
	    }

	    // - Logical Screen Descriptor.
	    var width = buf[p++] | buf[p++] << 8;
	    var height = buf[p++] | buf[p++] << 8;
	    var pf0 = buf[p++];  // <Packed Fields>.
	    var global_palette_flag = pf0 >> 7;
	    var num_global_colors_pow2 = pf0 & 0x7;
	    var num_global_colors = 1 << (num_global_colors_pow2 + 1);
	    var background = buf[p++];
	    buf[p++];  // Pixel aspect ratio (unused?).

	    var global_palette_offset = null;

	    if (global_palette_flag) {
	      global_palette_offset = p;
	      p += num_global_colors * 3;  // Seek past palette.
	    }

	    var no_eof = true;

	    var frames = [ ];

	    var delay = 0;
	    var transparent_index = null;
	    var disposal = 0;  // 0 - No disposal specified.
	    var loop_count = null;

	    this.width = width;
	    this.height = height;

	    while (no_eof && p < buf.length) {
	      switch (buf[p++]) {
	        case 0x21:  // Graphics Control Extension Block
	          switch (buf[p++]) {
	            case 0xff:  // Application specific block
	              // Try if it's a Netscape block (with animation loop counter).
	              if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
	                  // NETSCAPE2.0
	                  buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
	                  buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
	                  buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
	                  buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
	                  // Sub-block
	                  buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
	                p += 14;
	                loop_count = buf[p++] | buf[p++] << 8;
	                p++;  // Skip terminator.
	              } else {  // We don't know what it is, just try to get past it.
	                p += 12;
	                while (true) {  // Seek through subblocks.
	                  var block_size = buf[p++];
	                  if (block_size === 0) break;
	                  p += block_size;
	                }
	              }
	              break;

	            case 0xf9:  // Graphics Control Extension
	              if (buf[p++] !== 0x4 || buf[p+4] !== 0)
	                throw "Invalid graphics extension block.";
	              var pf1 = buf[p++];
	              delay = buf[p++] | buf[p++] << 8;
	              transparent_index = buf[p++];
	              if ((pf1 & 1) === 0) transparent_index = null;
	              disposal = pf1 >> 2 & 0x7;
	              p++;  // Skip terminator.
	              break;

	            case 0xfe:  // Comment Extension.
	              while (true) {  // Seek through subblocks.
	                var block_size = buf[p++];
	                if (block_size === 0) break;
	                // console.log(buf.slice(p, p+block_size).toString('ascii'));
	                p += block_size;
	              }
	              break;

	            default:
	              throw "Unknown graphic control label: 0x" + buf[p-1].toString(16);
	          }
	          break;

	        case 0x2c:  // Image Descriptor.
	          var x = buf[p++] | buf[p++] << 8;
	          var y = buf[p++] | buf[p++] << 8;
	          var w = buf[p++] | buf[p++] << 8;
	          var h = buf[p++] | buf[p++] << 8;
	          var pf2 = buf[p++];
	          var local_palette_flag = pf2 >> 7;
	          var interlace_flag = pf2 >> 6 & 1;
	          var num_local_colors_pow2 = pf2 & 0x7;
	          var num_local_colors = 1 << (num_local_colors_pow2 + 1);
	          var palette_offset = global_palette_offset;
	          var has_local_palette = false;
	          if (local_palette_flag) {
	            var has_local_palette = true;
	            palette_offset = p;  // Override with local palette.
	            p += num_local_colors * 3;  // Seek past palette.
	          }

	          var data_offset = p;

	          p++;  // codesize
	          while (true) {
	            var block_size = buf[p++];
	            if (block_size === 0) break;
	            p += block_size;
	          }

	          frames.push({x: x, y: y, width: w, height: h,
	                       has_local_palette: has_local_palette,
	                       palette_offset: palette_offset,
	                       data_offset: data_offset,
	                       data_length: p - data_offset,
	                       transparent_index: transparent_index,
	                       interlaced: !!interlace_flag,
	                       delay: delay,
	                       disposal: disposal});
	          break;

	        case 0x3b:  // Trailer Marker (end of file).
	          no_eof = false;
	          break;

	        default:
	          throw "Unknown gif block: 0x" + buf[p-1].toString(16);
	          break;
	      }
	    }

	    this.numFrames = function() {
	      return frames.length;
	    };

	    this.loopCount = function() {
	      return loop_count;
	    };

	    this.frameInfo = function(frame_num) {
	      if (frame_num < 0 || frame_num >= frames.length)
	        throw "Frame index out of range.";
	      return frames[frame_num];
	    };

	    this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
	      var frame = this.frameInfo(frame_num);
	      var num_pixels = frame.width * frame.height;
	      var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
	      GifReaderLZWOutputIndexStream(
	          buf, frame.data_offset, index_stream, num_pixels);
	      var palette_offset = frame.palette_offset;

	      // NOTE(deanm): It seems to be much faster to compare index to 256 than
	      // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
	      // the profile, not sure if it's related to using a Uint8Array.
	      var trans = frame.transparent_index;
	      if (trans === null) trans = 256;

	      // We are possibly just blitting to a portion of the entire frame.
	      // That is a subrect within the framerect, so the additional pixels
	      // must be skipped over after we finished a scanline.
	      var framewidth  = frame.width;
	      var framestride = width - framewidth;
	      var xleft       = framewidth;  // Number of subrect pixels left in scanline.

	      // Output indicies of the top left and bottom right corners of the subrect.
	      var opbeg = ((frame.y * width) + frame.x) * 4;
	      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
	      var op    = opbeg;

	      var scanstride = framestride * 4;

	      // Use scanstride to skip past the rows when interlacing.  This is skipping
	      // 7 rows for the first two passes, then 3 then 1.
	      if (frame.interlaced === true) {
	        scanstride += (framewidth + framestride) * 4 * 7;  // Pass 1.
	      }

	      var interlaceskip = 8;  // Tracking the row interval in the current pass.

	      for (var i = 0, il = index_stream.length; i < il; ++i) {
	        var index = index_stream[i];

	        if (xleft === 0) {  // Beginning of new scan line
	          op += scanstride;
	          xleft = framewidth;
	          if (op >= opend) { // Catch the wrap to switch passes when interlacing.
	            scanstride =
	                framestride + (framewidth + framestride) * 4 * (interlaceskip-1);
	            // interlaceskip / 2 * 4 is interlaceskip << 1.
	            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
	            interlaceskip >>= 1;
	          }
	        }

	        if (index === trans) {
	          op += 4;
	        } else {
	          var r = buf[palette_offset + index * 3];
	          var g = buf[palette_offset + index * 3 + 1];
	          var b = buf[palette_offset + index * 3 + 2];
	          pixels[op++] = b;
	          pixels[op++] = g;
	          pixels[op++] = r;
	          pixels[op++] = 255;
	        }
	        --xleft;
	      }
	    };

	    // I will go to copy and paste hell one day...
	    this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
	      var frame = this.frameInfo(frame_num);
	      var num_pixels = frame.width * frame.height;
	      var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
	      GifReaderLZWOutputIndexStream(
	          buf, frame.data_offset, index_stream, num_pixels);
	      var palette_offset = frame.palette_offset;

	      // NOTE(deanm): It seems to be much faster to compare index to 256 than
	      // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
	      // the profile, not sure if it's related to using a Uint8Array.
	      var trans = frame.transparent_index;
	      if (trans === null) trans = 256;

	      // We are possibly just blitting to a portion of the entire frame.
	      // That is a subrect within the framerect, so the additional pixels
	      // must be skipped over after we finished a scanline.
	      var framewidth  = frame.width;
	      var framestride = width - framewidth;
	      var xleft       = framewidth;  // Number of subrect pixels left in scanline.

	      // Output indicies of the top left and bottom right corners of the subrect.
	      var opbeg = ((frame.y * width) + frame.x) * 4;
	      var opend = ((frame.y + frame.height) * width + frame.x) * 4;
	      var op    = opbeg;

	      var scanstride = framestride * 4;

	      // Use scanstride to skip past the rows when interlacing.  This is skipping
	      // 7 rows for the first two passes, then 3 then 1.
	      if (frame.interlaced === true) {
	        scanstride += (framewidth + framestride) * 4 * 7;  // Pass 1.
	      }

	      var interlaceskip = 8;  // Tracking the row interval in the current pass.

	      for (var i = 0, il = index_stream.length; i < il; ++i) {
	        var index = index_stream[i];

	        if (xleft === 0) {  // Beginning of new scan line
	          op += scanstride;
	          xleft = framewidth;
	          if (op >= opend) { // Catch the wrap to switch passes when interlacing.
	            scanstride =
	                framestride + (framewidth + framestride) * 4 * (interlaceskip-1);
	            // interlaceskip / 2 * 4 is interlaceskip << 1.
	            op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
	            interlaceskip >>= 1;
	          }
	        }

	        if (index === trans) {
	          op += 4;
	        } else {
	          var r = buf[palette_offset + index * 3];
	          var g = buf[palette_offset + index * 3 + 1];
	          var b = buf[palette_offset + index * 3 + 2];
	          pixels[op++] = r;
	          pixels[op++] = g;
	          pixels[op++] = b;
	          pixels[op++] = 255;
	        }
	        --xleft;
	      }
	    };
	  }

	  function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
	    var min_code_size = code_stream[p++];

	    var clear_code = 1 << min_code_size;
	    var eoi_code = clear_code + 1;
	    var next_code = eoi_code + 1;

	    var cur_code_size = min_code_size + 1;  // Number of bits per code.
	    // NOTE: This shares the same name as the encoder, but has a different
	    // meaning here.  Here this masks each code coming from the code stream.
	    var code_mask = (1 << cur_code_size) - 1;
	    var cur_shift = 0;
	    var cur = 0;

	    var op = 0;  // Output pointer.
	    
	    var subblock_size = code_stream[p++];

	    // TODO(deanm): Would using a TypedArray be any faster?  At least it would
	    // solve the fast mode / backing store uncertainty.
	    // var code_table = Array(4096);
	    var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

	    var prev_code = null;  // Track code-1.

	    while (true) {
	      // Read up to two bytes, making sure we always 12-bits for max sized code.
	      while (cur_shift < 16) {
	        if (subblock_size === 0) break;  // No more data to be read.

	        cur |= code_stream[p++] << cur_shift;
	        cur_shift += 8;

	        if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
	          subblock_size = code_stream[p++];  // Next subblock.
	        } else {
	          --subblock_size;
	        }
	      }

	      // TODO(deanm): We should never really get here, we should have received
	      // and EOI.
	      if (cur_shift < cur_code_size)
	        break;

	      var code = cur & code_mask;
	      cur >>= cur_code_size;
	      cur_shift -= cur_code_size;

	      // TODO(deanm): Maybe should check that the first code was a clear code,
	      // at least this is what you're supposed to do.  But actually our encoder
	      // now doesn't emit a clear code first anyway.
	      if (code === clear_code) {
	        // We don't actually have to clear the table.  This could be a good idea
	        // for greater error checking, but we don't really do any anyway.  We
	        // will just track it with next_code and overwrite old entries.

	        next_code = eoi_code + 1;
	        cur_code_size = min_code_size + 1;
	        code_mask = (1 << cur_code_size) - 1;

	        // Don't update prev_code ?
	        prev_code = null;
	        continue;
	      } else if (code === eoi_code) {
	        break;
	      }

	      // We have a similar situation as the decoder, where we want to store
	      // variable length entries (code table entries), but we want to do in a
	      // faster manner than an array of arrays.  The code below stores sort of a
	      // linked list within the code table, and then "chases" through it to
	      // construct the dictionary entries.  When a new entry is created, just the
	      // last byte is stored, and the rest (prefix) of the entry is only
	      // referenced by its table entry.  Then the code chases through the
	      // prefixes until it reaches a single byte code.  We have to chase twice,
	      // first to compute the length, and then to actually copy the data to the
	      // output (backwards, since we know the length).  The alternative would be
	      // storing something in an intermediate stack, but that doesn't make any
	      // more sense.  I implemented an approach where it also stored the length
	      // in the code table, although it's a bit tricky because you run out of
	      // bits (12 + 12 + 8), but I didn't measure much improvements (the table
	      // entries are generally not the long).  Even when I created benchmarks for
	      // very long table entries the complexity did not seem worth it.
	      // The code table stores the prefix entry in 12 bits and then the suffix
	      // byte in 8 bits, so each entry is 20 bits.

	      var chase_code = code < next_code ? code : prev_code;

	      // Chase what we will output, either {CODE} or {CODE-1}.
	      var chase_length = 0;
	      var chase = chase_code;
	      while (chase > clear_code) {
	        chase = code_table[chase] >> 8;
	        ++chase_length;
	      }

	      var k = chase;
	      
	      var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
	      if (op_end > output_length) {
	        console.log("Warning, gif stream longer than expected.");
	        return;
	      }

	      // Already have the first byte from the chase, might as well write it fast.
	      output[op++] = k;

	      op += chase_length;
	      var b = op;  // Track pointer, writing backwards.

	      if (chase_code !== code)  // The case of emitting {CODE-1} + k.
	        output[op++] = k;

	      chase = chase_code;
	      while (chase_length--) {
	        chase = code_table[chase];
	        output[--b] = chase & 0xff;  // Write backwards.
	        chase >>= 8;  // Pull down to the prefix code.
	      }

	      if (prev_code !== null && next_code < 4096) {
	        code_table[next_code++] = prev_code << 8 | k;
	        // TODO(deanm): Figure out this clearing vs code growth logic better.  I
	        // have an feeling that it should just happen somewhere else, for now it
	        // is awkward between when we grow past the max and then hit a clear code.
	        // For now just check if we hit the max 12-bits (then a clear code should
	        // follow, also of course encoded in 12-bits).
	        if (next_code >= code_mask+1 && cur_code_size < 12) {
	          ++cur_code_size;
	          code_mask = code_mask << 1 | 1;
	        }
	      }

	      prev_code = code;
	    }

	    if (op !== output_length) {
	      console.log("Warning, gif stream shorter than expected.");
	    }

	    return output;
	  }

	  try { exports.GifWriter = GifWriter; exports.GifReader = GifReader; } catch(e) { }  // CommonJS.
	  

	  /*
	    Copyright (c) 2008, Adobe Systems Incorporated
	    All rights reserved.

	    Redistribution and use in source and binary forms, with or without 
	    modification, are permitted provided that the following conditions are
	    met:

	    * Redistributions of source code must retain the above copyright notice, 
	      this list of conditions and the following disclaimer.
	    
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the 
	      documentation and/or other materials provided with the distribution.
	    
	    * Neither the name of Adobe Systems Incorporated nor the names of its 
	      contributors may be used to endorse or promote products derived from 
	      this software without specific prior written permission.

	    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
	    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
	    THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	    PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
	    CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	    EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	    PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
	    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
	    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	  */
	  /*
	  JPEG encoder ported to JavaScript and optimized by Andreas Ritter, www.bytestrom.eu, 11/2009

	  Basic GUI blocking jpeg encoder
	  */

	  function JPEGEncoder(quality) {
	  	var ffloor = Math.floor;
	  	var YTable = new Array(64);
	  	var UVTable = new Array(64);
	  	var fdtbl_Y = new Array(64);
	  	var fdtbl_UV = new Array(64);
	  	var YDC_HT;
	  	var UVDC_HT;
	  	var YAC_HT;
	  	var UVAC_HT;
	  	
	  	var bitcode = new Array(65535);
	  	var category = new Array(65535);
	  	var outputfDCTQuant = new Array(64);
	  	var DU = new Array(64);
	  	var byteout = [];
	  	var bytenew = 0;
	  	var bytepos = 7;
	  	
	  	var YDU = new Array(64);
	  	var UDU = new Array(64);
	  	var VDU = new Array(64);
	  	var clt = new Array(256);
	  	var RGB_YUV_TABLE = new Array(2048);
	  	var currentQuality;
	  	
	  	var ZigZag = [
	  			 0, 1, 5, 6,14,15,27,28,
	  			 2, 4, 7,13,16,26,29,42,
	  			 3, 8,12,17,25,30,41,43,
	  			 9,11,18,24,31,40,44,53,
	  			10,19,23,32,39,45,52,54,
	  			20,22,33,38,46,51,55,60,
	  			21,34,37,47,50,56,59,61,
	  			35,36,48,49,57,58,62,63
	  		];
	  	
	  	var std_dc_luminance_nrcodes = [0,0,1,5,1,1,1,1,1,1,0,0,0,0,0,0,0];
	  	var std_dc_luminance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	  	var std_ac_luminance_nrcodes = [0,0,2,1,3,3,2,4,3,5,5,4,4,0,0,1,0x7d];
	  	var std_ac_luminance_values = [
	  			0x01,0x02,0x03,0x00,0x04,0x11,0x05,0x12,
	  			0x21,0x31,0x41,0x06,0x13,0x51,0x61,0x07,
	  			0x22,0x71,0x14,0x32,0x81,0x91,0xa1,0x08,
	  			0x23,0x42,0xb1,0xc1,0x15,0x52,0xd1,0xf0,
	  			0x24,0x33,0x62,0x72,0x82,0x09,0x0a,0x16,
	  			0x17,0x18,0x19,0x1a,0x25,0x26,0x27,0x28,
	  			0x29,0x2a,0x34,0x35,0x36,0x37,0x38,0x39,
	  			0x3a,0x43,0x44,0x45,0x46,0x47,0x48,0x49,
	  			0x4a,0x53,0x54,0x55,0x56,0x57,0x58,0x59,
	  			0x5a,0x63,0x64,0x65,0x66,0x67,0x68,0x69,
	  			0x6a,0x73,0x74,0x75,0x76,0x77,0x78,0x79,
	  			0x7a,0x83,0x84,0x85,0x86,0x87,0x88,0x89,
	  			0x8a,0x92,0x93,0x94,0x95,0x96,0x97,0x98,
	  			0x99,0x9a,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,
	  			0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,0xb5,0xb6,
	  			0xb7,0xb8,0xb9,0xba,0xc2,0xc3,0xc4,0xc5,
	  			0xc6,0xc7,0xc8,0xc9,0xca,0xd2,0xd3,0xd4,
	  			0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xe1,0xe2,
	  			0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,
	  			0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
	  			0xf9,0xfa
	  		];
	  	
	  	var std_dc_chrominance_nrcodes = [0,0,3,1,1,1,1,1,1,1,1,1,0,0,0,0,0];
	  	var std_dc_chrominance_values = [0,1,2,3,4,5,6,7,8,9,10,11];
	  	var std_ac_chrominance_nrcodes = [0,0,2,1,2,4,4,3,4,7,5,4,4,0,1,2,0x77];
	  	var std_ac_chrominance_values = [
	  			0x00,0x01,0x02,0x03,0x11,0x04,0x05,0x21,
	  			0x31,0x06,0x12,0x41,0x51,0x07,0x61,0x71,
	  			0x13,0x22,0x32,0x81,0x08,0x14,0x42,0x91,
	  			0xa1,0xb1,0xc1,0x09,0x23,0x33,0x52,0xf0,
	  			0x15,0x62,0x72,0xd1,0x0a,0x16,0x24,0x34,
	  			0xe1,0x25,0xf1,0x17,0x18,0x19,0x1a,0x26,
	  			0x27,0x28,0x29,0x2a,0x35,0x36,0x37,0x38,
	  			0x39,0x3a,0x43,0x44,0x45,0x46,0x47,0x48,
	  			0x49,0x4a,0x53,0x54,0x55,0x56,0x57,0x58,
	  			0x59,0x5a,0x63,0x64,0x65,0x66,0x67,0x68,
	  			0x69,0x6a,0x73,0x74,0x75,0x76,0x77,0x78,
	  			0x79,0x7a,0x82,0x83,0x84,0x85,0x86,0x87,
	  			0x88,0x89,0x8a,0x92,0x93,0x94,0x95,0x96,
	  			0x97,0x98,0x99,0x9a,0xa2,0xa3,0xa4,0xa5,
	  			0xa6,0xa7,0xa8,0xa9,0xaa,0xb2,0xb3,0xb4,
	  			0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xc2,0xc3,
	  			0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xd2,
	  			0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,
	  			0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,
	  			0xea,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,
	  			0xf9,0xfa
	  		];
	  	
	  	function initQuantTables(sf){
	  			var YQT = [
	  				16, 11, 10, 16, 24, 40, 51, 61,
	  				12, 12, 14, 19, 26, 58, 60, 55,
	  				14, 13, 16, 24, 40, 57, 69, 56,
	  				14, 17, 22, 29, 51, 87, 80, 62,
	  				18, 22, 37, 56, 68,109,103, 77,
	  				24, 35, 55, 64, 81,104,113, 92,
	  				49, 64, 78, 87,103,121,120,101,
	  				72, 92, 95, 98,112,100,103, 99
	  			];
	  			
	  			for (var i = 0; i < 64; i++) {
	  				var t = ffloor((YQT[i]*sf+50)/100);
	  				if (t < 1) {
	  					t = 1;
	  				} else if (t > 255) {
	  					t = 255;
	  				}
	  				YTable[ZigZag[i]] = t;
	  			}
	  			var UVQT = [
	  				17, 18, 24, 47, 99, 99, 99, 99,
	  				18, 21, 26, 66, 99, 99, 99, 99,
	  				24, 26, 56, 99, 99, 99, 99, 99,
	  				47, 66, 99, 99, 99, 99, 99, 99,
	  				99, 99, 99, 99, 99, 99, 99, 99,
	  				99, 99, 99, 99, 99, 99, 99, 99,
	  				99, 99, 99, 99, 99, 99, 99, 99,
	  				99, 99, 99, 99, 99, 99, 99, 99
	  			];
	  			for (var j = 0; j < 64; j++) {
	  				var u = ffloor((UVQT[j]*sf+50)/100);
	  				if (u < 1) {
	  					u = 1;
	  				} else if (u > 255) {
	  					u = 255;
	  				}
	  				UVTable[ZigZag[j]] = u;
	  			}
	  			var aasf = [
	  				1.0, 1.387039845, 1.306562965, 1.175875602,
	  				1.0, 0.785694958, 0.541196100, 0.275899379
	  			];
	  			var k = 0;
	  			for (var row = 0; row < 8; row++)
	  			{
	  				for (var col = 0; col < 8; col++)
	  				{
	  					fdtbl_Y[k]  = (1.0 / (YTable [ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
	  					fdtbl_UV[k] = (1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0));
	  					k++;
	  				}
	  			}
	  		}
	  		
	  		function computeHuffmanTbl(nrcodes, std_table){
	  			var codevalue = 0;
	  			var pos_in_table = 0;
	  			var HT = new Array();
	  			for (var k = 1; k <= 16; k++) {
	  				for (var j = 1; j <= nrcodes[k]; j++) {
	  					HT[std_table[pos_in_table]] = [];
	  					HT[std_table[pos_in_table]][0] = codevalue;
	  					HT[std_table[pos_in_table]][1] = k;
	  					pos_in_table++;
	  					codevalue++;
	  				}
	  				codevalue*=2;
	  			}
	  			return HT;
	  		}
	  		
	  		function initHuffmanTbl()
	  		{
	  			YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
	  			UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
	  			YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
	  			UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
	  		}
	  	
	  		function initCategoryNumber()
	  		{
	  			var nrlower = 1;
	  			var nrupper = 2;
	  			for (var cat = 1; cat <= 15; cat++) {
	  				//Positive numbers
	  				for (var nr = nrlower; nr<nrupper; nr++) {
	  					category[32767+nr] = cat;
	  					bitcode[32767+nr] = [];
	  					bitcode[32767+nr][1] = cat;
	  					bitcode[32767+nr][0] = nr;
	  				}
	  				//Negative numbers
	  				for (var nrneg =-(nrupper-1); nrneg<=-nrlower; nrneg++) {
	  					category[32767+nrneg] = cat;
	  					bitcode[32767+nrneg] = [];
	  					bitcode[32767+nrneg][1] = cat;
	  					bitcode[32767+nrneg][0] = nrupper-1+nrneg;
	  				}
	  				nrlower <<= 1;
	  				nrupper <<= 1;
	  			}
	  		}
	  		
	  		function initRGBYUVTable() {
	  			for(var i = 0; i < 256;i++) {
	  				RGB_YUV_TABLE[i]      		=  19595 * i;
	  				RGB_YUV_TABLE[(i+ 256)>>0] 	=  38470 * i;
	  				RGB_YUV_TABLE[(i+ 512)>>0] 	=   7471 * i + 0x8000;
	  				RGB_YUV_TABLE[(i+ 768)>>0] 	= -11059 * i;
	  				RGB_YUV_TABLE[(i+1024)>>0] 	= -21709 * i;
	  				RGB_YUV_TABLE[(i+1280)>>0] 	=  32768 * i + 0x807FFF;
	  				RGB_YUV_TABLE[(i+1536)>>0] 	= -27439 * i;
	  				RGB_YUV_TABLE[(i+1792)>>0] 	= - 5329 * i;
	  			}
	  		}
	  		
	  		// IO functions
	  		function writeBits(bs)
	  		{
	  			var value = bs[0];
	  			var posval = bs[1]-1;
	  			while ( posval >= 0 ) {
	  				if (value & (1 << posval) ) {
	  					bytenew |= (1 << bytepos);
	  				}
	  				posval--;
	  				bytepos--;
	  				if (bytepos < 0) {
	  					if (bytenew == 0xFF) {
	  						writeByte(0xFF);
	  						writeByte(0);
	  					}
	  					else {
	  						writeByte(bytenew);
	  					}
	  					bytepos=7;
	  					bytenew=0;
	  				}
	  			}
	  		}
	  	
	  		function writeByte(value)
	  		{
	  			//byteout.push(clt[value]); // write char directly instead of converting later
	        byteout.push(value);
	  		}
	  	
	  		function writeWord(value)
	  		{
	  			writeByte((value>>8)&0xFF);
	  			writeByte((value   )&0xFF);
	  		}
	  		
	  		// DCT & quantization core
	  		function fDCTQuant(data, fdtbl)
	  		{
	  			var d0, d1, d2, d3, d4, d5, d6, d7;
	  			/* Pass 1: process rows. */
	  			var dataOff=0;
	  			var i;
	  			var I8 = 8;
	  			var I64 = 64;
	  			for (i=0; i<I8; ++i)
	  			{
	  				d0 = data[dataOff];
	  				d1 = data[dataOff+1];
	  				d2 = data[dataOff+2];
	  				d3 = data[dataOff+3];
	  				d4 = data[dataOff+4];
	  				d5 = data[dataOff+5];
	  				d6 = data[dataOff+6];
	  				d7 = data[dataOff+7];
	  				
	  				var tmp0 = d0 + d7;
	  				var tmp7 = d0 - d7;
	  				var tmp1 = d1 + d6;
	  				var tmp6 = d1 - d6;
	  				var tmp2 = d2 + d5;
	  				var tmp5 = d2 - d5;
	  				var tmp3 = d3 + d4;
	  				var tmp4 = d3 - d4;
	  	
	  				/* Even part */
	  				var tmp10 = tmp0 + tmp3;	/* phase 2 */
	  				var tmp13 = tmp0 - tmp3;
	  				var tmp11 = tmp1 + tmp2;
	  				var tmp12 = tmp1 - tmp2;
	  	
	  				data[dataOff] = tmp10 + tmp11; /* phase 3 */
	  				data[dataOff+4] = tmp10 - tmp11;
	  	
	  				var z1 = (tmp12 + tmp13) * 0.707106781; /* c4 */
	  				data[dataOff+2] = tmp13 + z1; /* phase 5 */
	  				data[dataOff+6] = tmp13 - z1;
	  	
	  				/* Odd part */
	  				tmp10 = tmp4 + tmp5; /* phase 2 */
	  				tmp11 = tmp5 + tmp6;
	  				tmp12 = tmp6 + tmp7;
	  	
	  				/* The rotator is modified from fig 4-8 to avoid extra negations. */
	  				var z5 = (tmp10 - tmp12) * 0.382683433; /* c6 */
	  				var z2 = 0.541196100 * tmp10 + z5; /* c2-c6 */
	  				var z4 = 1.306562965 * tmp12 + z5; /* c2+c6 */
	  				var z3 = tmp11 * 0.707106781; /* c4 */
	  	
	  				var z11 = tmp7 + z3;	/* phase 5 */
	  				var z13 = tmp7 - z3;
	  	
	  				data[dataOff+5] = z13 + z2;	/* phase 6 */
	  				data[dataOff+3] = z13 - z2;
	  				data[dataOff+1] = z11 + z4;
	  				data[dataOff+7] = z11 - z4;
	  	
	  				dataOff += 8; /* advance pointer to next row */
	  			}
	  	
	  			/* Pass 2: process columns. */
	  			dataOff = 0;
	  			for (i=0; i<I8; ++i)
	  			{
	  				d0 = data[dataOff];
	  				d1 = data[dataOff + 8];
	  				d2 = data[dataOff + 16];
	  				d3 = data[dataOff + 24];
	  				d4 = data[dataOff + 32];
	  				d5 = data[dataOff + 40];
	  				d6 = data[dataOff + 48];
	  				d7 = data[dataOff + 56];
	  				
	  				var tmp0p2 = d0 + d7;
	  				var tmp7p2 = d0 - d7;
	  				var tmp1p2 = d1 + d6;
	  				var tmp6p2 = d1 - d6;
	  				var tmp2p2 = d2 + d5;
	  				var tmp5p2 = d2 - d5;
	  				var tmp3p2 = d3 + d4;
	  				var tmp4p2 = d3 - d4;
	  	
	  				/* Even part */
	  				var tmp10p2 = tmp0p2 + tmp3p2;	/* phase 2 */
	  				var tmp13p2 = tmp0p2 - tmp3p2;
	  				var tmp11p2 = tmp1p2 + tmp2p2;
	  				var tmp12p2 = tmp1p2 - tmp2p2;
	  	
	  				data[dataOff] = tmp10p2 + tmp11p2; /* phase 3 */
	  				data[dataOff+32] = tmp10p2 - tmp11p2;
	  	
	  				var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
	  				data[dataOff+16] = tmp13p2 + z1p2; /* phase 5 */
	  				data[dataOff+48] = tmp13p2 - z1p2;
	  	
	  				/* Odd part */
	  				tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
	  				tmp11p2 = tmp5p2 + tmp6p2;
	  				tmp12p2 = tmp6p2 + tmp7p2;
	  	
	  				/* The rotator is modified from fig 4-8 to avoid extra negations. */
	  				var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
	  				var z2p2 = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
	  				var z4p2 = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
	  				var z3p2 = tmp11p2 * 0.707106781; /* c4 */
	  	
	  				var z11p2 = tmp7p2 + z3p2;	/* phase 5 */
	  				var z13p2 = tmp7p2 - z3p2;
	  	
	  				data[dataOff+40] = z13p2 + z2p2; /* phase 6 */
	  				data[dataOff+24] = z13p2 - z2p2;
	  				data[dataOff+ 8] = z11p2 + z4p2;
	  				data[dataOff+56] = z11p2 - z4p2;
	  	
	  				dataOff++; /* advance pointer to next column */
	  			}
	  	
	  			// Quantize/descale the coefficients
	  			var fDCTQuant;
	  			for (i=0; i<I64; ++i)
	  			{
	  				// Apply the quantization and scaling factor & Round to nearest integer
	  				fDCTQuant = data[i]*fdtbl[i];
	  				outputfDCTQuant[i] = (fDCTQuant > 0.0) ? ((fDCTQuant + 0.5)|0) : ((fDCTQuant - 0.5)|0);
	  				//outputfDCTQuant[i] = fround(fDCTQuant);

	  			}
	  			return outputfDCTQuant;
	  		}
	  		
	  		function writeAPP0()
	  		{
	  			writeWord(0xFFE0); // marker
	  			writeWord(16); // length
	  			writeByte(0x4A); // J
	  			writeByte(0x46); // F
	  			writeByte(0x49); // I
	  			writeByte(0x46); // F
	  			writeByte(0); // = "JFIF",'\0'
	  			writeByte(1); // versionhi
	  			writeByte(1); // versionlo
	  			writeByte(0); // xyunits
	  			writeWord(1); // xdensity
	  			writeWord(1); // ydensity
	  			writeByte(0); // thumbnwidth
	  			writeByte(0); // thumbnheight
	  		}
	  	
	  		function writeSOF0(width, height)
	  		{
	  			writeWord(0xFFC0); // marker
	  			writeWord(17);   // length, truecolor YUV JPG
	  			writeByte(8);    // precision
	  			writeWord(height);
	  			writeWord(width);
	  			writeByte(3);    // nrofcomponents
	  			writeByte(1);    // IdY
	  			writeByte(0x11); // HVY
	  			writeByte(0);    // QTY
	  			writeByte(2);    // IdU
	  			writeByte(0x11); // HVU
	  			writeByte(1);    // QTU
	  			writeByte(3);    // IdV
	  			writeByte(0x11); // HVV
	  			writeByte(1);    // QTV
	  		}
	  	
	  		function writeDQT()
	  		{
	  			writeWord(0xFFDB); // marker
	  			writeWord(132);	   // length
	  			writeByte(0);
	  			for (var i=0; i<64; i++) {
	  				writeByte(YTable[i]);
	  			}
	  			writeByte(1);
	  			for (var j=0; j<64; j++) {
	  				writeByte(UVTable[j]);
	  			}
	  		}
	  	
	  		function writeDHT()
	  		{
	  			writeWord(0xFFC4); // marker
	  			writeWord(0x01A2); // length
	  	
	  			writeByte(0); // HTYDCinfo
	  			for (var i=0; i<16; i++) {
	  				writeByte(std_dc_luminance_nrcodes[i+1]);
	  			}
	  			for (var j=0; j<=11; j++) {
	  				writeByte(std_dc_luminance_values[j]);
	  			}
	  	
	  			writeByte(0x10); // HTYACinfo
	  			for (var k=0; k<16; k++) {
	  				writeByte(std_ac_luminance_nrcodes[k+1]);
	  			}
	  			for (var l=0; l<=161; l++) {
	  				writeByte(std_ac_luminance_values[l]);
	  			}
	  	
	  			writeByte(1); // HTUDCinfo
	  			for (var m=0; m<16; m++) {
	  				writeByte(std_dc_chrominance_nrcodes[m+1]);
	  			}
	  			for (var n=0; n<=11; n++) {
	  				writeByte(std_dc_chrominance_values[n]);
	  			}
	  	
	  			writeByte(0x11); // HTUACinfo
	  			for (var o=0; o<16; o++) {
	  				writeByte(std_ac_chrominance_nrcodes[o+1]);
	  			}
	  			for (var p=0; p<=161; p++) {
	  				writeByte(std_ac_chrominance_values[p]);
	  			}
	  		}
	  	
	  		function writeSOS()
	  		{
	  			writeWord(0xFFDA); // marker
	  			writeWord(12); // length
	  			writeByte(3); // nrofcomponents
	  			writeByte(1); // IdY
	  			writeByte(0); // HTY
	  			writeByte(2); // IdU
	  			writeByte(0x11); // HTU
	  			writeByte(3); // IdV
	  			writeByte(0x11); // HTV
	  			writeByte(0); // Ss
	  			writeByte(0x3f); // Se
	  			writeByte(0); // Bf
	  		}
	  		
	  		function processDU(CDU, fdtbl, DC, HTDC, HTAC){
	  			var EOB = HTAC[0x00];
	  			var M16zeroes = HTAC[0xF0];
	  			var pos;
	  			var I16 = 16;
	  			var I63 = 63;
	  			var I64 = 64;
	  			var DU_DCT = fDCTQuant(CDU, fdtbl);
	  			//ZigZag reorder
	  			for (var j=0;j<I64;++j) {
	  				DU[ZigZag[j]]=DU_DCT[j];
	  			}
	  			var Diff = DU[0] - DC; DC = DU[0];
	  			//Encode DC
	  			if (Diff==0) {
	  				writeBits(HTDC[0]); // Diff might be 0
	  			} else {
	  				pos = 32767+Diff;
	  				writeBits(HTDC[category[pos]]);
	  				writeBits(bitcode[pos]);
	  			}
	  			//Encode ACs
	  			var end0pos = 63; // was const... which is crazy
	  			for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {}			//end0pos = first element in reverse order !=0
	  			if ( end0pos == 0) {
	  				writeBits(EOB);
	  				return DC;
	  			}
	  			var i = 1;
	  			var lng;
	  			while ( i <= end0pos ) {
	  				var startpos = i;
	  				for (; (DU[i]==0) && (i<=end0pos); ++i) {}
	  				var nrzeroes = i-startpos;
	  				if ( nrzeroes >= I16 ) {
	  					lng = nrzeroes>>4;
	  					for (var nrmarker=1; nrmarker <= lng; ++nrmarker)
	  						writeBits(M16zeroes);
	  					nrzeroes = nrzeroes&0xF;
	  				}
	  				pos = 32767+DU[i];
	  				writeBits(HTAC[(nrzeroes<<4)+category[pos]]);
	  				writeBits(bitcode[pos]);
	  				i++;
	  			}
	  			if ( end0pos != I63 ) {
	  				writeBits(EOB);
	  			}
	  			return DC;
	  		}

	  		function initCharLookupTable(){
	  			var sfcc = String.fromCharCode;
	  			for(var i=0; i < 256; i++){ ///// ACHTUNG // 255
	  				clt[i] = sfcc(i);
	  			}
	  		}
	  		
	  		this.encode = function(image,quality) // image data object
	  		{
	  			var time_start = new Date().getTime();
	  			
	  			if(quality) setQuality(quality);
	  			
	  			// Initialize bit writer
	  			byteout = new Array();
	  			bytenew=0;
	  			bytepos=7;
	  	
	  			// Add JPEG headers
	  			writeWord(0xFFD8); // SOI
	  			writeAPP0();
	  			writeDQT();
	  			writeSOF0(image.width,image.height);
	  			writeDHT();
	  			writeSOS();

	  	
	  			// Encode 8x8 macroblocks
	  			var DCY=0;
	  			var DCU=0;
	  			var DCV=0;
	  			
	  			bytenew=0;
	  			bytepos=7;
	  			
	  			
	  			this.encode.displayName = "_encode_";

	  			var imageData = image.data;
	  			var width = image.width;
	  			var height = image.height;

	  			var quadWidth = width*4;
	  			
	  			var x, y = 0;
	  			var r, g, b;
	  			var start,p, col,row,pos;
	  			while(y < height){
	  				x = 0;
	  				while(x < quadWidth){
	  				start = quadWidth * y + x;
	  				p = start;
	  				col = -1;
	  				row = 0;
	  				
	  				for(pos=0; pos < 64; pos++){
	  					row = pos >> 3;// /8
	  					col = ( pos & 7 ) * 4; // %8
	  					p = start + ( row * quadWidth ) + col;		
	  					
	  					if(y+row >= height){ // padding bottom
	  						p-= (quadWidth*(y+1+row-height));
	  					}

	  					if(x+col >= quadWidth){ // padding right	
	  						p-= ((x+col) - quadWidth +4);
	  					}
	  					
	  					r = imageData[ p++ ];
	  					g = imageData[ p++ ];
	  					b = imageData[ p++ ];
	  					
	  					
	  					/* // calculate YUV values dynamically
	  					YDU[pos]=((( 0.29900)*r+( 0.58700)*g+( 0.11400)*b))-128; //-0x80
	  					UDU[pos]=(((-0.16874)*r+(-0.33126)*g+( 0.50000)*b));
	  					VDU[pos]=((( 0.50000)*r+(-0.41869)*g+(-0.08131)*b));
	  					*/
	  					
	  					// use lookup table (slightly faster)
	  					YDU[pos] = ((RGB_YUV_TABLE[r]             + RGB_YUV_TABLE[(g +  256)>>0] + RGB_YUV_TABLE[(b +  512)>>0]) >> 16)-128;
	  					UDU[pos] = ((RGB_YUV_TABLE[(r +  768)>>0] + RGB_YUV_TABLE[(g + 1024)>>0] + RGB_YUV_TABLE[(b + 1280)>>0]) >> 16)-128;
	  					VDU[pos] = ((RGB_YUV_TABLE[(r + 1280)>>0] + RGB_YUV_TABLE[(g + 1536)>>0] + RGB_YUV_TABLE[(b + 1792)>>0]) >> 16)-128;

	  				}
	  				
	  				DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
	  				DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
	  				DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
	  				x+=32;
	  				}
	  				y+=8;
	  			}
	  			
	  			
	  			////////////////////////////////////////////////////////////////
	  	
	  			// Do the bit alignment of the EOI marker
	  			if ( bytepos >= 0 ) {
	  				var fillbits = [];
	  				fillbits[1] = bytepos+1;
	  				fillbits[0] = (1<<(bytepos+1))-1;
	  				writeBits(fillbits);
	  			}
	  	
	  			writeWord(0xFFD9); //EOI

	        return new Uint8Array(byteout);
	        //return new Buffer(byteout);

	  			var jpegDataUri = 'data:image/jpeg;base64,' + btoa(byteout.join(''));
	  			
	  			byteout = [];
	  			
	  			// benchmarking
	  			var duration = new Date().getTime() - time_start;
	      		//console.log('Encoding time: '+ duration + 'ms');
	      		//
	  			
	  			return jpegDataUri			
	  	};
	  	
	  	function setQuality(quality){
	  		if (quality <= 0) {
	  			quality = 1;
	  		}
	  		if (quality > 100) {
	  			quality = 100;
	  		}
	  		
	  		if(currentQuality == quality) return // don't recalc if unchanged
	  		
	  		var sf = 0;
	  		if (quality < 50) {
	  			sf = Math.floor(5000 / quality);
	  		} else {
	  			sf = Math.floor(200 - quality*2);
	  		}
	  		
	  		initQuantTables(sf);
	  		currentQuality = quality;
	  		//console.log('Quality set to: '+quality +'%');
	  	}
	  	
	  	function init(){
	  		var time_start = new Date().getTime();
	  		if(!quality) quality = 50;
	  		// Create tables
	  		initCharLookupTable();
	  		initHuffmanTbl();
	  		initCategoryNumber();
	  		initRGBYUVTable();
	  		
	  		setQuality(quality);
	  		var duration = new Date().getTime() - time_start;
	      	//console.log('Initialization '+ duration + 'ms');
	  	}
	  	
	  	init();
	  	
	  }


	  try { module.exports = JPEGEncoder; } catch(e) { }  // CommonJS.

	  /**
	   * @author shaozilee
	   *
	   * Bmp format decoder,support 1bit 4bit 8bit 24bit bmp
	   *
	   */

	  function BmpDecoder(buffer,is_with_alpha) {
	    this.pos = 0;
	    this.buffer = buffer;
	    this.datav = new DataView(buffer.buffer);
	    this.is_with_alpha = !!is_with_alpha;
	    this.bottom_up = true;
	    this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]);
	    this.pos += 2;
	    if (["BM","BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File");
	    this.parseHeader();
	    this.parseBGR();
	  }

	  BmpDecoder.prototype.parseHeader = function() {
	    this.fileSize = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.reserved = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.offset = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.headerSize = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.width = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.height = this.datav.getInt32(this.pos, true);  this.pos += 4;
	    this.planes = this.datav.getUint16(this.pos, true); 
	    this.pos += 2;
	    this.bitPP = this.datav.getUint16(this.pos, true); 
	    this.pos += 2;
	    this.compress = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.rawSize = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.hr = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.vr = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.colors = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;
	    this.importantColors = this.datav.getUint32(this.pos, true); 
	    this.pos += 4;

	    if(this.bitPP === 16 && this.is_with_alpha){
	      this.bitPP = 15;
	    }
	    if (this.bitPP < 15) {
	      var len = this.colors === 0 ? 1 << this.bitPP : this.colors;
	      this.palette = new Array(len);
	      for (var i = 0; i < len; i++) {
	        var blue = this.datav.getUint8(this.pos++, true);      var green = this.datav.getUint8(this.pos++, true);      var red = this.datav.getUint8(this.pos++, true);      var quad = this.datav.getUint8(this.pos++, true);      this.palette[i] = {
	          red: red,
	          green: green,
	          blue: blue,
	          quad: quad
	        };
	      }
	    }
	    if(this.height < 0) {
	      this.height *= -1;
	      this.bottom_up = false;
	    }

	  };

	  BmpDecoder.prototype.parseBGR = function() {
	    this.pos = this.offset;
	    try {
	      var bitn = "bit" + this.bitPP;
	      var len = this.width * this.height * 4;
	      this.data = new Uint8Array(len);

	      this[bitn]();
	    } catch (e) {
	      console.log("bit decode error:" + e);
	    }

	  };

	  BmpDecoder.prototype.bit1 = function() {
	    var xlen = Math.ceil(this.width / 8);
	    var mode = xlen%4;
	    var y = this.height >= 0 ? this.height - 1 : -this.height;
	    for (var y = this.height - 1; y >= 0; y--) {
	      var line = this.bottom_up ? y : this.height - 1 - y;
	      for (var x = 0; x < xlen; x++) {
	        var b = this.datav.getUint8(this.pos++, true);      var location = line * this.width * 4 + x*8*4;
	        for (var i = 0; i < 8; i++) {
	          if(x*8+i<this.width){
	            var rgb = this.palette[((b>>(7-i))&0x1)];
	            this.data[location+i*4] = rgb.blue;
	            this.data[location+i*4 + 1] = rgb.green;
	            this.data[location+i*4 + 2] = rgb.red;
	            this.data[location+i*4 + 3] = 0xFF;
	          }else{
	            break;
	          }
	        }
	      }

	      if (mode != 0){
	        this.pos+=(4 - mode);
	      }
	    }
	  };

	  BmpDecoder.prototype.bit4 = function() {
	    var xlen = Math.ceil(this.width/2);
	    var mode = xlen%4;
	    for (var y = this.height - 1; y >= 0; y--) {
	      var line = this.bottom_up ? y : this.height - 1 - y;
	      for (var x = 0; x < xlen; x++) {
	        var b = this.datav.getUint8(this.pos++, true);      var location = line * this.width * 4 + x*2*4;

	        var before = b>>4;
	        var after = b&0x0F;

	        var rgb = this.palette[before];
	        this.data[location] = rgb.blue;
	        this.data[location + 1] = rgb.green;
	        this.data[location + 2] = rgb.red;
	        this.data[location + 3] = 0xFF;

	        if(x*2+1>=this.width)break;

	        rgb = this.palette[after];
	        this.data[location+4] = rgb.blue;
	        this.data[location+4 + 1] = rgb.green;
	        this.data[location+4 + 2] = rgb.red;
	        this.data[location+4 + 3] = 0xFF;
	      }

	      if (mode != 0){
	        this.pos+=(4 - mode);
	      }
	    }

	  };

	  BmpDecoder.prototype.bit8 = function() {
	    var mode = this.width%4;
	    for (var y = this.height - 1; y >= 0; y--) {
	      var line = this.bottom_up ? y : this.height - 1 - y;
	      for (var x = 0; x < this.width; x++) {
	        var b = this.datav.getUint8(this.pos++, true);      var location = line * this.width * 4 + x*4;
	        if(b < this.palette.length) {
	          var rgb = this.palette[b];
	          this.data[location] = rgb.red;
	          this.data[location + 1] = rgb.green;
	          this.data[location + 2] = rgb.blue;
	          this.data[location + 3] = 0xFF;
	        } else {
	          this.data[location] = 0xFF;
	          this.data[location + 1] = 0xFF;
	          this.data[location + 2] = 0xFF;
	          this.data[location + 3] = 0xFF;
	        }
	      }
	      if (mode != 0){
	        this.pos+=(4 - mode);
	      }
	    }
	  };

	  BmpDecoder.prototype.bit15 = function() {
	    var dif_w =this.width % 3;
	    var _11111 = parseInt("11111", 2),_1_5 = _11111;
	    for (var y = this.height - 1; y >= 0; y--) {
	      var line = this.bottom_up ? y : this.height - 1 - y;
	      for (var x = 0; x < this.width; x++) {

	        var B = this.datav.getUint16(this.pos, true); 
	        this.pos+=2;
	        var blue = (B & _1_5) / _1_5 * 255 | 0;
	        var green = (B >> 5 & _1_5 ) / _1_5 * 255 | 0;
	        var red = (B >> 10 & _1_5) / _1_5 * 255 | 0;
	        var alpha = (B>>15)?0xFF:0x00;

	        var location = line * this.width * 4 + x * 4;
	        this.data[location] = red;
	        this.data[location + 1] = green;
	        this.data[location + 2] = blue;
	        this.data[location + 3] = alpha;
	      }
	      //skip extra bytes
	      this.pos += dif_w;
	    }
	  };

	  BmpDecoder.prototype.bit16 = function() {
	    var dif_w =this.width % 3;
	    var _11111 = parseInt("11111", 2),_1_5 = _11111;
	    var _111111 = parseInt("111111", 2),_1_6 = _111111;
	    for (var y = this.height - 1; y >= 0; y--) {
	      var line = this.bottom_up ? y : this.height - 1 - y;
	      for (var x = 0; x < this.width; x++) {

	        var B = this.datav.getUint16(this.pos, true); 
	        this.pos+=2;
	        var alpha = 0xFF;
	        var blue = (B & _1_5) / _1_5 * 255 | 0;
	        var green = (B >> 5 & _1_6 ) / _1_6 * 255 | 0;
	        var red = (B >> 11) / _1_5 * 255 | 0;

	        var location = line * this.width * 4 + x * 4;
	        this.data[location] = red;
	        this.data[location + 1] = green;
	        this.data[location + 2] = blue;
	        this.data[location + 3] = alpha;
	      }
	      //skip extra bytes
	      this.pos += dif_w;
	    }
	  };

	  BmpDecoder.prototype.bit24 = function() {
	    //when height > 0
	    for (var y = this.height - 1; y >= 0; y--) {
	      var line = this.bottom_up ? y : this.height - 1 - y;
	      for (var x = 0; x < this.width; x++) {
	        var blue = this.datav.getUint8(this.pos++, true);      var green = this.datav.getUint8(this.pos++, true);      var red = this.datav.getUint8(this.pos++, true);      var location = line * this.width * 4 + x * 4;
	        this.data[location] = red;
	        this.data[location + 1] = green;
	        this.data[location + 2] = blue;
	        this.data[location + 3] = 0xFF;
	      }
	      //skip extra bytes
	      this.pos += (this.width % 4);
	    }

	  };

	  /**
	   * add 32bit decode func
	   * @author soubok
	   */
	  BmpDecoder.prototype.bit32 = function() {
	    //when height > 0
	    for (var y = this.height - 1; y >= 0; y--) {
	      var line = this.bottom_up ? y : this.height - 1 - y;
	      for (var x = 0; x < this.width; x++) {
	        var blue = this.datav.getUint8(this.pos++, true);      var green = this.datav.getUint8(this.pos++, true);      var red = this.datav.getUint8(this.pos++, true);      var alpha = this.datav.getUint8(this.pos++, true);      var location = line * this.width * 4 + x * 4;
	        this.data[location] = red;
	        this.data[location + 1] = green;
	        this.data[location + 2] = blue;
	        this.data[location + 3] = alpha;
	      }
	      //skip extra bytes
	      //this.pos += (this.width % 4);
	    }

	  };

	  BmpDecoder.prototype.getData = function() {
	    return this.data;
	  };

	  try { 
	  	module.exports = function(bmpData) {
	  		  var decoder = new BmpDecoder(bmpData);
	  		  return {
	  		    data: decoder.getData(),
	  		    width: decoder.width,
	  		    height: decoder.height
	  		  };
	  		};
	  } catch(e) { }  // CommonJS.
	  

	  /*
	   Copyright (c) 2013 Gildas Lormeau. All rights reserved.

	   Redistribution and use in source and binary forms, with or without
	   modification, are permitted provided that the following conditions are met:

	   1. Redistributions of source code must retain the above copyright notice,
	   this list of conditions and the following disclaimer.

	   2. Redistributions in binary form must reproduce the above copyright 
	   notice, this list of conditions and the following disclaimer in 
	   the documentation and/or other materials provided with the distribution.

	   3. The names of the authors may not be used to endorse or promote products
	   derived from this software without specific prior written permission.

	   THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,
	   INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
	   FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,
	   INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,
	   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
	   OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
	   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
	   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
	   EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	   */

	  /*
	   * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.
	   * JZlib is based on zlib-1.1.3, so all credit should go authors
	   * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)
	   * and contributors of zlib.
	   */

	  (function(global) {

	  	// Global

	  	var MAX_BITS = 15;
	  	var D_CODES = 30;
	  	var BL_CODES = 19;

	  	var LENGTH_CODES = 29;
	  	var LITERALS = 256;
	  	var L_CODES = (LITERALS + 1 + LENGTH_CODES);
	  	var HEAP_SIZE = (2 * L_CODES + 1);

	  	var END_BLOCK = 256;

	  	// Bit length codes must not exceed MAX_BL_BITS bits
	  	var MAX_BL_BITS = 7;

	  	// repeat previous bit length 3-6 times (2 bits of repeat count)
	  	var REP_3_6 = 16;

	  	// repeat a zero length 3-10 times (3 bits of repeat count)
	  	var REPZ_3_10 = 17;

	  	// repeat a zero length 11-138 times (7 bits of repeat count)
	  	var REPZ_11_138 = 18;

	  	// The lengths of the bit length codes are sent in order of decreasing
	  	// probability, to avoid transmitting the lengths for unused bit
	  	// length codes.

	  	var Buf_size = 8 * 2;

	  	// JZlib version : "1.0.2"
	  	var Z_DEFAULT_COMPRESSION = -1;

	  	// compression strategy
	  	var Z_FILTERED = 1;
	  	var Z_HUFFMAN_ONLY = 2;
	  	var Z_DEFAULT_STRATEGY = 0;

	  	var Z_NO_FLUSH = 0;
	  	var Z_PARTIAL_FLUSH = 1;
	  	var Z_FULL_FLUSH = 3;
	  	var Z_FINISH = 4;

	  	var Z_OK = 0;
	  	var Z_STREAM_END = 1;
	  	var Z_NEED_DICT = 2;
	  	var Z_STREAM_ERROR = -2;
	  	var Z_DATA_ERROR = -3;
	  	var Z_BUF_ERROR = -5;

	  	// Tree

	  	// see definition of array dist_code below
	  	var _dist_code = [ 0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10,
	  			10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
	  			12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
	  			13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
	  			14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
	  			14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
	  			15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19,
	  			20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	  			24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
	  			26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
	  			27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
	  			28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29,
	  			29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
	  			29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29 ];

	  	function Tree() {
	  		var that = this;

	  		// dyn_tree; // the dynamic tree
	  		// max_code; // largest code with non zero frequency
	  		// stat_desc; // the corresponding static tree

	  		// Compute the optimal bit lengths for a tree and update the total bit
	  		// length
	  		// for the current block.
	  		// IN assertion: the fields freq and dad are set, heap[heap_max] and
	  		// above are the tree nodes sorted by increasing frequency.
	  		// OUT assertions: the field len is set to the optimal bit length, the
	  		// array bl_count contains the frequencies for each bit length.
	  		// The length opt_len is updated; static_len is also updated if stree is
	  		// not null.
	  		function gen_bitlen(s) {
	  			var tree = that.dyn_tree;
	  			var stree = that.stat_desc.static_tree;
	  			var extra = that.stat_desc.extra_bits;
	  			var base = that.stat_desc.extra_base;
	  			var max_length = that.stat_desc.max_length;
	  			var h; // heap index
	  			var n, m; // iterate over the tree elements
	  			var bits; // bit length
	  			var xbits; // extra bits
	  			var f; // frequency
	  			var overflow = 0; // number of elements with bit length too large

	  			for (bits = 0; bits <= MAX_BITS; bits++)
	  				s.bl_count[bits] = 0;

	  			// In a first pass, compute the optimal bit lengths (which may
	  			// overflow in the case of the bit length tree).
	  			tree[s.heap[s.heap_max] * 2 + 1] = 0; // root of the heap

	  			for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
	  				n = s.heap[h];
	  				bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
	  				if (bits > max_length) {
	  					bits = max_length;
	  					overflow++;
	  				}
	  				tree[n * 2 + 1] = bits;
	  				// We overwrite tree[n*2+1] which is no longer needed

	  				if (n > that.max_code)
	  					continue; // not a leaf node

	  				s.bl_count[bits]++;
	  				xbits = 0;
	  				if (n >= base)
	  					xbits = extra[n - base];
	  				f = tree[n * 2];
	  				s.opt_len += f * (bits + xbits);
	  				if (stree)
	  					s.static_len += f * (stree[n * 2 + 1] + xbits);
	  			}
	  			if (overflow === 0)
	  				return;

	  			// This happens for example on obj2 and pic of the Calgary corpus
	  			// Find the first bit length which could increase:
	  			do {
	  				bits = max_length - 1;
	  				while (s.bl_count[bits] === 0)
	  					bits--;
	  				s.bl_count[bits]--; // move one leaf down the tree
	  				s.bl_count[bits + 1] += 2; // move one overflow item as its brother
	  				s.bl_count[max_length]--;
	  				// The brother of the overflow item also moves one step up,
	  				// but this does not affect bl_count[max_length]
	  				overflow -= 2;
	  			} while (overflow > 0);

	  			for (bits = max_length; bits !== 0; bits--) {
	  				n = s.bl_count[bits];
	  				while (n !== 0) {
	  					m = s.heap[--h];
	  					if (m > that.max_code)
	  						continue;
	  					if (tree[m * 2 + 1] != bits) {
	  						s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
	  						tree[m * 2 + 1] = bits;
	  					}
	  					n--;
	  				}
	  			}
	  		}

	  		// Reverse the first len bits of a code, using straightforward code (a
	  		// faster
	  		// method would use a table)
	  		// IN assertion: 1 <= len <= 15
	  		function bi_reverse(code, // the value to invert
	  		len // its bit length
	  		) {
	  			var res = 0;
	  			do {
	  				res |= code & 1;
	  				code >>>= 1;
	  				res <<= 1;
	  			} while (--len > 0);
	  			return res >>> 1;
	  		}

	  		// Generate the codes for a given tree and bit counts (which need not be
	  		// optimal).
	  		// IN assertion: the array bl_count contains the bit length statistics for
	  		// the given tree and the field len is set for all tree elements.
	  		// OUT assertion: the field code is set for all tree elements of non
	  		// zero code length.
	  		function gen_codes(tree, // the tree to decorate
	  		max_code, // largest code with non zero frequency
	  		bl_count // number of codes at each bit length
	  		) {
	  			var next_code = []; // next code value for each
	  			// bit length
	  			var code = 0; // running code value
	  			var bits; // bit index
	  			var n; // code index
	  			var len;

	  			// The distribution counts are first used to generate the code values
	  			// without bit reversal.
	  			for (bits = 1; bits <= MAX_BITS; bits++) {
	  				next_code[bits] = code = ((code + bl_count[bits - 1]) << 1);
	  			}

	  			// Check that the bit counts in bl_count are consistent. The last code
	  			// must be all ones.
	  			// Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
	  			// "inconsistent bit counts");
	  			// Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

	  			for (n = 0; n <= max_code; n++) {
	  				len = tree[n * 2 + 1];
	  				if (len === 0)
	  					continue;
	  				// Now reverse the bits
	  				tree[n * 2] = bi_reverse(next_code[len]++, len);
	  			}
	  		}

	  		// Construct one Huffman tree and assigns the code bit strings and lengths.
	  		// Update the total bit length for the current block.
	  		// IN assertion: the field freq is set for all tree elements.
	  		// OUT assertions: the fields len and code are set to the optimal bit length
	  		// and corresponding code. The length opt_len is updated; static_len is
	  		// also updated if stree is not null. The field max_code is set.
	  		that.build_tree = function(s) {
	  			var tree = that.dyn_tree;
	  			var stree = that.stat_desc.static_tree;
	  			var elems = that.stat_desc.elems;
	  			var n, m; // iterate over heap elements
	  			var max_code = -1; // largest code with non zero frequency
	  			var node; // new node being created

	  			// Construct the initial heap, with least frequent element in
	  			// heap[1]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
	  			// heap[0] is not used.
	  			s.heap_len = 0;
	  			s.heap_max = HEAP_SIZE;

	  			for (n = 0; n < elems; n++) {
	  				if (tree[n * 2] !== 0) {
	  					s.heap[++s.heap_len] = max_code = n;
	  					s.depth[n] = 0;
	  				} else {
	  					tree[n * 2 + 1] = 0;
	  				}
	  			}

	  			// The pkzip format requires that at least one distance code exists,
	  			// and that at least one bit should be sent even if there is only one
	  			// possible code. So to avoid special checks later on we force at least
	  			// two codes of non zero frequency.
	  			while (s.heap_len < 2) {
	  				node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
	  				tree[node * 2] = 1;
	  				s.depth[node] = 0;
	  				s.opt_len--;
	  				if (stree)
	  					s.static_len -= stree[node * 2 + 1];
	  				// node is 0 or 1 so it does not have extra bits
	  			}
	  			that.max_code = max_code;

	  			// The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
	  			// establish sub-heaps of increasing lengths:

	  			for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
	  				s.pqdownheap(tree, n);

	  			// Construct the Huffman tree by repeatedly combining the least two
	  			// frequent nodes.

	  			node = elems; // next internal node of the tree
	  			do {
	  				// n = node of least frequency
	  				n = s.heap[1];
	  				s.heap[1] = s.heap[s.heap_len--];
	  				s.pqdownheap(tree, 1);
	  				m = s.heap[1]; // m = node of next least frequency

	  				s.heap[--s.heap_max] = n; // keep the nodes sorted by frequency
	  				s.heap[--s.heap_max] = m;

	  				// Create a new node father of n and m
	  				tree[node * 2] = (tree[n * 2] + tree[m * 2]);
	  				s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
	  				tree[n * 2 + 1] = tree[m * 2 + 1] = node;

	  				// and insert the new node in the heap
	  				s.heap[1] = node++;
	  				s.pqdownheap(tree, 1);
	  			} while (s.heap_len >= 2);

	  			s.heap[--s.heap_max] = s.heap[1];

	  			// At this point, the fields freq and dad are set. We can now
	  			// generate the bit lengths.

	  			gen_bitlen(s);

	  			// The field len is now set, we can generate the bit codes
	  			gen_codes(tree, that.max_code, s.bl_count);
	  		};

	  	}

	  	Tree._length_code = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16,
	  			16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20,
	  			20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
	  			22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
	  			24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
	  			25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
	  			26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28 ];

	  	Tree.base_length = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0 ];

	  	Tree.base_dist = [ 0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384,
	  			24576 ];

	  	// Mapping from a distance to a distance code. dist is the distance - 1 and
	  	// must not have side effects. _dist_code[256] and _dist_code[257] are never
	  	// used.
	  	Tree.d_code = function(dist) {
	  		return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + ((dist) >>> 7)]);
	  	};

	  	// extra bits for each length code
	  	Tree.extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ];

	  	// extra bits for each distance code
	  	Tree.extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];

	  	// extra bits for each bit length code
	  	Tree.extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ];

	  	Tree.bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];

	  	// StaticTree

	  	function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
	  		var that = this;
	  		that.static_tree = static_tree;
	  		that.extra_bits = extra_bits;
	  		that.extra_base = extra_base;
	  		that.elems = elems;
	  		that.max_length = max_length;
	  	}

	  	StaticTree.static_ltree = [ 12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 188, 8, 124, 8, 252, 8, 2, 8,
	  			130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42,
	  			8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8,
	  			22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8,
	  			222, 8, 62, 8, 190, 8, 126, 8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113,
	  			8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8,
	  			69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8,
	  			173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9,
	  			51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9,
	  			427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379,
	  			9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23,
	  			9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9,
	  			399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9,
	  			223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7,
	  			40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8,
	  			99, 8, 227, 8 ];

	  	StaticTree.static_dtree = [ 0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5,
	  			25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5 ];

	  	StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);

	  	StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);

	  	StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);

	  	// Deflate

	  	var MAX_MEM_LEVEL = 9;
	  	var DEF_MEM_LEVEL = 8;

	  	function Config(good_length, max_lazy, nice_length, max_chain, func) {
	  		var that = this;
	  		that.good_length = good_length;
	  		that.max_lazy = max_lazy;
	  		that.nice_length = nice_length;
	  		that.max_chain = max_chain;
	  		that.func = func;
	  	}

	  	var STORED = 0;
	  	var FAST = 1;
	  	var SLOW = 2;
	  	var config_table = [ new Config(0, 0, 0, 0, STORED), new Config(4, 4, 8, 4, FAST), new Config(4, 5, 16, 8, FAST), new Config(4, 6, 32, 32, FAST),
	  			new Config(4, 4, 16, 16, SLOW), new Config(8, 16, 32, 32, SLOW), new Config(8, 16, 128, 128, SLOW), new Config(8, 32, 128, 256, SLOW),
	  			new Config(32, 128, 258, 1024, SLOW), new Config(32, 258, 258, 4096, SLOW) ];

	  	var z_errmsg = [ "need dictionary", // Z_NEED_DICT
	  	// 2
	  	"stream end", // Z_STREAM_END 1
	  	"", // Z_OK 0
	  	"", // Z_ERRNO (-1)
	  	"stream error", // Z_STREAM_ERROR (-2)
	  	"data error", // Z_DATA_ERROR (-3)
	  	"", // Z_MEM_ERROR (-4)
	  	"buffer error", // Z_BUF_ERROR (-5)
	  	"",// Z_VERSION_ERROR (-6)
	  	"" ];

	  	// block not completed, need more input or more output
	  	var NeedMore = 0;

	  	// block flush performed
	  	var BlockDone = 1;

	  	// finish started, need only more output at next deflate
	  	var FinishStarted = 2;

	  	// finish done, accept no more input or output
	  	var FinishDone = 3;

	  	// preset dictionary flag in zlib header
	  	var PRESET_DICT = 0x20;

	  	var INIT_STATE = 42;
	  	var BUSY_STATE = 113;
	  	var FINISH_STATE = 666;

	  	// The deflate compression method
	  	var Z_DEFLATED = 8;

	  	var STORED_BLOCK = 0;
	  	var STATIC_TREES = 1;
	  	var DYN_TREES = 2;

	  	var MIN_MATCH = 3;
	  	var MAX_MATCH = 258;
	  	var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

	  	function smaller(tree, n, m, depth) {
	  		var tn2 = tree[n * 2];
	  		var tm2 = tree[m * 2];
	  		return (tn2 < tm2 || (tn2 == tm2 && depth[n] <= depth[m]));
	  	}

	  	function Deflate() {

	  		var that = this;
	  		var strm; // pointer back to this zlib stream
	  		var status; // as the name implies
	  		// pending_buf; // output still pending
	  		var pending_buf_size; // size of pending_buf
	  		var last_flush; // value of flush param for previous deflate call

	  		var w_size; // LZ77 window size (32K by default)
	  		var w_bits; // log2(w_size) (8..16)
	  		var w_mask; // w_size - 1

	  		var window;
	  		// Sliding window. Input bytes are read into the second half of the window,
	  		// and move to the first half later to keep a dictionary of at least wSize
	  		// bytes. With this organization, matches are limited to a distance of
	  		// wSize-MAX_MATCH bytes, but this ensures that IO is always
	  		// performed with a length multiple of the block size. Also, it limits
	  		// the window size to 64K, which is quite useful on MSDOS.
	  		// To do: use the user input buffer as sliding window.

	  		var window_size;
	  		// Actual size of window: 2*wSize, except when the user input buffer
	  		// is directly used as sliding window.

	  		var prev;
	  		// Link to older string with same hash index. To limit the size of this
	  		// array to 64K, this link is maintained only for the last 32K strings.
	  		// An index in this array is thus a window index modulo 32K.

	  		var head; // Heads of the hash chains or NIL.

	  		var ins_h; // hash index of string to be inserted
	  		var hash_size; // number of elements in hash table
	  		var hash_bits; // log2(hash_size)
	  		var hash_mask; // hash_size-1

	  		// Number of bits by which ins_h must be shifted at each input
	  		// step. It must be such that after MIN_MATCH steps, the oldest
	  		// byte no longer takes part in the hash key, that is:
	  		// hash_shift * MIN_MATCH >= hash_bits
	  		var hash_shift;

	  		// Window position at the beginning of the current output block. Gets
	  		// negative when the window is moved backwards.

	  		var block_start;

	  		var match_length; // length of best match
	  		var prev_match; // previous match
	  		var match_available; // set if previous match exists
	  		var strstart; // start of string to insert
	  		var match_start; // start of matching string
	  		var lookahead; // number of valid bytes ahead in window

	  		// Length of the best match at previous step. Matches not greater than this
	  		// are discarded. This is used in the lazy match evaluation.
	  		var prev_length;

	  		// To speed up deflation, hash chains are never searched beyond this
	  		// length. A higher limit improves compression ratio but degrades the speed.
	  		var max_chain_length;

	  		// Attempt to find a better match only when the current match is strictly
	  		// smaller than this value. This mechanism is used only for compression
	  		// levels >= 4.
	  		var max_lazy_match;

	  		// Insert new strings in the hash table only if the match length is not
	  		// greater than this length. This saves time but degrades compression.
	  		// max_insert_length is used only for compression levels <= 3.

	  		var level; // compression level (1..9)
	  		var strategy; // favor or force Huffman coding

	  		// Use a faster search when the previous match is longer than this
	  		var good_match;

	  		// Stop searching when current match exceeds this
	  		var nice_match;

	  		var dyn_ltree; // literal and length tree
	  		var dyn_dtree; // distance tree
	  		var bl_tree; // Huffman tree for bit lengths

	  		var l_desc = new Tree(); // desc for literal tree
	  		var d_desc = new Tree(); // desc for distance tree
	  		var bl_desc = new Tree(); // desc for bit length tree

	  		// that.heap_len; // number of elements in the heap
	  		// that.heap_max; // element of largest frequency
	  		// The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
	  		// The same heap array is used to build all trees.

	  		// Depth of each subtree used as tie breaker for trees of equal frequency
	  		that.depth = [];

	  		var l_buf; // index for literals or lengths */

	  		// Size of match buffer for literals/lengths. There are 4 reasons for
	  		// limiting lit_bufsize to 64K:
	  		// - frequencies can be kept in 16 bit counters
	  		// - if compression is not successful for the first block, all input
	  		// data is still in the window so we can still emit a stored block even
	  		// when input comes from standard input. (This can also be done for
	  		// all blocks if lit_bufsize is not greater than 32K.)
	  		// - if compression is not successful for a file smaller than 64K, we can
	  		// even emit a stored file instead of a stored block (saving 5 bytes).
	  		// This is applicable only for zip (not gzip or zlib).
	  		// - creating new Huffman trees less frequently may not provide fast
	  		// adaptation to changes in the input data statistics. (Take for
	  		// example a binary file with poorly compressible code followed by
	  		// a highly compressible string table.) Smaller buffer sizes give
	  		// fast adaptation but have of course the overhead of transmitting
	  		// trees more frequently.
	  		// - I can't count above 4
	  		var lit_bufsize;

	  		var last_lit; // running index in l_buf

	  		// Buffer for distances. To simplify the code, d_buf and l_buf have
	  		// the same number of elements. To use different lengths, an extra flag
	  		// array would be necessary.

	  		var d_buf; // index of pendig_buf

	  		// that.opt_len; // bit length of current block with optimal trees
	  		// that.static_len; // bit length of current block with static trees
	  		var matches; // number of string matches in current block
	  		var last_eob_len; // bit length of EOB code for last block

	  		// Output buffer. bits are inserted starting at the bottom (least
	  		// significant bits).
	  		var bi_buf;

	  		// Number of valid bits in bi_buf. All bits above the last valid bit
	  		// are always zero.
	  		var bi_valid;

	  		// number of codes at each bit length for an optimal tree
	  		that.bl_count = [];

	  		// heap used to build the Huffman trees
	  		that.heap = [];

	  		dyn_ltree = [];
	  		dyn_dtree = [];
	  		bl_tree = [];

	  		function lm_init() {
	  			var i;
	  			window_size = 2 * w_size;

	  			head[hash_size - 1] = 0;
	  			for (i = 0; i < hash_size - 1; i++) {
	  				head[i] = 0;
	  			}

	  			// Set the default configuration parameters:
	  			max_lazy_match = config_table[level].max_lazy;
	  			good_match = config_table[level].good_length;
	  			nice_match = config_table[level].nice_length;
	  			max_chain_length = config_table[level].max_chain;

	  			strstart = 0;
	  			block_start = 0;
	  			lookahead = 0;
	  			match_length = prev_length = MIN_MATCH - 1;
	  			match_available = 0;
	  			ins_h = 0;
	  		}

	  		function init_block() {
	  			var i;
	  			// Initialize the trees.
	  			for (i = 0; i < L_CODES; i++)
	  				dyn_ltree[i * 2] = 0;
	  			for (i = 0; i < D_CODES; i++)
	  				dyn_dtree[i * 2] = 0;
	  			for (i = 0; i < BL_CODES; i++)
	  				bl_tree[i * 2] = 0;

	  			dyn_ltree[END_BLOCK * 2] = 1;
	  			that.opt_len = that.static_len = 0;
	  			last_lit = matches = 0;
	  		}

	  		// Initialize the tree data structures for a new zlib stream.
	  		function tr_init() {

	  			l_desc.dyn_tree = dyn_ltree;
	  			l_desc.stat_desc = StaticTree.static_l_desc;

	  			d_desc.dyn_tree = dyn_dtree;
	  			d_desc.stat_desc = StaticTree.static_d_desc;

	  			bl_desc.dyn_tree = bl_tree;
	  			bl_desc.stat_desc = StaticTree.static_bl_desc;

	  			bi_buf = 0;
	  			bi_valid = 0;
	  			last_eob_len = 8; // enough lookahead for inflate

	  			// Initialize the first block of the first file:
	  			init_block();
	  		}

	  		// Restore the heap property by moving down the tree starting at node k,
	  		// exchanging a node with the smallest of its two sons if necessary,
	  		// stopping
	  		// when the heap property is re-established (each father smaller than its
	  		// two sons).
	  		that.pqdownheap = function(tree, // the tree to restore
	  		k // node to move down
	  		) {
	  			var heap = that.heap;
	  			var v = heap[k];
	  			var j = k << 1; // left son of k
	  			while (j <= that.heap_len) {
	  				// Set j to the smallest of the two sons:
	  				if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
	  					j++;
	  				}
	  				// Exit if v is smaller than both sons
	  				if (smaller(tree, v, heap[j], that.depth))
	  					break;

	  				// Exchange v with the smallest son
	  				heap[k] = heap[j];
	  				k = j;
	  				// And continue down the tree, setting j to the left son of k
	  				j <<= 1;
	  			}
	  			heap[k] = v;
	  		};

	  		// Scan a literal or distance tree to determine the frequencies of the codes
	  		// in the bit length tree.
	  		function scan_tree(tree,// the tree to be scanned
	  		max_code // and its largest code of non zero frequency
	  		) {
	  			var n; // iterates over all tree elements
	  			var prevlen = -1; // last emitted length
	  			var curlen; // length of current code
	  			var nextlen = tree[0 * 2 + 1]; // length of next code
	  			var count = 0; // repeat count of the current code
	  			var max_count = 7; // max repeat count
	  			var min_count = 4; // min repeat count

	  			if (nextlen === 0) {
	  				max_count = 138;
	  				min_count = 3;
	  			}
	  			tree[(max_code + 1) * 2 + 1] = 0xffff; // guard

	  			for (n = 0; n <= max_code; n++) {
	  				curlen = nextlen;
	  				nextlen = tree[(n + 1) * 2 + 1];
	  				if (++count < max_count && curlen == nextlen) {
	  					continue;
	  				} else if (count < min_count) {
	  					bl_tree[curlen * 2] += count;
	  				} else if (curlen !== 0) {
	  					if (curlen != prevlen)
	  						bl_tree[curlen * 2]++;
	  					bl_tree[REP_3_6 * 2]++;
	  				} else if (count <= 10) {
	  					bl_tree[REPZ_3_10 * 2]++;
	  				} else {
	  					bl_tree[REPZ_11_138 * 2]++;
	  				}
	  				count = 0;
	  				prevlen = curlen;
	  				if (nextlen === 0) {
	  					max_count = 138;
	  					min_count = 3;
	  				} else if (curlen == nextlen) {
	  					max_count = 6;
	  					min_count = 3;
	  				} else {
	  					max_count = 7;
	  					min_count = 4;
	  				}
	  			}
	  		}

	  		// Construct the Huffman tree for the bit lengths and return the index in
	  		// bl_order of the last bit length code to send.
	  		function build_bl_tree() {
	  			var max_blindex; // index of last bit length code of non zero freq

	  			// Determine the bit length frequencies for literal and distance trees
	  			scan_tree(dyn_ltree, l_desc.max_code);
	  			scan_tree(dyn_dtree, d_desc.max_code);

	  			// Build the bit length tree:
	  			bl_desc.build_tree(that);
	  			// opt_len now includes the length of the tree representations, except
	  			// the lengths of the bit lengths codes and the 5+5+4 bits for the
	  			// counts.

	  			// Determine the number of bit length codes to send. The pkzip format
	  			// requires that at least 4 bit length codes be sent. (appnote.txt says
	  			// 3 but the actual value used is 4.)
	  			for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
	  				if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
	  					break;
	  			}
	  			// Update opt_len to include the bit length tree and counts
	  			that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;

	  			return max_blindex;
	  		}

	  		// Output a byte on the stream.
	  		// IN assertion: there is enough room in pending_buf.
	  		function put_byte(p) {
	  			that.pending_buf[that.pending++] = p;
	  		}

	  		function put_short(w) {
	  			put_byte(w & 0xff);
	  			put_byte((w >>> 8) & 0xff);
	  		}

	  		function putShortMSB(b) {
	  			put_byte((b >> 8) & 0xff);
	  			put_byte((b & 0xff) & 0xff);
	  		}

	  		function send_bits(value, length) {
	  			var val, len = length;
	  			if (bi_valid > Buf_size - len) {
	  				val = value;
	  				// bi_buf |= (val << bi_valid);
	  				bi_buf |= ((val << bi_valid) & 0xffff);
	  				put_short(bi_buf);
	  				bi_buf = val >>> (Buf_size - bi_valid);
	  				bi_valid += len - Buf_size;
	  			} else {
	  				// bi_buf |= (value) << bi_valid;
	  				bi_buf |= (((value) << bi_valid) & 0xffff);
	  				bi_valid += len;
	  			}
	  		}

	  		function send_code(c, tree) {
	  			var c2 = c * 2;
	  			send_bits(tree[c2] & 0xffff, tree[c2 + 1] & 0xffff);
	  		}

	  		// Send a literal or distance tree in compressed form, using the codes in
	  		// bl_tree.
	  		function send_tree(tree,// the tree to be sent
	  		max_code // and its largest code of non zero frequency
	  		) {
	  			var n; // iterates over all tree elements
	  			var prevlen = -1; // last emitted length
	  			var curlen; // length of current code
	  			var nextlen = tree[0 * 2 + 1]; // length of next code
	  			var count = 0; // repeat count of the current code
	  			var max_count = 7; // max repeat count
	  			var min_count = 4; // min repeat count

	  			if (nextlen === 0) {
	  				max_count = 138;
	  				min_count = 3;
	  			}

	  			for (n = 0; n <= max_code; n++) {
	  				curlen = nextlen;
	  				nextlen = tree[(n + 1) * 2 + 1];
	  				if (++count < max_count && curlen == nextlen) {
	  					continue;
	  				} else if (count < min_count) {
	  					do {
	  						send_code(curlen, bl_tree);
	  					} while (--count !== 0);
	  				} else if (curlen !== 0) {
	  					if (curlen != prevlen) {
	  						send_code(curlen, bl_tree);
	  						count--;
	  					}
	  					send_code(REP_3_6, bl_tree);
	  					send_bits(count - 3, 2);
	  				} else if (count <= 10) {
	  					send_code(REPZ_3_10, bl_tree);
	  					send_bits(count - 3, 3);
	  				} else {
	  					send_code(REPZ_11_138, bl_tree);
	  					send_bits(count - 11, 7);
	  				}
	  				count = 0;
	  				prevlen = curlen;
	  				if (nextlen === 0) {
	  					max_count = 138;
	  					min_count = 3;
	  				} else if (curlen == nextlen) {
	  					max_count = 6;
	  					min_count = 3;
	  				} else {
	  					max_count = 7;
	  					min_count = 4;
	  				}
	  			}
	  		}

	  		// Send the header for a block using dynamic Huffman trees: the counts, the
	  		// lengths of the bit length codes, the literal tree and the distance tree.
	  		// IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
	  		function send_all_trees(lcodes, dcodes, blcodes) {
	  			var rank; // index in bl_order

	  			send_bits(lcodes - 257, 5); // not +255 as stated in appnote.txt
	  			send_bits(dcodes - 1, 5);
	  			send_bits(blcodes - 4, 4); // not -3 as stated in appnote.txt
	  			for (rank = 0; rank < blcodes; rank++) {
	  				send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
	  			}
	  			send_tree(dyn_ltree, lcodes - 1); // literal tree
	  			send_tree(dyn_dtree, dcodes - 1); // distance tree
	  		}

	  		// Flush the bit buffer, keeping at most 7 bits in it.
	  		function bi_flush() {
	  			if (bi_valid == 16) {
	  				put_short(bi_buf);
	  				bi_buf = 0;
	  				bi_valid = 0;
	  			} else if (bi_valid >= 8) {
	  				put_byte(bi_buf & 0xff);
	  				bi_buf >>>= 8;
	  				bi_valid -= 8;
	  			}
	  		}

	  		// Send one empty static block to give enough lookahead for inflate.
	  		// This takes 10 bits, of which 7 may remain in the bit buffer.
	  		// The current inflate code requires 9 bits of lookahead. If the
	  		// last two codes for the previous block (real code plus EOB) were coded
	  		// on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
	  		// the last real code. In this case we send two empty static blocks instead
	  		// of one. (There are no problems if the previous block is stored or fixed.)
	  		// To simplify the code, we assume the worst case of last real code encoded
	  		// on one bit only.
	  		function _tr_align() {
	  			send_bits(STATIC_TREES << 1, 3);
	  			send_code(END_BLOCK, StaticTree.static_ltree);

	  			bi_flush();

	  			// Of the 10 bits for the empty block, we have already sent
	  			// (10 - bi_valid) bits. The lookahead for the last real code (before
	  			// the EOB of the previous block) was thus at least one plus the length
	  			// of the EOB plus what we have just sent of the empty static block.
	  			if (1 + last_eob_len + 10 - bi_valid < 9) {
	  				send_bits(STATIC_TREES << 1, 3);
	  				send_code(END_BLOCK, StaticTree.static_ltree);
	  				bi_flush();
	  			}
	  			last_eob_len = 7;
	  		}

	  		// Save the match info and tally the frequency counts. Return true if
	  		// the current block must be flushed.
	  		function _tr_tally(dist, // distance of matched string
	  		lc // match length-MIN_MATCH or unmatched char (if dist==0)
	  		) {
	  			var out_length, in_length, dcode;
	  			that.pending_buf[d_buf + last_lit * 2] = (dist >>> 8) & 0xff;
	  			that.pending_buf[d_buf + last_lit * 2 + 1] = dist & 0xff;

	  			that.pending_buf[l_buf + last_lit] = lc & 0xff;
	  			last_lit++;

	  			if (dist === 0) {
	  				// lc is the unmatched char
	  				dyn_ltree[lc * 2]++;
	  			} else {
	  				matches++;
	  				// Here, lc is the match length - MIN_MATCH
	  				dist--; // dist = match distance - 1
	  				dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;
	  				dyn_dtree[Tree.d_code(dist) * 2]++;
	  			}

	  			if ((last_lit & 0x1fff) === 0 && level > 2) {
	  				// Compute an upper bound for the compressed length
	  				out_length = last_lit * 8;
	  				in_length = strstart - block_start;
	  				for (dcode = 0; dcode < D_CODES; dcode++) {
	  					out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
	  				}
	  				out_length >>>= 3;
	  				if ((matches < Math.floor(last_lit / 2)) && out_length < Math.floor(in_length / 2))
	  					return true;
	  			}

	  			return (last_lit == lit_bufsize - 1);
	  			// We avoid equality with lit_bufsize because of wraparound at 64K
	  			// on 16 bit machines and because stored blocks are restricted to
	  			// 64K-1 bytes.
	  		}

	  		// Send the block data compressed using the given Huffman trees
	  		function compress_block(ltree, dtree) {
	  			var dist; // distance of matched string
	  			var lc; // match length or unmatched char (if dist === 0)
	  			var lx = 0; // running index in l_buf
	  			var code; // the code to send
	  			var extra; // number of extra bits to send

	  			if (last_lit !== 0) {
	  				do {
	  					dist = ((that.pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (that.pending_buf[d_buf + lx * 2 + 1] & 0xff);
	  					lc = (that.pending_buf[l_buf + lx]) & 0xff;
	  					lx++;

	  					if (dist === 0) {
	  						send_code(lc, ltree); // send a literal byte
	  					} else {
	  						// Here, lc is the match length - MIN_MATCH
	  						code = Tree._length_code[lc];

	  						send_code(code + LITERALS + 1, ltree); // send the length
	  						// code
	  						extra = Tree.extra_lbits[code];
	  						if (extra !== 0) {
	  							lc -= Tree.base_length[code];
	  							send_bits(lc, extra); // send the extra length bits
	  						}
	  						dist--; // dist is now the match distance - 1
	  						code = Tree.d_code(dist);

	  						send_code(code, dtree); // send the distance code
	  						extra = Tree.extra_dbits[code];
	  						if (extra !== 0) {
	  							dist -= Tree.base_dist[code];
	  							send_bits(dist, extra); // send the extra distance bits
	  						}
	  					} // literal or match pair ?

	  					// Check that the overlay between pending_buf and d_buf+l_buf is
	  					// ok:
	  				} while (lx < last_lit);
	  			}

	  			send_code(END_BLOCK, ltree);
	  			last_eob_len = ltree[END_BLOCK * 2 + 1];
	  		}

	  		// Flush the bit buffer and align the output on a byte boundary
	  		function bi_windup() {
	  			if (bi_valid > 8) {
	  				put_short(bi_buf);
	  			} else if (bi_valid > 0) {
	  				put_byte(bi_buf & 0xff);
	  			}
	  			bi_buf = 0;
	  			bi_valid = 0;
	  		}

	  		// Copy a stored block, storing first the length and its
	  		// one's complement if requested.
	  		function copy_block(buf, // the input data
	  		len, // its length
	  		header // true if block header must be written
	  		) {
	  			bi_windup(); // align on byte boundary
	  			last_eob_len = 8; // enough lookahead for inflate

	  			if (header) {
	  				put_short(len);
	  				put_short(~len);
	  			}

	  			that.pending_buf.set(window.subarray(buf, buf + len), that.pending);
	  			that.pending += len;
	  		}

	  		// Send a stored block
	  		function _tr_stored_block(buf, // input block
	  		stored_len, // length of input block
	  		eof // true if this is the last block for a file
	  		) {
	  			send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3); // send block type
	  			copy_block(buf, stored_len, true); // with header
	  		}

	  		// Determine the best encoding for the current block: dynamic trees, static
	  		// trees or store, and output the encoded block to the zip file.
	  		function _tr_flush_block(buf, // input block, or NULL if too old
	  		stored_len, // length of input block
	  		eof // true if this is the last block for a file
	  		) {
	  			var opt_lenb, static_lenb;// opt_len and static_len in bytes
	  			var max_blindex = 0; // index of last bit length code of non zero freq

	  			// Build the Huffman trees unless a stored block is forced
	  			if (level > 0) {
	  				// Construct the literal and distance trees
	  				l_desc.build_tree(that);

	  				d_desc.build_tree(that);

	  				// At this point, opt_len and static_len are the total bit lengths
	  				// of
	  				// the compressed block data, excluding the tree representations.

	  				// Build the bit length tree for the above two trees, and get the
	  				// index
	  				// in bl_order of the last bit length code to send.
	  				max_blindex = build_bl_tree();

	  				// Determine the best encoding. Compute first the block length in
	  				// bytes
	  				opt_lenb = (that.opt_len + 3 + 7) >>> 3;
	  				static_lenb = (that.static_len + 3 + 7) >>> 3;

	  				if (static_lenb <= opt_lenb)
	  					opt_lenb = static_lenb;
	  			} else {
	  				opt_lenb = static_lenb = stored_len + 5; // force a stored block
	  			}

	  			if ((stored_len + 4 <= opt_lenb) && buf != -1) {
	  				// 4: two words for the lengths
	  				// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
	  				// Otherwise we can't have processed more than WSIZE input bytes
	  				// since
	  				// the last block flush, because compression would have been
	  				// successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
	  				// transform a block into a stored block.
	  				_tr_stored_block(buf, stored_len, eof);
	  			} else if (static_lenb == opt_lenb) {
	  				send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
	  				compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
	  			} else {
	  				send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
	  				send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
	  				compress_block(dyn_ltree, dyn_dtree);
	  			}

	  			// The above check is made mod 2^32, for files larger than 512 MB
	  			// and uLong implemented on 32 bits.

	  			init_block();

	  			if (eof) {
	  				bi_windup();
	  			}
	  		}

	  		function flush_block_only(eof) {
	  			_tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
	  			block_start = strstart;
	  			strm.flush_pending();
	  		}

	  		// Fill the window when the lookahead becomes insufficient.
	  		// Updates strstart and lookahead.
	  		//
	  		// IN assertion: lookahead < MIN_LOOKAHEAD
	  		// OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
	  		// At least one byte has been read, or avail_in === 0; reads are
	  		// performed for at least two bytes (required for the zip translate_eol
	  		// option -- not supported here).
	  		function fill_window() {
	  			var n, m;
	  			var p;
	  			var more; // Amount of free space at the end of the window.

	  			do {
	  				more = (window_size - lookahead - strstart);

	  				// Deal with !@#$% 64K limit:
	  				if (more === 0 && strstart === 0 && lookahead === 0) {
	  					more = w_size;
	  				} else if (more == -1) {
	  					// Very unlikely, but possible on 16 bit machine if strstart ==
	  					// 0
	  					// and lookahead == 1 (input done one byte at time)
	  					more--;

	  					// If the window is almost full and there is insufficient
	  					// lookahead,
	  					// move the upper half to the lower one to make room in the
	  					// upper half.
	  				} else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
	  					window.set(window.subarray(w_size, w_size + w_size), 0);

	  					match_start -= w_size;
	  					strstart -= w_size; // we now have strstart >= MAX_DIST
	  					block_start -= w_size;

	  					// Slide the hash table (could be avoided with 32 bit values
	  					// at the expense of memory usage). We slide even when level ==
	  					// 0
	  					// to keep the hash table consistent if we switch back to level
	  					// > 0
	  					// later. (Using level 0 permanently is not an optimal usage of
	  					// zlib, so we don't care about this pathological case.)

	  					n = hash_size;
	  					p = n;
	  					do {
	  						m = (head[--p] & 0xffff);
	  						head[p] = (m >= w_size ? m - w_size : 0);
	  					} while (--n !== 0);

	  					n = w_size;
	  					p = n;
	  					do {
	  						m = (prev[--p] & 0xffff);
	  						prev[p] = (m >= w_size ? m - w_size : 0);
	  						// If n is not on any hash chain, prev[n] is garbage but
	  						// its value will never be used.
	  					} while (--n !== 0);
	  					more += w_size;
	  				}

	  				if (strm.avail_in === 0)
	  					return;

	  				// If there was no sliding:
	  				// strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
	  				// more == window_size - lookahead - strstart
	  				// => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
	  				// => more >= window_size - 2*WSIZE + 2
	  				// In the BIG_MEM or MMAP case (not yet supported),
	  				// window_size == input_size + MIN_LOOKAHEAD &&
	  				// strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
	  				// Otherwise, window_size == 2*WSIZE so more >= 2.
	  				// If there was sliding, more >= WSIZE. So in all cases, more >= 2.

	  				n = strm.read_buf(window, strstart + lookahead, more);
	  				lookahead += n;

	  				// Initialize the hash value now that we have some input:
	  				if (lookahead >= MIN_MATCH) {
	  					ins_h = window[strstart] & 0xff;
	  					ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;
	  				}
	  				// If the whole input has less than MIN_MATCH bytes, ins_h is
	  				// garbage,
	  				// but this is not important since only literal bytes will be
	  				// emitted.
	  			} while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);
	  		}

	  		// Copy without compression as much as possible from the input stream,
	  		// return
	  		// the current block state.
	  		// This function does not insert new strings in the dictionary since
	  		// uncompressible data is probably not useful. This function is used
	  		// only for the level=0 compression option.
	  		// NOTE: this function should be optimized to avoid extra copying from
	  		// window to pending_buf.
	  		function deflate_stored(flush) {
	  			// Stored blocks are limited to 0xffff bytes, pending_buf is limited
	  			// to pending_buf_size, and each stored block has a 5 byte header:

	  			var max_block_size = 0xffff;
	  			var max_start;

	  			if (max_block_size > pending_buf_size - 5) {
	  				max_block_size = pending_buf_size - 5;
	  			}

	  			// Copy as much as possible from input to output:
	  			while (true) {
	  				// Fill the window as much as possible:
	  				if (lookahead <= 1) {
	  					fill_window();
	  					if (lookahead === 0 && flush == Z_NO_FLUSH)
	  						return NeedMore;
	  					if (lookahead === 0)
	  						break; // flush the current block
	  				}

	  				strstart += lookahead;
	  				lookahead = 0;

	  				// Emit a stored block if pending_buf will be full:
	  				max_start = block_start + max_block_size;
	  				if (strstart === 0 || strstart >= max_start) {
	  					// strstart === 0 is possible when wraparound on 16-bit machine
	  					lookahead = (strstart - max_start);
	  					strstart = max_start;

	  					flush_block_only(false);
	  					if (strm.avail_out === 0)
	  						return NeedMore;

	  				}

	  				// Flush if we may have to slide, otherwise block_start may become
	  				// negative and the data will be gone:
	  				if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
	  					flush_block_only(false);
	  					if (strm.avail_out === 0)
	  						return NeedMore;
	  				}
	  			}

	  			flush_block_only(flush == Z_FINISH);
	  			if (strm.avail_out === 0)
	  				return (flush == Z_FINISH) ? FinishStarted : NeedMore;

	  			return flush == Z_FINISH ? FinishDone : BlockDone;
	  		}

	  		function longest_match(cur_match) {
	  			var chain_length = max_chain_length; // max hash chain length
	  			var scan = strstart; // current string
	  			var match; // matched string
	  			var len; // length of current match
	  			var best_len = prev_length; // best match length so far
	  			var limit = strstart > (w_size - MIN_LOOKAHEAD) ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
	  			var _nice_match = nice_match;

	  			// Stop when cur_match becomes <= limit. To simplify the code,
	  			// we prevent matches with the string of window index 0.

	  			var wmask = w_mask;

	  			var strend = strstart + MAX_MATCH;
	  			var scan_end1 = window[scan + best_len - 1];
	  			var scan_end = window[scan + best_len];

	  			// The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of
	  			// 16.
	  			// It is easy to get rid of this optimization if necessary.

	  			// Do not waste too much time if we already have a good match:
	  			if (prev_length >= good_match) {
	  				chain_length >>= 2;
	  			}

	  			// Do not look for matches beyond the end of the input. This is
	  			// necessary
	  			// to make deflate deterministic.
	  			if (_nice_match > lookahead)
	  				_nice_match = lookahead;

	  			do {
	  				match = cur_match;

	  				// Skip to next match if the match length cannot increase
	  				// or if the match length is less than 2:
	  				if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan]
	  						|| window[++match] != window[scan + 1])
	  					continue;

	  				// The check at best_len-1 can be removed because it will be made
	  				// again later. (This heuristic is not always a win.)
	  				// It is not necessary to compare scan[2] and match[2] since they
	  				// are always equal when the other bytes match, given that
	  				// the hash keys are equal and that HASH_BITS >= 8.
	  				scan += 2;
	  				match++;

	  				// We check for insufficient lookahead only every 8th comparison;
	  				// the 256th check will be made at strstart+258.
	  				do {
	  				} while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]
	  						&& window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match]
	  						&& window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend);

	  				len = MAX_MATCH - (strend - scan);
	  				scan = strend - MAX_MATCH;

	  				if (len > best_len) {
	  					match_start = cur_match;
	  					best_len = len;
	  					if (len >= _nice_match)
	  						break;
	  					scan_end1 = window[scan + best_len - 1];
	  					scan_end = window[scan + best_len];
	  				}

	  			} while ((cur_match = (prev[cur_match & wmask] & 0xffff)) > limit && --chain_length !== 0);

	  			if (best_len <= lookahead)
	  				return best_len;
	  			return lookahead;
	  		}

	  		// Compress as much as possible from the input stream, return the current
	  		// block state.
	  		// This function does not perform lazy evaluation of matches and inserts
	  		// new strings in the dictionary only for unmatched strings or for short
	  		// matches. It is used only for the fast compression options.
	  		function deflate_fast(flush) {
	  			// short hash_head = 0; // head of the hash chain
	  			var hash_head = 0; // head of the hash chain
	  			var bflush; // set if current block must be flushed

	  			while (true) {
	  				// Make sure that we always have enough lookahead, except
	  				// at the end of the input file. We need MAX_MATCH bytes
	  				// for the next match, plus MIN_MATCH bytes to insert the
	  				// string following the next match.
	  				if (lookahead < MIN_LOOKAHEAD) {
	  					fill_window();
	  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	  						return NeedMore;
	  					}
	  					if (lookahead === 0)
	  						break; // flush the current block
	  				}

	  				// Insert the string window[strstart .. strstart+2] in the
	  				// dictionary, and set hash_head to the head of the hash chain:
	  				if (lookahead >= MIN_MATCH) {
	  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;

	  					// prev[strstart&w_mask]=hash_head=head[ins_h];
	  					hash_head = (head[ins_h] & 0xffff);
	  					prev[strstart & w_mask] = head[ins_h];
	  					head[ins_h] = strstart;
	  				}

	  				// Find the longest match, discarding those <= prev_length.
	  				// At this point we have always match_length < MIN_MATCH

	  				if (hash_head !== 0 && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
	  					// To simplify the code, we prevent matches with the string
	  					// of window index 0 (in particular we have to avoid a match
	  					// of the string with itself at the start of the input file).
	  					if (strategy != Z_HUFFMAN_ONLY) {
	  						match_length = longest_match(hash_head);
	  					}
	  					// longest_match() sets match_start
	  				}
	  				if (match_length >= MIN_MATCH) {
	  					// check_match(strstart, match_start, match_length);

	  					bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);

	  					lookahead -= match_length;

	  					// Insert new strings in the hash table only if the match length
	  					// is not too large. This saves time but degrades compression.
	  					if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {
	  						match_length--; // string at strstart already in hash table
	  						do {
	  							strstart++;

	  							ins_h = ((ins_h << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
	  							// prev[strstart&w_mask]=hash_head=head[ins_h];
	  							hash_head = (head[ins_h] & 0xffff);
	  							prev[strstart & w_mask] = head[ins_h];
	  							head[ins_h] = strstart;

	  							// strstart never exceeds WSIZE-MAX_MATCH, so there are
	  							// always MIN_MATCH bytes ahead.
	  						} while (--match_length !== 0);
	  						strstart++;
	  					} else {
	  						strstart += match_length;
	  						match_length = 0;
	  						ins_h = window[strstart] & 0xff;

	  						ins_h = (((ins_h) << hash_shift) ^ (window[strstart + 1] & 0xff)) & hash_mask;
	  						// If lookahead < MIN_MATCH, ins_h is garbage, but it does
	  						// not
	  						// matter since it will be recomputed at next deflate call.
	  					}
	  				} else {
	  					// No match, output a literal byte

	  					bflush = _tr_tally(0, window[strstart] & 0xff);
	  					lookahead--;
	  					strstart++;
	  				}
	  				if (bflush) {

	  					flush_block_only(false);
	  					if (strm.avail_out === 0)
	  						return NeedMore;
	  				}
	  			}

	  			flush_block_only(flush == Z_FINISH);
	  			if (strm.avail_out === 0) {
	  				if (flush == Z_FINISH)
	  					return FinishStarted;
	  				else
	  					return NeedMore;
	  			}
	  			return flush == Z_FINISH ? FinishDone : BlockDone;
	  		}

	  		// Same as above, but achieves better compression. We use a lazy
	  		// evaluation for matches: a match is finally adopted only if there is
	  		// no better match at the next window position.
	  		function deflate_slow(flush) {
	  			// short hash_head = 0; // head of hash chain
	  			var hash_head = 0; // head of hash chain
	  			var bflush; // set if current block must be flushed
	  			var max_insert;

	  			// Process the input block.
	  			while (true) {
	  				// Make sure that we always have enough lookahead, except
	  				// at the end of the input file. We need MAX_MATCH bytes
	  				// for the next match, plus MIN_MATCH bytes to insert the
	  				// string following the next match.

	  				if (lookahead < MIN_LOOKAHEAD) {
	  					fill_window();
	  					if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	  						return NeedMore;
	  					}
	  					if (lookahead === 0)
	  						break; // flush the current block
	  				}

	  				// Insert the string window[strstart .. strstart+2] in the
	  				// dictionary, and set hash_head to the head of the hash chain:

	  				if (lookahead >= MIN_MATCH) {
	  					ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
	  					// prev[strstart&w_mask]=hash_head=head[ins_h];
	  					hash_head = (head[ins_h] & 0xffff);
	  					prev[strstart & w_mask] = head[ins_h];
	  					head[ins_h] = strstart;
	  				}

	  				// Find the longest match, discarding those <= prev_length.
	  				prev_length = match_length;
	  				prev_match = match_start;
	  				match_length = MIN_MATCH - 1;

	  				if (hash_head !== 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {
	  					// To simplify the code, we prevent matches with the string
	  					// of window index 0 (in particular we have to avoid a match
	  					// of the string with itself at the start of the input file).

	  					if (strategy != Z_HUFFMAN_ONLY) {
	  						match_length = longest_match(hash_head);
	  					}
	  					// longest_match() sets match_start

	  					if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {

	  						// If prev_match is also MIN_MATCH, match_start is garbage
	  						// but we will ignore the current match anyway.
	  						match_length = MIN_MATCH - 1;
	  					}
	  				}

	  				// If there was a match at the previous step and the current
	  				// match is not better, output the previous match:
	  				if (prev_length >= MIN_MATCH && match_length <= prev_length) {
	  					max_insert = strstart + lookahead - MIN_MATCH;
	  					// Do not insert strings in hash table beyond this.

	  					// check_match(strstart-1, prev_match, prev_length);

	  					bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);

	  					// Insert in hash table all strings up to the end of the match.
	  					// strstart-1 and strstart are already inserted. If there is not
	  					// enough lookahead, the last two strings are not inserted in
	  					// the hash table.
	  					lookahead -= prev_length - 1;
	  					prev_length -= 2;
	  					do {
	  						if (++strstart <= max_insert) {
	  							ins_h = (((ins_h) << hash_shift) ^ (window[(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
	  							// prev[strstart&w_mask]=hash_head=head[ins_h];
	  							hash_head = (head[ins_h] & 0xffff);
	  							prev[strstart & w_mask] = head[ins_h];
	  							head[ins_h] = strstart;
	  						}
	  					} while (--prev_length !== 0);
	  					match_available = 0;
	  					match_length = MIN_MATCH - 1;
	  					strstart++;

	  					if (bflush) {
	  						flush_block_only(false);
	  						if (strm.avail_out === 0)
	  							return NeedMore;
	  					}
	  				} else if (match_available !== 0) {

	  					// If there was no match at the previous position, output a
	  					// single literal. If there was a match but the current match
	  					// is longer, truncate the previous match to a single literal.

	  					bflush = _tr_tally(0, window[strstart - 1] & 0xff);

	  					if (bflush) {
	  						flush_block_only(false);
	  					}
	  					strstart++;
	  					lookahead--;
	  					if (strm.avail_out === 0)
	  						return NeedMore;
	  				} else {
	  					// There is no previous match to compare with, wait for
	  					// the next step to decide.

	  					match_available = 1;
	  					strstart++;
	  					lookahead--;
	  				}
	  			}

	  			if (match_available !== 0) {
	  				bflush = _tr_tally(0, window[strstart - 1] & 0xff);
	  				match_available = 0;
	  			}
	  			flush_block_only(flush == Z_FINISH);

	  			if (strm.avail_out === 0) {
	  				if (flush == Z_FINISH)
	  					return FinishStarted;
	  				else
	  					return NeedMore;
	  			}

	  			return flush == Z_FINISH ? FinishDone : BlockDone;
	  		}

	  		function deflateReset(strm) {
	  			strm.total_in = strm.total_out = 0;
	  			strm.msg = null; //
	  			
	  			that.pending = 0;
	  			that.pending_out = 0;

	  			status = BUSY_STATE;

	  			last_flush = Z_NO_FLUSH;

	  			tr_init();
	  			lm_init();
	  			return Z_OK;
	  		}

	  		that.deflateInit = function(strm, _level, bits, _method, memLevel, _strategy) {
	  			if (!_method)
	  				_method = Z_DEFLATED;
	  			if (!memLevel)
	  				memLevel = DEF_MEM_LEVEL;
	  			if (!_strategy)
	  				_strategy = Z_DEFAULT_STRATEGY;

	  			// byte[] my_version=ZLIB_VERSION;

	  			//
	  			// if (!version || version[0] != my_version[0]
	  			// || stream_size != sizeof(z_stream)) {
	  			// return Z_VERSION_ERROR;
	  			// }

	  			strm.msg = null;

	  			if (_level == Z_DEFAULT_COMPRESSION)
	  				_level = 6;

	  			if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0
	  					|| _strategy > Z_HUFFMAN_ONLY) {
	  				return Z_STREAM_ERROR;
	  			}

	  			strm.dstate = that;

	  			w_bits = bits;
	  			w_size = 1 << w_bits;
	  			w_mask = w_size - 1;

	  			hash_bits = memLevel + 7;
	  			hash_size = 1 << hash_bits;
	  			hash_mask = hash_size - 1;
	  			hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);

	  			window = new Uint8Array(w_size * 2);
	  			prev = [];
	  			head = [];

	  			lit_bufsize = 1 << (memLevel + 6); // 16K elements by default

	  			// We overlay pending_buf and d_buf+l_buf. This works since the average
	  			// output size for (length,distance) codes is <= 24 bits.
	  			that.pending_buf = new Uint8Array(lit_bufsize * 4);
	  			pending_buf_size = lit_bufsize * 4;

	  			d_buf = Math.floor(lit_bufsize / 2);
	  			l_buf = (1 + 2) * lit_bufsize;

	  			level = _level;

	  			strategy = _strategy;

	  			return deflateReset(strm);
	  		};

	  		that.deflateEnd = function() {
	  			if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
	  				return Z_STREAM_ERROR;
	  			}
	  			// Deallocate in reverse order of allocations:
	  			that.pending_buf = null;
	  			head = null;
	  			prev = null;
	  			window = null;
	  			// free
	  			that.dstate = null;
	  			return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
	  		};

	  		that.deflateParams = function(strm, _level, _strategy) {
	  			var err = Z_OK;

	  			if (_level == Z_DEFAULT_COMPRESSION) {
	  				_level = 6;
	  			}
	  			if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
	  				return Z_STREAM_ERROR;
	  			}

	  			if (config_table[level].func != config_table[_level].func && strm.total_in !== 0) {
	  				// Flush the last buffer:
	  				err = strm.deflate(Z_PARTIAL_FLUSH);
	  			}

	  			if (level != _level) {
	  				level = _level;
	  				max_lazy_match = config_table[level].max_lazy;
	  				good_match = config_table[level].good_length;
	  				nice_match = config_table[level].nice_length;
	  				max_chain_length = config_table[level].max_chain;
	  			}
	  			strategy = _strategy;
	  			return err;
	  		};

	  		that.deflateSetDictionary = function(strm, dictionary, dictLength) {
	  			var length = dictLength;
	  			var n, index = 0;

	  			if (!dictionary || status != INIT_STATE)
	  				return Z_STREAM_ERROR;

	  			if (length < MIN_MATCH)
	  				return Z_OK;
	  			if (length > w_size - MIN_LOOKAHEAD) {
	  				length = w_size - MIN_LOOKAHEAD;
	  				index = dictLength - length; // use the tail of the dictionary
	  			}
	  			window.set(dictionary.subarray(index, index + length), 0);

	  			strstart = length;
	  			block_start = length;

	  			// Insert all strings in the hash table (except for the last two bytes).
	  			// s->lookahead stays null, so s->ins_h will be recomputed at the next
	  			// call of fill_window.

	  			ins_h = window[0] & 0xff;
	  			ins_h = (((ins_h) << hash_shift) ^ (window[1] & 0xff)) & hash_mask;

	  			for (n = 0; n <= length - MIN_MATCH; n++) {
	  				ins_h = (((ins_h) << hash_shift) ^ (window[(n) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;
	  				prev[n & w_mask] = head[ins_h];
	  				head[ins_h] = n;
	  			}
	  			return Z_OK;
	  		};

	  		that.deflate = function(_strm, flush) {
	  			var i, header, level_flags, old_flush, bstate;

	  			if (flush > Z_FINISH || flush < 0) {
	  				return Z_STREAM_ERROR;
	  			}

	  			if (!_strm.next_out || (!_strm.next_in && _strm.avail_in !== 0) || (status == FINISH_STATE && flush != Z_FINISH)) {
	  				_strm.msg = z_errmsg[Z_NEED_DICT - (Z_STREAM_ERROR)];
	  				return Z_STREAM_ERROR;
	  			}
	  			if (_strm.avail_out === 0) {
	  				_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];
	  				return Z_BUF_ERROR;
	  			}

	  			strm = _strm; // just in case
	  			old_flush = last_flush;
	  			last_flush = flush;

	  			// Write the zlib header
	  			if (status == INIT_STATE) {
	  				header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
	  				level_flags = ((level - 1) & 0xff) >> 1;

	  				if (level_flags > 3)
	  					level_flags = 3;
	  				header |= (level_flags << 6);
	  				if (strstart !== 0)
	  					header |= PRESET_DICT;
	  				header += 31 - (header % 31);

	  				status = BUSY_STATE;
	  				putShortMSB(header);
	  			}

	  			// Flush as much pending output as possible
	  			if (that.pending !== 0) {
	  				strm.flush_pending();
	  				if (strm.avail_out === 0) {
	  					// console.log(" avail_out==0");
	  					// Since avail_out is 0, deflate will be called again with
	  					// more output space, but possibly with both pending and
	  					// avail_in equal to zero. There won't be anything to do,
	  					// but this is not an error situation so make sure we
	  					// return OK instead of BUF_ERROR at next call of deflate:
	  					last_flush = -1;
	  					return Z_OK;
	  				}

	  				// Make sure there is something to do and avoid duplicate
	  				// consecutive
	  				// flushes. For repeated and useless calls with Z_FINISH, we keep
	  				// returning Z_STREAM_END instead of Z_BUFF_ERROR.
	  			} else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {
	  				strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];
	  				return Z_BUF_ERROR;
	  			}

	  			// User must not provide more input after the first FINISH:
	  			if (status == FINISH_STATE && strm.avail_in !== 0) {
	  				_strm.msg = z_errmsg[Z_NEED_DICT - (Z_BUF_ERROR)];
	  				return Z_BUF_ERROR;
	  			}

	  			// Start a new block or continue the current one.
	  			if (strm.avail_in !== 0 || lookahead !== 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)) {
	  				bstate = -1;
	  				switch (config_table[level].func) {
	  				case STORED:
	  					bstate = deflate_stored(flush);
	  					break;
	  				case FAST:
	  					bstate = deflate_fast(flush);
	  					break;
	  				case SLOW:
	  					bstate = deflate_slow(flush);
	  					break;
	  				default:
	  				}

	  				if (bstate == FinishStarted || bstate == FinishDone) {
	  					status = FINISH_STATE;
	  				}
	  				if (bstate == NeedMore || bstate == FinishStarted) {
	  					if (strm.avail_out === 0) {
	  						last_flush = -1; // avoid BUF_ERROR next call, see above
	  					}
	  					return Z_OK;
	  					// If flush != Z_NO_FLUSH && avail_out === 0, the next call
	  					// of deflate should use the same flush parameter to make sure
	  					// that the flush is complete. So we don't have to output an
	  					// empty block here, this will be done at next call. This also
	  					// ensures that for a very small output buffer, we emit at most
	  					// one empty block.
	  				}

	  				if (bstate == BlockDone) {
	  					if (flush == Z_PARTIAL_FLUSH) {
	  						_tr_align();
	  					} else { // FULL_FLUSH or SYNC_FLUSH
	  						_tr_stored_block(0, 0, false);
	  						// For a full flush, this empty block will be recognized
	  						// as a special marker by inflate_sync().
	  						if (flush == Z_FULL_FLUSH) {
	  							// state.head[s.hash_size-1]=0;
	  							for (i = 0; i < hash_size/*-1*/; i++)
	  								// forget history
	  								head[i] = 0;
	  						}
	  					}
	  					strm.flush_pending();
	  					if (strm.avail_out === 0) {
	  						last_flush = -1; // avoid BUF_ERROR at next call, see above
	  						return Z_OK;
	  					}
	  				}
	  			}

	  			if (flush != Z_FINISH)
	  				return Z_OK;
	  			return Z_STREAM_END;
	  		};
	  	}

	  	// ZStream

	  	function ZStream() {
	  		var that = this;
	  		that.next_in_index = 0;
	  		that.next_out_index = 0;
	  		// that.next_in; // next input byte
	  		that.avail_in = 0; // number of bytes available at next_in
	  		that.total_in = 0; // total nb of input bytes read so far
	  		// that.next_out; // next output byte should be put there
	  		that.avail_out = 0; // remaining free space at next_out
	  		that.total_out = 0; // total nb of bytes output so far
	  		// that.msg;
	  		// that.dstate;
	  	}

	  	ZStream.prototype = {
	  		deflateInit : function(level, bits) {
	  			var that = this;
	  			that.dstate = new Deflate();
	  			if (!bits)
	  				bits = MAX_BITS;
	  			return that.dstate.deflateInit(that, level, bits);
	  		},

	  		deflate : function(flush) {
	  			var that = this;
	  			if (!that.dstate) {
	  				return Z_STREAM_ERROR;
	  			}
	  			return that.dstate.deflate(that, flush);
	  		},

	  		deflateEnd : function() {
	  			var that = this;
	  			if (!that.dstate)
	  				return Z_STREAM_ERROR;
	  			var ret = that.dstate.deflateEnd();
	  			that.dstate = null;
	  			return ret;
	  		},

	  		deflateParams : function(level, strategy) {
	  			var that = this;
	  			if (!that.dstate)
	  				return Z_STREAM_ERROR;
	  			return that.dstate.deflateParams(that, level, strategy);
	  		},

	  		deflateSetDictionary : function(dictionary, dictLength) {
	  			var that = this;
	  			if (!that.dstate)
	  				return Z_STREAM_ERROR;
	  			return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
	  		},

	  		// Read a new buffer from the current input stream, update the
	  		// total number of bytes read. All deflate() input goes through
	  		// this function so some applications may wish to modify it to avoid
	  		// allocating a large strm->next_in buffer and copying from it.
	  		// (See also flush_pending()).
	  		read_buf : function(buf, start, size) {
	  			var that = this;
	  			var len = that.avail_in;
	  			if (len > size)
	  				len = size;
	  			if (len === 0)
	  				return 0;
	  			that.avail_in -= len;
	  			buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
	  			that.next_in_index += len;
	  			that.total_in += len;
	  			return len;
	  		},

	  		// Flush as much pending output as possible. All deflate() output goes
	  		// through this function so some applications may wish to modify it
	  		// to avoid allocating a large strm->next_out buffer and copying into it.
	  		// (See also read_buf()).
	  		flush_pending : function() {
	  			var that = this;
	  			var len = that.dstate.pending;

	  			if (len > that.avail_out)
	  				len = that.avail_out;
	  			if (len === 0)
	  				return;

	  			// if (that.dstate.pending_buf.length <= that.dstate.pending_out || that.next_out.length <= that.next_out_index
	  			// || that.dstate.pending_buf.length < (that.dstate.pending_out + len) || that.next_out.length < (that.next_out_index +
	  			// len)) {
	  			// console.log(that.dstate.pending_buf.length + ", " + that.dstate.pending_out + ", " + that.next_out.length + ", " +
	  			// that.next_out_index + ", " + len);
	  			// console.log("avail_out=" + that.avail_out);
	  			// }

	  			that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);

	  			that.next_out_index += len;
	  			that.dstate.pending_out += len;
	  			that.total_out += len;
	  			that.avail_out -= len;
	  			that.dstate.pending -= len;
	  			if (that.dstate.pending === 0) {
	  				that.dstate.pending_out = 0;
	  			}
	  		}
	  	};

	  	// Deflater

	  	function Deflater(options) {
	  		var that = this;
	  		var z = new ZStream();
	  		var bufsize = 512;
	  		var flush = Z_NO_FLUSH;
	  		var buf = new Uint8Array(bufsize);
	  		var level = options ? options.level : Z_DEFAULT_COMPRESSION;
	  		if (typeof level == "undefined")
	  			level = Z_DEFAULT_COMPRESSION;
	  		z.deflateInit(level);
	  		z.next_out = buf;

	  		that.append = function(data, onprogress) {
	  			var err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;
	  			if (!data.length)
	  				return;
	  			z.next_in_index = 0;
	  			z.next_in = data;
	  			z.avail_in = data.length;
	  			do {
	  				z.next_out_index = 0;
	  				z.avail_out = bufsize;
	  				err = z.deflate(flush);
	  				if (err != Z_OK)
	  					throw new Error("deflating: " + z.msg);
	  				if (z.next_out_index)
	  					if (z.next_out_index == bufsize)
	  						buffers.push(new Uint8Array(buf));
	  					else
	  						buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));
	  				bufferSize += z.next_out_index;
	  				if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
	  					onprogress(z.next_in_index);
	  					lastIndex = z.next_in_index;
	  				}
	  			} while (z.avail_in > 0 || z.avail_out === 0);
	  			array = new Uint8Array(bufferSize);
	  			buffers.forEach(function(chunk) {
	  				array.set(chunk, bufferIndex);
	  				bufferIndex += chunk.length;
	  			});
	  			return array;
	  		};
	  		that.flush = function() {
	  			var err, buffers = [], bufferIndex = 0, bufferSize = 0, array;
	  			do {
	  				z.next_out_index = 0;
	  				z.avail_out = bufsize;
	  				err = z.deflate(Z_FINISH);
	  				if (err != Z_STREAM_END && err != Z_OK)
	  					throw new Error("deflating: " + z.msg);
	  				if (bufsize - z.avail_out > 0)
	  					buffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));
	  				bufferSize += z.next_out_index;
	  			} while (z.avail_in > 0 || z.avail_out === 0);
	  			z.deflateEnd();
	  			array = new Uint8Array(bufferSize);
	  			buffers.forEach(function(chunk) {
	  				array.set(chunk, bufferIndex);
	  				bufferIndex += chunk.length;
	  			});
	  			return array;
	  		};
	  	}

	  	// 'zip' may not be defined in z-worker and some tests
	  	var env = global.zip || global;
	  	env.Deflater = env._jzlib_Deflater = Deflater;
	  }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || typeof global !== "undefined" && global ||  Function('return typeof this === "object" && this.content')() || Function('return this')()));
	  // `self` is undefined in Firefox for Android content script context
	  // while `this` is nsIContentFrameMessageManager
	  // with an attribute `content` that corresponds to the window

	  /**
	   * A class to parse color values
	   * @author Stoyan Stefanov <sstoo@gmail.com>
	   * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
	   * @license Use it if you like it
	   */
	   
	  (function ( global ) {
	   
	  	function RGBColor(color_string)
	  	{
	  		this.ok = false;

	  		// strip any leading #
	  		if (color_string.charAt(0) == '#') { // remove # if any
	  			color_string = color_string.substr(1,6);
	  		}

	  		color_string = color_string.replace(/ /g,'');
	  		color_string = color_string.toLowerCase();

	  		var channels;

	  		// before getting into regexps, try simple matches
	  		// and overwrite the input
	  		var simple_colors = {
	  			aliceblue: 'f0f8ff',
	  			antiquewhite: 'faebd7',
	  			aqua: '00ffff',
	  			aquamarine: '7fffd4',
	  			azure: 'f0ffff',
	  			beige: 'f5f5dc',
	  			bisque: 'ffe4c4',
	  			black: '000000',
	  			blanchedalmond: 'ffebcd',
	  			blue: '0000ff',
	  			blueviolet: '8a2be2',
	  			brown: 'a52a2a',
	  			burlywood: 'deb887',
	  			cadetblue: '5f9ea0',
	  			chartreuse: '7fff00',
	  			chocolate: 'd2691e',
	  			coral: 'ff7f50',
	  			cornflowerblue: '6495ed',
	  			cornsilk: 'fff8dc',
	  			crimson: 'dc143c',
	  			cyan: '00ffff',
	  			darkblue: '00008b',
	  			darkcyan: '008b8b',
	  			darkgoldenrod: 'b8860b',
	  			darkgray: 'a9a9a9',
	  			darkgreen: '006400',
	  			darkkhaki: 'bdb76b',
	  			darkmagenta: '8b008b',
	  			darkolivegreen: '556b2f',
	  			darkorange: 'ff8c00',
	  			darkorchid: '9932cc',
	  			darkred: '8b0000',
	  			darksalmon: 'e9967a',
	  			darkseagreen: '8fbc8f',
	  			darkslateblue: '483d8b',
	  			darkslategray: '2f4f4f',
	  			darkturquoise: '00ced1',
	  			darkviolet: '9400d3',
	  			deeppink: 'ff1493',
	  			deepskyblue: '00bfff',
	  			dimgray: '696969',
	  			dodgerblue: '1e90ff',
	  			feldspar: 'd19275',
	  			firebrick: 'b22222',
	  			floralwhite: 'fffaf0',
	  			forestgreen: '228b22',
	  			fuchsia: 'ff00ff',
	  			gainsboro: 'dcdcdc',
	  			ghostwhite: 'f8f8ff',
	  			gold: 'ffd700',
	  			goldenrod: 'daa520',
	  			gray: '808080',
	  			green: '008000',
	  			greenyellow: 'adff2f',
	  			honeydew: 'f0fff0',
	  			hotpink: 'ff69b4',
	  			indianred : 'cd5c5c',
	  			indigo : '4b0082',
	  			ivory: 'fffff0',
	  			khaki: 'f0e68c',
	  			lavender: 'e6e6fa',
	  			lavenderblush: 'fff0f5',
	  			lawngreen: '7cfc00',
	  			lemonchiffon: 'fffacd',
	  			lightblue: 'add8e6',
	  			lightcoral: 'f08080',
	  			lightcyan: 'e0ffff',
	  			lightgoldenrodyellow: 'fafad2',
	  			lightgrey: 'd3d3d3',
	  			lightgreen: '90ee90',
	  			lightpink: 'ffb6c1',
	  			lightsalmon: 'ffa07a',
	  			lightseagreen: '20b2aa',
	  			lightskyblue: '87cefa',
	  			lightslateblue: '8470ff',
	  			lightslategray: '778899',
	  			lightsteelblue: 'b0c4de',
	  			lightyellow: 'ffffe0',
	  			lime: '00ff00',
	  			limegreen: '32cd32',
	  			linen: 'faf0e6',
	  			magenta: 'ff00ff',
	  			maroon: '800000',
	  			mediumaquamarine: '66cdaa',
	  			mediumblue: '0000cd',
	  			mediumorchid: 'ba55d3',
	  			mediumpurple: '9370d8',
	  			mediumseagreen: '3cb371',
	  			mediumslateblue: '7b68ee',
	  			mediumspringgreen: '00fa9a',
	  			mediumturquoise: '48d1cc',
	  			mediumvioletred: 'c71585',
	  			midnightblue: '191970',
	  			mintcream: 'f5fffa',
	  			mistyrose: 'ffe4e1',
	  			moccasin: 'ffe4b5',
	  			navajowhite: 'ffdead',
	  			navy: '000080',
	  			oldlace: 'fdf5e6',
	  			olive: '808000',
	  			olivedrab: '6b8e23',
	  			orange: 'ffa500',
	  			orangered: 'ff4500',
	  			orchid: 'da70d6',
	  			palegoldenrod: 'eee8aa',
	  			palegreen: '98fb98',
	  			paleturquoise: 'afeeee',
	  			palevioletred: 'd87093',
	  			papayawhip: 'ffefd5',
	  			peachpuff: 'ffdab9',
	  			peru: 'cd853f',
	  			pink: 'ffc0cb',
	  			plum: 'dda0dd',
	  			powderblue: 'b0e0e6',
	  			purple: '800080',
	  			red: 'ff0000',
	  			rosybrown: 'bc8f8f',
	  			royalblue: '4169e1',
	  			saddlebrown: '8b4513',
	  			salmon: 'fa8072',
	  			sandybrown: 'f4a460',
	  			seagreen: '2e8b57',
	  			seashell: 'fff5ee',
	  			sienna: 'a0522d',
	  			silver: 'c0c0c0',
	  			skyblue: '87ceeb',
	  			slateblue: '6a5acd',
	  			slategray: '708090',
	  			snow: 'fffafa',
	  			springgreen: '00ff7f',
	  			steelblue: '4682b4',
	  			tan: 'd2b48c',
	  			teal: '008080',
	  			thistle: 'd8bfd8',
	  			tomato: 'ff6347',
	  			turquoise: '40e0d0',
	  			violet: 'ee82ee',
	  			violetred: 'd02090',
	  			wheat: 'f5deb3',
	  			white: 'ffffff',
	  			whitesmoke: 'f5f5f5',
	  			yellow: 'ffff00',
	  			yellowgreen: '9acd32'
	  		};
	  		for (var key in simple_colors) {
	  			if (color_string == key) {
	  				color_string = simple_colors[key];
	  			}
	  		}
	  		// emd of simple type-in colors

	  		// array of color definition objects
	  		var color_defs = [
	  			{
	  				re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
	  				example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
	  				process: function (bits){
	  					return [
	  						parseInt(bits[1]),
	  						parseInt(bits[2]),
	  						parseInt(bits[3])
	  					];
	  				}
	  			},
	  			{
	  				re: /^(\w{2})(\w{2})(\w{2})$/,
	  				example: ['#00ff00', '336699'],
	  				process: function (bits){
	  					return [
	  						parseInt(bits[1], 16),
	  						parseInt(bits[2], 16),
	  						parseInt(bits[3], 16)
	  					];
	  				}
	  			},
	  			{
	  				re: /^(\w{1})(\w{1})(\w{1})$/,
	  				example: ['#fb0', 'f0f'],
	  				process: function (bits){
	  					return [
	  						parseInt(bits[1] + bits[1], 16),
	  						parseInt(bits[2] + bits[2], 16),
	  						parseInt(bits[3] + bits[3], 16)
	  					];
	  				}
	  			}
	  		];

	  		// search through the definitions to find a match
	  		for (var i = 0; i < color_defs.length; i++) {
	  			var re = color_defs[i].re;
	  			var processor = color_defs[i].process;
	  			var bits = re.exec(color_string);
	  			if (bits) {
	  				channels = processor(bits);
	  				this.r = channels[0];
	  				this.g = channels[1];
	  				this.b = channels[2];
	  				this.ok = true;
	  			}

	  		}

	  		// validate/cleanup values
	  		this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
	  		this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
	  		this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

	  		// some getters
	  		this.toRGB = function () {
	  			return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
	  		};
	  		this.toHex = function () {
	  			var r = this.r.toString(16);
	  			var g = this.g.toString(16);
	  			var b = this.b.toString(16);
	  			if (r.length == 1) r = '0' + r;
	  			if (g.length == 1) g = '0' + g;
	  			if (b.length == 1) b = '0' + b;
	  			return '#' + r + g + b;
	  		};

	  		// help
	  		this.getHelpXML = function () {

	  			var examples = new Array();
	  			// add regexps
	  			for (var i = 0; i < color_defs.length; i++) {
	  				var example = color_defs[i].example;
	  				for (var j = 0; j < example.length; j++) {
	  					examples[examples.length] = example[j];
	  				}
	  			}
	  			// add type-in colors
	  			for (var sc in simple_colors) {
	  				examples[examples.length] = sc;
	  			}

	  			var xml = document.createElement('ul');
	  			xml.setAttribute('id', 'rgbcolor-examples');
	  			for (var i = 0; i < examples.length; i++) {
	  				try {
	  					var list_item = document.createElement('li');
	  					var list_color = new RGBColor(examples[i]);
	  					var example_div = document.createElement('div');
	  					example_div.style.cssText =
	  							'margin: 3px; '
	  							+ 'border: 1px solid black; '
	  							+ 'background:' + list_color.toHex() + '; '
	  							+ 'color:' + list_color.toHex()
	  					;
	  					example_div.appendChild(document.createTextNode('test'));
	  					var list_item_value = document.createTextNode(
	  						' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
	  					);
	  					list_item.appendChild(example_div);
	  					list_item.appendChild(list_item_value);
	  					xml.appendChild(list_item);

	  				} catch(e){}
	  			}
	  			return xml;

	  		};

	  	}

	      // export as AMD...
	      if ( typeof define !== 'undefined' && define.amd ) {
	          define('RGBColor', function () { return RGBColor; });
	      }

	      // ...or as browserify
	      else if (typeof module !== 'undefined' && module.exports ) {
	          module.exports = RGBColor;
	      }

	      global.RGBColor = RGBColor;
	  	
	  }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || typeof global !== "undefined" && global ||  Function('return typeof this === "object" && this.content')() || Function('return this')()));
	  // `self` is undefined in Firefox for Android content script context
	  // while `this` is nsIContentFrameMessageManager
	  // with an attribute `content` that corresponds to the window

	  /*
	    html2canvas 0.5.0-beta3 <http://html2canvas.hertzen.com>
	    Copyright (c) 2016 Niklas von Hertzen

	    Released under  License
	  */

	  !function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.html2canvas=e();}}(function(){var define;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r);}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	  (function (global){
	  (function(root) {

	  	/** Detect free variables */
	  	var freeExports = typeof exports == 'object' && exports;
	  	var freeModule = typeof module == 'object' && module &&
	  		module.exports == freeExports && module;
	  	var freeGlobal = typeof global == 'object' && global;
	  	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
	  		root = freeGlobal;
	  	}

	  	/**
	  	 * The `punycode` object.
	  	 * @name punycode
	  	 * @type Object
	  	 */
	  	var punycode,

	  	/** Highest positive signed 32-bit float value */
	  	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	  	/** Bootstring parameters */
	  	base = 36,
	  	tMin = 1,
	  	tMax = 26,
	  	skew = 38,
	  	damp = 700,
	  	initialBias = 72,
	  	initialN = 128, // 0x80
	  	delimiter = '-', // '\x2D'

	  	/** Regular expressions */
	  	regexPunycode = /^xn--/,
	  	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	  	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	  	/** Error messages */
	  	errors = {
	  		'overflow': 'Overflow: input needs wider integers to process',
	  		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	  		'invalid-input': 'Invalid input'
	  	},

	  	/** Convenience shortcuts */
	  	baseMinusTMin = base - tMin,
	  	floor = Math.floor,
	  	stringFromCharCode = String.fromCharCode,

	  	/** Temporary variable */
	  	key;

	  	/*--------------------------------------------------------------------------*/

	  	/**
	  	 * A generic error utility function.
	  	 * @private
	  	 * @param {String} type The error type.
	  	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	  	 */
	  	function error(type) {
	  		throw RangeError(errors[type]);
	  	}

	  	/**
	  	 * A generic `Array#map` utility function.
	  	 * @private
	  	 * @param {Array} array The array to iterate over.
	  	 * @param {Function} callback The function that gets called for every array
	  	 * item.
	  	 * @returns {Array} A new array of values returned by the callback function.
	  	 */
	  	function map(array, fn) {
	  		var length = array.length;
	  		while (length--) {
	  			array[length] = fn(array[length]);
	  		}
	  		return array;
	  	}

	  	/**
	  	 * A simple `Array#map`-like wrapper to work with domain name strings.
	  	 * @private
	  	 * @param {String} domain The domain name.
	  	 * @param {Function} callback The function that gets called for every
	  	 * character.
	  	 * @returns {Array} A new string of characters returned by the callback
	  	 * function.
	  	 */
	  	function mapDomain(string, fn) {
	  		return map(string.split(regexSeparators), fn).join('.');
	  	}

	  	/**
	  	 * Creates an array containing the numeric code points of each Unicode
	  	 * character in the string. While JavaScript uses UCS-2 internally,
	  	 * this function will convert a pair of surrogate halves (each of which
	  	 * UCS-2 exposes as separate characters) into a single code point,
	  	 * matching UTF-16.
	  	 * @see `punycode.ucs2.encode`
	  	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	  	 * @memberOf punycode.ucs2
	  	 * @name decode
	  	 * @param {String} string The Unicode input string (UCS-2).
	  	 * @returns {Array} The new array of code points.
	  	 */
	  	function ucs2decode(string) {
	  		var output = [],
	  		    counter = 0,
	  		    length = string.length,
	  		    value,
	  		    extra;
	  		while (counter < length) {
	  			value = string.charCodeAt(counter++);
	  			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
	  				// high surrogate, and there is a next character
	  				extra = string.charCodeAt(counter++);
	  				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
	  					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
	  				} else {
	  					// unmatched surrogate; only append this code unit, in case the next
	  					// code unit is the high surrogate of a surrogate pair
	  					output.push(value);
	  					counter--;
	  				}
	  			} else {
	  				output.push(value);
	  			}
	  		}
	  		return output;
	  	}

	  	/**
	  	 * Creates a string based on an array of numeric code points.
	  	 * @see `punycode.ucs2.decode`
	  	 * @memberOf punycode.ucs2
	  	 * @name encode
	  	 * @param {Array} codePoints The array of numeric code points.
	  	 * @returns {String} The new Unicode string (UCS-2).
	  	 */
	  	function ucs2encode(array) {
	  		return map(array, function(value) {
	  			var output = '';
	  			if (value > 0xFFFF) {
	  				value -= 0x10000;
	  				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
	  				value = 0xDC00 | value & 0x3FF;
	  			}
	  			output += stringFromCharCode(value);
	  			return output;
	  		}).join('');
	  	}

	  	/**
	  	 * Converts a basic code point into a digit/integer.
	  	 * @see `digitToBasic()`
	  	 * @private
	  	 * @param {Number} codePoint The basic numeric code point value.
	  	 * @returns {Number} The numeric value of a basic code point (for use in
	  	 * representing integers) in the range `0` to `base - 1`, or `base` if
	  	 * the code point does not represent a value.
	  	 */
	  	function basicToDigit(codePoint) {
	  		if (codePoint - 48 < 10) {
	  			return codePoint - 22;
	  		}
	  		if (codePoint - 65 < 26) {
	  			return codePoint - 65;
	  		}
	  		if (codePoint - 97 < 26) {
	  			return codePoint - 97;
	  		}
	  		return base;
	  	}

	  	/**
	  	 * Converts a digit/integer into a basic code point.
	  	 * @see `basicToDigit()`
	  	 * @private
	  	 * @param {Number} digit The numeric value of a basic code point.
	  	 * @returns {Number} The basic code point whose value (when used for
	  	 * representing integers) is `digit`, which needs to be in the range
	  	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	  	 * used; else, the lowercase form is used. The behavior is undefined
	  	 * if `flag` is non-zero and `digit` has no uppercase form.
	  	 */
	  	function digitToBasic(digit, flag) {
	  		//  0..25 map to ASCII a..z or A..Z
	  		// 26..35 map to ASCII 0..9
	  		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	  	}

	  	/**
	  	 * Bias adaptation function as per section 3.4 of RFC 3492.
	  	 * http://tools.ietf.org/html/rfc3492#section-3.4
	  	 * @private
	  	 */
	  	function adapt(delta, numPoints, firstTime) {
	  		var k = 0;
	  		delta = firstTime ? floor(delta / damp) : delta >> 1;
	  		delta += floor(delta / numPoints);
	  		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
	  			delta = floor(delta / baseMinusTMin);
	  		}
	  		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	  	}

	  	/**
	  	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	  	 * symbols.
	  	 * @memberOf punycode
	  	 * @param {String} input The Punycode string of ASCII-only symbols.
	  	 * @returns {String} The resulting string of Unicode symbols.
	  	 */
	  	function decode(input) {
	  		// Don't use UCS-2
	  		var output = [],
	  		    inputLength = input.length,
	  		    out,
	  		    i = 0,
	  		    n = initialN,
	  		    bias = initialBias,
	  		    basic,
	  		    j,
	  		    index,
	  		    oldi,
	  		    w,
	  		    k,
	  		    digit,
	  		    t,
	  		    /** Cached calculation results */
	  		    baseMinusT;

	  		// Handle the basic code points: let `basic` be the number of input code
	  		// points before the last delimiter, or `0` if there is none, then copy
	  		// the first basic code points to the output.

	  		basic = input.lastIndexOf(delimiter);
	  		if (basic < 0) {
	  			basic = 0;
	  		}

	  		for (j = 0; j < basic; ++j) {
	  			// if it's not a basic code point
	  			if (input.charCodeAt(j) >= 0x80) {
	  				error('not-basic');
	  			}
	  			output.push(input.charCodeAt(j));
	  		}

	  		// Main decoding loop: start just after the last delimiter if any basic code
	  		// points were copied; start at the beginning otherwise.

	  		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

	  			// `index` is the index of the next character to be consumed.
	  			// Decode a generalized variable-length integer into `delta`,
	  			// which gets added to `i`. The overflow checking is easier
	  			// if we increase `i` as we go, then subtract off its starting
	  			// value at the end to obtain `delta`.
	  			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

	  				if (index >= inputLength) {
	  					error('invalid-input');
	  				}

	  				digit = basicToDigit(input.charCodeAt(index++));

	  				if (digit >= base || digit > floor((maxInt - i) / w)) {
	  					error('overflow');
	  				}

	  				i += digit * w;
	  				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

	  				if (digit < t) {
	  					break;
	  				}

	  				baseMinusT = base - t;
	  				if (w > floor(maxInt / baseMinusT)) {
	  					error('overflow');
	  				}

	  				w *= baseMinusT;

	  			}

	  			out = output.length + 1;
	  			bias = adapt(i - oldi, out, oldi == 0);

	  			// `i` was supposed to wrap around from `out` to `0`,
	  			// incrementing `n` each time, so we'll fix that now:
	  			if (floor(i / out) > maxInt - n) {
	  				error('overflow');
	  			}

	  			n += floor(i / out);
	  			i %= out;

	  			// Insert `n` at position `i` of the output
	  			output.splice(i++, 0, n);

	  		}

	  		return ucs2encode(output);
	  	}

	  	/**
	  	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	  	 * symbols.
	  	 * @memberOf punycode
	  	 * @param {String} input The string of Unicode symbols.
	  	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	  	 */
	  	function encode(input) {
	  		var n,
	  		    delta,
	  		    handledCPCount,
	  		    basicLength,
	  		    bias,
	  		    j,
	  		    m,
	  		    q,
	  		    k,
	  		    t,
	  		    currentValue,
	  		    output = [],
	  		    /** `inputLength` will hold the number of code points in `input`. */
	  		    inputLength,
	  		    /** Cached calculation results */
	  		    handledCPCountPlusOne,
	  		    baseMinusT,
	  		    qMinusT;

	  		// Convert the input in UCS-2 to Unicode
	  		input = ucs2decode(input);

	  		// Cache the length
	  		inputLength = input.length;

	  		// Initialize the state
	  		n = initialN;
	  		delta = 0;
	  		bias = initialBias;

	  		// Handle the basic code points
	  		for (j = 0; j < inputLength; ++j) {
	  			currentValue = input[j];
	  			if (currentValue < 0x80) {
	  				output.push(stringFromCharCode(currentValue));
	  			}
	  		}

	  		handledCPCount = basicLength = output.length;

	  		// `handledCPCount` is the number of code points that have been handled;
	  		// `basicLength` is the number of basic code points.

	  		// Finish the basic string - if it is not empty - with a delimiter
	  		if (basicLength) {
	  			output.push(delimiter);
	  		}

	  		// Main encoding loop:
	  		while (handledCPCount < inputLength) {

	  			// All non-basic code points < n have been handled already. Find the next
	  			// larger one:
	  			for (m = maxInt, j = 0; j < inputLength; ++j) {
	  				currentValue = input[j];
	  				if (currentValue >= n && currentValue < m) {
	  					m = currentValue;
	  				}
	  			}

	  			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
	  			// but guard against overflow
	  			handledCPCountPlusOne = handledCPCount + 1;
	  			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
	  				error('overflow');
	  			}

	  			delta += (m - n) * handledCPCountPlusOne;
	  			n = m;

	  			for (j = 0; j < inputLength; ++j) {
	  				currentValue = input[j];

	  				if (currentValue < n && ++delta > maxInt) {
	  					error('overflow');
	  				}

	  				if (currentValue == n) {
	  					// Represent delta as a generalized variable-length integer
	  					for (q = delta, k = base; /* no condition */; k += base) {
	  						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	  						if (q < t) {
	  							break;
	  						}
	  						qMinusT = q - t;
	  						baseMinusT = base - t;
	  						output.push(
	  							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
	  						);
	  						q = floor(qMinusT / baseMinusT);
	  					}

	  					output.push(stringFromCharCode(digitToBasic(q, 0)));
	  					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
	  					delta = 0;
	  					++handledCPCount;
	  				}
	  			}

	  			++delta;
	  			++n;

	  		}
	  		return output.join('');
	  	}

	  	/**
	  	 * Converts a Punycode string representing a domain name to Unicode. Only the
	  	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	  	 * matter if you call it on a string that has already been converted to
	  	 * Unicode.
	  	 * @memberOf punycode
	  	 * @param {String} domain The Punycode domain name to convert to Unicode.
	  	 * @returns {String} The Unicode representation of the given Punycode
	  	 * string.
	  	 */
	  	function toUnicode(domain) {
	  		return mapDomain(domain, function(string) {
	  			return regexPunycode.test(string)
	  				? decode(string.slice(4).toLowerCase())
	  				: string;
	  		});
	  	}

	  	/**
	  	 * Converts a Unicode string representing a domain name to Punycode. Only the
	  	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	  	 * matter if you call it with a domain that's already in ASCII.
	  	 * @memberOf punycode
	  	 * @param {String} domain The domain name to convert, as a Unicode string.
	  	 * @returns {String} The Punycode representation of the given domain name.
	  	 */
	  	function toASCII(domain) {
	  		return mapDomain(domain, function(string) {
	  			return regexNonASCII.test(string)
	  				? 'xn--' + encode(string)
	  				: string;
	  		});
	  	}

	  	/*--------------------------------------------------------------------------*/

	  	/** Define the public API */
	  	punycode = {
	  		/**
	  		 * A string representing the current Punycode.js version number.
	  		 * @memberOf punycode
	  		 * @type String
	  		 */
	  		'version': '1.2.4',
	  		/**
	  		 * An object of methods to convert from JavaScript's internal character
	  		 * representation (UCS-2) to Unicode code points, and back.
	  		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	  		 * @memberOf punycode
	  		 * @type Object
	  		 */
	  		'ucs2': {
	  			'decode': ucs2decode,
	  			'encode': ucs2encode
	  		},
	  		'decode': decode,
	  		'encode': encode,
	  		'toASCII': toASCII,
	  		'toUnicode': toUnicode
	  	};

	  	/** Expose `punycode` */
	  	// Some AMD build optimizers, like r.js, check for specific condition patterns
	  	// like the following:
	  	if (
	  		typeof define == 'function' &&
	  		typeof define.amd == 'object' && define.amd && false
	  	) {
	  		define('punycode', function() {
	  			return punycode;
	  		});
	  	} else if (freeExports && !freeExports.nodeType) {
	  		if (freeModule) { // in Node.js or RingoJS v0.8.0+
	  			freeModule.exports = punycode;
	  		} else { // in Narwhal or RingoJS v0.7.0-
	  			for (key in punycode) {
	  				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
	  			}
	  		}
	  	} else { // in Rhino or a web browser
	  		root.punycode = punycode;
	  	}

	  }(this));

	  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
	  },{}],2:[function(_dereq_,module,exports){
	  var log = _dereq_('./log');

	  function restoreOwnerScroll(ownerDocument, x, y) {
	      if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
	          ownerDocument.defaultView.scrollTo(x, y);
	      }
	  }

	  function cloneCanvasContents(canvas, clonedCanvas) {
	      try {
	          if (clonedCanvas) {
	              clonedCanvas.width = canvas.width;
	              clonedCanvas.height = canvas.height;
	              clonedCanvas.getContext("2d").putImageData(canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height), 0, 0);
	          }
	      } catch(e) {
	          log("Unable to copy canvas content from", canvas, e);
	      }
	  }

	  function cloneNode(node, javascriptEnabled) {
	      var clone = node.nodeType === 3 ? document.createTextNode(node.nodeValue) : node.cloneNode(false);

	      var child = node.firstChild;
	      while(child) {
	          if (javascriptEnabled === true || child.nodeType !== 1 || child.nodeName !== 'SCRIPT') {
	              clone.appendChild(cloneNode(child, javascriptEnabled));
	          }
	          child = child.nextSibling;
	      }

	      if (node.nodeType === 1) {
	          clone._scrollTop = node.scrollTop;
	          clone._scrollLeft = node.scrollLeft;
	          if (node.nodeName === "CANVAS") {
	              cloneCanvasContents(node, clone);
	          } else if (node.nodeName === "TEXTAREA" || node.nodeName === "SELECT") {
	              clone.value = node.value;
	          }
	      }

	      return clone;
	  }

	  function initNode(node) {
	      if (node.nodeType === 1) {
	          node.scrollTop = node._scrollTop;
	          node.scrollLeft = node._scrollLeft;

	          var child = node.firstChild;
	          while(child) {
	              initNode(child);
	              child = child.nextSibling;
	          }
	      }
	  }

	  module.exports = function(ownerDocument, containerDocument, width, height, options, x ,y) {
	      var documentElement = cloneNode(ownerDocument.documentElement, options.javascriptEnabled);
	      var container = containerDocument.createElement("iframe");

	      container.className = "html2canvas-container";
	      container.style.visibility = "hidden";
	      container.style.position = "fixed";
	      container.style.left = "-10000px";
	      container.style.top = "0px";
	      container.style.border = "0";
	      container.width = width;
	      container.height = height;
	      container.scrolling = "no"; // ios won't scroll without it
	      containerDocument.body.appendChild(container);

	      return new Promise(function(resolve) {
	          var documentClone = container.contentWindow.document;

	          /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
	           if window url is about:blank, we can assign the url to current by writing onto the document
	           */
	          container.contentWindow.onload = container.onload = function() {
	              var interval = setInterval(function() {
	                  if (documentClone.body.childNodes.length > 0) {
	                      initNode(documentClone.documentElement);
	                      clearInterval(interval);
	                      if (options.type === "view") {
	                          container.contentWindow.scrollTo(x, y);
	                          if ((/(iPad|iPhone|iPod)/g).test(navigator.userAgent) && (container.contentWindow.scrollY !== y || container.contentWindow.scrollX !== x)) {
	                              documentClone.documentElement.style.top = (-y) + "px";
	                              documentClone.documentElement.style.left = (-x) + "px";
	                              documentClone.documentElement.style.position = 'absolute';
	                          }
	                      }
	                      resolve(container);
	                  }
	              }, 50);
	          };

	          documentClone.open();
	          documentClone.write("<!DOCTYPE html><html></html>");
	          // Chrome scrolls the parent document for some reason after the write to the cloned window???
	          restoreOwnerScroll(ownerDocument, x, y);
	          documentClone.replaceChild(documentClone.adoptNode(documentElement), documentClone.documentElement);
	          documentClone.close();
	      });
	  };

	  },{"./log":13}],3:[function(_dereq_,module,exports){
	  // http://dev.w3.org/csswg/css-color/

	  function Color(value) {
	      this.r = 0;
	      this.g = 0;
	      this.b = 0;
	      this.a = null;
	      var result = this.fromArray(value) ||
	          this.namedColor(value) ||
	          this.rgb(value) ||
	          this.rgba(value) ||
	          this.hex6(value) ||
	          this.hex3(value);
	  }

	  Color.prototype.darken = function(amount) {
	      var a = 1 - amount;
	      return  new Color([
	          Math.round(this.r * a),
	          Math.round(this.g * a),
	          Math.round(this.b * a),
	          this.a
	      ]);
	  };

	  Color.prototype.isTransparent = function() {
	      return this.a === 0;
	  };

	  Color.prototype.isBlack = function() {
	      return this.r === 0 && this.g === 0 && this.b === 0;
	  };

	  Color.prototype.fromArray = function(array) {
	      if (Array.isArray(array)) {
	          this.r = Math.min(array[0], 255);
	          this.g = Math.min(array[1], 255);
	          this.b = Math.min(array[2], 255);
	          if (array.length > 3) {
	              this.a = array[3];
	          }
	      }

	      return (Array.isArray(array));
	  };

	  var _hex3 = /^#([a-f0-9]{3})$/i;

	  Color.prototype.hex3 = function(value) {
	      var match = null;
	      if ((match = value.match(_hex3)) !== null) {
	          this.r = parseInt(match[1][0] + match[1][0], 16);
	          this.g = parseInt(match[1][1] + match[1][1], 16);
	          this.b = parseInt(match[1][2] + match[1][2], 16);
	      }
	      return match !== null;
	  };

	  var _hex6 = /^#([a-f0-9]{6})$/i;

	  Color.prototype.hex6 = function(value) {
	      var match = null;
	      if ((match = value.match(_hex6)) !== null) {
	          this.r = parseInt(match[1].substring(0, 2), 16);
	          this.g = parseInt(match[1].substring(2, 4), 16);
	          this.b = parseInt(match[1].substring(4, 6), 16);
	      }
	      return match !== null;
	  };


	  var _rgb = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;

	  Color.prototype.rgb = function(value) {
	      var match = null;
	      if ((match = value.match(_rgb)) !== null) {
	          this.r = Number(match[1]);
	          this.g = Number(match[2]);
	          this.b = Number(match[3]);
	      }
	      return match !== null;
	  };

	  var _rgba = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;

	  Color.prototype.rgba = function(value) {
	      var match = null;
	      if ((match = value.match(_rgba)) !== null) {
	          this.r = Number(match[1]);
	          this.g = Number(match[2]);
	          this.b = Number(match[3]);
	          this.a = Number(match[4]);
	      }
	      return match !== null;
	  };

	  Color.prototype.toString = function() {
	      return this.a !== null && this.a !== 1 ?
	      "rgba(" + [this.r, this.g, this.b, this.a].join(",") + ")" :
	      "rgb(" + [this.r, this.g, this.b].join(",") + ")";
	  };

	  Color.prototype.namedColor = function(value) {
	      value = value.toLowerCase();
	      var color = colors[value];
	      if (color) {
	          this.r = color[0];
	          this.g = color[1];
	          this.b = color[2];
	      } else if (value === "transparent") {
	          this.r = this.g = this.b = this.a = 0;
	          return true;
	      }

	      return !!color;
	  };

	  Color.prototype.isColor = true;

	  // JSON.stringify([].slice.call($$('.named-color-table tr'), 1).map(function(row) { return [row.childNodes[3].textContent, row.childNodes[5].textContent.trim().split(",").map(Number)] }).reduce(function(data, row) {data[row[0]] = row[1]; return data}, {}))
	  var colors = {
	      "aliceblue": [240, 248, 255],
	      "antiquewhite": [250, 235, 215],
	      "aqua": [0, 255, 255],
	      "aquamarine": [127, 255, 212],
	      "azure": [240, 255, 255],
	      "beige": [245, 245, 220],
	      "bisque": [255, 228, 196],
	      "black": [0, 0, 0],
	      "blanchedalmond": [255, 235, 205],
	      "blue": [0, 0, 255],
	      "blueviolet": [138, 43, 226],
	      "brown": [165, 42, 42],
	      "burlywood": [222, 184, 135],
	      "cadetblue": [95, 158, 160],
	      "chartreuse": [127, 255, 0],
	      "chocolate": [210, 105, 30],
	      "coral": [255, 127, 80],
	      "cornflowerblue": [100, 149, 237],
	      "cornsilk": [255, 248, 220],
	      "crimson": [220, 20, 60],
	      "cyan": [0, 255, 255],
	      "darkblue": [0, 0, 139],
	      "darkcyan": [0, 139, 139],
	      "darkgoldenrod": [184, 134, 11],
	      "darkgray": [169, 169, 169],
	      "darkgreen": [0, 100, 0],
	      "darkgrey": [169, 169, 169],
	      "darkkhaki": [189, 183, 107],
	      "darkmagenta": [139, 0, 139],
	      "darkolivegreen": [85, 107, 47],
	      "darkorange": [255, 140, 0],
	      "darkorchid": [153, 50, 204],
	      "darkred": [139, 0, 0],
	      "darksalmon": [233, 150, 122],
	      "darkseagreen": [143, 188, 143],
	      "darkslateblue": [72, 61, 139],
	      "darkslategray": [47, 79, 79],
	      "darkslategrey": [47, 79, 79],
	      "darkturquoise": [0, 206, 209],
	      "darkviolet": [148, 0, 211],
	      "deeppink": [255, 20, 147],
	      "deepskyblue": [0, 191, 255],
	      "dimgray": [105, 105, 105],
	      "dimgrey": [105, 105, 105],
	      "dodgerblue": [30, 144, 255],
	      "firebrick": [178, 34, 34],
	      "floralwhite": [255, 250, 240],
	      "forestgreen": [34, 139, 34],
	      "fuchsia": [255, 0, 255],
	      "gainsboro": [220, 220, 220],
	      "ghostwhite": [248, 248, 255],
	      "gold": [255, 215, 0],
	      "goldenrod": [218, 165, 32],
	      "gray": [128, 128, 128],
	      "green": [0, 128, 0],
	      "greenyellow": [173, 255, 47],
	      "grey": [128, 128, 128],
	      "honeydew": [240, 255, 240],
	      "hotpink": [255, 105, 180],
	      "indianred": [205, 92, 92],
	      "indigo": [75, 0, 130],
	      "ivory": [255, 255, 240],
	      "khaki": [240, 230, 140],
	      "lavender": [230, 230, 250],
	      "lavenderblush": [255, 240, 245],
	      "lawngreen": [124, 252, 0],
	      "lemonchiffon": [255, 250, 205],
	      "lightblue": [173, 216, 230],
	      "lightcoral": [240, 128, 128],
	      "lightcyan": [224, 255, 255],
	      "lightgoldenrodyellow": [250, 250, 210],
	      "lightgray": [211, 211, 211],
	      "lightgreen": [144, 238, 144],
	      "lightgrey": [211, 211, 211],
	      "lightpink": [255, 182, 193],
	      "lightsalmon": [255, 160, 122],
	      "lightseagreen": [32, 178, 170],
	      "lightskyblue": [135, 206, 250],
	      "lightslategray": [119, 136, 153],
	      "lightslategrey": [119, 136, 153],
	      "lightsteelblue": [176, 196, 222],
	      "lightyellow": [255, 255, 224],
	      "lime": [0, 255, 0],
	      "limegreen": [50, 205, 50],
	      "linen": [250, 240, 230],
	      "magenta": [255, 0, 255],
	      "maroon": [128, 0, 0],
	      "mediumaquamarine": [102, 205, 170],
	      "mediumblue": [0, 0, 205],
	      "mediumorchid": [186, 85, 211],
	      "mediumpurple": [147, 112, 219],
	      "mediumseagreen": [60, 179, 113],
	      "mediumslateblue": [123, 104, 238],
	      "mediumspringgreen": [0, 250, 154],
	      "mediumturquoise": [72, 209, 204],
	      "mediumvioletred": [199, 21, 133],
	      "midnightblue": [25, 25, 112],
	      "mintcream": [245, 255, 250],
	      "mistyrose": [255, 228, 225],
	      "moccasin": [255, 228, 181],
	      "navajowhite": [255, 222, 173],
	      "navy": [0, 0, 128],
	      "oldlace": [253, 245, 230],
	      "olive": [128, 128, 0],
	      "olivedrab": [107, 142, 35],
	      "orange": [255, 165, 0],
	      "orangered": [255, 69, 0],
	      "orchid": [218, 112, 214],
	      "palegoldenrod": [238, 232, 170],
	      "palegreen": [152, 251, 152],
	      "paleturquoise": [175, 238, 238],
	      "palevioletred": [219, 112, 147],
	      "papayawhip": [255, 239, 213],
	      "peachpuff": [255, 218, 185],
	      "peru": [205, 133, 63],
	      "pink": [255, 192, 203],
	      "plum": [221, 160, 221],
	      "powderblue": [176, 224, 230],
	      "purple": [128, 0, 128],
	      "rebeccapurple": [102, 51, 153],
	      "red": [255, 0, 0],
	      "rosybrown": [188, 143, 143],
	      "royalblue": [65, 105, 225],
	      "saddlebrown": [139, 69, 19],
	      "salmon": [250, 128, 114],
	      "sandybrown": [244, 164, 96],
	      "seagreen": [46, 139, 87],
	      "seashell": [255, 245, 238],
	      "sienna": [160, 82, 45],
	      "silver": [192, 192, 192],
	      "skyblue": [135, 206, 235],
	      "slateblue": [106, 90, 205],
	      "slategray": [112, 128, 144],
	      "slategrey": [112, 128, 144],
	      "snow": [255, 250, 250],
	      "springgreen": [0, 255, 127],
	      "steelblue": [70, 130, 180],
	      "tan": [210, 180, 140],
	      "teal": [0, 128, 128],
	      "thistle": [216, 191, 216],
	      "tomato": [255, 99, 71],
	      "turquoise": [64, 224, 208],
	      "violet": [238, 130, 238],
	      "wheat": [245, 222, 179],
	      "white": [255, 255, 255],
	      "whitesmoke": [245, 245, 245],
	      "yellow": [255, 255, 0],
	      "yellowgreen": [154, 205, 50]
	  };

	  module.exports = Color;

	  },{}],4:[function(_dereq_,module,exports){
	  var Support = _dereq_('./support');
	  var CanvasRenderer = _dereq_('./renderers/canvas');
	  var ImageLoader = _dereq_('./imageloader');
	  var NodeParser = _dereq_('./nodeparser');
	  var NodeContainer = _dereq_('./nodecontainer');
	  var log = _dereq_('./log');
	  var utils = _dereq_('./utils');
	  var createWindowClone = _dereq_('./clone');
	  var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;
	  var getBounds = utils.getBounds;

	  var html2canvasNodeAttribute = "data-html2canvas-node";
	  var html2canvasCloneIndex = 0;

	  function html2canvas(nodeList, options) {
	      var index = html2canvasCloneIndex++;
	      options = options || {};
	      if (options.logging) {
	          log.options.logging = true;
	          log.options.start = Date.now();
	      }

	      options.async = typeof(options.async) === "undefined" ? true : options.async;
	      options.allowTaint = typeof(options.allowTaint) === "undefined" ? false : options.allowTaint;
	      options.removeContainer = typeof(options.removeContainer) === "undefined" ? true : options.removeContainer;
	      options.javascriptEnabled = typeof(options.javascriptEnabled) === "undefined" ? false : options.javascriptEnabled;
	      options.imageTimeout = typeof(options.imageTimeout) === "undefined" ? 10000 : options.imageTimeout;
	      options.renderer = typeof(options.renderer) === "function" ? options.renderer : CanvasRenderer;
	      options.strict = !!options.strict;

	      if (typeof(nodeList) === "string") {
	          if (typeof(options.proxy) !== "string") {
	              return Promise.reject("Proxy must be used when rendering url");
	          }
	          var width = options.width != null ? options.width : window.innerWidth;
	          var height = options.height != null ? options.height : window.innerHeight;
	          return loadUrlDocument(absoluteUrl(nodeList), options.proxy, document, width, height, options).then(function(container) {
	              return renderWindow(container.contentWindow.document.documentElement, container, options, width, height);
	          });
	      }

	      var node = ((nodeList === undefined) ? [document.documentElement] : ((nodeList.length) ? nodeList : [nodeList]))[0];
	      node.setAttribute(html2canvasNodeAttribute + index, index);
	      return renderDocument(node.ownerDocument, options, node.ownerDocument.defaultView.innerWidth, node.ownerDocument.defaultView.innerHeight, index).then(function(canvas) {
	          if (typeof(options.onrendered) === "function") {
	              log("options.onrendered is deprecated, html2canvas returns a Promise containing the canvas");
	              options.onrendered(canvas);
	          }
	          return canvas;
	      });
	  }

	  html2canvas.CanvasRenderer = CanvasRenderer;
	  html2canvas.NodeContainer = NodeContainer;
	  html2canvas.log = log;
	  html2canvas.utils = utils;

	  var html2canvasExport = (typeof(document) === "undefined" || typeof(Object.create) !== "function" || typeof(document.createElement("canvas").getContext) !== "function") ? function() {
	      return Promise.reject("No canvas support");
	  } : html2canvas;

	  module.exports = html2canvasExport;

	  if (typeof(define) === 'function' && define.amd && false) {
	      define('html2canvas', [], function() {
	          return html2canvasExport;
	      });
	  }

	  function renderDocument(document, options, windowWidth, windowHeight, html2canvasIndex) {
	      return createWindowClone(document, document, windowWidth, windowHeight, options, document.defaultView.pageXOffset, document.defaultView.pageYOffset).then(function(container) {
	          log("Document cloned");
	          var attributeName = html2canvasNodeAttribute + html2canvasIndex;
	          var selector = "[" + attributeName + "='" + html2canvasIndex + "']";
	          document.querySelector(selector).removeAttribute(attributeName);
	          var clonedWindow = container.contentWindow;
	          var node = clonedWindow.document.querySelector(selector);
	          var oncloneHandler = (typeof(options.onclone) === "function") ? Promise.resolve(options.onclone(clonedWindow.document)) : Promise.resolve(true);
	          return oncloneHandler.then(function() {
	              return renderWindow(node, container, options, windowWidth, windowHeight);
	          });
	      });
	  }

	  function renderWindow(node, container, options, windowWidth, windowHeight) {
	      var clonedWindow = container.contentWindow;
	      var support = new Support(clonedWindow.document);
	      var imageLoader = new ImageLoader(options, support);
	      var bounds = getBounds(node);
	      var width = options.type === "view" ? windowWidth : documentWidth(clonedWindow.document);
	      var height = options.type === "view" ? windowHeight : documentHeight(clonedWindow.document);
	      var renderer = new options.renderer(width, height, imageLoader, options, document);
	      var parser = new NodeParser(node, renderer, support, imageLoader, options);
	      return parser.ready.then(function() {
	          log("Finished rendering");
	          var canvas;

	          if (options.type === "view") {
	              canvas = crop(renderer.canvas, {width: renderer.canvas.width, height: renderer.canvas.height, top: 0, left: 0, x: 0, y: 0});
	          } else if (node === clonedWindow.document.body || node === clonedWindow.document.documentElement || options.canvas != null) {
	              canvas = renderer.canvas;
	          } else {
	              canvas = crop(renderer.canvas, {width:  options.width != null ? options.width : bounds.width, height: options.height != null ? options.height : bounds.height, top: bounds.top, left: bounds.left, x: 0, y: 0});
	          }

	          cleanupContainer(container, options);
	          return canvas;
	      });
	  }

	  function cleanupContainer(container, options) {
	      if (options.removeContainer) {
	          container.parentNode.removeChild(container);
	          log("Cleaned up container");
	      }
	  }

	  function crop(canvas, bounds) {
	      var croppedCanvas = document.createElement("canvas");
	      var x1 = Math.min(canvas.width - 1, Math.max(0, bounds.left));
	      var x2 = Math.min(canvas.width, Math.max(1, bounds.left + bounds.width));
	      var y1 = Math.min(canvas.height - 1, Math.max(0, bounds.top));
	      var y2 = Math.min(canvas.height, Math.max(1, bounds.top + bounds.height));
	      croppedCanvas.width = bounds.width;
	      croppedCanvas.height =  bounds.height;
	      var width = x2-x1;
	      var height = y2-y1;
	      log("Cropping canvas at:", "left:", bounds.left, "top:", bounds.top, "width:", width, "height:", height);
	      log("Resulting crop with width", bounds.width, "and height", bounds.height, "with x", x1, "and y", y1);
	      croppedCanvas.getContext("2d").drawImage(canvas, x1, y1, width, height, bounds.x, bounds.y, width, height);
	      return croppedCanvas;
	  }

	  function documentWidth (doc) {
	      return Math.max(
	          Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),
	          Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),
	          Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)
	      );
	  }

	  function documentHeight (doc) {
	      return Math.max(
	          Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),
	          Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),
	          Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)
	      );
	  }

	  function absoluteUrl(url) {
	      var link = document.createElement("a");
	      link.href = url;
	      link.href = link.href;
	      return link;
	  }

	  },{"./clone":2,"./imageloader":11,"./log":13,"./nodecontainer":14,"./nodeparser":15,"./proxy":16,"./renderers/canvas":20,"./support":22,"./utils":26}],5:[function(_dereq_,module,exports){
	  var log = _dereq_('./log');
	  var smallImage = _dereq_('./utils').smallImage;

	  function DummyImageContainer(src) {
	      this.src = src;
	      log("DummyImageContainer for", src);
	      if (!this.promise || !this.image) {
	          log("Initiating DummyImageContainer");
	          DummyImageContainer.prototype.image = new Image();
	          var image = this.image;
	          DummyImageContainer.prototype.promise = new Promise(function(resolve, reject) {
	              image.onload = resolve;
	              image.onerror = reject;
	              image.src = smallImage();
	              if (image.complete === true) {
	                  resolve(image);
	              }
	          });
	      }
	  }

	  module.exports = DummyImageContainer;

	  },{"./log":13,"./utils":26}],6:[function(_dereq_,module,exports){
	  var smallImage = _dereq_('./utils').smallImage;

	  function Font(family, size) {
	      var container = document.createElement('div'),
	          img = document.createElement('img'),
	          span = document.createElement('span'),
	          sampleText = 'Hidden Text',
	          baseline,
	          middle;

	      container.style.visibility = "hidden";
	      container.style.fontFamily = family;
	      container.style.fontSize = size;
	      container.style.margin = 0;
	      container.style.padding = 0;

	      document.body.appendChild(container);

	      img.src = smallImage();
	      img.width = 1;
	      img.height = 1;

	      img.style.margin = 0;
	      img.style.padding = 0;
	      img.style.verticalAlign = "baseline";

	      span.style.fontFamily = family;
	      span.style.fontSize = size;
	      span.style.margin = 0;
	      span.style.padding = 0;

	      span.appendChild(document.createTextNode(sampleText));
	      container.appendChild(span);
	      container.appendChild(img);
	      baseline = (img.offsetTop - span.offsetTop) + 1;

	      container.removeChild(span);
	      container.appendChild(document.createTextNode(sampleText));

	      container.style.lineHeight = "normal";
	      img.style.verticalAlign = "super";

	      middle = (img.offsetTop-container.offsetTop) + 1;

	      document.body.removeChild(container);

	      this.baseline = baseline;
	      this.lineWidth = 1;
	      this.middle = middle;
	  }

	  module.exports = Font;

	  },{"./utils":26}],7:[function(_dereq_,module,exports){
	  var Font = _dereq_('./font');

	  function FontMetrics() {
	      this.data = {};
	  }

	  FontMetrics.prototype.getMetrics = function(family, size) {
	      if (this.data[family + "-" + size] === undefined) {
	          this.data[family + "-" + size] = new Font(family, size);
	      }
	      return this.data[family + "-" + size];
	  };

	  module.exports = FontMetrics;

	  },{"./font":6}],8:[function(_dereq_,module,exports){
	  var utils = _dereq_('./utils');
	  var getBounds = utils.getBounds;
	  var loadUrlDocument = _dereq_('./proxy').loadUrlDocument;

	  function FrameContainer(container, sameOrigin, options) {
	      this.image = null;
	      this.src = container;
	      var self = this;
	      var bounds = getBounds(container);
	      this.promise = (!sameOrigin ? this.proxyLoad(options.proxy, bounds, options) : new Promise(function(resolve) {
	          if (container.contentWindow.document.URL === "about:blank" || container.contentWindow.document.documentElement == null) {
	              container.contentWindow.onload = container.onload = function() {
	                  resolve(container);
	              };
	          } else {
	              resolve(container);
	          }
	      })).then(function(container) {
	          var html2canvas = _dereq_('./core');
	          return html2canvas(container.contentWindow.document.documentElement, {type: 'view', width: container.width, height: container.height, proxy: options.proxy, javascriptEnabled: options.javascriptEnabled, removeContainer: options.removeContainer, allowTaint: options.allowTaint, imageTimeout: options.imageTimeout / 2});
	      }).then(function(canvas) {
	          return self.image = canvas;
	      });
	  }

	  FrameContainer.prototype.proxyLoad = function(proxy, bounds, options) {
	      var container = this.src;
	      return loadUrlDocument(container.src, proxy, container.ownerDocument, bounds.width, bounds.height, options);
	  };

	  module.exports = FrameContainer;

	  },{"./core":4,"./proxy":16,"./utils":26}],9:[function(_dereq_,module,exports){
	  function GradientContainer(imageData) {
	      this.src = imageData.value;
	      this.colorStops = [];
	      this.type = null;
	      this.x0 = 0.5;
	      this.y0 = 0.5;
	      this.x1 = 0.5;
	      this.y1 = 0.5;
	      this.promise = Promise.resolve(true);
	  }

	  GradientContainer.TYPES = {
	      LINEAR: 1,
	      RADIAL: 2
	  };

	  // TODO: support hsl[a], negative %/length values
	  // TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
	  GradientContainer.REGEXP_COLORSTOP = /^\s*(rgba?\(\s*\d{1,3},\s*\d{1,3},\s*\d{1,3}(?:,\s*[0-9\.]+)?\s*\)|[a-z]{3,20}|#[a-f0-9]{3,6})(?:\s+(\d{1,3}(?:\.\d+)?)(%|px)?)?(?:\s|$)/i;

	  module.exports = GradientContainer;

	  },{}],10:[function(_dereq_,module,exports){
	  function ImageContainer(src, cors) {
	      this.src = src;
	      this.image = new Image();
	      var self = this;
	      this.tainted = null;
	      this.promise = new Promise(function(resolve, reject) {
	          self.image.onload = resolve;
	          self.image.onerror = reject;
	          if (cors) {
	              self.image.crossOrigin = "anonymous";
	          }
	          self.image.src = src;
	          if (self.image.complete === true) {
	              resolve(self.image);
	          }
	      });
	  }

	  module.exports = ImageContainer;

	  },{}],11:[function(_dereq_,module,exports){
	  var log = _dereq_('./log');
	  var ImageContainer = _dereq_('./imagecontainer');
	  var DummyImageContainer = _dereq_('./dummyimagecontainer');
	  var ProxyImageContainer = _dereq_('./proxyimagecontainer');
	  var FrameContainer = _dereq_('./framecontainer');
	  var SVGContainer = _dereq_('./svgcontainer');
	  var SVGNodeContainer = _dereq_('./svgnodecontainer');
	  var LinearGradientContainer = _dereq_('./lineargradientcontainer');
	  var WebkitGradientContainer = _dereq_('./webkitgradientcontainer');
	  var bind = _dereq_('./utils').bind;

	  function ImageLoader(options, support) {
	      this.link = null;
	      this.options = options;
	      this.support = support;
	      this.origin = this.getOrigin(window.location.href);
	  }

	  ImageLoader.prototype.findImages = function(nodes) {
	      var images = [];
	      nodes.reduce(function(imageNodes, container) {
	          switch(container.node.nodeName) {
	          case "IMG":
	              return imageNodes.concat([{
	                  args: [container.node.src],
	                  method: "url"
	              }]);
	          case "svg":
	          case "IFRAME":
	              return imageNodes.concat([{
	                  args: [container.node],
	                  method: container.node.nodeName
	              }]);
	          }
	          return imageNodes;
	      }, []).forEach(this.addImage(images, this.loadImage), this);
	      return images;
	  };

	  ImageLoader.prototype.findBackgroundImage = function(images, container) {
	      container.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(images, this.loadImage), this);
	      return images;
	  };

	  ImageLoader.prototype.addImage = function(images, callback) {
	      return function(newImage) {
	          newImage.args.forEach(function(image) {
	              if (!this.imageExists(images, image)) {
	                  images.splice(0, 0, callback.call(this, newImage));
	                  log('Added image #' + (images.length), typeof(image) === "string" ? image.substring(0, 100) : image);
	              }
	          }, this);
	      };
	  };

	  ImageLoader.prototype.hasImageBackground = function(imageData) {
	      return imageData.method !== "none";
	  };

	  ImageLoader.prototype.loadImage = function(imageData) {
	      if (imageData.method === "url") {
	          var src = imageData.args[0];
	          if (this.isSVG(src) && !this.support.svg && !this.options.allowTaint) {
	              return new SVGContainer(src);
	          } else if (src.match(/data:image\/.*;base64,/i)) {
	              return new ImageContainer(src.replace(/url\(['"]{0,}|['"]{0,}\)$/ig, ''), false);
	          } else if (this.isSameOrigin(src) || this.options.allowTaint === true || this.isSVG(src)) {
	              return new ImageContainer(src, false);
	          } else if (this.support.cors && !this.options.allowTaint && this.options.useCORS) {
	              return new ImageContainer(src, true);
	          } else if (this.options.proxy) {
	              return new ProxyImageContainer(src, this.options.proxy);
	          } else {
	              return new DummyImageContainer(src);
	          }
	      } else if (imageData.method === "linear-gradient") {
	          return new LinearGradientContainer(imageData);
	      } else if (imageData.method === "gradient") {
	          return new WebkitGradientContainer(imageData);
	      } else if (imageData.method === "svg") {
	          return new SVGNodeContainer(imageData.args[0], this.support.svg);
	      } else if (imageData.method === "IFRAME") {
	          return new FrameContainer(imageData.args[0], this.isSameOrigin(imageData.args[0].src), this.options);
	      } else {
	          return new DummyImageContainer(imageData);
	      }
	  };

	  ImageLoader.prototype.isSVG = function(src) {
	      return src.substring(src.length - 3).toLowerCase() === "svg" || SVGContainer.prototype.isInline(src);
	  };

	  ImageLoader.prototype.imageExists = function(images, src) {
	      return images.some(function(image) {
	          return image.src === src;
	      });
	  };

	  ImageLoader.prototype.isSameOrigin = function(url) {
	      return (this.getOrigin(url) === this.origin);
	  };

	  ImageLoader.prototype.getOrigin = function(url) {
	      var link = this.link || (this.link = document.createElement("a"));
	      link.href = url;
	      link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
	      return link.protocol + link.hostname + link.port;
	  };

	  ImageLoader.prototype.getPromise = function(container) {
	      return this.timeout(container, this.options.imageTimeout)['catch'](function() {
	          var dummy = new DummyImageContainer(container.src);
	          return dummy.promise.then(function(image) {
	              container.image = image;
	          });
	      });
	  };

	  ImageLoader.prototype.get = function(src) {
	      var found = null;
	      return this.images.some(function(img) {
	          return (found = img).src === src;
	      }) ? found : null;
	  };

	  ImageLoader.prototype.fetch = function(nodes) {
	      this.images = nodes.reduce(bind(this.findBackgroundImage, this), this.findImages(nodes));
	      this.images.forEach(function(image, index) {
	          image.promise.then(function() {
	              log("Succesfully loaded image #"+ (index+1), image);
	          }, function(e) {
	              log("Failed loading image #"+ (index+1), image, e);
	          });
	      });
	      this.ready = Promise.all(this.images.map(this.getPromise, this));
	      log("Finished searching images");
	      return this;
	  };

	  ImageLoader.prototype.timeout = function(container, timeout) {
	      var timer;
	      var promise = Promise.race([container.promise, new Promise(function(res, reject) {
	          timer = setTimeout(function() {
	              log("Timed out loading image", container);
	              reject(container);
	          }, timeout);
	      })]).then(function(container) {
	          clearTimeout(timer);
	          return container;
	      });
	      promise['catch'](function() {
	          clearTimeout(timer);
	      });
	      return promise;
	  };

	  module.exports = ImageLoader;

	  },{"./dummyimagecontainer":5,"./framecontainer":8,"./imagecontainer":10,"./lineargradientcontainer":12,"./log":13,"./proxyimagecontainer":17,"./svgcontainer":23,"./svgnodecontainer":24,"./utils":26,"./webkitgradientcontainer":27}],12:[function(_dereq_,module,exports){
	  var GradientContainer = _dereq_('./gradientcontainer');
	  var Color = _dereq_('./color');

	  function LinearGradientContainer(imageData) {
	      GradientContainer.apply(this, arguments);
	      this.type = GradientContainer.TYPES.LINEAR;

	      var hasDirection = LinearGradientContainer.REGEXP_DIRECTION.test( imageData.args[0] ) ||
	          !GradientContainer.REGEXP_COLORSTOP.test( imageData.args[0] );

	      if (hasDirection) {
	          imageData.args[0].split(/\s+/).reverse().forEach(function(position, index) {
	              switch(position) {
	              case "left":
	                  this.x0 = 0;
	                  this.x1 = 1;
	                  break;
	              case "top":
	                  this.y0 = 0;
	                  this.y1 = 1;
	                  break;
	              case "right":
	                  this.x0 = 1;
	                  this.x1 = 0;
	                  break;
	              case "bottom":
	                  this.y0 = 1;
	                  this.y1 = 0;
	                  break;
	              case "to":
	                  var y0 = this.y0;
	                  var x0 = this.x0;
	                  this.y0 = this.y1;
	                  this.x0 = this.x1;
	                  this.x1 = x0;
	                  this.y1 = y0;
	                  break;
	              case "center":
	                  break; // centered by default
	              // Firefox internally converts position keywords to percentages:
	              // http://www.w3.org/TR/2010/WD-CSS2-20101207/colors.html#propdef-background-position
	              default: // percentage or absolute length
	                  // TODO: support absolute start point positions (e.g., use bounds to convert px to a ratio)
	                  var ratio = parseFloat(position, 10) * 1e-2;
	                  if (isNaN(ratio)) { // invalid or unhandled value
	                      break;
	                  }
	                  if (index === 0) {
	                      this.y0 = ratio;
	                      this.y1 = 1 - this.y0;
	                  } else {
	                      this.x0 = ratio;
	                      this.x1 = 1 - this.x0;
	                  }
	                  break;
	              }
	          }, this);
	      } else {
	          this.y0 = 0;
	          this.y1 = 1;
	      }

	      this.colorStops = imageData.args.slice(hasDirection ? 1 : 0).map(function(colorStop) {
	          var colorStopMatch = colorStop.match(GradientContainer.REGEXP_COLORSTOP);
	          var value = +colorStopMatch[2];
	          var unit = value === 0 ? "%" : colorStopMatch[3]; // treat "0" as "0%"
	          return {
	              color: new Color(colorStopMatch[1]),
	              // TODO: support absolute stop positions (e.g., compute gradient line length & convert px to ratio)
	              stop: unit === "%" ? value / 100 : null
	          };
	      });

	      if (this.colorStops[0].stop === null) {
	          this.colorStops[0].stop = 0;
	      }

	      if (this.colorStops[this.colorStops.length - 1].stop === null) {
	          this.colorStops[this.colorStops.length - 1].stop = 1;
	      }

	      // calculates and fills-in explicit stop positions when omitted from rule
	      this.colorStops.forEach(function(colorStop, index) {
	          if (colorStop.stop === null) {
	              this.colorStops.slice(index).some(function(find, count) {
	                  if (find.stop !== null) {
	                      colorStop.stop = ((find.stop - this.colorStops[index - 1].stop) / (count + 1)) + this.colorStops[index - 1].stop;
	                      return true;
	                  } else {
	                      return false;
	                  }
	              }, this);
	          }
	      }, this);
	  }

	  LinearGradientContainer.prototype = Object.create(GradientContainer.prototype);

	  // TODO: support <angle> (e.g. -?\d{1,3}(?:\.\d+)deg, etc. : https://developer.mozilla.org/docs/Web/CSS/angle )
	  LinearGradientContainer.REGEXP_DIRECTION = /^\s*(?:to|left|right|top|bottom|center|\d{1,3}(?:\.\d+)?%?)(?:\s|$)/i;

	  module.exports = LinearGradientContainer;

	  },{"./color":3,"./gradientcontainer":9}],13:[function(_dereq_,module,exports){
	  var logger = function() {
	      if (logger.options.logging && window.console && window.console.log) {
	          Function.prototype.bind.call(window.console.log, (window.console)).apply(window.console, [(Date.now() - logger.options.start) + "ms", "html2canvas:"].concat([].slice.call(arguments, 0)));
	      }
	  };

	  logger.options = {logging: false};
	  module.exports = logger;

	  },{}],14:[function(_dereq_,module,exports){
	  var Color = _dereq_('./color');
	  var utils = _dereq_('./utils');
	  var getBounds = utils.getBounds;
	  var parseBackgrounds = utils.parseBackgrounds;
	  var offsetBounds = utils.offsetBounds;

	  function NodeContainer(node, parent) {
	      this.node = node;
	      this.parent = parent;
	      this.stack = null;
	      this.bounds = null;
	      this.borders = null;
	      this.clip = [];
	      this.backgroundClip = [];
	      this.offsetBounds = null;
	      this.visible = null;
	      this.computedStyles = null;
	      this.colors = {};
	      this.styles = {};
	      this.backgroundImages = null;
	      this.transformData = null;
	      this.transformMatrix = null;
	      this.isPseudoElement = false;
	      this.opacity = null;
	  }

	  NodeContainer.prototype.cloneTo = function(stack) {
	      stack.visible = this.visible;
	      stack.borders = this.borders;
	      stack.bounds = this.bounds;
	      stack.clip = this.clip;
	      stack.backgroundClip = this.backgroundClip;
	      stack.computedStyles = this.computedStyles;
	      stack.styles = this.styles;
	      stack.backgroundImages = this.backgroundImages;
	      stack.opacity = this.opacity;
	  };

	  NodeContainer.prototype.getOpacity = function() {
	      return this.opacity === null ? (this.opacity = this.cssFloat('opacity')) : this.opacity;
	  };

	  NodeContainer.prototype.assignStack = function(stack) {
	      this.stack = stack;
	      stack.children.push(this);
	  };

	  NodeContainer.prototype.isElementVisible = function() {
	      return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : (
	          this.css('display') !== "none" &&
	          this.css('visibility') !== "hidden" &&
	          !this.node.hasAttribute("data-html2canvas-ignore") &&
	          (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden")
	      );
	  };

	  NodeContainer.prototype.css = function(attribute) {
	      if (!this.computedStyles) {
	          this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null);
	      }

	      return this.styles[attribute] || (this.styles[attribute] = this.computedStyles[attribute]);
	  };

	  NodeContainer.prototype.prefixedCss = function(attribute) {
	      var prefixes = ["webkit", "moz", "ms", "o"];
	      var value = this.css(attribute);
	      if (value === undefined) {
	          prefixes.some(function(prefix) {
	              value = this.css(prefix + attribute.substr(0, 1).toUpperCase() + attribute.substr(1));
	              return value !== undefined;
	          }, this);
	      }
	      return value === undefined ? null : value;
	  };

	  NodeContainer.prototype.computedStyle = function(type) {
	      return this.node.ownerDocument.defaultView.getComputedStyle(this.node, type);
	  };

	  NodeContainer.prototype.cssInt = function(attribute) {
	      var value = parseInt(this.css(attribute), 10);
	      return (isNaN(value)) ? 0 : value; // borders in old IE are throwing 'medium' for demo.html
	  };

	  NodeContainer.prototype.color = function(attribute) {
	      return this.colors[attribute] || (this.colors[attribute] = new Color(this.css(attribute)));
	  };

	  NodeContainer.prototype.cssFloat = function(attribute) {
	      var value = parseFloat(this.css(attribute));
	      return (isNaN(value)) ? 0 : value;
	  };

	  NodeContainer.prototype.fontWeight = function() {
	      var weight = this.css("fontWeight");
	      switch(parseInt(weight, 10)){
	      case 401:
	          weight = "bold";
	          break;
	      case 400:
	          weight = "normal";
	          break;
	      }
	      return weight;
	  };

	  NodeContainer.prototype.parseClip = function() {
	      var matches = this.css('clip').match(this.CLIP);
	      if (matches) {
	          return {
	              top: parseInt(matches[1], 10),
	              right: parseInt(matches[2], 10),
	              bottom: parseInt(matches[3], 10),
	              left: parseInt(matches[4], 10)
	          };
	      }
	      return null;
	  };

	  NodeContainer.prototype.parseBackgroundImages = function() {
	      return this.backgroundImages || (this.backgroundImages = parseBackgrounds(this.css("backgroundImage")));
	  };

	  NodeContainer.prototype.cssList = function(property, index) {
	      var value = (this.css(property) || '').split(',');
	      value = value[index || 0] || value[0] || 'auto';
	      value = value.trim().split(' ');
	      if (value.length === 1) {
	          value = [value[0], isPercentage(value[0]) ? 'auto' : value[0]];
	      }
	      return value;
	  };

	  NodeContainer.prototype.parseBackgroundSize = function(bounds, image, index) {
	      var size = this.cssList("backgroundSize", index);
	      var width, height;

	      if (isPercentage(size[0])) {
	          width = bounds.width * parseFloat(size[0]) / 100;
	      } else if (/contain|cover/.test(size[0])) {
	          var targetRatio = bounds.width / bounds.height, currentRatio = image.width / image.height;
	          return (targetRatio < currentRatio ^ size[0] === 'contain') ?  {width: bounds.height * currentRatio, height: bounds.height} : {width: bounds.width, height: bounds.width / currentRatio};
	      } else {
	          width = parseInt(size[0], 10);
	      }

	      if (size[0] === 'auto' && size[1] === 'auto') {
	          height = image.height;
	      } else if (size[1] === 'auto') {
	          height = width / image.width * image.height;
	      } else if (isPercentage(size[1])) {
	          height =  bounds.height * parseFloat(size[1]) / 100;
	      } else {
	          height = parseInt(size[1], 10);
	      }

	      if (size[0] === 'auto') {
	          width = height / image.height * image.width;
	      }

	      return {width: width, height: height};
	  };

	  NodeContainer.prototype.parseBackgroundPosition = function(bounds, image, index, backgroundSize) {
	      var position = this.cssList('backgroundPosition', index);
	      var left, top;

	      if (isPercentage(position[0])){
	          left = (bounds.width - (backgroundSize || image).width) * (parseFloat(position[0]) / 100);
	      } else {
	          left = parseInt(position[0], 10);
	      }

	      if (position[1] === 'auto') {
	          top = left / image.width * image.height;
	      } else if (isPercentage(position[1])){
	          top =  (bounds.height - (backgroundSize || image).height) * parseFloat(position[1]) / 100;
	      } else {
	          top = parseInt(position[1], 10);
	      }

	      if (position[0] === 'auto') {
	          left = top / image.height * image.width;
	      }

	      return {left: left, top: top};
	  };

	  NodeContainer.prototype.parseBackgroundRepeat = function(index) {
	      return this.cssList("backgroundRepeat", index)[0];
	  };

	  NodeContainer.prototype.parseTextShadows = function() {
	      var textShadow = this.css("textShadow");
	      var results = [];

	      if (textShadow && textShadow !== 'none') {
	          var shadows = textShadow.match(this.TEXT_SHADOW_PROPERTY);
	          for (var i = 0; shadows && (i < shadows.length); i++) {
	              var s = shadows[i].match(this.TEXT_SHADOW_VALUES);
	              results.push({
	                  color: new Color(s[0]),
	                  offsetX: s[1] ? parseFloat(s[1].replace('px', '')) : 0,
	                  offsetY: s[2] ? parseFloat(s[2].replace('px', '')) : 0,
	                  blur: s[3] ? s[3].replace('px', '') : 0
	              });
	          }
	      }
	      return results;
	  };

	  NodeContainer.prototype.parseTransform = function() {
	      if (!this.transformData) {
	          if (this.hasTransform()) {
	              var offset = this.parseBounds();
	              var origin = this.prefixedCss("transformOrigin").split(" ").map(removePx).map(asFloat);
	              origin[0] += offset.left;
	              origin[1] += offset.top;
	              this.transformData = {
	                  origin: origin,
	                  matrix: this.parseTransformMatrix()
	              };
	          } else {
	              this.transformData = {
	                  origin: [0, 0],
	                  matrix: [1, 0, 0, 1, 0, 0]
	              };
	          }
	      }
	      return this.transformData;
	  };

	  NodeContainer.prototype.parseTransformMatrix = function() {
	      if (!this.transformMatrix) {
	          var transform = this.prefixedCss("transform");
	          var matrix = transform ? parseMatrix(transform.match(this.MATRIX_PROPERTY)) : null;
	          this.transformMatrix = matrix ? matrix : [1, 0, 0, 1, 0, 0];
	      }
	      return this.transformMatrix;
	  };

	  NodeContainer.prototype.parseBounds = function() {
	      return this.bounds || (this.bounds = this.hasTransform() ? offsetBounds(this.node) : getBounds(this.node));
	  };

	  NodeContainer.prototype.hasTransform = function() {
	      return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || (this.parent && this.parent.hasTransform());
	  };

	  NodeContainer.prototype.getValue = function() {
	      var value = this.node.value || "";
	      if (this.node.tagName === "SELECT") {
	          value = selectionValue(this.node);
	      } else if (this.node.type === "password") {
	          value = Array(value.length + 1).join('\u2022'); // jshint ignore:line
	      }
	      return value.length === 0 ? (this.node.placeholder || "") : value;
	  };

	  NodeContainer.prototype.MATRIX_PROPERTY = /(matrix|matrix3d)\((.+)\)/;
	  NodeContainer.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g;
	  NodeContainer.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g;
	  NodeContainer.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/;

	  function selectionValue(node) {
	      var option = node.options[node.selectedIndex || 0];
	      return option ? (option.text || "") : "";
	  }

	  function parseMatrix(match) {
	      if (match && match[1] === "matrix") {
	          return match[2].split(",").map(function(s) {
	              return parseFloat(s.trim());
	          });
	      } else if (match && match[1] === "matrix3d") {
	          var matrix3d = match[2].split(",").map(function(s) {
	            return parseFloat(s.trim());
	          });
	          return [matrix3d[0], matrix3d[1], matrix3d[4], matrix3d[5], matrix3d[12], matrix3d[13]];
	      }
	  }

	  function isPercentage(value) {
	      return value.toString().indexOf("%") !== -1;
	  }

	  function removePx(str) {
	      return str.replace("px", "");
	  }

	  function asFloat(str) {
	      return parseFloat(str);
	  }

	  module.exports = NodeContainer;

	  },{"./color":3,"./utils":26}],15:[function(_dereq_,module,exports){
	  var log = _dereq_('./log');
	  var punycode = _dereq_('punycode');
	  var NodeContainer = _dereq_('./nodecontainer');
	  var TextContainer = _dereq_('./textcontainer');
	  var PseudoElementContainer = _dereq_('./pseudoelementcontainer');
	  var FontMetrics = _dereq_('./fontmetrics');
	  var Color = _dereq_('./color');
	  var StackingContext = _dereq_('./stackingcontext');
	  var utils = _dereq_('./utils');
	  var bind = utils.bind;
	  var getBounds = utils.getBounds;
	  var parseBackgrounds = utils.parseBackgrounds;
	  var offsetBounds = utils.offsetBounds;

	  function NodeParser(element, renderer, support, imageLoader, options) {
	      log("Starting NodeParser");
	      this.renderer = renderer;
	      this.options = options;
	      this.range = null;
	      this.support = support;
	      this.renderQueue = [];
	      this.stack = new StackingContext(true, 1, element.ownerDocument, null);
	      var parent = new NodeContainer(element, null);
	      if (options.background) {
	          renderer.rectangle(0, 0, renderer.width, renderer.height, new Color(options.background));
	      }
	      if (element === element.ownerDocument.documentElement) {
	          // http://www.w3.org/TR/css3-background/#special-backgrounds
	          var canvasBackground = new NodeContainer(parent.color('backgroundColor').isTransparent() ? element.ownerDocument.body : element.ownerDocument.documentElement, null);
	          renderer.rectangle(0, 0, renderer.width, renderer.height, canvasBackground.color('backgroundColor'));
	      }
	      parent.visibile = parent.isElementVisible();
	      this.createPseudoHideStyles(element.ownerDocument);
	      this.disableAnimations(element.ownerDocument);
	      this.nodes = flatten([parent].concat(this.getChildren(parent)).filter(function(container) {
	          return container.visible = container.isElementVisible();
	      }).map(this.getPseudoElements, this));
	      this.fontMetrics = new FontMetrics();
	      log("Fetched nodes, total:", this.nodes.length);
	      log("Calculate overflow clips");
	      this.calculateOverflowClips();
	      log("Start fetching images");
	      this.images = imageLoader.fetch(this.nodes.filter(isElement));
	      this.ready = this.images.ready.then(bind(function() {
	          log("Images loaded, starting parsing");
	          log("Creating stacking contexts");
	          this.createStackingContexts();
	          log("Sorting stacking contexts");
	          this.sortStackingContexts(this.stack);
	          this.parse(this.stack);
	          log("Render queue created with " + this.renderQueue.length + " items");
	          return new Promise(bind(function(resolve) {
	              if (!options.async) {
	                  this.renderQueue.forEach(this.paint, this);
	                  resolve();
	              } else if (typeof(options.async) === "function") {
	                  options.async.call(this, this.renderQueue, resolve);
	              } else if (this.renderQueue.length > 0){
	                  this.renderIndex = 0;
	                  this.asyncRenderer(this.renderQueue, resolve);
	              } else {
	                  resolve();
	              }
	          }, this));
	      }, this));
	  }

	  NodeParser.prototype.calculateOverflowClips = function() {
	      this.nodes.forEach(function(container) {
	          if (isElement(container)) {
	              if (isPseudoElement(container)) {
	                  container.appendToDOM();
	              }
	              container.borders = this.parseBorders(container);
	              var clip = (container.css('overflow') === "hidden") ? [container.borders.clip] : [];
	              var cssClip = container.parseClip();
	              if (cssClip && ["absolute", "fixed"].indexOf(container.css('position')) !== -1) {
	                  clip.push([["rect",
	                          container.bounds.left + cssClip.left,
	                          container.bounds.top + cssClip.top,
	                          cssClip.right - cssClip.left,
	                          cssClip.bottom - cssClip.top
	                  ]]);
	              }
	              container.clip = hasParentClip(container) ? container.parent.clip.concat(clip) : clip;
	              container.backgroundClip = (container.css('overflow') !== "hidden") ? container.clip.concat([container.borders.clip]) : container.clip;
	              if (isPseudoElement(container)) {
	                  container.cleanDOM();
	              }
	          } else if (isTextNode(container)) {
	              container.clip = hasParentClip(container) ? container.parent.clip : [];
	          }
	          if (!isPseudoElement(container)) {
	              container.bounds = null;
	          }
	      }, this);
	  };

	  function hasParentClip(container) {
	      return container.parent && container.parent.clip.length;
	  }

	  NodeParser.prototype.asyncRenderer = function(queue, resolve, asyncTimer) {
	      asyncTimer = asyncTimer || Date.now();
	      this.paint(queue[this.renderIndex++]);
	      if (queue.length === this.renderIndex) {
	          resolve();
	      } else if (asyncTimer + 20 > Date.now()) {
	          this.asyncRenderer(queue, resolve, asyncTimer);
	      } else {
	          setTimeout(bind(function() {
	              this.asyncRenderer(queue, resolve);
	          }, this), 0);
	      }
	  };

	  NodeParser.prototype.createPseudoHideStyles = function(document) {
	      this.createStyles(document, '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }' +
	          '.' + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
	  };

	  NodeParser.prototype.disableAnimations = function(document) {
	      this.createStyles(document, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; ' +
	          '-webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
	  };

	  NodeParser.prototype.createStyles = function(document, styles) {
	      var hidePseudoElements = document.createElement('style');
	      hidePseudoElements.innerHTML = styles;
	      document.body.appendChild(hidePseudoElements);
	  };

	  NodeParser.prototype.getPseudoElements = function(container) {
	      var nodes = [[container]];
	      if (container.node.nodeType === Node.ELEMENT_NODE) {
	          var before = this.getPseudoElement(container, ":before");
	          var after = this.getPseudoElement(container, ":after");

	          if (before) {
	              nodes.push(before);
	          }

	          if (after) {
	              nodes.push(after);
	          }
	      }
	      return flatten(nodes);
	  };

	  function toCamelCase(str) {
	      return str.replace(/(\-[a-z])/g, function(match){
	          return match.toUpperCase().replace('-','');
	      });
	  }

	  NodeParser.prototype.getPseudoElement = function(container, type) {
	      var style = container.computedStyle(type);
	      if(!style || !style.content || style.content === "none" || style.content === "-moz-alt-content" || style.display === "none") {
	          return null;
	      }

	      var content = stripQuotes(style.content);
	      var isImage = content.substr(0, 3) === 'url';
	      var pseudoNode = document.createElement(isImage ? 'img' : 'html2canvaspseudoelement');
	      var pseudoContainer = new PseudoElementContainer(pseudoNode, container, type);

	      for (var i = style.length-1; i >= 0; i--) {
	          var property = toCamelCase(style.item(i));
	          pseudoNode.style[property] = style[property];
	      }

	      pseudoNode.className = PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER;

	      if (isImage) {
	          pseudoNode.src = parseBackgrounds(content)[0].args[0];
	          return [pseudoContainer];
	      } else {
	          var text = document.createTextNode(content);
	          pseudoNode.appendChild(text);
	          return [pseudoContainer, new TextContainer(text, pseudoContainer)];
	      }
	  };


	  NodeParser.prototype.getChildren = function(parentContainer) {
	      return flatten([].filter.call(parentContainer.node.childNodes, renderableNode).map(function(node) {
	          var container = [node.nodeType === Node.TEXT_NODE ? new TextContainer(node, parentContainer) : new NodeContainer(node, parentContainer)].filter(nonIgnoredElement);
	          return node.nodeType === Node.ELEMENT_NODE && container.length && node.tagName !== "TEXTAREA" ? (container[0].isElementVisible() ? container.concat(this.getChildren(container[0])) : []) : container;
	      }, this));
	  };

	  NodeParser.prototype.newStackingContext = function(container, hasOwnStacking) {
	      var stack = new StackingContext(hasOwnStacking, container.getOpacity(), container.node, container.parent);
	      container.cloneTo(stack);
	      var parentStack = hasOwnStacking ? stack.getParentStack(this) : stack.parent.stack;
	      parentStack.contexts.push(stack);
	      container.stack = stack;
	  };

	  NodeParser.prototype.createStackingContexts = function() {
	      this.nodes.forEach(function(container) {
	          if (isElement(container) && (this.isRootElement(container) || hasOpacity(container) || isPositionedForStacking(container) || this.isBodyWithTransparentRoot(container) || container.hasTransform())) {
	              this.newStackingContext(container, true);
	          } else if (isElement(container) && ((isPositioned(container) && zIndex0(container)) || isInlineBlock(container) || isFloating(container))) {
	              this.newStackingContext(container, false);
	          } else {
	              container.assignStack(container.parent.stack);
	          }
	      }, this);
	  };

	  NodeParser.prototype.isBodyWithTransparentRoot = function(container) {
	      return container.node.nodeName === "BODY" && container.parent.color('backgroundColor').isTransparent();
	  };

	  NodeParser.prototype.isRootElement = function(container) {
	      return container.parent === null;
	  };

	  NodeParser.prototype.sortStackingContexts = function(stack) {
	      stack.contexts.sort(zIndexSort(stack.contexts.slice(0)));
	      stack.contexts.forEach(this.sortStackingContexts, this);
	  };

	  NodeParser.prototype.parseTextBounds = function(container) {
	      return function(text, index, textList) {
	          if (container.parent.css("textDecoration").substr(0, 4) !== "none" || text.trim().length !== 0) {
	              if (this.support.rangeBounds && !container.parent.hasTransform()) {
	                  var offset = textList.slice(0, index).join("").length;
	                  return this.getRangeBounds(container.node, offset, text.length);
	              } else if (container.node && typeof(container.node.data) === "string") {
	                  var replacementNode = container.node.splitText(text.length);
	                  var bounds = this.getWrapperBounds(container.node, container.parent.hasTransform());
	                  container.node = replacementNode;
	                  return bounds;
	              }
	          } else if(!this.support.rangeBounds || container.parent.hasTransform()){
	              container.node = container.node.splitText(text.length);
	          }
	          return {};
	      };
	  };

	  NodeParser.prototype.getWrapperBounds = function(node, transform) {
	      var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
	      var parent = node.parentNode,
	          backupText = node.cloneNode(true);

	      wrapper.appendChild(node.cloneNode(true));
	      parent.replaceChild(wrapper, node);
	      var bounds = transform ? offsetBounds(wrapper) : getBounds(wrapper);
	      parent.replaceChild(backupText, wrapper);
	      return bounds;
	  };

	  NodeParser.prototype.getRangeBounds = function(node, offset, length) {
	      var range = this.range || (this.range = node.ownerDocument.createRange());
	      range.setStart(node, offset);
	      range.setEnd(node, offset + length);
	      return range.getBoundingClientRect();
	  };

	  function ClearTransform() {}

	  NodeParser.prototype.parse = function(stack) {
	      // http://www.w3.org/TR/CSS21/visuren.html#z-index
	      var negativeZindex = stack.contexts.filter(negativeZIndex); // 2. the child stacking contexts with negative stack levels (most negative first).
	      var descendantElements = stack.children.filter(isElement);
	      var descendantNonFloats = descendantElements.filter(not(isFloating));
	      var nonInlineNonPositionedDescendants = descendantNonFloats.filter(not(isPositioned)).filter(not(inlineLevel)); // 3 the in-flow, non-inline-level, non-positioned descendants.
	      var nonPositionedFloats = descendantElements.filter(not(isPositioned)).filter(isFloating); // 4. the non-positioned floats.
	      var inFlow = descendantNonFloats.filter(not(isPositioned)).filter(inlineLevel); // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
	      var stackLevel0 = stack.contexts.concat(descendantNonFloats.filter(isPositioned)).filter(zIndex0); // 6. the child stacking contexts with stack level 0 and the positioned descendants with stack level 0.
	      var text = stack.children.filter(isTextNode).filter(hasText);
	      var positiveZindex = stack.contexts.filter(positiveZIndex); // 7. the child stacking contexts with positive stack levels (least positive first).
	      negativeZindex.concat(nonInlineNonPositionedDescendants).concat(nonPositionedFloats)
	          .concat(inFlow).concat(stackLevel0).concat(text).concat(positiveZindex).forEach(function(container) {
	              this.renderQueue.push(container);
	              if (isStackingContext(container)) {
	                  this.parse(container);
	                  this.renderQueue.push(new ClearTransform());
	              }
	          }, this);
	  };

	  NodeParser.prototype.paint = function(container) {
	      try {
	          if (container instanceof ClearTransform) {
	              this.renderer.ctx.restore();
	          } else if (isTextNode(container)) {
	              if (isPseudoElement(container.parent)) {
	                  container.parent.appendToDOM();
	              }
	              this.paintText(container);
	              if (isPseudoElement(container.parent)) {
	                  container.parent.cleanDOM();
	              }
	          } else {
	              this.paintNode(container);
	          }
	      } catch(e) {
	          log(e);
	          if (this.options.strict) {
	              throw e;
	          }
	      }
	  };

	  NodeParser.prototype.paintNode = function(container) {
	      if (isStackingContext(container)) {
	          this.renderer.setOpacity(container.opacity);
	          this.renderer.ctx.save();
	          if (container.hasTransform()) {
	              this.renderer.setTransform(container.parseTransform());
	          }
	      }

	      if (container.node.nodeName === "INPUT" && container.node.type === "checkbox") {
	          this.paintCheckbox(container);
	      } else if (container.node.nodeName === "INPUT" && container.node.type === "radio") {
	          this.paintRadio(container);
	      } else {
	          this.paintElement(container);
	      }
	  };

	  NodeParser.prototype.paintElement = function(container) {
	      var bounds = container.parseBounds();
	      this.renderer.clip(container.backgroundClip, function() {
	          this.renderer.renderBackground(container, bounds, container.borders.borders.map(getWidth));
	      }, this);

	      this.renderer.clip(container.clip, function() {
	          this.renderer.renderBorders(container.borders.borders);
	      }, this);

	      this.renderer.clip(container.backgroundClip, function() {
	          switch (container.node.nodeName) {
	          case "svg":
	          case "IFRAME":
	              var imgContainer = this.images.get(container.node);
	              if (imgContainer) {
	                  this.renderer.renderImage(container, bounds, container.borders, imgContainer);
	              } else {
	                  log("Error loading <" + container.node.nodeName + ">", container.node);
	              }
	              break;
	          case "IMG":
	              var imageContainer = this.images.get(container.node.src);
	              if (imageContainer) {
	                  this.renderer.renderImage(container, bounds, container.borders, imageContainer);
	              } else {
	                  log("Error loading <img>", container.node.src);
	              }
	              break;
	          case "CANVAS":
	              this.renderer.renderImage(container, bounds, container.borders, {image: container.node});
	              break;
	          case "SELECT":
	          case "INPUT":
	          case "TEXTAREA":
	              this.paintFormValue(container);
	              break;
	          }
	      }, this);
	  };

	  NodeParser.prototype.paintCheckbox = function(container) {
	      var b = container.parseBounds();

	      var size = Math.min(b.width, b.height);
	      var bounds = {width: size - 1, height: size - 1, top: b.top, left: b.left};
	      var r = [3, 3];
	      var radius = [r, r, r, r];
	      var borders = [1,1,1,1].map(function(w) {
	          return {color: new Color('#A5A5A5'), width: w};
	      });

	      var borderPoints = calculateCurvePoints(bounds, radius, borders);

	      this.renderer.clip(container.backgroundClip, function() {
	          this.renderer.rectangle(bounds.left + 1, bounds.top + 1, bounds.width - 2, bounds.height - 2, new Color("#DEDEDE"));
	          this.renderer.renderBorders(calculateBorders(borders, bounds, borderPoints, radius));
	          if (container.node.checked) {
	              this.renderer.font(new Color('#424242'), 'normal', 'normal', 'bold', (size - 3) + "px", 'arial');
	              this.renderer.text("\u2714", bounds.left + size / 6, bounds.top + size - 1);
	          }
	      }, this);
	  };

	  NodeParser.prototype.paintRadio = function(container) {
	      var bounds = container.parseBounds();

	      var size = Math.min(bounds.width, bounds.height) - 2;

	      this.renderer.clip(container.backgroundClip, function() {
	          this.renderer.circleStroke(bounds.left + 1, bounds.top + 1, size, new Color('#DEDEDE'), 1, new Color('#A5A5A5'));
	          if (container.node.checked) {
	              this.renderer.circle(Math.ceil(bounds.left + size / 4) + 1, Math.ceil(bounds.top + size / 4) + 1, Math.floor(size / 2), new Color('#424242'));
	          }
	      }, this);
	  };

	  NodeParser.prototype.paintFormValue = function(container) {
	      var value = container.getValue();
	      if (value.length > 0) {
	          var document = container.node.ownerDocument;
	          var wrapper = document.createElement('html2canvaswrapper');
	          var properties = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color',
	              'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom',
	              'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth',
	              'boxSizing', 'whiteSpace', 'wordWrap'];

	          properties.forEach(function(property) {
	              try {
	                  wrapper.style[property] = container.css(property);
	              } catch(e) {
	                  // Older IE has issues with "border"
	                  log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);
	              }
	          });
	          var bounds = container.parseBounds();
	          wrapper.style.position = "fixed";
	          wrapper.style.left = bounds.left + "px";
	          wrapper.style.top = bounds.top + "px";
	          wrapper.textContent = value;
	          document.body.appendChild(wrapper);
	          this.paintText(new TextContainer(wrapper.firstChild, container));
	          document.body.removeChild(wrapper);
	      }
	  };

	  NodeParser.prototype.paintText = function(container) {
	      container.applyTextTransform();
	      var characters = punycode.ucs2.decode(container.node.data);
	      var textList = (!this.options.letterRendering || noLetterSpacing(container)) && !hasUnicode(container.node.data) ? getWords(characters) : characters.map(function(character) {
	          return punycode.ucs2.encode([character]);
	      });

	      var weight = container.parent.fontWeight();
	      var size = container.parent.css('fontSize');
	      var family = container.parent.css('fontFamily');
	      var shadows = container.parent.parseTextShadows();

	      this.renderer.font(container.parent.color('color'), container.parent.css('fontStyle'), container.parent.css('fontVariant'), weight, size, family);
	      if (shadows.length) {
	          // TODO: support multiple text shadows
	          this.renderer.fontShadow(shadows[0].color, shadows[0].offsetX, shadows[0].offsetY, shadows[0].blur);
	      } else {
	          this.renderer.clearShadow();
	      }

	      this.renderer.clip(container.parent.clip, function() {
	          textList.map(this.parseTextBounds(container), this).forEach(function(bounds, index) {
	              if (bounds && /^\s*$/.test(textList[index]) === false) {
	                  this.renderer.text(textList[index], bounds.left, bounds.bottom);
	                  this.renderTextDecoration(container.parent, bounds, this.fontMetrics.getMetrics(family, size));
	              }
	          }, this);
	      }, this);
	  };

	  NodeParser.prototype.renderTextDecoration = function(container, bounds, metrics) {
	      switch(container.css("textDecoration").split(" ")[0]) {
	      case "underline":
	          // Draws a line at the baseline of the font
	          // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size
	          this.renderer.rectangle(bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, container.color("color"));
	          break;
	      case "overline":
	          this.renderer.rectangle(bounds.left, Math.round(bounds.top), bounds.width, 1, container.color("color"));
	          break;
	      case "line-through":
	          // TODO try and find exact position for line-through
	          this.renderer.rectangle(bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, container.color("color"));
	          break;
	      }
	  };

	  var borderColorTransforms = {
	      inset: [
	          ["darken", 0.60],
	          ["darken", 0.10],
	          ["darken", 0.10],
	          ["darken", 0.60]
	      ]
	  };

	  NodeParser.prototype.parseBorders = function(container) {
	      var nodeBounds = container.parseBounds();
	      var radius = getBorderRadiusData(container);
	      var borders = ["Top", "Right", "Bottom", "Left"].map(function(side, index) {
	          var style = container.css('border' + side + 'Style');
	          var color = container.color('border' + side + 'Color');
	          if (style === "inset" && color.isBlack()) {
	              color = new Color([255, 255, 255, color.a]); // this is wrong, but
	          }
	          var colorTransform = borderColorTransforms[style] ? borderColorTransforms[style][index] : null;
	          return {
	              width: container.cssInt('border' + side + 'Width'),
	              color: colorTransform ? color[colorTransform[0]](colorTransform[1]) : color,
	              args: null
	          };
	      });
	      var borderPoints = calculateCurvePoints(nodeBounds, radius, borders);

	      return {
	          clip: this.parseBackgroundClip(container, borderPoints, borders, radius, nodeBounds),
	          borders: calculateBorders(borders, nodeBounds, borderPoints, radius)
	      };
	  };

	  function calculateBorders(borders, nodeBounds, borderPoints, radius) {
	      return borders.map(function(border, borderSide) {
	          if (border.width > 0) {
	              var bx = nodeBounds.left;
	              var by = nodeBounds.top;
	              var bw = nodeBounds.width;
	              var bh = nodeBounds.height - (borders[2].width);

	              switch(borderSide) {
	              case 0:
	                  // top border
	                  bh = borders[0].width;
	                  border.args = drawSide({
	                          c1: [bx, by],
	                          c2: [bx + bw, by],
	                          c3: [bx + bw - borders[1].width, by + bh],
	                          c4: [bx + borders[3].width, by + bh]
	                      }, radius[0], radius[1],
	                      borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);
	                  break;
	              case 1:
	                  // right border
	                  bx = nodeBounds.left + nodeBounds.width - (borders[1].width);
	                  bw = borders[1].width;

	                  border.args = drawSide({
	                          c1: [bx + bw, by],
	                          c2: [bx + bw, by + bh + borders[2].width],
	                          c3: [bx, by + bh],
	                          c4: [bx, by + borders[0].width]
	                      }, radius[1], radius[2],
	                      borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);
	                  break;
	              case 2:
	                  // bottom border
	                  by = (by + nodeBounds.height) - (borders[2].width);
	                  bh = borders[2].width;
	                  border.args = drawSide({
	                          c1: [bx + bw, by + bh],
	                          c2: [bx, by + bh],
	                          c3: [bx + borders[3].width, by],
	                          c4: [bx + bw - borders[3].width, by]
	                      }, radius[2], radius[3],
	                      borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);
	                  break;
	              case 3:
	                  // left border
	                  bw = borders[3].width;
	                  border.args = drawSide({
	                          c1: [bx, by + bh + borders[2].width],
	                          c2: [bx, by],
	                          c3: [bx + bw, by + borders[0].width],
	                          c4: [bx + bw, by + bh]
	                      }, radius[3], radius[0],
	                      borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);
	                  break;
	              }
	          }
	          return border;
	      });
	  }

	  NodeParser.prototype.parseBackgroundClip = function(container, borderPoints, borders, radius, bounds) {
	      var backgroundClip = container.css('backgroundClip'),
	          borderArgs = [];

	      switch(backgroundClip) {
	      case "content-box":
	      case "padding-box":
	          parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);
	          parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);
	          parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);
	          parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);
	          break;

	      default:
	          parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);
	          parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);
	          parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);
	          parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);
	          break;
	      }

	      return borderArgs;
	  };

	  function getCurvePoints(x, y, r1, r2) {
	      var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
	      var ox = (r1) * kappa, // control point offset horizontal
	          oy = (r2) * kappa, // control point offset vertical
	          xm = x + r1, // x-middle
	          ym = y + r2; // y-middle
	      return {
	          topLeft: bezierCurve({x: x, y: ym}, {x: x, y: ym - oy}, {x: xm - ox, y: y}, {x: xm, y: y}),
	          topRight: bezierCurve({x: x, y: y}, {x: x + ox,y: y}, {x: xm, y: ym - oy}, {x: xm, y: ym}),
	          bottomRight: bezierCurve({x: xm, y: y}, {x: xm, y: y + oy}, {x: x + ox, y: ym}, {x: x, y: ym}),
	          bottomLeft: bezierCurve({x: xm, y: ym}, {x: xm - ox, y: ym}, {x: x, y: y + oy}, {x: x, y:y})
	      };
	  }

	  function calculateCurvePoints(bounds, borderRadius, borders) {
	      var x = bounds.left,
	          y = bounds.top,
	          width = bounds.width,
	          height = bounds.height,

	          tlh = borderRadius[0][0] < width / 2 ? borderRadius[0][0] : width / 2,
	          tlv = borderRadius[0][1] < height / 2 ? borderRadius[0][1] : height / 2,
	          trh = borderRadius[1][0] < width / 2 ? borderRadius[1][0] : width / 2,
	          trv = borderRadius[1][1] < height / 2 ? borderRadius[1][1] : height / 2,
	          brh = borderRadius[2][0] < width / 2 ? borderRadius[2][0] : width / 2,
	          brv = borderRadius[2][1] < height / 2 ? borderRadius[2][1] : height / 2,
	          blh = borderRadius[3][0] < width / 2 ? borderRadius[3][0] : width / 2,
	          blv = borderRadius[3][1] < height / 2 ? borderRadius[3][1] : height / 2;

	      var topWidth = width - trh,
	          rightHeight = height - brv,
	          bottomWidth = width - brh,
	          leftHeight = height - blv;

	      return {
	          topLeftOuter: getCurvePoints(x, y, tlh, tlv).topLeft.subdivide(0.5),
	          topLeftInner: getCurvePoints(x + borders[3].width, y + borders[0].width, Math.max(0, tlh - borders[3].width), Math.max(0, tlv - borders[0].width)).topLeft.subdivide(0.5),
	          topRightOuter: getCurvePoints(x + topWidth, y, trh, trv).topRight.subdivide(0.5),
	          topRightInner: getCurvePoints(x + Math.min(topWidth, width + borders[3].width), y + borders[0].width, (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width, trv - borders[0].width).topRight.subdivide(0.5),
	          bottomRightOuter: getCurvePoints(x + bottomWidth, y + rightHeight, brh, brv).bottomRight.subdivide(0.5),
	          bottomRightInner: getCurvePoints(x + Math.min(bottomWidth, width - borders[3].width), y + Math.min(rightHeight, height + borders[0].width), Math.max(0, brh - borders[1].width),  brv - borders[2].width).bottomRight.subdivide(0.5),
	          bottomLeftOuter: getCurvePoints(x, y + leftHeight, blh, blv).bottomLeft.subdivide(0.5),
	          bottomLeftInner: getCurvePoints(x + borders[3].width, y + leftHeight, Math.max(0, blh - borders[3].width), blv - borders[2].width).bottomLeft.subdivide(0.5)
	      };
	  }

	  function bezierCurve(start, startControl, endControl, end) {
	      var lerp = function (a, b, t) {
	          return {
	              x: a.x + (b.x - a.x) * t,
	              y: a.y + (b.y - a.y) * t
	          };
	      };

	      return {
	          start: start,
	          startControl: startControl,
	          endControl: endControl,
	          end: end,
	          subdivide: function(t) {
	              var ab = lerp(start, startControl, t),
	                  bc = lerp(startControl, endControl, t),
	                  cd = lerp(endControl, end, t),
	                  abbc = lerp(ab, bc, t),
	                  bccd = lerp(bc, cd, t),
	                  dest = lerp(abbc, bccd, t);
	              return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];
	          },
	          curveTo: function(borderArgs) {
	              borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);
	          },
	          curveToReversed: function(borderArgs) {
	              borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);
	          }
	      };
	  }

	  function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {
	      var borderArgs = [];

	      if (radius1[0] > 0 || radius1[1] > 0) {
	          borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);
	          outer1[1].curveTo(borderArgs);
	      } else {
	          borderArgs.push([ "line", borderData.c1[0], borderData.c1[1]]);
	      }

	      if (radius2[0] > 0 || radius2[1] > 0) {
	          borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);
	          outer2[0].curveTo(borderArgs);
	          borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);
	          inner2[0].curveToReversed(borderArgs);
	      } else {
	          borderArgs.push(["line", borderData.c2[0], borderData.c2[1]]);
	          borderArgs.push(["line", borderData.c3[0], borderData.c3[1]]);
	      }

	      if (radius1[0] > 0 || radius1[1] > 0) {
	          borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);
	          inner1[1].curveToReversed(borderArgs);
	      } else {
	          borderArgs.push(["line", borderData.c4[0], borderData.c4[1]]);
	      }

	      return borderArgs;
	  }

	  function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {
	      if (radius1[0] > 0 || radius1[1] > 0) {
	          borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);
	          corner1[0].curveTo(borderArgs);
	          corner1[1].curveTo(borderArgs);
	      } else {
	          borderArgs.push(["line", x, y]);
	      }

	      if (radius2[0] > 0 || radius2[1] > 0) {
	          borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);
	      }
	  }

	  function negativeZIndex(container) {
	      return container.cssInt("zIndex") < 0;
	  }

	  function positiveZIndex(container) {
	      return container.cssInt("zIndex") > 0;
	  }

	  function zIndex0(container) {
	      return container.cssInt("zIndex") === 0;
	  }

	  function inlineLevel(container) {
	      return ["inline", "inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
	  }

	  function isStackingContext(container) {
	      return (container instanceof StackingContext);
	  }

	  function hasText(container) {
	      return container.node.data.trim().length > 0;
	  }

	  function noLetterSpacing(container) {
	      return (/^(normal|none|0px)$/.test(container.parent.css("letterSpacing")));
	  }

	  function getBorderRadiusData(container) {
	      return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {
	          var value = container.css('border' + side + 'Radius');
	          var arr = value.split(" ");
	          if (arr.length <= 1) {
	              arr[1] = arr[0];
	          }
	          return arr.map(asInt);
	      });
	  }

	  function renderableNode(node) {
	      return (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.ELEMENT_NODE);
	  }

	  function isPositionedForStacking(container) {
	      var position = container.css("position");
	      var zIndex = (["absolute", "relative", "fixed"].indexOf(position) !== -1) ? container.css("zIndex") : "auto";
	      return zIndex !== "auto";
	  }

	  function isPositioned(container) {
	      return container.css("position") !== "static";
	  }

	  function isFloating(container) {
	      return container.css("float") !== "none";
	  }

	  function isInlineBlock(container) {
	      return ["inline-block", "inline-table"].indexOf(container.css("display")) !== -1;
	  }

	  function not(callback) {
	      var context = this;
	      return function() {
	          return !callback.apply(context, arguments);
	      };
	  }

	  function isElement(container) {
	      return container.node.nodeType === Node.ELEMENT_NODE;
	  }

	  function isPseudoElement(container) {
	      return container.isPseudoElement === true;
	  }

	  function isTextNode(container) {
	      return container.node.nodeType === Node.TEXT_NODE;
	  }

	  function zIndexSort(contexts) {
	      return function(a, b) {
	          return (a.cssInt("zIndex") + (contexts.indexOf(a) / contexts.length)) - (b.cssInt("zIndex") + (contexts.indexOf(b) / contexts.length));
	      };
	  }

	  function hasOpacity(container) {
	      return container.getOpacity() < 1;
	  }

	  function asInt(value) {
	      return parseInt(value, 10);
	  }

	  function getWidth(border) {
	      return border.width;
	  }

	  function nonIgnoredElement(nodeContainer) {
	      return (nodeContainer.node.nodeType !== Node.ELEMENT_NODE || ["SCRIPT", "HEAD", "TITLE", "OBJECT", "BR", "OPTION"].indexOf(nodeContainer.node.nodeName) === -1);
	  }

	  function flatten(arrays) {
	      return [].concat.apply([], arrays);
	  }

	  function stripQuotes(content) {
	      var first = content.substr(0, 1);
	      return (first === content.substr(content.length - 1) && first.match(/'|"/)) ? content.substr(1, content.length - 2) : content;
	  }

	  function getWords(characters) {
	      var words = [], i = 0, onWordBoundary = false, word;
	      while(characters.length) {
	          if (isWordBoundary(characters[i]) === onWordBoundary) {
	              word = characters.splice(0, i);
	              if (word.length) {
	                  words.push(punycode.ucs2.encode(word));
	              }
	              onWordBoundary =! onWordBoundary;
	              i = 0;
	          } else {
	              i++;
	          }

	          if (i >= characters.length) {
	              word = characters.splice(0, i);
	              if (word.length) {
	                  words.push(punycode.ucs2.encode(word));
	              }
	          }
	      }
	      return words;
	  }

	  function isWordBoundary(characterCode) {
	      return [
	          32, // <space>
	          13, // \r
	          10, // \n
	          9, // \t
	          45 // -
	      ].indexOf(characterCode) !== -1;
	  }

	  function hasUnicode(string) {
	      return (/[^\u0000-\u00ff]/).test(string);
	  }

	  module.exports = NodeParser;

	  },{"./color":3,"./fontmetrics":7,"./log":13,"./nodecontainer":14,"./pseudoelementcontainer":18,"./stackingcontext":21,"./textcontainer":25,"./utils":26,"punycode":1}],16:[function(_dereq_,module,exports){
	  var XHR = _dereq_('./xhr');
	  var utils = _dereq_('./utils');
	  var log = _dereq_('./log');
	  var createWindowClone = _dereq_('./clone');
	  var decode64 = utils.decode64;

	  function Proxy(src, proxyUrl, document) {
	      var supportsCORS = ('withCredentials' in new XMLHttpRequest());
	      if (!proxyUrl) {
	          return Promise.reject("No proxy configured");
	      }
	      var callback = createCallback(supportsCORS);
	      var url = createProxyUrl(proxyUrl, src, callback);

	      return supportsCORS ? XHR(url) : (jsonp(document, url, callback).then(function(response) {
	          return decode64(response.content);
	      }));
	  }
	  var proxyCount = 0;

	  function ProxyURL(src, proxyUrl, document) {
	      var supportsCORSImage = ('crossOrigin' in new Image());
	      var callback = createCallback(supportsCORSImage);
	      var url = createProxyUrl(proxyUrl, src, callback);
	      return (supportsCORSImage ? Promise.resolve(url) : jsonp(document, url, callback).then(function(response) {
	          return "data:" + response.type + ";base64," + response.content;
	      }));
	  }

	  function jsonp(document, url, callback) {
	      return new Promise(function(resolve, reject) {
	          var s = document.createElement("script");
	          var cleanup = function() {
	              delete window.html2canvas.proxy[callback];
	              document.body.removeChild(s);
	          };
	          window.html2canvas.proxy[callback] = function(response) {
	              cleanup();
	              resolve(response);
	          };
	          s.src = url;
	          s.onerror = function(e) {
	              cleanup();
	              reject(e);
	          };
	          document.body.appendChild(s);
	      });
	  }

	  function createCallback(useCORS) {
	      return !useCORS ? "html2canvas_" + Date.now() + "_" + (++proxyCount) + "_" + Math.round(Math.random() * 100000) : "";
	  }

	  function createProxyUrl(proxyUrl, src, callback) {
	      return proxyUrl + "?url=" + encodeURIComponent(src) + (callback.length ? "&callback=html2canvas.proxy." + callback : "");
	  }

	  function documentFromHTML(src) {
	      return function(html) {
	          var parser = new DOMParser(), doc;
	          try {
	              doc = parser.parseFromString(html, "text/html");
	          } catch(e) {
	              log("DOMParser not supported, falling back to createHTMLDocument");
	              doc = document.implementation.createHTMLDocument("");
	              try {
	                  doc.open();
	                  doc.write(html);
	                  doc.close();
	              } catch(ee) {
	                  log("createHTMLDocument write not supported, falling back to document.body.innerHTML");
	                  doc.body.innerHTML = html; // ie9 doesnt support writing to documentElement
	              }
	          }

	          var b = doc.querySelector("base");
	          if (!b || !b.href.host) {
	              var base = doc.createElement("base");
	              base.href = src;
	              doc.head.insertBefore(base, doc.head.firstChild);
	          }

	          return doc;
	      };
	  }

	  function loadUrlDocument(src, proxy, document, width, height, options) {
	      return new Proxy(src, proxy, window.document).then(documentFromHTML(src)).then(function(doc) {
	          return createWindowClone(doc, document, width, height, options, 0, 0);
	      });
	  }

	  exports.Proxy = Proxy;
	  exports.ProxyURL = ProxyURL;
	  exports.loadUrlDocument = loadUrlDocument;

	  },{"./clone":2,"./log":13,"./utils":26,"./xhr":28}],17:[function(_dereq_,module,exports){
	  var ProxyURL = _dereq_('./proxy').ProxyURL;

	  function ProxyImageContainer(src, proxy) {
	      var link = document.createElement("a");
	      link.href = src;
	      src = link.href;
	      this.src = src;
	      this.image = new Image();
	      var self = this;
	      this.promise = new Promise(function(resolve, reject) {
	          self.image.crossOrigin = "Anonymous";
	          self.image.onload = resolve;
	          self.image.onerror = reject;

	          new ProxyURL(src, proxy, document).then(function(url) {
	              self.image.src = url;
	          })['catch'](reject);
	      });
	  }

	  module.exports = ProxyImageContainer;

	  },{"./proxy":16}],18:[function(_dereq_,module,exports){
	  var NodeContainer = _dereq_('./nodecontainer');

	  function PseudoElementContainer(node, parent, type) {
	      NodeContainer.call(this, node, parent);
	      this.isPseudoElement = true;
	      this.before = type === ":before";
	  }

	  PseudoElementContainer.prototype.cloneTo = function(stack) {
	      PseudoElementContainer.prototype.cloneTo.call(this, stack);
	      stack.isPseudoElement = true;
	      stack.before = this.before;
	  };

	  PseudoElementContainer.prototype = Object.create(NodeContainer.prototype);

	  PseudoElementContainer.prototype.appendToDOM = function() {
	      if (this.before) {
	          this.parent.node.insertBefore(this.node, this.parent.node.firstChild);
	      } else {
	          this.parent.node.appendChild(this.node);
	      }
	      this.parent.node.className += " " + this.getHideClass();
	  };

	  PseudoElementContainer.prototype.cleanDOM = function() {
	      this.node.parentNode.removeChild(this.node);
	      this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
	  };

	  PseudoElementContainer.prototype.getHideClass = function() {
	      return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
	  };

	  PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
	  PseudoElementContainer.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";

	  module.exports = PseudoElementContainer;

	  },{"./nodecontainer":14}],19:[function(_dereq_,module,exports){
	  var log = _dereq_('./log');

	  function Renderer(width, height, images, options, document) {
	      this.width = width;
	      this.height = height;
	      this.images = images;
	      this.options = options;
	      this.document = document;
	  }

	  Renderer.prototype.renderImage = function(container, bounds, borderData, imageContainer) {
	      var paddingLeft = container.cssInt('paddingLeft'),
	          paddingTop = container.cssInt('paddingTop'),
	          paddingRight = container.cssInt('paddingRight'),
	          paddingBottom = container.cssInt('paddingBottom'),
	          borders = borderData.borders;

	      var width = bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight);
	      var height = bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom);
	      this.drawImage(
	          imageContainer,
	          0,
	          0,
	          imageContainer.image.width || width,
	          imageContainer.image.height || height,
	          bounds.left + paddingLeft + borders[3].width,
	          bounds.top + paddingTop + borders[0].width,
	          width,
	          height
	      );
	  };

	  Renderer.prototype.renderBackground = function(container, bounds, borderData) {
	      if (bounds.height > 0 && bounds.width > 0) {
	          this.renderBackgroundColor(container, bounds);
	          this.renderBackgroundImage(container, bounds, borderData);
	      }
	  };

	  Renderer.prototype.renderBackgroundColor = function(container, bounds) {
	      var color = container.color("backgroundColor");
	      if (!color.isTransparent()) {
	          this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, color);
	      }
	  };

	  Renderer.prototype.renderBorders = function(borders) {
	      borders.forEach(this.renderBorder, this);
	  };

	  Renderer.prototype.renderBorder = function(data) {
	      if (!data.color.isTransparent() && data.args !== null) {
	          this.drawShape(data.args, data.color);
	      }
	  };

	  Renderer.prototype.renderBackgroundImage = function(container, bounds, borderData) {
	      var backgroundImages = container.parseBackgroundImages();
	      backgroundImages.reverse().forEach(function(backgroundImage, index, arr) {
	          switch(backgroundImage.method) {
	          case "url":
	              var image = this.images.get(backgroundImage.args[0]);
	              if (image) {
	                  this.renderBackgroundRepeating(container, bounds, image, arr.length - (index+1), borderData);
	              } else {
	                  log("Error loading background-image", backgroundImage.args[0]);
	              }
	              break;
	          case "linear-gradient":
	          case "gradient":
	              var gradientImage = this.images.get(backgroundImage.value);
	              if (gradientImage) {
	                  this.renderBackgroundGradient(gradientImage, bounds, borderData);
	              } else {
	                  log("Error loading background-image", backgroundImage.args[0]);
	              }
	              break;
	          case "none":
	              break;
	          default:
	              log("Unknown background-image type", backgroundImage.args[0]);
	          }
	      }, this);
	  };

	  Renderer.prototype.renderBackgroundRepeating = function(container, bounds, imageContainer, index, borderData) {
	      var size = container.parseBackgroundSize(bounds, imageContainer.image, index);
	      var position = container.parseBackgroundPosition(bounds, imageContainer.image, index, size);
	      var repeat = container.parseBackgroundRepeat(index);
	      switch (repeat) {
	      case "repeat-x":
	      case "repeat no-repeat":
	          this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + borderData[3], bounds.top + position.top + borderData[0], 99999, size.height, borderData);
	          break;
	      case "repeat-y":
	      case "no-repeat repeat":
	          this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + borderData[0], size.width, 99999, borderData);
	          break;
	      case "no-repeat":
	          this.backgroundRepeatShape(imageContainer, position, size, bounds, bounds.left + position.left + borderData[3], bounds.top + position.top + borderData[0], size.width, size.height, borderData);
	          break;
	      default:
	          this.renderBackgroundRepeat(imageContainer, position, size, {top: bounds.top, left: bounds.left}, borderData[3], borderData[0]);
	          break;
	      }
	  };

	  module.exports = Renderer;

	  },{"./log":13}],20:[function(_dereq_,module,exports){
	  var Renderer = _dereq_('../renderer');
	  var LinearGradientContainer = _dereq_('../lineargradientcontainer');
	  var log = _dereq_('../log');

	  function CanvasRenderer(width, height) {
	      Renderer.apply(this, arguments);
	      this.canvas = this.options.canvas || this.document.createElement("canvas");
	      if (!this.options.canvas) {
	          this.canvas.width = width;
	          this.canvas.height = height;
	      }
	      this.ctx = this.canvas.getContext("2d");
	      this.taintCtx = this.document.createElement("canvas").getContext("2d");
	      this.ctx.textBaseline = "bottom";
	      this.variables = {};
	      log("Initialized CanvasRenderer with size", width, "x", height);
	  }

	  CanvasRenderer.prototype = Object.create(Renderer.prototype);

	  CanvasRenderer.prototype.setFillStyle = function(fillStyle) {
	      this.ctx.fillStyle = typeof(fillStyle) === "object" && !!fillStyle.isColor ? fillStyle.toString() : fillStyle;
	      return this.ctx;
	  };

	  CanvasRenderer.prototype.rectangle = function(left, top, width, height, color) {
	      this.setFillStyle(color).fillRect(left, top, width, height);
	  };

	  CanvasRenderer.prototype.circle = function(left, top, size, color) {
	      this.setFillStyle(color);
	      this.ctx.beginPath();
	      this.ctx.arc(left + size / 2, top + size / 2, size / 2, 0, Math.PI*2, true);
	      this.ctx.closePath();
	      this.ctx.fill();
	  };

	  CanvasRenderer.prototype.circleStroke = function(left, top, size, color, stroke, strokeColor) {
	      this.circle(left, top, size, color);
	      this.ctx.strokeStyle = strokeColor.toString();
	      this.ctx.stroke();
	  };

	  CanvasRenderer.prototype.drawShape = function(shape, color) {
	      this.shape(shape);
	      this.setFillStyle(color).fill();
	  };

	  CanvasRenderer.prototype.taints = function(imageContainer) {
	      if (imageContainer.tainted === null) {
	          this.taintCtx.drawImage(imageContainer.image, 0, 0);
	          try {
	              this.taintCtx.getImageData(0, 0, 1, 1);
	              imageContainer.tainted = false;
	          } catch(e) {
	              this.taintCtx = document.createElement("canvas").getContext("2d");
	              imageContainer.tainted = true;
	          }
	      }

	      return imageContainer.tainted;
	  };

	  CanvasRenderer.prototype.drawImage = function(imageContainer, sx, sy, sw, sh, dx, dy, dw, dh) {
	      if (!this.taints(imageContainer) || this.options.allowTaint) {
	          this.ctx.drawImage(imageContainer.image, sx, sy, sw, sh, dx, dy, dw, dh);
	      }
	  };

	  CanvasRenderer.prototype.clip = function(shapes, callback, context) {
	      this.ctx.save();
	      shapes.filter(hasEntries).forEach(function(shape) {
	          this.shape(shape).clip();
	      }, this);
	      callback.call(context);
	      this.ctx.restore();
	  };

	  CanvasRenderer.prototype.shape = function(shape) {
	      this.ctx.beginPath();
	      shape.forEach(function(point, index) {
	          if (point[0] === "rect") {
	              this.ctx.rect.apply(this.ctx, point.slice(1));
	          } else {
	              this.ctx[(index === 0) ? "moveTo" : point[0] + "To" ].apply(this.ctx, point.slice(1));
	          }
	      }, this);
	      this.ctx.closePath();
	      return this.ctx;
	  };

	  CanvasRenderer.prototype.font = function(color, style, variant, weight, size, family) {
	      this.setFillStyle(color).font = [style, variant, weight, size, family].join(" ").split(",")[0];
	  };

	  CanvasRenderer.prototype.fontShadow = function(color, offsetX, offsetY, blur) {
	      this.setVariable("shadowColor", color.toString())
	          .setVariable("shadowOffsetY", offsetX)
	          .setVariable("shadowOffsetX", offsetY)
	          .setVariable("shadowBlur", blur);
	  };

	  CanvasRenderer.prototype.clearShadow = function() {
	      this.setVariable("shadowColor", "rgba(0,0,0,0)");
	  };

	  CanvasRenderer.prototype.setOpacity = function(opacity) {
	      this.ctx.globalAlpha = opacity;
	  };

	  CanvasRenderer.prototype.setTransform = function(transform) {
	      this.ctx.translate(transform.origin[0], transform.origin[1]);
	      this.ctx.transform.apply(this.ctx, transform.matrix);
	      this.ctx.translate(-transform.origin[0], -transform.origin[1]);
	  };

	  CanvasRenderer.prototype.setVariable = function(property, value) {
	      if (this.variables[property] !== value) {
	          this.variables[property] = this.ctx[property] = value;
	      }

	      return this;
	  };

	  CanvasRenderer.prototype.text = function(text, left, bottom) {
	      this.ctx.fillText(text, left, bottom);
	  };

	  CanvasRenderer.prototype.backgroundRepeatShape = function(imageContainer, backgroundPosition, size, bounds, left, top, width, height, borderData) {
	      var shape = [
	          ["line", Math.round(left), Math.round(top)],
	          ["line", Math.round(left + width), Math.round(top)],
	          ["line", Math.round(left + width), Math.round(height + top)],
	          ["line", Math.round(left), Math.round(height + top)]
	      ];
	      this.clip([shape], function() {
	          this.renderBackgroundRepeat(imageContainer, backgroundPosition, size, bounds, borderData[3], borderData[0]);
	      }, this);
	  };

	  CanvasRenderer.prototype.renderBackgroundRepeat = function(imageContainer, backgroundPosition, size, bounds, borderLeft, borderTop) {
	      var offsetX = Math.round(bounds.left + backgroundPosition.left + borderLeft), offsetY = Math.round(bounds.top + backgroundPosition.top + borderTop);
	      this.setFillStyle(this.ctx.createPattern(this.resizeImage(imageContainer, size), "repeat"));
	      this.ctx.translate(offsetX, offsetY);
	      this.ctx.fill();
	      this.ctx.translate(-offsetX, -offsetY);
	  };

	  CanvasRenderer.prototype.renderBackgroundGradient = function(gradientImage, bounds) {
	      if (gradientImage instanceof LinearGradientContainer) {
	          var gradient = this.ctx.createLinearGradient(
	              bounds.left + bounds.width * gradientImage.x0,
	              bounds.top + bounds.height * gradientImage.y0,
	              bounds.left +  bounds.width * gradientImage.x1,
	              bounds.top +  bounds.height * gradientImage.y1);
	          gradientImage.colorStops.forEach(function(colorStop) {
	              gradient.addColorStop(colorStop.stop, colorStop.color.toString());
	          });
	          this.rectangle(bounds.left, bounds.top, bounds.width, bounds.height, gradient);
	      }
	  };

	  CanvasRenderer.prototype.resizeImage = function(imageContainer, size) {
	      var image = imageContainer.image;
	      if(image.width === size.width && image.height === size.height) {
	          return image;
	      }

	      var ctx, canvas = document.createElement('canvas');
	      canvas.width = size.width;
	      canvas.height = size.height;
	      ctx = canvas.getContext("2d");
	      ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height );
	      return canvas;
	  };

	  function hasEntries(array) {
	      return array.length > 0;
	  }

	  module.exports = CanvasRenderer;

	  },{"../lineargradientcontainer":12,"../log":13,"../renderer":19}],21:[function(_dereq_,module,exports){
	  var NodeContainer = _dereq_('./nodecontainer');

	  function StackingContext(hasOwnStacking, opacity, element, parent) {
	      NodeContainer.call(this, element, parent);
	      this.ownStacking = hasOwnStacking;
	      this.contexts = [];
	      this.children = [];
	      this.opacity = (this.parent ? this.parent.stack.opacity : 1) * opacity;
	  }

	  StackingContext.prototype = Object.create(NodeContainer.prototype);

	  StackingContext.prototype.getParentStack = function(context) {
	      var parentStack = (this.parent) ? this.parent.stack : null;
	      return parentStack ? (parentStack.ownStacking ? parentStack : parentStack.getParentStack(context)) : context.stack;
	  };

	  module.exports = StackingContext;

	  },{"./nodecontainer":14}],22:[function(_dereq_,module,exports){
	  function Support(document) {
	      this.rangeBounds = this.testRangeBounds(document);
	      this.cors = this.testCORS();
	      this.svg = this.testSVG();
	  }

	  Support.prototype.testRangeBounds = function(document) {
	      var range, testElement, rangeBounds, rangeHeight, support = false;

	      if (document.createRange) {
	          range = document.createRange();
	          if (range.getBoundingClientRect) {
	              testElement = document.createElement('boundtest');
	              testElement.style.height = "123px";
	              testElement.style.display = "block";
	              document.body.appendChild(testElement);

	              range.selectNode(testElement);
	              rangeBounds = range.getBoundingClientRect();
	              rangeHeight = rangeBounds.height;

	              if (rangeHeight === 123) {
	                  support = true;
	              }
	              document.body.removeChild(testElement);
	          }
	      }

	      return support;
	  };

	  Support.prototype.testCORS = function() {
	      return typeof((new Image()).crossOrigin) !== "undefined";
	  };

	  Support.prototype.testSVG = function() {
	      var img = new Image();
	      var canvas = document.createElement("canvas");
	      var ctx =  canvas.getContext("2d");
	      img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";

	      try {
	          ctx.drawImage(img, 0, 0);
	          canvas.toDataURL();
	      } catch(e) {
	          return false;
	      }
	      return true;
	  };

	  module.exports = Support;

	  },{}],23:[function(_dereq_,module,exports){
	  var XHR = _dereq_('./xhr');
	  var decode64 = _dereq_('./utils').decode64;

	  function SVGContainer(src) {
	      this.src = src;
	      this.image = null;
	      var self = this;

	      this.promise = this.hasFabric().then(function() {
	          return (self.isInline(src) ? Promise.resolve(self.inlineFormatting(src)) : XHR(src));
	      }).then(function(svg) {
	          return new Promise(function(resolve) {
	              window.html2canvas.svg.fabric.loadSVGFromString(svg, self.createCanvas.call(self, resolve));
	          });
	      });
	  }

	  SVGContainer.prototype.hasFabric = function() {
	      return !window.html2canvas.svg || !window.html2canvas.svg.fabric ? Promise.reject(new Error("html2canvas.svg.js is not loaded, cannot render svg")) : Promise.resolve();
	  };

	  SVGContainer.prototype.inlineFormatting = function(src) {
	      return (/^data:image\/svg\+xml;base64,/.test(src)) ? this.decode64(this.removeContentType(src)) : this.removeContentType(src);
	  };

	  SVGContainer.prototype.removeContentType = function(src) {
	      return src.replace(/^data:image\/svg\+xml(;base64)?,/,'');
	  };

	  SVGContainer.prototype.isInline = function(src) {
	      return (/^data:image\/svg\+xml/i.test(src));
	  };

	  SVGContainer.prototype.createCanvas = function(resolve) {
	      var self = this;
	      return function (objects, options) {
	          var canvas = new window.html2canvas.svg.fabric.StaticCanvas('c');
	          self.image = canvas.lowerCanvasEl;
	          canvas
	              .setWidth(options.width)
	              .setHeight(options.height)
	              .add(window.html2canvas.svg.fabric.util.groupSVGElements(objects, options))
	              .renderAll();
	          resolve(canvas.lowerCanvasEl);
	      };
	  };

	  SVGContainer.prototype.decode64 = function(str) {
	      return (typeof(window.atob) === "function") ? window.atob(str) : decode64(str);
	  };

	  module.exports = SVGContainer;

	  },{"./utils":26,"./xhr":28}],24:[function(_dereq_,module,exports){
	  var SVGContainer = _dereq_('./svgcontainer');

	  function SVGNodeContainer(node, _native) {
	      this.src = node;
	      this.image = null;
	      var self = this;

	      this.promise = _native ? new Promise(function(resolve, reject) {
	          self.image = new Image();
	          self.image.onload = resolve;
	          self.image.onerror = reject;
	          self.image.src = "data:image/svg+xml," + (new XMLSerializer()).serializeToString(node);
	          if (self.image.complete === true) {
	              resolve(self.image);
	          }
	      }) : this.hasFabric().then(function() {
	          return new Promise(function(resolve) {
	              window.html2canvas.svg.fabric.parseSVGDocument(node, self.createCanvas.call(self, resolve));
	          });
	      });
	  }

	  SVGNodeContainer.prototype = Object.create(SVGContainer.prototype);

	  module.exports = SVGNodeContainer;

	  },{"./svgcontainer":23}],25:[function(_dereq_,module,exports){
	  var NodeContainer = _dereq_('./nodecontainer');

	  function TextContainer(node, parent) {
	      NodeContainer.call(this, node, parent);
	  }

	  TextContainer.prototype = Object.create(NodeContainer.prototype);

	  TextContainer.prototype.applyTextTransform = function() {
	      this.node.data = this.transform(this.parent.css("textTransform"));
	  };

	  TextContainer.prototype.transform = function(transform) {
	      var text = this.node.data;
	      switch(transform){
	          case "lowercase":
	              return text.toLowerCase();
	          case "capitalize":
	              return text.replace(/(^|\s|:|-|\(|\))([a-z])/g, capitalize);
	          case "uppercase":
	              return text.toUpperCase();
	          default:
	              return text;
	      }
	  };

	  function capitalize(m, p1, p2) {
	      if (m.length > 0) {
	          return p1 + p2.toUpperCase();
	      }
	  }

	  module.exports = TextContainer;

	  },{"./nodecontainer":14}],26:[function(_dereq_,module,exports){
	  exports.smallImage = function smallImage() {
	      return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
	  };

	  exports.bind = function(callback, context) {
	      return function() {
	          return callback.apply(context, arguments);
	      };
	  };

	  /*
	   * base64-arraybuffer
	   * https://github.com/niklasvh/base64-arraybuffer
	   *
	   * Copyright (c) 2012 Niklas von Hertzen
	   * Licensed under the MIT license.
	   */

	  exports.decode64 = function(base64) {
	      var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	      var len = base64.length, i, encoded1, encoded2, encoded3, encoded4, byte1, byte2, byte3;

	      var output = "";

	      for (i = 0; i < len; i+=4) {
	          encoded1 = chars.indexOf(base64[i]);
	          encoded2 = chars.indexOf(base64[i+1]);
	          encoded3 = chars.indexOf(base64[i+2]);
	          encoded4 = chars.indexOf(base64[i+3]);

	          byte1 = (encoded1 << 2) | (encoded2 >> 4);
	          byte2 = ((encoded2 & 15) << 4) | (encoded3 >> 2);
	          byte3 = ((encoded3 & 3) << 6) | encoded4;
	          if (encoded3 === 64) {
	              output += String.fromCharCode(byte1);
	          } else if (encoded4 === 64 || encoded4 === -1) {
	              output += String.fromCharCode(byte1, byte2);
	          } else{
	              output += String.fromCharCode(byte1, byte2, byte3);
	          }
	      }

	      return output;
	  };

	  exports.getBounds = function(node) {
	      if (node.getBoundingClientRect) {
	          var clientRect = node.getBoundingClientRect();
	          var width = node.offsetWidth == null ? clientRect.width : node.offsetWidth;
	          return {
	              top: clientRect.top,
	              bottom: clientRect.bottom || (clientRect.top + clientRect.height),
	              right: clientRect.left + width,
	              left: clientRect.left,
	              width:  width,
	              height: node.offsetHeight == null ? clientRect.height : node.offsetHeight
	          };
	      }
	      return {};
	  };

	  exports.offsetBounds = function(node) {
	      var parent = node.offsetParent ? exports.offsetBounds(node.offsetParent) : {top: 0, left: 0};

	      return {
	          top: node.offsetTop + parent.top,
	          bottom: node.offsetTop + node.offsetHeight + parent.top,
	          right: node.offsetLeft + parent.left + node.offsetWidth,
	          left: node.offsetLeft + parent.left,
	          width: node.offsetWidth,
	          height: node.offsetHeight
	      };
	  };

	  exports.parseBackgrounds = function(backgroundImage) {
	      var whitespace = ' \r\n\t',
	          method, definition, prefix, prefix_i, block, results = [],
	          mode = 0, numParen = 0, quote, args;
	      var appendResult = function() {
	          if(method) {
	              if (definition.substr(0, 1) === '"') {
	                  definition = definition.substr(1, definition.length - 2);
	              }
	              if (definition) {
	                  args.push(definition);
	              }
	              if (method.substr(0, 1) === '-' && (prefix_i = method.indexOf('-', 1 ) + 1) > 0) {
	                  prefix = method.substr(0, prefix_i);
	                  method = method.substr(prefix_i);
	              }
	              results.push({
	                  prefix: prefix,
	                  method: method.toLowerCase(),
	                  value: block,
	                  args: args,
	                  image: null
	              });
	          }
	          args = [];
	          method = prefix = definition = block = '';
	      };
	      args = [];
	      method = prefix = definition = block = '';
	      backgroundImage.split("").forEach(function(c) {
	          if (mode === 0 && whitespace.indexOf(c) > -1) {
	              return;
	          }
	          switch(c) {
	          case '"':
	              if(!quote) {
	                  quote = c;
	              } else if(quote === c) {
	                  quote = null;
	              }
	              break;
	          case '(':
	              if(quote) {
	                  break;
	              } else if(mode === 0) {
	                  mode = 1;
	                  block += c;
	                  return;
	              } else {
	                  numParen++;
	              }
	              break;
	          case ')':
	              if (quote) {
	                  break;
	              } else if(mode === 1) {
	                  if(numParen === 0) {
	                      mode = 0;
	                      block += c;
	                      appendResult();
	                      return;
	                  } else {
	                      numParen--;
	                  }
	              }
	              break;

	          case ',':
	              if (quote) {
	                  break;
	              } else if(mode === 0) {
	                  appendResult();
	                  return;
	              } else if (mode === 1) {
	                  if (numParen === 0 && !method.match(/^url$/i)) {
	                      args.push(definition);
	                      definition = '';
	                      block += c;
	                      return;
	                  }
	              }
	              break;
	          }

	          block += c;
	          if (mode === 0) {
	              method += c;
	          } else {
	              definition += c;
	          }
	      });

	      appendResult();
	      return results;
	  };

	  },{}],27:[function(_dereq_,module,exports){
	  var GradientContainer = _dereq_('./gradientcontainer');

	  function WebkitGradientContainer(imageData) {
	      GradientContainer.apply(this, arguments);
	      this.type = imageData.args[0] === "linear" ? GradientContainer.TYPES.LINEAR : GradientContainer.TYPES.RADIAL;
	  }

	  WebkitGradientContainer.prototype = Object.create(GradientContainer.prototype);

	  module.exports = WebkitGradientContainer;

	  },{"./gradientcontainer":9}],28:[function(_dereq_,module,exports){
	  function XHR(url) {
	      return new Promise(function(resolve, reject) {
	          var xhr = new XMLHttpRequest();
	          xhr.open('GET', url);

	          xhr.onload = function() {
	              if (xhr.status === 200) {
	                  resolve(xhr.responseText);
	              } else {
	                  reject(new Error(xhr.statusText));
	              }
	          };

	          xhr.onerror = function() {
	              reject(new Error("Network Error"));
	          };

	          xhr.send();
	      });
	  }

	  module.exports = XHR;

	  },{}]},{},[4])(4)
	  });

	  /************************************************
	   * Title : custom font                          *
	   * Start Data : 2017. 01. 22.                   *
	   * Comment : TEXT API                           *
	   ************************************************/

	  /******************************
	   * jsPDF extension API Design *
	   * ****************************/
	  (function(jsPDF){
	      var PLUS = '+'.charCodeAt(0);
	      var SLASH = '/'.charCodeAt(0);
	      var NUMBER = '0'.charCodeAt(0);
	      var LOWER = 'a'.charCodeAt(0);
	      var UPPER = 'A'.charCodeAt(0);
	      var PLUS_URL_SAFE = '-'.charCodeAt(0);
	      var SLASH_URL_SAFE = '_'.charCodeAt(0);

	      /*****************************************************************/
	      /* function : b64ToByteArray                                     */
	      /* comment : Base64 encoded TTF file contents (b64) are decoded  */
	      /*     by Byte array and stored.                                 */
	      /*****************************************************************/
	      var b64ToByteArray = function(b64) {
	          var i, j, l, tmp, placeHolders, arr;
	          if (b64.length % 4 > 0) {
	              throw new Error('Invalid string. Length must be a multiple of 4')
	          }
	          // the number of equal signs (place holders)
	          // if there are two placeholders, than the two characters before it
	          // represent one byte
	          // if there is only one, then the three characters before it represent 2 bytes
	          // this is just a cheap hack to not do indexOf twice
	          var len = b64.length;
	          placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;
	              // base64 is 4/3 + up to two characters of the original data
	          arr = new Uint8Array(b64.length * 3 / 4 - placeHolders);
	              // if there are placeholders, only get up to the last complete 4 chars
	          l = placeHolders > 0 ? b64.length - 4 : b64.length;
	          var L = 0;

	          function push(v) {
	              arr[L++] = v;
	          }
	          for (i = 0, j = 0; i < l; i += 4, j += 3) {
	              tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3));
	              push((tmp & 0xFF0000) >> 16);
	              push((tmp & 0xFF00) >> 8);
	              push(tmp & 0xFF);
	          }
	          if (placeHolders === 2) {
	              tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4);
	              push(tmp & 0xFF);
	          }
	          else if (placeHolders === 1) {
	              tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2);
	              push((tmp >> 8) & 0xFF);
	              push(tmp & 0xFF);
	          }
	          return arr
	      };

	      /***************************************************************/
	      /* function : decode                                           */
	      /* comment : Change the base64 encoded font's content to match */
	      /*   the base64 index value.                                   */
	      /***************************************************************/
	      var decode = function(elt) {
	          var code = elt.charCodeAt(0);
	          if (code === PLUS || code === PLUS_URL_SAFE) return 62 // '+'
	          if (code === SLASH || code === SLASH_URL_SAFE) return 63 // '/'
	          if (code < NUMBER) return -1 //no match
	          if (code < NUMBER + 10) return code - NUMBER + 26 + 26
	          if (code < UPPER + 26) return code - UPPER
	          if (code < LOWER + 26) return code - LOWER + 26
	      };

	      jsPDF.API.TTFFont = (function () {
	          /************************************************************************/
	          /* function : open                                                       */
	          /* comment : Decode the encoded ttf content and create a TTFFont object. */
	          /************************************************************************/
	          TTFFont.open = function (filename, name, vfs, encoding) {
	              var contents;
	              contents = b64ToByteArray(vfs);
	              return new TTFFont(contents, name, encoding);
	          };
	          /***************************************************************/
	          /* function : TTFFont gernerator                               */
	          /* comment : Decode TTF contents are parsed, Data,             */
	          /* Subset object is created, and registerTTF function is called.*/
	          /***************************************************************/
	          function TTFFont(rawData, name, encoding) {
	              var data;
	              this.rawData = rawData;
	              data = this.contents = new Data(rawData);
	              this.contents.pos = 4;
	              if (data.readString(4) === 'ttcf') {
	                  if (!name) {
	                      throw new Error("Must specify a font name for TTC files.");
	                  }
	                  throw new Error("Font " + name + " not found in TTC file.");
	              }
	              else {
	                  data.pos = 0;
	                  this.parse();
	                  this.subset = new Subset(this);
	                  this.registerTTF();
	              }
	          }
	          /********************************************************/
	          /* function : parse                                     */
	          /* comment : TTF Parses the file contents by each table.*/
	          /********************************************************/
	          TTFFont.prototype.parse = function () {
	              this.directory = new Directory(this.contents);
	              this.head = new HeadTable(this);
	              this.name = new NameTable(this);
	              this.cmap = new CmapTable(this);
	              this.hhea = new HheaTable(this);
	              this.maxp = new MaxpTable(this);
	              this.hmtx = new HmtxTable(this);
	              this.post = new PostTable(this);
	              this.os2 = new OS2Table(this);
	              this.loca = new LocaTable(this);
	              this.glyf = new GlyfTable(this);
	              this.ascender = (this.os2.exists && this.os2.ascender) || this.hhea.ascender;
	              this.decender = (this.os2.exists && this.os2.decender) || this.hhea.decender;
	              this.lineGap = (this.os2.exists && this.os2.lineGap) || this.hhea.lineGap;
	              return this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
	          };
	          /***************************************************************/
	          /* function : registerTTF                                      */
	          /* comment : Get the value to assign pdf font descriptors.     */
	          /***************************************************************/
	          TTFFont.prototype.registerTTF = function () {
	              var e, hi, low, raw, _ref;
	              this.scaleFactor = 1000.0 / this.head.unitsPerEm;
	              this.bbox = (function () {
	                  var _i, _len, _ref, _results;
	                  _ref = this.bbox;
	                  _results = [];
	                  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
	                      e = _ref[_i];
	                      _results.push(Math.round(e * this.scaleFactor));
	                  }
	                  return _results;
	              }).call(this);
	              this.stemV = 0;
	              if (this.post.exists) {
	                  raw = this.post.italic_angle;
	                  hi = raw >> 16;
	                  low = raw & 0xFF;
	                  if (hi & 0x8000 !== 0) {
	                      hi = -((hi ^ 0xFFFF) + 1);
	                  }
	                  this.italicAngle = +("" + hi + "." + low);
	              }
	              else {
	                  this.italicAngle = 0;
	              }
	              this.ascender = Math.round(this.ascender * this.scaleFactor);
	              this.decender = Math.round(this.decender * this.scaleFactor);
	              this.lineGap = Math.round(this.lineGap * this.scaleFactor);
	              this.capHeight = (this.os2.exists && this.os2.capHeight) || this.ascender;
	              this.xHeight = (this.os2.exists && this.os2.xHeight) || 0;
	              this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8;
	              this.isSerif = (_ref = this.familyClass) === 1 || _ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 7;
	              this.isScript = this.familyClass === 10;
	              this.flags = 0;
	              if (this.post.isFixedPitch) {
	                  this.flags |= 1 << 0;
	              }
	              if (this.isSerif) {
	                  this.flags |= 1 << 1;
	              }
	              if (this.isScript) {
	                  this.flags |= 1 << 3;
	              }
	              if (this.italicAngle !== 0) {
	                  this.flags |= 1 << 6;
	              }
	              this.flags |= 1 << 5;
	              if (!this.cmap.unicode) {
	                  throw new Error('No unicode cmap for font');
	              }
	          };
	          TTFFont.prototype.characterToGlyph = function (character) {
	              var _ref;
	              return ((_ref = this.cmap.unicode) != null ? _ref.codeMap[character] : void 0) || 0;
	          };
	          TTFFont.prototype.widthOfGlyph = function (glyph) {
	              var scale;
	              scale = 1000.0 / this.head.unitsPerEm;
	              return this.hmtx.forGlyph(glyph).advance * scale;
	          };
	          TTFFont.prototype.widthOfString = function (string, size, charSpace) {
	              var charCode, i, scale, width, _i, _ref, charSpace;
	              string = '' + string;
	              width = 0;
	              for (i = _i = 0, _ref = string.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	                  charCode = string.charCodeAt(i);
	                  width += (this.widthOfGlyph(this.characterToGlyph(charCode)) + charSpace * (1000/ size)) || 0;
	              }
	              scale = size / 1000;
	              return width * scale;
	          };
	          TTFFont.prototype.lineHeight = function (size, includeGap) {
	              var gap;
	              if (includeGap == null) {
	                  includeGap = false;
	              }
	              gap = includeGap ? this.lineGap : 0;
	              return (this.ascender + gap - this.decender) / 1000 * size;
	          };
	          return TTFFont;
	      })();

	      /************************************************************************************************/
	      /* function : Data                                                                              */
	      /* comment : The ttf data decoded and stored in an array is read and written to the Data object.*/
	      /************************************************************************************************/
	      var Data = (function () {
	          function Data(data) {
	              this.data = data != null ? data : [];
	              this.pos = 0;
	              this.length = this.data.length;
	          }
	          Data.prototype.readByte = function () {
	              return this.data[this.pos++];
	          };
	          Data.prototype.writeByte = function (byte) {
	              return this.data[this.pos++] = byte;
	          };
	          Data.prototype.readUInt32 = function () {
	              var b1, b2, b3, b4;
	              b1 = this.readByte() * 0x1000000;
	              b2 = this.readByte() << 16;
	              b3 = this.readByte() << 8;
	              b4 = this.readByte();
	              return b1 + b2 + b3 + b4;
	          };
	          Data.prototype.writeUInt32 = function (val) {
	              this.writeByte((val >>> 24) & 0xff);
	              this.writeByte((val >> 16) & 0xff);
	              this.writeByte((val >> 8) & 0xff);
	              return this.writeByte(val & 0xff);
	          };
	          Data.prototype.readInt32 = function () {
	              var int;
	              int = this.readUInt32();
	              if (int >= 0x80000000) {
	                  return int - 0x100000000;
	              }
	              else {
	                  return int;
	              }
	          };
	          Data.prototype.writeInt32 = function (val) {
	              if (val < 0) {
	                  val += 0x100000000;
	              }
	              return this.writeUInt32(val);
	          };
	          Data.prototype.readUInt16 = function () {
	              var b1, b2;
	              b1 = this.readByte() << 8;
	              b2 = this.readByte();
	              return b1 | b2;
	          };
	          Data.prototype.writeUInt16 = function (val) {
	              this.writeByte((val >> 8) & 0xff);
	              return this.writeByte(val & 0xff);
	          };
	          Data.prototype.readInt16 = function () {
	              var int;
	              int = this.readUInt16();
	              if (int >= 0x8000) {
	                  return int - 0x10000;
	              }
	              else {
	                  return int;
	              }
	          };
	          Data.prototype.writeInt16 = function (val) {
	              if (val < 0) {
	                  val += 0x10000;
	              }
	              return this.writeUInt16(val);
	          };
	          Data.prototype.readString = function (length) {
	              var i, ret, _i;
	              ret = [];
	              for (i = _i = 0; 0 <= length ? _i < length : _i > length; i = 0 <= length ? ++_i : --_i) {
	                  ret[i] = String.fromCharCode(this.readByte());
	              }
	              return ret.join('');
	          };
	          Data.prototype.writeString = function (val) {
	              var i, _i, _ref, _results;
	              _results = [];
	              for (i = _i = 0, _ref = val.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	                  _results.push(this.writeByte(val.charCodeAt(i)));
	              }
	              return _results;
	          };
	          /*Data.prototype.stringAt = function (pos, length) {
	              this.pos = pos;
	              return this.readString(length);
	          };*/
	          Data.prototype.readShort = function () {
	              return this.readInt16();
	          };
	          Data.prototype.writeShort = function (val) {
	              return this.writeInt16(val);
	          };
	          Data.prototype.readLongLong = function () {
	              var b1, b2, b3, b4, b5, b6, b7, b8;
	              b1 = this.readByte();
	              b2 = this.readByte();
	              b3 = this.readByte();
	              b4 = this.readByte();
	              b5 = this.readByte();
	              b6 = this.readByte();
	              b7 = this.readByte();
	              b8 = this.readByte();
	              if (b1 & 0x80) {
	                  return ((b1 ^ 0xff) * 0x100000000000000 + (b2 ^ 0xff) * 0x1000000000000 + (b3 ^ 0xff) * 0x10000000000 + (b4 ^ 0xff) * 0x100000000 + (b5 ^ 0xff) * 0x1000000 + (b6 ^ 0xff) * 0x10000 + (b7 ^ 0xff) * 0x100 + (b8 ^ 0xff) + 1) * -1;
	              }
	              return b1 * 0x100000000000000 + b2 * 0x1000000000000 + b3 * 0x10000000000 + b4 * 0x100000000 + b5 * 0x1000000 + b6 * 0x10000 + b7 * 0x100 + b8;
	          };
	          /*Data.prototype.writeLongLong = function (val) {
	              var high, low;
	              high = Math.floor(val / 0x100000000);
	              low = val & 0xffffffff;
	              this.writeByte((high >> 24) & 0xff);
	              this.writeByte((high >> 16) & 0xff);
	              this.writeByte((high >> 8) & 0xff);
	              this.writeByte(high & 0xff);
	              this.writeByte((low >> 24) & 0xff);
	              this.writeByte((low >> 16) & 0xff);
	              this.writeByte((low >> 8) & 0xff);
	              return this.writeByte(low & 0xff);
	          };*/
	          Data.prototype.readInt = function () {
	              return this.readInt32();
	          };
	          Data.prototype.writeInt = function (val) {
	              return this.writeInt32(val);
	          };
	          /*Data.prototype.slice = function (start, end) {
	              return this.data.slice(start, end);
	          };*/
	          Data.prototype.read = function (bytes) {
	              var buf, i, _i;
	              buf = [];
	              for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
	                  buf.push(this.readByte());
	              }
	              return buf;
	          };
	          Data.prototype.write = function (bytes) {
	              var byte, _i, _len, _results;
	              _results = [];
	              for (_i = 0, _len = bytes.length; _i < _len; _i++) {
	                  byte = bytes[_i];
	                  _results.push(this.writeByte(byte));
	              }
	              return _results;
	          };
	          return Data;
	      })();

	      var Directory = (function () {
	          var checksum;

	          /*****************************************************************************************************/
	          /* function : Directory generator                                                                    */
	          /* comment : Initialize the offset, tag, length, and checksum for each table for the font to be used.*/
	          /*****************************************************************************************************/
	          function Directory(data) {
	              var entry, i, _i, _ref;
	              this.scalarType = data.readInt();
	              this.tableCount = data.readShort();
	              this.searchRange = data.readShort();
	              this.entrySelector = data.readShort();
	              this.rangeShift = data.readShort();
	              this.tables = {};
	              for (i = _i = 0, _ref = this.tableCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	                  entry = {
	                      tag: data.readString(4)
	                      , checksum: data.readInt()
	                      , offset: data.readInt()
	                      , length: data.readInt()
	                  };
	                  this.tables[entry.tag] = entry;
	              }
	          }
	          /********************************************************************************************************/
	          /* function : encode                                                                                    */
	          /* comment : It encodes and stores the font table object and information used for the directory object. */
	          /********************************************************************************************************/
	          Directory.prototype.encode = function (tables) {
	              var adjustment, directory, directoryLength, entrySelector, headOffset, log2, offset, rangeShift, searchRange, sum, table, tableCount, tableData, tag;
	              tableCount = Object.keys(tables).length;
	              log2 = Math.log(2);
	              searchRange = Math.floor(Math.log(tableCount) / log2) * 16;
	              entrySelector = Math.floor(searchRange / log2);
	              rangeShift = tableCount * 16 - searchRange;
	              directory = new Data;
	              directory.writeInt(this.scalarType);
	              directory.writeShort(tableCount);
	              directory.writeShort(searchRange);
	              directory.writeShort(entrySelector);
	              directory.writeShort(rangeShift);
	              directoryLength = tableCount * 16;
	              offset = directory.pos + directoryLength;
	              headOffset = null;
	              tableData = [];
	              for (tag in tables) {
	                  table = tables[tag];
	                  directory.writeString(tag);
	                  directory.writeInt(checksum(table));
	                  directory.writeInt(offset);
	                  directory.writeInt(table.length);
	                  tableData = tableData.concat(table);
	                  if (tag === 'head') {
	                      headOffset = offset;
	                  }
	                  offset += table.length;
	                  while (offset % 4) {
	                      tableData.push(0);
	                      offset++;
	                  }
	              }
	              directory.write(tableData);
	              sum = checksum(directory.data);
	              adjustment = 0xB1B0AFBA - sum;
	              directory.pos = headOffset + 8;
	              directory.writeUInt32(adjustment);
	              return directory.data;
	          };
	          /***************************************************************/
	          /* function : checksum                                         */
	          /* comment : Duplicate the table for the tag.                  */
	          /***************************************************************/
	          checksum = function (data) {
	              var i, sum, tmp, _i, _ref;
	              data = __slice.call(data);
	              while (data.length % 4) {
	                  data.push(0);
	              }
	              tmp = new Data(data);
	              sum = 0;
	              for (i = _i = 0, _ref = data.length; _i < _ref; i = _i += 4) {
	                  sum += tmp.readUInt32();
	              }
	              return sum & 0xFFFFFFFF;
	          };
	          return Directory;
	      })();

	      var Table, __hasProp = {}.hasOwnProperty
	          , __extends = function (child, parent) {
	              for (var key in parent) {
	                  if (__hasProp.call(parent, key)) child[key] = parent[key];
	              }

	              function ctor() {
	                  this.constructor = child;
	              }
	              ctor.prototype = parent.prototype;
	              child.prototype = new ctor();
	              child.__super__ = parent.prototype;
	              return child;
	      };
	      /***************************************************************/
	      /* function : Table                                            */
	      /* comment : Save info for each table, and parse the table.    */
	      /***************************************************************/
	      Table = (function () {
	          function Table(file) {
	              var info;
	              this.file = file;
	              info = this.file.directory.tables[this.tag];
	              this.exists = !!info;
	              if (info) {
	                  this.offset = info.offset, this.length = info.length;
	                  this.parse(this.file.contents);
	              }
	          }
	          Table.prototype.parse = function () {};
	          Table.prototype.encode = function () {};
	          Table.prototype.raw = function () {
	              if (!this.exists) {
	                  return null;
	              }
	              this.file.contents.pos = this.offset;
	              return this.file.contents.read(this.length);
	          };
	          return Table;
	      })();

	      var HeadTable = (function (_super) {
	          __extends(HeadTable, _super);

	          function HeadTable() {
	              return HeadTable.__super__.constructor.apply(this, arguments);
	          }
	          HeadTable.prototype.tag = 'head';
	          HeadTable.prototype.parse = function (data) {
	              data.pos = this.offset;
	              this.version = data.readInt();
	              this.revision = data.readInt();
	              this.checkSumAdjustment = data.readInt();
	              this.magicNumber = data.readInt();
	              this.flags = data.readShort();
	              this.unitsPerEm = data.readShort();
	              this.created = data.readLongLong();
	              this.modified = data.readLongLong();
	              this.xMin = data.readShort();
	              this.yMin = data.readShort();
	              this.xMax = data.readShort();
	              this.yMax = data.readShort();
	              this.macStyle = data.readShort();
	              this.lowestRecPPEM = data.readShort();
	              this.fontDirectionHint = data.readShort();
	              this.indexToLocFormat = data.readShort();
	              return this.glyphDataFormat = data.readShort();
	          };
	          /*HeadTable.prototype.encode = function (loca) {
	              var table;
	              table = new Data;
	              table.writeInt(this.version);
	              table.writeInt(this.revision);
	              table.writeInt(this.checkSumAdjustment);
	              table.writeInt(this.magicNumber);
	              table.writeShort(this.flags);
	              table.writeShort(this.unitsPerEm);
	              table.writeLongLong(this.created);
	              table.writeLongLong(this.modified);
	              table.writeShort(this.xMin);
	              table.writeShort(this.yMin);
	              table.writeShort(this.xMax);
	              table.writeShort(this.yMax);
	              table.writeShort(this.macStyle);
	              table.writeShort(this.lowestRecPPEM);
	              table.writeShort(this.fontDirectionHint);
	              table.writeShort(loca.type);
	              table.writeShort(this.glyphDataFormat);
	              return table.data;
	          };*/
	          return HeadTable;
	      })(Table);

	      /************************************************************************************/
	      /* function : CmapEntry                                                             */
	      /* comment : Cmap Initializes and encodes object information (required by pdf spec).*/
	      /************************************************************************************/
	      var CmapEntry = (function () {
	          function CmapEntry(data, offset) {
	              var code, count, endCode, glyphId, glyphIds, i, idDelta, idRangeOffset, index, saveOffset, segCount, segCountX2, start, startCode, tail, _i, _j, _k, _len;
	              this.platformID = data.readUInt16();
	              this.encodingID = data.readShort();
	              this.offset = offset + data.readInt();
	              saveOffset = data.pos;
	              data.pos = this.offset;
	              this.format = data.readUInt16();
	              this.length = data.readUInt16();
	              this.language = data.readUInt16();
	              this.isUnicode = (this.platformID === 3 && this.encodingID === 1 && this.format === 4) || this.platformID === 0 && this.format === 4;
	              this.codeMap = {};
	              switch (this.format) {
	              case 0:
	                  for (i = _i = 0; _i < 256; i = ++_i) {
	                      this.codeMap[i] = data.readByte();
	                  }
	                  break;
	              case 4:
	                  segCountX2 = data.readUInt16();
	                  segCount = segCountX2 / 2;
	                  data.pos += 6;
	                  endCode = (function () {
	                      var _j, _results;
	                      _results = [];
	                      for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {
	                          _results.push(data.readUInt16());
	                      }
	                      return _results;
	                  })();
	                  data.pos += 2;
	                  startCode = (function () {
	                      var _j, _results;
	                      _results = [];
	                      for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {
	                          _results.push(data.readUInt16());
	                      }
	                      return _results;
	                  })();
	                  idDelta = (function () {
	                      var _j, _results;
	                      _results = [];
	                      for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {
	                          _results.push(data.readUInt16());
	                      }
	                      return _results;
	                  })();
	                  idRangeOffset = (function () {
	                      var _j, _results;
	                      _results = [];
	                      for (i = _j = 0; 0 <= segCount ? _j < segCount : _j > segCount; i = 0 <= segCount ? ++_j : --_j) {
	                          _results.push(data.readUInt16());
	                      }
	                      return _results;
	                  })();
	                  count = (this.length - data.pos + this.offset) / 2;
	                  glyphIds = (function () {
	                      var _j, _results;
	                      _results = [];
	                      for (i = _j = 0; 0 <= count ? _j < count : _j > count; i = 0 <= count ? ++_j : --_j) {
	                          _results.push(data.readUInt16());
	                      }
	                      return _results;
	                  })();
	                  for (i = _j = 0, _len = endCode.length; _j < _len; i = ++_j) {
	                      tail = endCode[i];
	                      start = startCode[i];
	                      for (code = _k = start; start <= tail ? _k <= tail : _k >= tail; code = start <= tail ? ++_k : --_k) {
	                          if (idRangeOffset[i] === 0) {
	                              glyphId = code + idDelta[i];
	                          }
	                          else {
	                              index = idRangeOffset[i] / 2 + (code - start) - (segCount - i);
	                              glyphId = glyphIds[index] || 0;
	                              if (glyphId !== 0) {
	                                  glyphId += idDelta[i];
	                              }
	                          }
	                          this.codeMap[code] = glyphId & 0xFFFF;
	                      }
	                  }
	              }
	              data.pos = saveOffset;
	          }
	          CmapEntry.encode = function (charmap, encoding) {
	              var charMap, code, codeMap, codes, delta, deltas, diff, endCode, endCodes, entrySelector, glyphIDs, i, id, indexes, last, map, nextID, offset, old, rangeOffsets, rangeShift, result, searchRange, segCount, segCountX2, startCode, startCodes, startGlyph, subtable, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _name, _o, _p, _q;
	              subtable = new Data;
	              codes = Object.keys(charmap).sort(function (a, b) {
	                  return a - b;
	              });
	              switch (encoding) {
	              case 'macroman':
	                  id = 0;
	                  indexes = (function () {
	                      var _i, _results;
	                      _results = [];
	                      for (i = _i = 0; _i < 256; i = ++_i) {
	                          _results.push(0);
	                      }
	                      return _results;
	                  })();
	                  map = {
	                      0: 0
	                  };
	                  codeMap = {};
	                  for (_i = 0, _len = codes.length; _i < _len; _i++) {
	                      code = codes[_i];
	                      if (map[_name = charmap[code]] == null) {
	                          map[_name] = ++id;
	                      }
	                      codeMap[code] = {
	                          old: charmap[code]
	                          , "new": map[charmap[code]]
	                      };
	                      indexes[code] = map[charmap[code]];
	                  }
	                  subtable.writeUInt16(1);
	                  subtable.writeUInt16(0);
	                  subtable.writeUInt32(12);
	                  subtable.writeUInt16(0);
	                  subtable.writeUInt16(262);
	                  subtable.writeUInt16(0);
	                  subtable.write(indexes);
	                  return result = {
	                      charMap: codeMap
	                      , subtable: subtable.data
	                      , maxGlyphID: id + 1
	                  };
	              case 'unicode':
	                  startCodes = [];
	                  endCodes = [];
	                  nextID = 0;
	                  map = {};
	                  charMap = {};
	                  last = diff = null;
	                  for (_j = 0, _len1 = codes.length; _j < _len1; _j++) {
	                      code = codes[_j];
	                      old = charmap[code];
	                      if (map[old] == null) {
	                          map[old] = ++nextID;
	                      }
	                      charMap[code] = {
	                          old: old
	                          , "new": map[old]
	                      };
	                      delta = map[old] - code;
	                      if ((last == null) || delta !== diff) {
	                          if (last) {
	                              endCodes.push(last);
	                          }
	                          startCodes.push(code);
	                          diff = delta;
	                      }
	                      last = code;
	                  }
	                  if (last) {
	                      endCodes.push(last);
	                  }
	                  endCodes.push(0xFFFF);
	                  startCodes.push(0xFFFF);
	                  segCount = startCodes.length;
	                  segCountX2 = segCount * 2;
	                  searchRange = 2 * Math.pow(Math.log(segCount) / Math.LN2, 2);
	                  entrySelector = Math.log(searchRange / 2) / Math.LN2;
	                  rangeShift = 2 * segCount - searchRange;
	                  deltas = [];
	                  rangeOffsets = [];
	                  glyphIDs = [];
	                  for (i = _k = 0, _len2 = startCodes.length; _k < _len2; i = ++_k) {
	                      startCode = startCodes[i];
	                      endCode = endCodes[i];
	                      if (startCode === 0xFFFF) {
	                          deltas.push(0);
	                          rangeOffsets.push(0);
	                          break;
	                      }
	                      startGlyph = charMap[startCode]["new"];
	                      if (startCode - startGlyph >= 0x8000) {
	                          deltas.push(0);
	                          rangeOffsets.push(2 * (glyphIDs.length + segCount - i));
	                          for (code = _l = startCode; startCode <= endCode ? _l <= endCode : _l >= endCode; code = startCode <= endCode ? ++_l : --_l) {
	                              glyphIDs.push(charMap[code]["new"]);
	                          }
	                      }
	                      else {
	                          deltas.push(startGlyph - startCode);
	                          rangeOffsets.push(0);
	                      }
	                  }
	                  subtable.writeUInt16(3);
	                  subtable.writeUInt16(1);
	                  subtable.writeUInt32(12);
	                  subtable.writeUInt16(4);
	                  subtable.writeUInt16(16 + segCount * 8 + glyphIDs.length * 2);
	                  subtable.writeUInt16(0);
	                  subtable.writeUInt16(segCountX2);
	                  subtable.writeUInt16(searchRange);
	                  subtable.writeUInt16(entrySelector);
	                  subtable.writeUInt16(rangeShift);
	                  for (_m = 0, _len3 = endCodes.length; _m < _len3; _m++) {
	                      code = endCodes[_m];
	                      subtable.writeUInt16(code);
	                  }
	                  subtable.writeUInt16(0);
	                  for (_n = 0, _len4 = startCodes.length; _n < _len4; _n++) {
	                      code = startCodes[_n];
	                      subtable.writeUInt16(code);
	                  }
	                  for (_o = 0, _len5 = deltas.length; _o < _len5; _o++) {
	                      delta = deltas[_o];
	                      subtable.writeUInt16(delta);
	                  }
	                  for (_p = 0, _len6 = rangeOffsets.length; _p < _len6; _p++) {
	                      offset = rangeOffsets[_p];
	                      subtable.writeUInt16(offset);
	                  }
	                  for (_q = 0, _len7 = glyphIDs.length; _q < _len7; _q++) {
	                      id = glyphIDs[_q];
	                      subtable.writeUInt16(id);
	                  }
	                  return result = {
	                      charMap: charMap
	                      , subtable: subtable.data
	                      , maxGlyphID: nextID + 1
	                  };
	              }
	          };
	          return CmapEntry;
	      })();

	      var CmapTable = (function (_super) {
	          __extends(CmapTable, _super);

	          function CmapTable() {
	              return CmapTable.__super__.constructor.apply(this, arguments);
	          }
	          CmapTable.prototype.tag = 'cmap';
	          CmapTable.prototype.parse = function (data) {
	              var entry, i, tableCount, _i;
	              data.pos = this.offset;
	              this.version = data.readUInt16();
	              tableCount = data.readUInt16();
	              this.tables = [];
	              this.unicode = null;
	              for (i = _i = 0; 0 <= tableCount ? _i < tableCount : _i > tableCount; i = 0 <= tableCount ? ++_i : --_i) {
	                  entry = new CmapEntry(data, this.offset);
	                  this.tables.push(entry);
	                  if (entry.isUnicode) {
	                      if (this.unicode == null) {
	                          this.unicode = entry;
	                      }
	                  }
	              }
	              return true;
	          };
	          /*************************************************************************/
	          /* function : encode                                                     */
	          /* comment : Encode the cmap table corresponding to the input character. */
	          /*************************************************************************/
	          CmapTable.encode = function (charmap, encoding) {
	              var result, table;
	              if (encoding == null) {
	                  encoding = 'macroman';
	              }
	              result = CmapEntry.encode(charmap, encoding);
	              table = new Data;
	              table.writeUInt16(0);
	              table.writeUInt16(1);
	              result.table = table.data.concat(result.subtable);
	              return result;
	          };
	          return CmapTable;
	      })(Table);

	      var HheaTable = (function (_super) {
	          __extends(HheaTable, _super);

	          function HheaTable() {
	              return HheaTable.__super__.constructor.apply(this, arguments);
	          }
	          HheaTable.prototype.tag = 'hhea';
	          HheaTable.prototype.parse = function (data) {
	              data.pos = this.offset;
	              this.version = data.readInt();
	              this.ascender = data.readShort();
	              this.decender = data.readShort();
	              this.lineGap = data.readShort();
	              this.advanceWidthMax = data.readShort();
	              this.minLeftSideBearing = data.readShort();
	              this.minRightSideBearing = data.readShort();
	              this.xMaxExtent = data.readShort();
	              this.caretSlopeRise = data.readShort();
	              this.caretSlopeRun = data.readShort();
	              this.caretOffset = data.readShort();
	              data.pos += 4 * 2;
	              this.metricDataFormat = data.readShort();
	              return this.numberOfMetrics = data.readUInt16();
	          };
	          /*HheaTable.prototype.encode = function (ids) {
	              var i, table, _i, _ref;
	              table = new Data;
	              table.writeInt(this.version);
	              table.writeShort(this.ascender);
	              table.writeShort(this.decender);
	              table.writeShort(this.lineGap);
	              table.writeShort(this.advanceWidthMax);
	              table.writeShort(this.minLeftSideBearing);
	              table.writeShort(this.minRightSideBearing);
	              table.writeShort(this.xMaxExtent);
	              table.writeShort(this.caretSlopeRise);
	              table.writeShort(this.caretSlopeRun);
	              table.writeShort(this.caretOffset);
	              for (i = _i = 0, _ref = 4 * 2; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	                  table.writeByte(0);
	              }
	              table.writeShort(this.metricDataFormat);
	              table.writeUInt16(ids.length);
	              return table.data;
	          };*/
	          return HheaTable;
	      })(Table);

	      var OS2Table = (function (_super) {
	          __extends(OS2Table, _super);

	          function OS2Table() {
	              return OS2Table.__super__.constructor.apply(this, arguments);
	          }
	          OS2Table.prototype.tag = 'OS/2';
	          OS2Table.prototype.parse = function (data) {
	              var i;
	              data.pos = this.offset;
	              this.version = data.readUInt16();
	              this.averageCharWidth = data.readShort();
	              this.weightClass = data.readUInt16();
	              this.widthClass = data.readUInt16();
	              this.type = data.readShort();
	              this.ySubscriptXSize = data.readShort();
	              this.ySubscriptYSize = data.readShort();
	              this.ySubscriptXOffset = data.readShort();
	              this.ySubscriptYOffset = data.readShort();
	              this.ySuperscriptXSize = data.readShort();
	              this.ySuperscriptYSize = data.readShort();
	              this.ySuperscriptXOffset = data.readShort();
	              this.ySuperscriptYOffset = data.readShort();
	              this.yStrikeoutSize = data.readShort();
	              this.yStrikeoutPosition = data.readShort();
	              this.familyClass = data.readShort();
	              this.panose = (function () {
	                  var _i, _results;
	                  _results = [];
	                  for (i = _i = 0; _i < 10; i = ++_i) {
	                      _results.push(data.readByte());
	                  }
	                  return _results;
	              })();
	              this.charRange = (function () {
	                  var _i, _results;
	                  _results = [];
	                  for (i = _i = 0; _i < 4; i = ++_i) {
	                      _results.push(data.readInt());
	                  }
	                  return _results;
	              })();
	              this.vendorID = data.readString(4);
	              this.selection = data.readShort();
	              this.firstCharIndex = data.readShort();
	              this.lastCharIndex = data.readShort();
	              if (this.version > 0) {
	                  this.ascent = data.readShort();
	                  this.descent = data.readShort();
	                  this.lineGap = data.readShort();
	                  this.winAscent = data.readShort();
	                  this.winDescent = data.readShort();
	                  this.codePageRange = (function () {
	                      var _i, _results;
	                      _results = [];
	                      for (i = _i = 0; _i < 2; i = ++_i) {
	                          _results.push(data.readInt());
	                      }
	                      return _results;
	                  })();
	                  if (this.version > 1) {
	                      this.xHeight = data.readShort();
	                      this.capHeight = data.readShort();
	                      this.defaultChar = data.readShort();
	                      this.breakChar = data.readShort();
	                      return this.maxContext = data.readShort();
	                  }
	              }
	          };
	          /*OS2Table.prototype.encode = function () {
	              return this.raw();
	          };*/
	          return OS2Table;
	      })(Table);

	      var PostTable = (function (_super) {
	          __extends(PostTable, _super);

	          function PostTable() {
	              return PostTable.__super__.constructor.apply(this, arguments);
	          }
	          PostTable.prototype.tag = 'post';
	          PostTable.prototype.parse = function (data) {
	              var i, length, numberOfGlyphs, _i, _results;
	              data.pos = this.offset;
	              this.format = data.readInt();
	              this.italicAngle = data.readInt();
	              this.underlinePosition = data.readShort();
	              this.underlineThickness = data.readShort();
	              this.isFixedPitch = data.readInt();
	              this.minMemType42 = data.readInt();
	              this.maxMemType42 = data.readInt();
	              this.minMemType1 = data.readInt();
	              this.maxMemType1 = data.readInt();
	              switch (this.format) {
	              case 0x00010000:
	                  break;
	              case 0x00020000:
	                  numberOfGlyphs = data.readUInt16();
	                  this.glyphNameIndex = [];
	                  for (i = _i = 0; 0 <= numberOfGlyphs ? _i < numberOfGlyphs : _i > numberOfGlyphs; i = 0 <= numberOfGlyphs ? ++_i : --_i) {
	                      this.glyphNameIndex.push(data.readUInt16());
	                  }
	                  this.names = [];
	                  _results = [];
	                  while (data.pos < this.offset + this.length) {
	                      length = data.readByte();
	                      _results.push(this.names.push(data.readString(length)));
	                  }
	                  return _results;
	                  break;
	              case 0x00025000:
	                  numberOfGlyphs = data.readUInt16();
	                  return this.offsets = data.read(numberOfGlyphs);
	              case 0x00030000:
	                  break;
	              case 0x00040000:
	                  return this.map = (function () {
	                      var _j, _ref, _results1;
	                      _results1 = [];
	                      for (i = _j = 0, _ref = this.file.maxp.numGlyphs; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
	                          _results1.push(data.readUInt32());
	                      }
	                      return _results1;
	                  }).call(this);
	              }
	          };
	          return PostTable;
	      })(Table);

	      /*********************************************************************************************************/
	      /* function : NameEntry                                                                                  */
	      /* comment : Store copyright information, platformID, encodingID, and languageID in the NameEntry object.*/
	      /*********************************************************************************************************/
	      var NameEntry = (function () {
	          function NameEntry(raw, entry) {
	              this.raw = raw;
	              this.length = raw.length;
	              this.platformID = entry.platformID;
	              this.encodingID = entry.encodingID;
	              this.languageID = entry.languageID;
	          }
	          return NameEntry;
	      })();

	      var NameTable = (function (_super) {
	          __extends(NameTable, _super);

	          function NameTable() {
	              return NameTable.__super__.constructor.apply(this, arguments);
	          }
	          NameTable.prototype.tag = 'name';
	          NameTable.prototype.parse = function (data) {
	              var count, entries, entry, format, i, name, stringOffset, strings, text, _i, _j, _len, _name;
	              data.pos = this.offset;
	              format = data.readShort();
	              count = data.readShort();
	              stringOffset = data.readShort();
	              entries = [];
	              for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
	                  entries.push({
	                      platformID: data.readShort()
	                      , encodingID: data.readShort()
	                      , languageID: data.readShort()
	                      , nameID: data.readShort()
	                      , length: data.readShort()
	                      , offset: this.offset + stringOffset + data.readShort()
	                  });
	              }
	              strings = {};
	              for (i = _j = 0, _len = entries.length; _j < _len; i = ++_j) {
	                  entry = entries[i];
	                  data.pos = entry.offset;
	                  text = data.readString(entry.length);
	                  name = new NameEntry(text, entry);
	                  if (strings[_name = entry.nameID] == null) {
	                      strings[_name] = [];
	                  }
	                  strings[entry.nameID].push(name);
	              }
	              this.strings = strings;
	              this.copyright = strings[0];
	              this.fontFamily = strings[1];
	              this.fontSubfamily = strings[2];
	              this.uniqueSubfamily = strings[3];
	              this.fontName = strings[4];
	              this.version = strings[5];
	              this.postscriptName = strings[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
	              this.trademark = strings[7];
	              this.manufacturer = strings[8];
	              this.designer = strings[9];
	              this.description = strings[10];
	              this.vendorUrl = strings[11];
	              this.designerUrl = strings[12];
	              this.license = strings[13];
	              this.licenseUrl = strings[14];
	              this.preferredFamily = strings[15];
	              this.preferredSubfamily = strings[17];
	              this.compatibleFull = strings[18];
	              return this.sampleText = strings[19];
	          };
	          /*NameTable.prototype.encode = function () {
	              var id, list, nameID, nameTable, postscriptName, strCount, strTable, string, strings, table, val, _i, _len, _ref;
	              strings = {};
	              _ref = this.strings;
	              for (id in _ref) {
	                  val = _ref[id];
	                  strings[id] = val;
	              }
	              postscriptName = new NameEntry("" + subsetTag + "+" + this.postscriptName, {
	                  platformID: 1
	                  , encodingID: 0
	                  , languageID: 0
	              });
	              strings[6] = [postscriptName];
	              subsetTag = successorOf(subsetTag);
	              strCount = 0;
	              for (id in strings) {
	                  list = strings[id];
	                  if (list != null) {
	                      strCount += list.length;
	                  }
	              }
	              table = new Data;
	              strTable = new Data;
	              table.writeShort(0);
	              table.writeShort(strCount);
	              table.writeShort(6 + 12 * strCount);
	              for (nameID in strings) {
	                  list = strings[nameID];
	                  if (list != null) {
	                      for (_i = 0, _len = list.length; _i < _len; _i++) {
	                          string = list[_i];
	                          table.writeShort(string.platformID);
	                          table.writeShort(string.encodingID);
	                          table.writeShort(string.languageID);
	                          table.writeShort(nameID);
	                          table.writeShort(string.length);
	                          table.writeShort(strTable.pos);
	                          strTable.writeString(string.raw);
	                      }
	                  }
	              }
	              return nameTable = {
	                  postscriptName: postscriptName.raw
	                  , table: table.data.concat(strTable.data)
	              };
	          };*/
	          return NameTable;
	      })(Table);

	      var MaxpTable = (function (_super) {
	          __extends(MaxpTable, _super);

	          function MaxpTable() {
	              return MaxpTable.__super__.constructor.apply(this, arguments);
	          }
	          MaxpTable.prototype.tag = 'maxp';
	          MaxpTable.prototype.parse = function (data) {
	              data.pos = this.offset;
	              this.version = data.readInt();
	              this.numGlyphs = data.readUInt16();
	              this.maxPoints = data.readUInt16();
	              this.maxContours = data.readUInt16();
	              this.maxCompositePoints = data.readUInt16();
	              this.maxComponentContours = data.readUInt16();
	              this.maxZones = data.readUInt16();
	              this.maxTwilightPoints = data.readUInt16();
	              this.maxStorage = data.readUInt16();
	              this.maxFunctionDefs = data.readUInt16();
	              this.maxInstructionDefs = data.readUInt16();
	              this.maxStackElements = data.readUInt16();
	              this.maxSizeOfInstructions = data.readUInt16();
	              this.maxComponentElements = data.readUInt16();
	              return this.maxComponentDepth = data.readUInt16();
	          };
	          /*MaxpTable.prototype.encode = function (ids) {
	              var table;
	              table = new Data;
	              table.writeInt(this.version);
	              table.writeUInt16(ids.length);
	              table.writeUInt16(this.maxPoints);
	              table.writeUInt16(this.maxContours);
	              table.writeUInt16(this.maxCompositePoints);
	              table.writeUInt16(this.maxComponentContours);
	              table.writeUInt16(this.maxZones);
	              table.writeUInt16(this.maxTwilightPoints);
	              table.writeUInt16(this.maxStorage);
	              table.writeUInt16(this.maxFunctionDefs);
	              table.writeUInt16(this.maxInstructionDefs);
	              table.writeUInt16(this.maxStackElements);
	              table.writeUInt16(this.maxSizeOfInstructions);
	              table.writeUInt16(this.maxComponentElements);
	              table.writeUInt16(this.maxComponentDepth);
	              return table.data;
	          };*/
	          return MaxpTable;
	      })(Table);

	      var HmtxTable = (function (_super) {
	          __extends(HmtxTable, _super);

	          function HmtxTable() {
	              return HmtxTable.__super__.constructor.apply(this, arguments);
	          }
	          HmtxTable.prototype.tag = 'hmtx';
	          HmtxTable.prototype.parse = function (data) {
	              var i, last, lsbCount, m, _i, _j, _ref, _results;
	              data.pos = this.offset;
	              this.metrics = [];
	              for (i = _i = 0, _ref = this.file.hhea.numberOfMetrics; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	                  this.metrics.push({
	                      advance: data.readUInt16()
	                      , lsb: data.readInt16()
	                  });
	              }
	              lsbCount = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics;
	              this.leftSideBearings = (function () {
	                  var _j, _results;
	                  _results = [];
	                  for (i = _j = 0; 0 <= lsbCount ? _j < lsbCount : _j > lsbCount; i = 0 <= lsbCount ? ++_j : --_j) {
	                      _results.push(data.readInt16());
	                  }
	                  return _results;
	              })();
	              this.widths = (function () {
	                  var _j, _len, _ref1, _results;
	                  _ref1 = this.metrics;
	                  _results = [];
	                  for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
	                      m = _ref1[_j];
	                      _results.push(m.advance);
	                  }
	                  return _results;
	              }).call(this);
	              last = this.widths[this.widths.length - 1];
	              _results = [];
	              for (i = _j = 0; 0 <= lsbCount ? _j < lsbCount : _j > lsbCount; i = 0 <= lsbCount ? ++_j : --_j) {
	                  _results.push(this.widths.push(last));
	              }
	              return _results;
	          };
	          /***************************************************************/
	          /* function : forGlyph                                         */
	          /* comment : Returns the advance width and lsb for this glyph. */
	          /***************************************************************/
	          HmtxTable.prototype.forGlyph = function (id) {
	              var metrics;
	              if (id in this.metrics) {
	                  return this.metrics[id];
	              }
	              return metrics = {
	                  advance: this.metrics[this.metrics.length - 1].advance
	                  , lsb: this.leftSideBearings[id - this.metrics.length]
	              };
	          };
	          /*HmtxTable.prototype.encode = function (mapping) {
	              var id, metric, table, _i, _len;
	              table = new Data;
	              for (_i = 0, _len = mapping.length; _i < _len; _i++) {
	                  id = mapping[_i];
	                  metric = this.forGlyph(id);
	                  table.writeUInt16(metric.advance);
	                  table.writeUInt16(metric.lsb);
	              }
	              return table.data;
	          };*/
	          return HmtxTable;
	      })(Table);

	      var __slice = [].slice;

	      var GlyfTable = (function (_super) {
	          __extends(GlyfTable, _super);

	          function GlyfTable() {
	              return GlyfTable.__super__.constructor.apply(this, arguments);
	          }
	          GlyfTable.prototype.tag = 'glyf';
	          GlyfTable.prototype.parse = function (data) {
	              return this.cache = {};
	          };
	          GlyfTable.prototype.glyphFor = function (id) {
	              id = id;
	              var data, index, length, loca, numberOfContours, raw, xMax, xMin, yMax, yMin;
	              if (id in this.cache) {
	                  return this.cache[id];
	              }
	              loca = this.file.loca;
	              data = this.file.contents;
	              index = loca.indexOf(id);
	              length = loca.lengthOf(id);
	              if (length === 0) {
	                  return this.cache[id] = null;
	              }
	              data.pos = this.offset + index;
	              raw = new Data(data.read(length));
	              numberOfContours = raw.readShort();
	              xMin = raw.readShort();
	              yMin = raw.readShort();
	              xMax = raw.readShort();
	              yMax = raw.readShort();
	              if (numberOfContours === -1) {
	                  this.cache[id] = new CompoundGlyph(raw, xMin, yMin, xMax, yMax);
	              }
	              else {
	                  this.cache[id] = new SimpleGlyph(raw, numberOfContours, xMin, yMin, xMax, yMax);
	              }
	              return this.cache[id];
	          };
	          GlyfTable.prototype.encode = function (glyphs, mapping, old2new) {
	              var glyph, id, offsets, table, _i, _len;
	              table = [];
	              offsets = [];
	              for (_i = 0, _len = mapping.length; _i < _len; _i++) {
	                  id = mapping[_i];
	                  glyph = glyphs[id];
	                  offsets.push(table.length);
	                  if (glyph) {
	                      table = table.concat(glyph.encode(old2new));
	                  }
	              }
	              offsets.push(table.length);
	              return {
	                  table: table
	                  , offsets: offsets
	              };
	          };
	          return GlyfTable;
	      })(Table);

	      var SimpleGlyph = (function () {
	          /**************************************************************************/
	          /* function : SimpleGlyph                                                 */
	          /* comment : Stores raw, xMin, yMin, xMax, and yMax values for this glyph.*/
	          /**************************************************************************/
	          function SimpleGlyph(raw, numberOfContours, xMin, yMin, xMax, yMax) {
	              this.raw = raw;
	              this.numberOfContours = numberOfContours;
	              this.xMin = xMin;
	              this.yMin = yMin;
	              this.xMax = xMax;
	              this.yMax = yMax;
	              this.compound = false;
	          }
	          SimpleGlyph.prototype.encode = function () {
	              return this.raw.data;
	          };
	          return SimpleGlyph;
	      })();

	      var CompoundGlyph = (function () {
	          var ARG_1_AND_2_ARE_WORDS, MORE_COMPONENTS, WE_HAVE_AN_X_AND_Y_SCALE, WE_HAVE_A_SCALE, WE_HAVE_A_TWO_BY_TWO;
	          ARG_1_AND_2_ARE_WORDS = 0x0001;
	          WE_HAVE_A_SCALE = 0x0008;
	          MORE_COMPONENTS = 0x0020;
	          WE_HAVE_AN_X_AND_Y_SCALE = 0x0040;
	          WE_HAVE_A_TWO_BY_TWO = 0x0080;

	          /********************************************************************************************************************/
	          /* function : CompoundGlypg generator                                                                               */
	          /* comment : It stores raw, xMin, yMin, xMax, yMax, glyph id, and glyph offset for the corresponding compound glyph.*/
	          /********************************************************************************************************************/
	          function CompoundGlyph(raw, xMin, yMin, xMax, yMax) {
	              var data, flags;
	              this.raw = raw;
	              this.xMin = xMin;
	              this.yMin = yMin;
	              this.xMax = xMax;
	              this.yMax = yMax;
	              this.compound = true;
	              this.glyphIDs = [];
	              this.glyphOffsets = [];
	              data = this.raw;
	              while (true) {
	                  flags = data.readShort();
	                  this.glyphOffsets.push(data.pos);
	                  this.glyphIDs.push(data.readShort());
	                  if (!(flags & MORE_COMPONENTS)) {
	                      break;
	                  }
	                  if (flags & ARG_1_AND_2_ARE_WORDS) {
	                      data.pos += 4;
	                  }
	                  else {
	                      data.pos += 2;
	                  }
	                  if (flags & WE_HAVE_A_TWO_BY_TWO) {
	                      data.pos += 8;
	                  }
	                  else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
	                      data.pos += 4;
	                  }
	                  else if (flags & WE_HAVE_A_SCALE) {
	                      data.pos += 2;
	                  }
	              }
	          }
	          /****************************************************************************************************************/
	          /* function : CompoundGlypg encode                                                                              */
	          /* comment : After creating a table for the characters you typed, you call directory.encode to encode the table.*/
	          /****************************************************************************************************************/
	          CompoundGlyph.prototype.encode = function (mapping) {
	              var i, id, result, _i, _len, _ref;
	              result = new Data(__slice.call(this.raw.data));
	              _ref = this.glyphIDs;
	              for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
	                  id = _ref[i];
	                  result.pos = this.glyphOffsets[i];
	              }
	              return result.data;
	          };
	          return CompoundGlyph;
	      })();

	      var LocaTable = (function (_super) {
	          __extends(LocaTable, _super);

	          function LocaTable() {
	              return LocaTable.__super__.constructor.apply(this, arguments);
	          }
	          LocaTable.prototype.tag = 'loca';
	          LocaTable.prototype.parse = function (data) {
	              var format, i;
	              data.pos = this.offset;
	              format = this.file.head.indexToLocFormat;
	              if (format === 0) {
	                  return this.offsets = (function () {
	                      var _i, _ref, _results;
	                      _results = [];
	                      for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 2) {
	                          _results.push(data.readUInt16() * 2);
	                      }
	                      return _results;
	                  }).call(this);
	              }
	              else {
	                  return this.offsets = (function () {
	                      var _i, _ref, _results;
	                      _results = [];
	                      for (i = _i = 0, _ref = this.length; _i < _ref; i = _i += 4) {
	                          _results.push(data.readUInt32());
	                      }
	                      return _results;
	                  }).call(this);
	              }
	          };
	          LocaTable.prototype.indexOf = function (id) {
	              return this.offsets[id];
	          };
	          LocaTable.prototype.lengthOf = function (id) {
	              return this.offsets[id + 1] - this.offsets[id];
	          };
	          LocaTable.prototype.encode = function (offsets, activeGlyphs) {
	              var LocaTable = new Uint32Array(this.offsets.length);
	              var glyfPtr = 0;
	              var listGlyf = 0;
	              for (var k = 0; k < LocaTable.length; ++k) {
	                  LocaTable[k] = glyfPtr;
	                  if (listGlyf < activeGlyphs.length && activeGlyphs[listGlyf] == k) {
	                      ++listGlyf;
	                      LocaTable[k] = glyfPtr;
	                      var start = this.offsets[k];
	                      var len = this.offsets[k + 1] - start;
	                      if (len > 0) {
	                          glyfPtr += len;
	                      }
	                  }
	              }
	              var newLocaTable = new Array(LocaTable.length * 4);
	              for (var j = 0; j < LocaTable.length; ++j) {
	                  newLocaTable[4 * j + 3] = (LocaTable[j] & 0x000000ff);
	                  newLocaTable[4 * j + 2] = (LocaTable[j] & 0x0000ff00) >> 8;
	                  newLocaTable[4 * j + 1] = (LocaTable[j] & 0x00ff0000) >> 16;
	                  newLocaTable[4 * j] = (LocaTable[j] & 0xff000000) >> 24;
	              }
	              return newLocaTable;
	          };
	          return LocaTable;
	      })(Table);

	      /************************************************************************************/
	      /* function : invert                                                                */
	      /* comment : Change the object's (key: value) to create an object with (value: key).*/
	      /************************************************************************************/
	      var invert = function (object) {
	          var key, ret, val;
	          ret = {};
	          for (key in object) {
	              val = object[key];
	              ret[val] = key;
	          }
	          return ret;
	      };

	      /*var successorOf = function (input) {
	          var added, alphabet, carry, i, index, isUpperCase, last, length, next, result;
	          alphabet = 'abcdefghijklmnopqrstuvwxyz';
	          length = alphabet.length;
	          result = input;
	          i = input.length;
	          while (i >= 0) {
	              last = input.charAt(--i);
	              if (isNaN(last)) {
	                  index = alphabet.indexOf(last.toLowerCase());
	                  if (index === -1) {
	                      next = last;
	                      carry = true;
	                  }
	                  else {
	                      next = alphabet.charAt((index + 1) % length);
	                      isUpperCase = last === last.toUpperCase();
	                      if (isUpperCase) {
	                          next = next.toUpperCase();
	                      }
	                      carry = index + 1 >= length;
	                      if (carry && i === 0) {
	                          added = isUpperCase ? 'A' : 'a';
	                          result = added + next + result.slice(1);
	                          break;
	                      }
	                  }
	              }
	              else {
	                  next = +last + 1;
	                  carry = next > 9;
	                  if (carry) {
	                      next = 0;
	                  }
	                  if (carry && i === 0) {
	                      result = '1' + next + result.slice(1);
	                      break;
	                  }
	              }
	              result = result.slice(0, i) + next + result.slice(i + 1);
	              if (!carry) {
	                  break;
	              }
	          }
	          return result;
	      };*/

	      var Subset = (function () {
	          function Subset(font) {
	              this.font = font;
	              this.subset = {};
	              this.unicodes = {};
	              this.next = 33;
	          }
	          /*Subset.prototype.use = function (character) {
	              var i, _i, _ref;
	              if (typeof character === 'string') {
	                  for (i = _i = 0, _ref = character.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	                      this.use(character.charCodeAt(i));
	                  }
	                  return;
	              }
	              if (!this.unicodes[character]) {
	                  this.subset[this.next] = character;
	                  return this.unicodes[character] = this.next++;
	              }
	          };*/
	          /*Subset.prototype.encodeText = function (text) {
	              var char, i, string, _i, _ref;
	              string = '';
	              for (i = _i = 0, _ref = text.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
	                  char = this.unicodes[text.charCodeAt(i)];
	                  string += String.fromCharCode(char);
	              }
	              return string;
	          };*/
	          /***************************************************************/
	          /* function : generateCmap                                     */
	          /* comment : Returns the unicode cmap for this font.         */
	          /***************************************************************/
	          Subset.prototype.generateCmap = function () {
	              var mapping, roman, unicode, unicodeCmap, _ref;
	              unicodeCmap = this.font.cmap.tables[0].codeMap;
	              mapping = {};
	              _ref = this.subset;
	              for (roman in _ref) {
	                  unicode = _ref[roman];
	                  mapping[roman] = unicodeCmap[unicode];
	              }
	              return mapping;
	          };
	          /*Subset.prototype.glyphIDs = function () {
	              var ret, roman, unicode, unicodeCmap, val, _ref;
	              unicodeCmap = this.font.cmap.tables[0].codeMap;
	              ret = [0];
	              _ref = this.subset;
	              for (roman in _ref) {
	                  unicode = _ref[roman];
	                  val = unicodeCmap[unicode];
	                  if ((val != null) && __indexOf.call(ret, val) < 0) {
	                      ret.push(val);
	                  }
	              }
	              return ret.sort();
	          };*/
	          /******************************************************************/
	          /* function : glyphsFor                                           */
	          /* comment : Returns simple glyph objects for the input character.*/
	          /******************************************************************/
	          Subset.prototype.glyphsFor = function (glyphIDs) {
	              var additionalIDs, glyph, glyphs, id, _i, _len, _ref;
	              glyphs = {};
	              for (_i = 0, _len = glyphIDs.length; _i < _len; _i++) {
	                  id = glyphIDs[_i];
	                  glyphs[id] = this.font.glyf.glyphFor(id);
	              }
	              additionalIDs = [];
	              for (id in glyphs) {
	                  glyph = glyphs[id];
	                  if (glyph != null ? glyph.compound : void 0) {
	                      additionalIDs.push.apply(additionalIDs, glyph.glyphIDs);
	                  }
	              }
	              if (additionalIDs.length > 0) {
	                  _ref = this.glyphsFor(additionalIDs);
	                  for (id in _ref) {
	                      glyph = _ref[id];
	                      glyphs[id] = glyph;
	                  }
	              }
	              return glyphs;
	          };
	          /***************************************************************/
	          /* function : encode                                           */
	          /* comment : Encode various tables for the characters you use. */
	          /***************************************************************/
	          Subset.prototype.encode = function (glyID) {
	              var cmap, code, glyf, glyphs, id, ids, loca, new2old, newIDs, nextGlyphID, old2new, oldID, oldIDs, tables, _ref;
	              cmap = CmapTable.encode(this.generateCmap(), 'unicode');
	              glyphs = this.glyphsFor(glyID);
	              old2new = {
	                  0: 0
	              };
	              _ref = cmap.charMap;
	              for (code in _ref) {
	                  ids = _ref[code];
	                  old2new[ids.old] = ids["new"];
	              }
	              nextGlyphID = cmap.maxGlyphID;
	              for (oldID in glyphs) {
	                  if (!(oldID in old2new)) {
	                      old2new[oldID] = nextGlyphID++;
	                  }
	              }
	              new2old = invert(old2new);
	              newIDs = Object.keys(new2old).sort(function (a, b) {
	                  return a - b;
	              });
	              oldIDs = (function () {
	                  var _i, _len, _results;
	                  _results = [];
	                  for (_i = 0, _len = newIDs.length; _i < _len; _i++) {
	                      id = newIDs[_i];
	                      _results.push(new2old[id]);
	                  }
	                  return _results;
	              })();
	              glyf = this.font.glyf.encode(glyphs, oldIDs, old2new);
	              loca = this.font.loca.encode(glyf.offsets, oldIDs);
	              tables = {
	                  cmap: this.font.cmap.raw()
	                  , glyf: glyf.table
	                  , loca: loca
	                  , hmtx: this.font.hmtx.raw()
	                  , hhea: this.font.hhea.raw()
	                  , maxp: this.font.maxp.raw()
	                  , post: this.font.post.raw()
	                  , name: this.font.name.raw()
	                  , head: this.font.head.raw()
	              };
	              if (this.font.os2.exists) {
	                  tables['OS/2'] = this.font.os2.raw();
	              }
	              return this.font.directory.encode(tables);
	          };
	          return Subset;
	      })();

	      jsPDF.API.PDFObject = (function () {
	          var pad;

	          function PDFObject() {}
	          pad = function (str, length) {
	              return (Array(length + 1).join('0') + str).slice(-length);
	          };
	          /*****************************************************************************/
	          /* function : convert                                                        */
	          /* comment :Converts pdf tag's / FontBBox and array values in / W to strings */
	          /*****************************************************************************/
	          PDFObject.convert = function (object) {
	              var e, items, key, out, val;
	              if (Array.isArray(object)) {
	                  items = ((function () {
	                      var _i, _len, _results;
	                      _results = [];
	                      for (_i = 0, _len = object.length; _i < _len; _i++) {
	                          e = object[_i];
	                          _results.push(PDFObject.convert(e));
	                      }
	                      return _results;
	                  })()).join(' ');
	                  return '[' + items + ']';
	              }
	              else if (typeof object === 'string') {
	                  return '/' + object;
	              }
	              else if (object != null ? object.isString : void 0) {
	                  return '(' + object + ')';
	              }
	              else if (object instanceof Date) {
	                  return '(D:' + pad(object.getUTCFullYear(), 4) + pad(object.getUTCMonth(), 2) + pad(object.getUTCDate(), 2) + pad(object.getUTCHours(), 2) + pad(object.getUTCMinutes(), 2) + pad(object.getUTCSeconds(), 2) + 'Z)';
	              }
	              else if ({}.toString.call(object) === '[object Object]') {
	                  out = ['<<'];
	                  for (key in object) {
	                      val = object[key];
	                      out.push('/' + key + ' ' + PDFObject.convert(val));
	                  }
	                  out.push('>>');
	                  return out.join('\n');
	              }
	              else {
	                  return '' + object;
	              }
	          };
	          return PDFObject;
	      })();
	  })(jsPDF);

	  // Generated by CoffeeScript 1.4.0

	  /*
	  # PNG.js
	  # Copyright (c) 2011 Devon Govett
	  # MIT LICENSE
	  # 
	  # 
	  */


	  (function(global) {
	    var PNG;

	    PNG = (function() {
	      var APNG_BLEND_OP_SOURCE, APNG_DISPOSE_OP_BACKGROUND, APNG_DISPOSE_OP_PREVIOUS, makeImage, scratchCanvas, scratchCtx;

	      PNG.load = function(url, canvas, callback) {
	        var xhr;
	        if (typeof canvas === 'function') {
	          callback = canvas;
	        }
	        xhr = new XMLHttpRequest;
	        xhr.open("GET", url, true);
	        xhr.responseType = "arraybuffer";
	        xhr.onload = function() {
	          var data, png;
	          data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
	          png = new PNG(data);
	          if (typeof (canvas != null ? canvas.getContext : void 0) === 'function') {
	            png.render(canvas);
	          }
	          return typeof callback === "function" ? callback(png) : void 0;
	        };
	        return xhr.send(null);
	      };

	      APNG_DISPOSE_OP_BACKGROUND = 1;

	      APNG_DISPOSE_OP_PREVIOUS = 2;

	      APNG_BLEND_OP_SOURCE = 0;

	      function PNG(data) {
	        var chunkSize, colors, palLen, delayDen, delayNum, frame, i, index, key, section, palShort, text, _i, _j, _ref;
	        this.data = data;
	        this.pos = 8;
	        this.palette = [];
	        this.imgData = [];
	        this.transparency = {};
	        this.animation = null;
	        this.text = {};
	        frame = null;
	        while (true) {
	          chunkSize = this.readUInt32();
	          section = ((function() {
	            var _i, _results;
	            _results = [];
	            for (i = _i = 0; _i < 4; i = ++_i) {
	              _results.push(String.fromCharCode(this.data[this.pos++]));
	            }
	            return _results;
	          }).call(this)).join('');
	          switch (section) {
	            case 'IHDR':
	              this.width = this.readUInt32();
	              this.height = this.readUInt32();
	              this.bits = this.data[this.pos++];
	              this.colorType = this.data[this.pos++];
	              this.compressionMethod = this.data[this.pos++];
	              this.filterMethod = this.data[this.pos++];
	              this.interlaceMethod = this.data[this.pos++];
	              break;
	            case 'acTL':
	              this.animation = {
	                numFrames: this.readUInt32(),
	                numPlays: this.readUInt32() || Infinity,
	                frames: []
	              };
	              break;
	            case 'PLTE':
	              this.palette = this.read(chunkSize);
	              break;
	            case 'fcTL':
	              if (frame) {
	                this.animation.frames.push(frame);
	              }
	              this.pos += 4;
	              frame = {
	                width: this.readUInt32(),
	                height: this.readUInt32(),
	                xOffset: this.readUInt32(),
	                yOffset: this.readUInt32()
	              };
	              delayNum = this.readUInt16();
	              delayDen = this.readUInt16() || 100;
	              frame.delay = 1000 * delayNum / delayDen;
	              frame.disposeOp = this.data[this.pos++];
	              frame.blendOp = this.data[this.pos++];
	              frame.data = [];
	              break;
	            case 'IDAT':
	            case 'fdAT':
	              if (section === 'fdAT') {
	                this.pos += 4;
	                chunkSize -= 4;
	              }
	              data = (frame != null ? frame.data : void 0) || this.imgData;
	              for (i = _i = 0; 0 <= chunkSize ? _i < chunkSize : _i > chunkSize; i = 0 <= chunkSize ? ++_i : --_i) {
	                data.push(this.data[this.pos++]);
	              }
	              break;
	            case 'tRNS':
	              this.transparency = {};
	              switch (this.colorType) {
	                case 3:
	              	palLen = this.palette.length/3;
	                  this.transparency.indexed = this.read(chunkSize);
	                  if(this.transparency.indexed.length > palLen)
	                  	throw new Error('More transparent colors than palette size');
	                  /*
	                   * According to the PNG spec trns should be increased to the same size as palette if shorter
	                   */
	                  //palShort = 255 - this.transparency.indexed.length;
	                  palShort = palLen - this.transparency.indexed.length;
	                  if (palShort > 0) {
	                    for (i = _j = 0; 0 <= palShort ? _j < palShort : _j > palShort; i = 0 <= palShort ? ++_j : --_j) {
	                      this.transparency.indexed.push(255);
	                    }
	                  }
	                  break;
	                case 0:
	                  this.transparency.grayscale = this.read(chunkSize)[0];
	                  break;
	                case 2:
	                  this.transparency.rgb = this.read(chunkSize);
	              }
	              break;
	            case 'tEXt':
	              text = this.read(chunkSize);
	              index = text.indexOf(0);
	              key = String.fromCharCode.apply(String, text.slice(0, index));
	              this.text[key] = String.fromCharCode.apply(String, text.slice(index + 1));
	              break;
	            case 'IEND':
	              if (frame) {
	                this.animation.frames.push(frame);
	              }
	              this.colors = (function() {
	                switch (this.colorType) {
	                  case 0:
	                  case 3:
	                  case 4:
	                    return 1;
	                  case 2:
	                  case 6:
	                    return 3;
	                }
	              }).call(this);
	              this.hasAlphaChannel = (_ref = this.colorType) === 4 || _ref === 6;
	              colors = this.colors + (this.hasAlphaChannel ? 1 : 0);
	              this.pixelBitlength = this.bits * colors;
	              this.colorSpace = (function() {
	                switch (this.colors) {
	                  case 1:
	                    return 'DeviceGray';
	                  case 3:
	                    return 'DeviceRGB';
	                }
	              }).call(this);
	              this.imgData = new Uint8Array(this.imgData);
	              return;
	            default:
	              this.pos += chunkSize;
	          }
	          this.pos += 4;
	          if (this.pos > this.data.length) {
	            throw new Error("Incomplete or corrupt PNG file");
	          }
	        }
	        return;
	      }

	      PNG.prototype.read = function(bytes) {
	        var i, _i, _results;
	        _results = [];
	        for (i = _i = 0; 0 <= bytes ? _i < bytes : _i > bytes; i = 0 <= bytes ? ++_i : --_i) {
	          _results.push(this.data[this.pos++]);
	        }
	        return _results;
	      };

	      PNG.prototype.readUInt32 = function() {
	        var b1, b2, b3, b4;
	        b1 = this.data[this.pos++] << 24;
	        b2 = this.data[this.pos++] << 16;
	        b3 = this.data[this.pos++] << 8;
	        b4 = this.data[this.pos++];
	        return b1 | b2 | b3 | b4;
	      };

	      PNG.prototype.readUInt16 = function() {
	        var b1, b2;
	        b1 = this.data[this.pos++] << 8;
	        b2 = this.data[this.pos++];
	        return b1 | b2;
	      };


	      PNG.prototype.decodePixels = function(data) {
	        var pixelBytes = this.pixelBitlength / 8;
	        var fullPixels = new Uint8Array(this.width * this.height * pixelBytes);
	        var pos = 0;
	        var _this = this;
	        
	        if (data == null) {
	            data = this.imgData;
	        }
	        if (data.length === 0) {
	            return new Uint8Array(0);
	        }
	        
	        data = new FlateStream(data);
	        data = data.getBytes();
	        function pass (x0, y0, dx, dy) {
	            var abyte, c, col, i, left, length, p, pa, paeth, pb, pc, pixels, row, scanlineLength, upper, upperLeft, _i, _j, _k, _l, _m;
	            var w = Math.ceil((_this.width - x0) / dx), h = Math.ceil((_this.height - y0) / dy);
	            var isFull = _this.width == w && _this.height == h;
	            scanlineLength = pixelBytes * w;
	            pixels = isFull ? fullPixels : new Uint8Array(scanlineLength * h);
	            length = data.length;
	            row = 0;
	            c = 0;
	            while (row < h && pos < length) {
	              switch (data[pos++]) {
	                case 0:
	                  for (i = _i = 0; _i < scanlineLength; i = _i += 1) {
	                    pixels[c++] = data[pos++];
	                  }
	                  break;
	                case 1:
	                  for (i = _j = 0; _j < scanlineLength; i = _j += 1) {
	                    abyte = data[pos++];
	                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
	                    pixels[c++] = (abyte + left) % 256;
	                  }
	                  break;
	                case 2:
	                  for (i = _k = 0; _k < scanlineLength; i = _k += 1) {
	                    abyte = data[pos++];
	                    col = (i - (i % pixelBytes)) / pixelBytes;
	                    upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
	                    pixels[c++] = (upper + abyte) % 256;
	                  }
	                  break;
	                case 3:
	                  for (i = _l = 0; _l < scanlineLength; i = _l += 1) {
	                    abyte = data[pos++];
	                    col = (i - (i % pixelBytes)) / pixelBytes;
	                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
	                    upper = row && pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
	                    pixels[c++] = (abyte + Math.floor((left + upper) / 2)) % 256;
	                  }
	                  break;
	                case 4:
	                  for (i = _m = 0; _m < scanlineLength; i = _m += 1) {
	                    abyte = data[pos++];
	                    col = (i - (i % pixelBytes)) / pixelBytes;
	                    left = i < pixelBytes ? 0 : pixels[c - pixelBytes];
	                    if (row === 0) {
	                      upper = upperLeft = 0;
	                    } else {
	                      upper = pixels[(row - 1) * scanlineLength + col * pixelBytes + (i % pixelBytes)];
	                      upperLeft = col && pixels[(row - 1) * scanlineLength + (col - 1) * pixelBytes + (i % pixelBytes)];
	                    }
	                    p = left + upper - upperLeft;
	                    pa = Math.abs(p - left);
	                    pb = Math.abs(p - upper);
	                    pc = Math.abs(p - upperLeft);
	                    if (pa <= pb && pa <= pc) {
	                      paeth = left;
	                    } else if (pb <= pc) {
	                      paeth = upper;
	                    } else {
	                      paeth = upperLeft;
	                    }
	                    pixels[c++] = (abyte + paeth) % 256;
	                  }
	                  break;
	                default:
	                  throw new Error("Invalid filter algorithm: " + data[pos - 1]);
	              }
	              if (!isFull) {
	                  var fullPos = ((y0 + row * dy) * _this.width + x0) * pixelBytes;
	                  var partPos = row * scanlineLength;
	                  for (i = 0; i < w; i += 1) {
	                    for (var j = 0; j < pixelBytes; j += 1)
	                      fullPixels[fullPos++] = pixels[partPos++];
	                    fullPos += (dx - 1) * pixelBytes;
	                  }
	                }
	              row++;
	            }
	        }
	        if (_this.interlaceMethod == 1) {
	            /*
	              1 6 4 6 2 6 4 6
	              7 7 7 7 7 7 7 7
	              5 6 5 6 5 6 5 6
	              7 7 7 7 7 7 7 7
	              3 6 4 6 3 6 4 6
	              7 7 7 7 7 7 7 7
	              5 6 5 6 5 6 5 6
	              7 7 7 7 7 7 7 7
	            */
	            pass(0, 0, 8, 8); // 1
	            /* NOTE these seem to follow the pattern:
	             * pass(x, 0, 2*x, 2*x);
	             * pass(0, x,   x, 2*x);
	             * with x being 4, 2, 1.
	             */
	            pass(4, 0, 8, 8); // 2
	            pass(0, 4, 4, 8); // 3

	            pass(2, 0, 4, 4); // 4
	            pass(0, 2, 2, 4); // 5

	            pass(1, 0, 2, 2); // 6
	            pass(0, 1, 1, 2); // 7
	          } else {
	            pass(0, 0, 1, 1);
	          }
	        return fullPixels;
	      };

	      PNG.prototype.decodePalette = function() {
	        var c, i, length, palette, pos, ret, transparency, _i, _ref, _ref1;
	        palette = this.palette;
	        transparency = this.transparency.indexed || [];
	        ret = new Uint8Array((transparency.length || 0) + palette.length);
	        pos = 0;
	        length = palette.length;
	        c = 0;
	        for (i = _i = 0, _ref = palette.length; _i < _ref; i = _i += 3) {
	          ret[pos++] = palette[i];
	          ret[pos++] = palette[i + 1];
	          ret[pos++] = palette[i + 2];
	          ret[pos++] = (_ref1 = transparency[c++]) != null ? _ref1 : 255;
	        }
	        return ret;
	      };

	      PNG.prototype.copyToImageData = function(imageData, pixels) {
	        var alpha, colors, data, i, input, j, k, length, palette, v, _ref;
	        colors = this.colors;
	        palette = null;
	        alpha = this.hasAlphaChannel;
	        if (this.palette.length) {
	          palette = (_ref = this._decodedPalette) != null ? _ref : this._decodedPalette = this.decodePalette();
	          colors = 4;
	          alpha = true;
	        }
	        data = imageData.data || imageData;
	        length = data.length;
	        input = palette || pixels;
	        i = j = 0;
	        if (colors === 1) {
	          while (i < length) {
	            k = palette ? pixels[i / 4] * 4 : j;
	            v = input[k++];
	            data[i++] = v;
	            data[i++] = v;
	            data[i++] = v;
	            data[i++] = alpha ? input[k++] : 255;
	            j = k;
	          }
	        } else {
	          while (i < length) {
	            k = palette ? pixels[i / 4] * 4 : j;
	            data[i++] = input[k++];
	            data[i++] = input[k++];
	            data[i++] = input[k++];
	            data[i++] = alpha ? input[k++] : 255;
	            j = k;
	          }
	        }
	      };

	      PNG.prototype.decode = function() {
	        var ret;
	        ret = new Uint8Array(this.width * this.height * 4);
	        this.copyToImageData(ret, this.decodePixels());
	        return ret;
	      };

	      try {
	          scratchCanvas = global.document.createElement('canvas');
	          scratchCtx = scratchCanvas.getContext('2d');
	      } catch(e) {
	          return -1;
	      }

	      makeImage = function(imageData) {
	        var img;
	        scratchCtx.width = imageData.width;
	        scratchCtx.height = imageData.height;
	        scratchCtx.clearRect(0, 0, imageData.width, imageData.height);
	        scratchCtx.putImageData(imageData, 0, 0);
	        img = new Image;
	        img.src = scratchCanvas.toDataURL();
	        return img;
	      };

	      PNG.prototype.decodeFrames = function(ctx) {
	        var frame, i, imageData, pixels, _i, _len, _ref, _results;
	        if (!this.animation) {
	          return;
	        }
	        _ref = this.animation.frames;
	        _results = [];
	        for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
	          frame = _ref[i];
	          imageData = ctx.createImageData(frame.width, frame.height);
	          pixels = this.decodePixels(new Uint8Array(frame.data));
	          this.copyToImageData(imageData, pixels);
	          frame.imageData = imageData;
	          _results.push(frame.image = makeImage(imageData));
	        }
	        return _results;
	      };

	      PNG.prototype.renderFrame = function(ctx, number) {
	        var frame, frames, prev;
	        frames = this.animation.frames;
	        frame = frames[number];
	        prev = frames[number - 1];
	        if (number === 0) {
	          ctx.clearRect(0, 0, this.width, this.height);
	        }
	        if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_BACKGROUND) {
	          ctx.clearRect(prev.xOffset, prev.yOffset, prev.width, prev.height);
	        } else if ((prev != null ? prev.disposeOp : void 0) === APNG_DISPOSE_OP_PREVIOUS) {
	          ctx.putImageData(prev.imageData, prev.xOffset, prev.yOffset);
	        }
	        if (frame.blendOp === APNG_BLEND_OP_SOURCE) {
	          ctx.clearRect(frame.xOffset, frame.yOffset, frame.width, frame.height);
	        }
	        return ctx.drawImage(frame.image, frame.xOffset, frame.yOffset);
	      };

	      PNG.prototype.animate = function(ctx) {
	        var doFrame, frameNumber, frames, numFrames, numPlays, _ref,
	          _this = this;
	        frameNumber = 0;
	        _ref = this.animation, numFrames = _ref.numFrames, frames = _ref.frames, numPlays = _ref.numPlays;
	        return (doFrame = function() {
	          var f, frame;
	          f = frameNumber++ % numFrames;
	          frame = frames[f];
	          _this.renderFrame(ctx, f);
	          if (numFrames > 1 && frameNumber / numFrames < numPlays) {
	            return _this.animation._timeout = setTimeout(doFrame, frame.delay);
	          }
	        })();
	      };

	      PNG.prototype.stopAnimation = function() {
	        var _ref;
	        return clearTimeout((_ref = this.animation) != null ? _ref._timeout : void 0);
	      };

	      PNG.prototype.render = function(canvas) {
	        var ctx, data;
	        if (canvas._png) {
	          canvas._png.stopAnimation();
	        }
	        canvas._png = this;
	        canvas.width = this.width;
	        canvas.height = this.height;
	        ctx = canvas.getContext("2d");
	        if (this.animation) {
	          this.decodeFrames(ctx);
	          return this.animate(ctx);
	        } else {
	          data = ctx.createImageData(this.width, this.height);
	          this.copyToImageData(data, this.decodePixels());
	          return ctx.putImageData(data, 0, 0);
	        }
	      };

	      return PNG;

	    })();

	    global.PNG = PNG;

	  }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || typeof global !== "undefined" && global ||  Function('return typeof this === "object" && this.content')() || Function('return this')()));
	  // `self` is undefined in Firefox for Android content script context
	  // while `this` is nsIContentFrameMessageManager
	  // with an attribute `content` that corresponds to the window

	  /*
	   * Extracted from pdf.js
	   * https://github.com/andreasgal/pdf.js
	   *
	   * Copyright (c) 2011 Mozilla Foundation
	   *
	   * Contributors: Andreas Gal <gal@mozilla.com>
	   *               Chris G Jones <cjones@mozilla.com>
	   *               Shaon Barman <shaon.barman@gmail.com>
	   *               Vivien Nicolas <21@vingtetun.org>
	   *               Justin D'Arcangelo <justindarc@gmail.com>
	   *               Yury Delendik
	   *
	   * 
	   */

	  var DecodeStream = (function() {
	    function constructor() {
	      this.pos = 0;
	      this.bufferLength = 0;
	      this.eof = false;
	      this.buffer = null;
	    }

	    constructor.prototype = {
	      ensureBuffer: function decodestream_ensureBuffer(requested) {
	        var buffer = this.buffer;
	        var current = buffer ? buffer.byteLength : 0;
	        if (requested < current)
	          return buffer;
	        var size = 512;
	        while (size < requested)
	          size <<= 1;
	        var buffer2 = new Uint8Array(size);
	        for (var i = 0; i < current; ++i)
	          buffer2[i] = buffer[i];
	        return this.buffer = buffer2;
	      },
	      getByte: function decodestream_getByte() {
	        var pos = this.pos;
	        while (this.bufferLength <= pos) {
	          if (this.eof)
	            return null;
	          this.readBlock();
	        }
	        return this.buffer[this.pos++];
	      },
	      getBytes: function decodestream_getBytes(length) {
	        var pos = this.pos;

	        if (length) {
	          this.ensureBuffer(pos + length);
	          var end = pos + length;

	          while (!this.eof && this.bufferLength < end)
	            this.readBlock();

	          var bufEnd = this.bufferLength;
	          if (end > bufEnd)
	            end = bufEnd;
	        } else {
	          while (!this.eof)
	            this.readBlock();

	          var end = this.bufferLength;
	        }

	        this.pos = end;
	        return this.buffer.subarray(pos, end);
	      },
	      lookChar: function decodestream_lookChar() {
	        var pos = this.pos;
	        while (this.bufferLength <= pos) {
	          if (this.eof)
	            return null;
	          this.readBlock();
	        }
	        return String.fromCharCode(this.buffer[this.pos]);
	      },
	      getChar: function decodestream_getChar() {
	        var pos = this.pos;
	        while (this.bufferLength <= pos) {
	          if (this.eof)
	            return null;
	          this.readBlock();
	        }
	        return String.fromCharCode(this.buffer[this.pos++]);
	      },
	      makeSubStream: function decodestream_makeSubstream(start, length, dict) {
	        var end = start + length;
	        while (this.bufferLength <= end && !this.eof)
	          this.readBlock();
	        return new Stream(this.buffer, start, length, dict);
	      },
	      skip: function decodestream_skip(n) {
	        if (!n)
	          n = 1;
	        this.pos += n;
	      },
	      reset: function decodestream_reset() {
	        this.pos = 0;
	      }
	    };

	    return constructor;
	  })();

	  var FlateStream = (function() {
	    if (typeof Uint32Array === 'undefined') {
	      return undefined;
	    }
	    var codeLenCodeMap = new Uint32Array([
	      16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
	    ]);

	    var lengthDecode = new Uint32Array([
	      0x00003, 0x00004, 0x00005, 0x00006, 0x00007, 0x00008, 0x00009, 0x0000a,
	      0x1000b, 0x1000d, 0x1000f, 0x10011, 0x20013, 0x20017, 0x2001b, 0x2001f,
	      0x30023, 0x3002b, 0x30033, 0x3003b, 0x40043, 0x40053, 0x40063, 0x40073,
	      0x50083, 0x500a3, 0x500c3, 0x500e3, 0x00102, 0x00102, 0x00102
	    ]);

	    var distDecode = new Uint32Array([
	      0x00001, 0x00002, 0x00003, 0x00004, 0x10005, 0x10007, 0x20009, 0x2000d,
	      0x30011, 0x30019, 0x40021, 0x40031, 0x50041, 0x50061, 0x60081, 0x600c1,
	      0x70101, 0x70181, 0x80201, 0x80301, 0x90401, 0x90601, 0xa0801, 0xa0c01,
	      0xb1001, 0xb1801, 0xc2001, 0xc3001, 0xd4001, 0xd6001
	    ]);

	    var fixedLitCodeTab = [new Uint32Array([
	      0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c0,
	      0x70108, 0x80060, 0x80020, 0x900a0, 0x80000, 0x80080, 0x80040, 0x900e0,
	      0x70104, 0x80058, 0x80018, 0x90090, 0x70114, 0x80078, 0x80038, 0x900d0,
	      0x7010c, 0x80068, 0x80028, 0x900b0, 0x80008, 0x80088, 0x80048, 0x900f0,
	      0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c8,
	      0x7010a, 0x80064, 0x80024, 0x900a8, 0x80004, 0x80084, 0x80044, 0x900e8,
	      0x70106, 0x8005c, 0x8001c, 0x90098, 0x70116, 0x8007c, 0x8003c, 0x900d8,
	      0x7010e, 0x8006c, 0x8002c, 0x900b8, 0x8000c, 0x8008c, 0x8004c, 0x900f8,
	      0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c4,
	      0x70109, 0x80062, 0x80022, 0x900a4, 0x80002, 0x80082, 0x80042, 0x900e4,
	      0x70105, 0x8005a, 0x8001a, 0x90094, 0x70115, 0x8007a, 0x8003a, 0x900d4,
	      0x7010d, 0x8006a, 0x8002a, 0x900b4, 0x8000a, 0x8008a, 0x8004a, 0x900f4,
	      0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cc,
	      0x7010b, 0x80066, 0x80026, 0x900ac, 0x80006, 0x80086, 0x80046, 0x900ec,
	      0x70107, 0x8005e, 0x8001e, 0x9009c, 0x70117, 0x8007e, 0x8003e, 0x900dc,
	      0x7010f, 0x8006e, 0x8002e, 0x900bc, 0x8000e, 0x8008e, 0x8004e, 0x900fc,
	      0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c2,
	      0x70108, 0x80061, 0x80021, 0x900a2, 0x80001, 0x80081, 0x80041, 0x900e2,
	      0x70104, 0x80059, 0x80019, 0x90092, 0x70114, 0x80079, 0x80039, 0x900d2,
	      0x7010c, 0x80069, 0x80029, 0x900b2, 0x80009, 0x80089, 0x80049, 0x900f2,
	      0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900ca,
	      0x7010a, 0x80065, 0x80025, 0x900aa, 0x80005, 0x80085, 0x80045, 0x900ea,
	      0x70106, 0x8005d, 0x8001d, 0x9009a, 0x70116, 0x8007d, 0x8003d, 0x900da,
	      0x7010e, 0x8006d, 0x8002d, 0x900ba, 0x8000d, 0x8008d, 0x8004d, 0x900fa,
	      0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c6,
	      0x70109, 0x80063, 0x80023, 0x900a6, 0x80003, 0x80083, 0x80043, 0x900e6,
	      0x70105, 0x8005b, 0x8001b, 0x90096, 0x70115, 0x8007b, 0x8003b, 0x900d6,
	      0x7010d, 0x8006b, 0x8002b, 0x900b6, 0x8000b, 0x8008b, 0x8004b, 0x900f6,
	      0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900ce,
	      0x7010b, 0x80067, 0x80027, 0x900ae, 0x80007, 0x80087, 0x80047, 0x900ee,
	      0x70107, 0x8005f, 0x8001f, 0x9009e, 0x70117, 0x8007f, 0x8003f, 0x900de,
	      0x7010f, 0x8006f, 0x8002f, 0x900be, 0x8000f, 0x8008f, 0x8004f, 0x900fe,
	      0x70100, 0x80050, 0x80010, 0x80118, 0x70110, 0x80070, 0x80030, 0x900c1,
	      0x70108, 0x80060, 0x80020, 0x900a1, 0x80000, 0x80080, 0x80040, 0x900e1,
	      0x70104, 0x80058, 0x80018, 0x90091, 0x70114, 0x80078, 0x80038, 0x900d1,
	      0x7010c, 0x80068, 0x80028, 0x900b1, 0x80008, 0x80088, 0x80048, 0x900f1,
	      0x70102, 0x80054, 0x80014, 0x8011c, 0x70112, 0x80074, 0x80034, 0x900c9,
	      0x7010a, 0x80064, 0x80024, 0x900a9, 0x80004, 0x80084, 0x80044, 0x900e9,
	      0x70106, 0x8005c, 0x8001c, 0x90099, 0x70116, 0x8007c, 0x8003c, 0x900d9,
	      0x7010e, 0x8006c, 0x8002c, 0x900b9, 0x8000c, 0x8008c, 0x8004c, 0x900f9,
	      0x70101, 0x80052, 0x80012, 0x8011a, 0x70111, 0x80072, 0x80032, 0x900c5,
	      0x70109, 0x80062, 0x80022, 0x900a5, 0x80002, 0x80082, 0x80042, 0x900e5,
	      0x70105, 0x8005a, 0x8001a, 0x90095, 0x70115, 0x8007a, 0x8003a, 0x900d5,
	      0x7010d, 0x8006a, 0x8002a, 0x900b5, 0x8000a, 0x8008a, 0x8004a, 0x900f5,
	      0x70103, 0x80056, 0x80016, 0x8011e, 0x70113, 0x80076, 0x80036, 0x900cd,
	      0x7010b, 0x80066, 0x80026, 0x900ad, 0x80006, 0x80086, 0x80046, 0x900ed,
	      0x70107, 0x8005e, 0x8001e, 0x9009d, 0x70117, 0x8007e, 0x8003e, 0x900dd,
	      0x7010f, 0x8006e, 0x8002e, 0x900bd, 0x8000e, 0x8008e, 0x8004e, 0x900fd,
	      0x70100, 0x80051, 0x80011, 0x80119, 0x70110, 0x80071, 0x80031, 0x900c3,
	      0x70108, 0x80061, 0x80021, 0x900a3, 0x80001, 0x80081, 0x80041, 0x900e3,
	      0x70104, 0x80059, 0x80019, 0x90093, 0x70114, 0x80079, 0x80039, 0x900d3,
	      0x7010c, 0x80069, 0x80029, 0x900b3, 0x80009, 0x80089, 0x80049, 0x900f3,
	      0x70102, 0x80055, 0x80015, 0x8011d, 0x70112, 0x80075, 0x80035, 0x900cb,
	      0x7010a, 0x80065, 0x80025, 0x900ab, 0x80005, 0x80085, 0x80045, 0x900eb,
	      0x70106, 0x8005d, 0x8001d, 0x9009b, 0x70116, 0x8007d, 0x8003d, 0x900db,
	      0x7010e, 0x8006d, 0x8002d, 0x900bb, 0x8000d, 0x8008d, 0x8004d, 0x900fb,
	      0x70101, 0x80053, 0x80013, 0x8011b, 0x70111, 0x80073, 0x80033, 0x900c7,
	      0x70109, 0x80063, 0x80023, 0x900a7, 0x80003, 0x80083, 0x80043, 0x900e7,
	      0x70105, 0x8005b, 0x8001b, 0x90097, 0x70115, 0x8007b, 0x8003b, 0x900d7,
	      0x7010d, 0x8006b, 0x8002b, 0x900b7, 0x8000b, 0x8008b, 0x8004b, 0x900f7,
	      0x70103, 0x80057, 0x80017, 0x8011f, 0x70113, 0x80077, 0x80037, 0x900cf,
	      0x7010b, 0x80067, 0x80027, 0x900af, 0x80007, 0x80087, 0x80047, 0x900ef,
	      0x70107, 0x8005f, 0x8001f, 0x9009f, 0x70117, 0x8007f, 0x8003f, 0x900df,
	      0x7010f, 0x8006f, 0x8002f, 0x900bf, 0x8000f, 0x8008f, 0x8004f, 0x900ff
	    ]), 9];

	    var fixedDistCodeTab = [new Uint32Array([
	      0x50000, 0x50010, 0x50008, 0x50018, 0x50004, 0x50014, 0x5000c, 0x5001c,
	      0x50002, 0x50012, 0x5000a, 0x5001a, 0x50006, 0x50016, 0x5000e, 0x00000,
	      0x50001, 0x50011, 0x50009, 0x50019, 0x50005, 0x50015, 0x5000d, 0x5001d,
	      0x50003, 0x50013, 0x5000b, 0x5001b, 0x50007, 0x50017, 0x5000f, 0x00000
	    ]), 5];
	    
	    function error(e) {
	        throw new Error(e)
	    }

	    function constructor(bytes) {
	      //var bytes = stream.getBytes();
	      var bytesPos = 0;

	      var cmf = bytes[bytesPos++];
	      var flg = bytes[bytesPos++];
	      if (cmf == -1 || flg == -1)
	        error('Invalid header in flate stream');
	      if ((cmf & 0x0f) != 0x08)
	        error('Unknown compression method in flate stream');
	      if ((((cmf << 8) + flg) % 31) != 0)
	        error('Bad FCHECK in flate stream');
	      if (flg & 0x20)
	        error('FDICT bit set in flate stream');

	      this.bytes = bytes;
	      this.bytesPos = bytesPos;

	      this.codeSize = 0;
	      this.codeBuf = 0;

	      DecodeStream.call(this);
	    }

	    constructor.prototype = Object.create(DecodeStream.prototype);

	    constructor.prototype.getBits = function(bits) {
	      var codeSize = this.codeSize;
	      var codeBuf = this.codeBuf;
	      var bytes = this.bytes;
	      var bytesPos = this.bytesPos;

	      var b;
	      while (codeSize < bits) {
	        if (typeof (b = bytes[bytesPos++]) == 'undefined')
	          error('Bad encoding in flate stream');
	        codeBuf |= b << codeSize;
	        codeSize += 8;
	      }
	      b = codeBuf & ((1 << bits) - 1);
	      this.codeBuf = codeBuf >> bits;
	      this.codeSize = codeSize -= bits;
	      this.bytesPos = bytesPos;
	      return b;
	    };

	    constructor.prototype.getCode = function(table) {
	      var codes = table[0];
	      var maxLen = table[1];
	      var codeSize = this.codeSize;
	      var codeBuf = this.codeBuf;
	      var bytes = this.bytes;
	      var bytesPos = this.bytesPos;

	      while (codeSize < maxLen) {
	        var b;
	        if (typeof (b = bytes[bytesPos++]) == 'undefined')
	          error('Bad encoding in flate stream');
	        codeBuf |= (b << codeSize);
	        codeSize += 8;
	      }
	      var code = codes[codeBuf & ((1 << maxLen) - 1)];
	      var codeLen = code >> 16;
	      var codeVal = code & 0xffff;
	      if (codeSize == 0 || codeSize < codeLen || codeLen == 0)
	        error('Bad encoding in flate stream');
	      this.codeBuf = (codeBuf >> codeLen);
	      this.codeSize = (codeSize - codeLen);
	      this.bytesPos = bytesPos;
	      return codeVal;
	    };

	    constructor.prototype.generateHuffmanTable = function(lengths) {
	      var n = lengths.length;

	      // find max code length
	      var maxLen = 0;
	      for (var i = 0; i < n; ++i) {
	        if (lengths[i] > maxLen)
	          maxLen = lengths[i];
	      }

	      // build the table
	      var size = 1 << maxLen;
	      var codes = new Uint32Array(size);
	      for (var len = 1, code = 0, skip = 2;
	           len <= maxLen;
	           ++len, code <<= 1, skip <<= 1) {
	        for (var val = 0; val < n; ++val) {
	          if (lengths[val] == len) {
	            // bit-reverse the code
	            var code2 = 0;
	            var t = code;
	            for (var i = 0; i < len; ++i) {
	              code2 = (code2 << 1) | (t & 1);
	              t >>= 1;
	            }

	            // fill the table entries
	            for (var i = code2; i < size; i += skip)
	              codes[i] = (len << 16) | val;

	            ++code;
	          }
	        }
	      }

	      return [codes, maxLen];
	    };

	    constructor.prototype.readBlock = function() {
	      function repeat(stream, array, len, offset, what) {
	        var repeat = stream.getBits(len) + offset;
	        while (repeat-- > 0)
	          array[i++] = what;
	      }

	      // read block header
	      var hdr = this.getBits(3);
	      if (hdr & 1)
	        this.eof = true;
	      hdr >>= 1;

	      if (hdr == 0) { // uncompressed block
	        var bytes = this.bytes;
	        var bytesPos = this.bytesPos;
	        var b;

	        if (typeof (b = bytes[bytesPos++]) == 'undefined')
	          error('Bad block header in flate stream');
	        var blockLen = b;
	        if (typeof (b = bytes[bytesPos++]) == 'undefined')
	          error('Bad block header in flate stream');
	        blockLen |= (b << 8);
	        if (typeof (b = bytes[bytesPos++]) == 'undefined')
	          error('Bad block header in flate stream');
	        var check = b;
	        if (typeof (b = bytes[bytesPos++]) == 'undefined')
	          error('Bad block header in flate stream');
	        check |= (b << 8);
	        if (check != (~blockLen & 0xffff))
	          error('Bad uncompressed block length in flate stream');

	        this.codeBuf = 0;
	        this.codeSize = 0;

	        var bufferLength = this.bufferLength;
	        var buffer = this.ensureBuffer(bufferLength + blockLen);
	        var end = bufferLength + blockLen;
	        this.bufferLength = end;
	        for (var n = bufferLength; n < end; ++n) {
	          if (typeof (b = bytes[bytesPos++]) == 'undefined') {
	            this.eof = true;
	            break;
	          }
	          buffer[n] = b;
	        }
	        this.bytesPos = bytesPos;
	        return;
	      }

	      var litCodeTable;
	      var distCodeTable;
	      if (hdr == 1) { // compressed block, fixed codes
	        litCodeTable = fixedLitCodeTab;
	        distCodeTable = fixedDistCodeTab;
	      } else if (hdr == 2) { // compressed block, dynamic codes
	        var numLitCodes = this.getBits(5) + 257;
	        var numDistCodes = this.getBits(5) + 1;
	        var numCodeLenCodes = this.getBits(4) + 4;

	        // build the code lengths code table
	        var codeLenCodeLengths = Array(codeLenCodeMap.length);
	        var i = 0;
	        while (i < numCodeLenCodes)
	          codeLenCodeLengths[codeLenCodeMap[i++]] = this.getBits(3);
	        var codeLenCodeTab = this.generateHuffmanTable(codeLenCodeLengths);

	        // build the literal and distance code tables
	        var len = 0;
	        var i = 0;
	        var codes = numLitCodes + numDistCodes;
	        var codeLengths = new Array(codes);
	        while (i < codes) {
	          var code = this.getCode(codeLenCodeTab);
	          if (code == 16) {
	            repeat(this, codeLengths, 2, 3, len);
	          } else if (code == 17) {
	            repeat(this, codeLengths, 3, 3, len = 0);
	          } else if (code == 18) {
	            repeat(this, codeLengths, 7, 11, len = 0);
	          } else {
	            codeLengths[i++] = len = code;
	          }
	        }

	        litCodeTable =
	          this.generateHuffmanTable(codeLengths.slice(0, numLitCodes));
	        distCodeTable =
	          this.generateHuffmanTable(codeLengths.slice(numLitCodes, codes));
	      } else {
	        error('Unknown block type in flate stream');
	      }

	      var buffer = this.buffer;
	      var limit = buffer ? buffer.length : 0;
	      var pos = this.bufferLength;
	      while (true) {
	        var code1 = this.getCode(litCodeTable);
	        if (code1 < 256) {
	          if (pos + 1 >= limit) {
	            buffer = this.ensureBuffer(pos + 1);
	            limit = buffer.length;
	          }
	          buffer[pos++] = code1;
	          continue;
	        }
	        if (code1 == 256) {
	          this.bufferLength = pos;
	          return;
	        }
	        code1 -= 257;
	        code1 = lengthDecode[code1];
	        var code2 = code1 >> 16;
	        if (code2 > 0)
	          code2 = this.getBits(code2);
	        var len = (code1 & 0xffff) + code2;
	        code1 = this.getCode(distCodeTable);
	        code1 = distDecode[code1];
	        code2 = code1 >> 16;
	        if (code2 > 0)
	          code2 = this.getBits(code2);
	        var dist = (code1 & 0xffff) + code2;
	        if (pos + len >= limit) {
	          buffer = this.ensureBuffer(pos + len);
	          limit = buffer.length;
	        }
	        for (var k = 0; k < len; ++k, ++pos)
	          buffer[pos] = buffer[pos - dist];
	      }
	    };

	    return constructor;
	  })();

	  /**
	   * JavaScript Polyfill functions for jsPDF
	   * Collected from public resources by
	   * https://github.com/diegocr
	   */

	  (function (global) {
	      
	      if (typeof global.console !== "object") {
	          // Console-polyfill. MIT license.
	          // https://github.com/paulmillr/console-polyfill
	          // Make it safe to do console.log() always.
	          global.console = {};
	          
	          var con = global.console;
	          var prop, method;
	          var dummy = function() {};
	          var properties = ['memory'];
	          var methods = ('assert,clear,count,debug,dir,dirxml,error,exception,group,' +
	           'groupCollapsed,groupEnd,info,log,markTimeline,profile,profiles,profileEnd,' +
	           'show,table,time,timeEnd,timeline,timelineEnd,timeStamp,trace,warn').split(',');
	          while (prop = properties.pop()) if (!con[prop]) con[prop] = {};
	          while (method = methods.pop()) if (!con[method]) con[method] = dummy;
	      }

	      var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	      if (typeof global.btoa === 'undefined') {
	          global.btoa = function(data) {
	              //  discuss at: http://phpjs.org/functions/base64_encode/
	              // original by: Tyler Akins (http://rumkin.com)
	              // improved by: Bayron Guevara
	              // improved by: Thunder.m
	              // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	              // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	              // improved by: Rafal Kukawski (http://kukawski.pl)
	              // bugfixed by: Pellentesque Malesuada
	              //   example 1: base64_encode('Kevin van Zonneveld');
	              //   returns 1: 'S2V2aW4gdmFuIFpvbm5ldmVsZA=='

	              var o1,o2,o3,h1,h2,h3,h4,bits,i = 0,ac = 0,enc = '',tmp_arr = [];

	              if (!data) {
	                  return data;
	              }

	              do { // pack three octets into four hexets
	                  o1 = data.charCodeAt(i++);
	                  o2 = data.charCodeAt(i++);
	                  o3 = data.charCodeAt(i++);

	                  bits = o1 << 16 | o2 << 8 | o3;

	                  h1 = bits >> 18 & 0x3f;
	                  h2 = bits >> 12 & 0x3f;
	                  h3 = bits >> 6 & 0x3f;
	                  h4 = bits & 0x3f;

	                  // use hexets to index into b64, and append result to encoded string
	                  tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
	              } while (i < data.length);

	              enc = tmp_arr.join('');

	              var r = data.length % 3;

	              return (r ? enc.slice(0, r - 3) : enc) + '==='.slice(r || 3);
	          };
	      }

	      if (typeof global.atob === 'undefined') {
	          global.atob = function(data) {
	              //  discuss at: http://phpjs.org/functions/base64_decode/
	              // original by: Tyler Akins (http://rumkin.com)
	              // improved by: Thunder.m
	              // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	              // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	              //    input by: Aman Gupta
	              //    input by: Brett Zamir (http://brett-zamir.me)
	              // bugfixed by: Onno Marsman
	              // bugfixed by: Pellentesque Malesuada
	              // bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	              //   example 1: base64_decode('S2V2aW4gdmFuIFpvbm5ldmVsZA==');
	              //   returns 1: 'Kevin van Zonneveld'

	              var o1,o2,o3,h1,h2,h3,h4,bits,i = 0,ac = 0,dec = '',tmp_arr = [];

	              if (!data) {
	                  return data;
	              }

	              data += '';

	              do { // unpack four hexets into three octets using index points in b64
	                  h1 = b64.indexOf(data.charAt(i++));
	                  h2 = b64.indexOf(data.charAt(i++));
	                  h3 = b64.indexOf(data.charAt(i++));
	                  h4 = b64.indexOf(data.charAt(i++));

	                  bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

	                  o1 = bits >> 16 & 0xff;
	                  o2 = bits >> 8 & 0xff;
	                  o3 = bits & 0xff;

	                  if (h3 == 64) {
	                      tmp_arr[ac++] = String.fromCharCode(o1);
	                  } else if (h4 == 64) {
	                      tmp_arr[ac++] = String.fromCharCode(o1, o2);
	                  } else {
	                      tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);
	                  }
	              } while (i < data.length);

	              dec = tmp_arr.join('');

	              return dec;
	          };
	      }

	      if (!Array.prototype.map) {
	          Array.prototype.map = function(fun /*, thisArg */) {
	              if (this === void 0 || this === null || typeof fun !== "function")
	                  throw new TypeError();

	              var t = Object(this), len = t.length >>> 0, res = new Array(len);
	              var thisArg = arguments.length > 1 ? arguments[1] : void 0;
	              for (var i = 0; i < len; i++) {
	                  // NOTE: Absolute correctness would demand Object.defineProperty
	                  //       be used.  But this method is fairly new, and failure is
	                  //       possible only if Object.prototype or Array.prototype
	                  //       has a property |i| (very unlikely), so use a less-correct
	                  //       but more portable alternative.
	                  if (i in t)
	                      res[i] = fun.call(thisArg, t[i], i, t);
	              }

	              return res;
	          };
	      }


	      if(!Array.isArray) {
	          Array.isArray = function(arg) {
	              return Object.prototype.toString.call(arg) === '[object Array]';
	          };
	      }

	      if (!Array.prototype.forEach) {
	          Array.prototype.forEach = function(fun, thisArg) {

	              if (this === void 0 || this === null || typeof fun !== "function")
	                  throw new TypeError();

	              var t = Object(this), len = t.length >>> 0;
	              for (var i = 0; i < len; i++) {
	                  if (i in t)
	                      fun.call(thisArg, t[i], i, t);
	              }
	          };
	      }
	      
	      if (!Object.keys) {
	          Object.keys = (function () {

	              var hasOwnProperty = Object.prototype.hasOwnProperty,
	                  hasDontEnumBug = !({toString: null}).propertyIsEnumerable('toString'),
	                  dontEnums = ['toString','toLocaleString','valueOf','hasOwnProperty',
	                      'isPrototypeOf','propertyIsEnumerable','constructor'],
	                  dontEnumsLength = dontEnums.length;

	              return function (obj) {
	                  if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null)) {
	                      throw new TypeError();
	                  }
	                  var result = [], prop, i;

	                  for (prop in obj) {
	                      if (hasOwnProperty.call(obj, prop)) {
	                          result.push(prop);
	                      }
	                  }

	                  if (hasDontEnumBug) {
	                      for (i = 0; i < dontEnumsLength; i++) {
	                          if (hasOwnProperty.call(obj, dontEnums[i])) {
	                              result.push(dontEnums[i]);
	                          }
	                      }
	                  }
	                  return result;
	              };
	          }());
	      }
	      
	      if (typeof Object.assign != 'function') {
	            Object.assign = function(target) {
	              if (target == null) {
	                throw new TypeError('Cannot convert undefined or null to object');
	              }

	              target = Object(target);
	              for (var index = 1; index < arguments.length; index++) {
	                var source = arguments[index];
	                if (source != null) {
	                  for (var key in source) {
	                    if (Object.prototype.hasOwnProperty.call(source, key)) {
	                      target[key] = source[key];
	                    }
	                  }
	                }
	              }
	              return target;
	            };
	          }

	      if (!String.prototype.trim) {
	          String.prototype.trim = function () {
	              return this.replace(/^\s+|\s+$/g, '');
	          };
	      }
	      if (!String.prototype.trimLeft) {
	          String.prototype.trimLeft = function() {
	              return this.replace(/^\s+/g, "");
	          };
	      }
	      if (!String.prototype.trimRight) {
	          String.prototype.trimRight = function() {
	              return this.replace(/\s+$/g, "");
	          };
	      }


	  }(typeof self !== "undefined" && self || typeof window !== "undefined" && window || typeof global !== "undefined" && global ||  Function('return typeof this === "object" && this.content')() || Function('return this')()));
	  // `self` is undefined in Firefox for Android content script context
	  // while `this` is nsIContentFrameMessageManager
	  // with an attribute `content` that corresponds to the window

	  return jsPDF;

	})));

//------------------------------------------------ End of jsPdf.js file-----------------------

//------------------------------------------------FileServer.js file-----------------------

/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2013-01-23
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
	 || (navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
	 || (function (view) {
		"use strict";
		var
		doc = view.document
			// only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
	,
		get_URL = function () {
			return view.URL || view.webkitURL || view;
		},
		URL = view.URL || view.webkitURL || view,
		save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
		can_use_save_link = !view.externalHost && "download" in save_link,
		click = function (node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
			node.dispatchEvent(event);
		},
		webkit_req_fs = view.webkitRequestFileSystem,
		req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
		throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function () {
				throw ex;
			}, 0);
		},
		force_saveable_type = "application/octet-stream",
		fs_min_size = 0,
		deletion_queue = [],
		process_deletion_queue = function () {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					URL.revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		},
		dispatch = function (filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		},
		FileSaver = function (blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
			filesaver = this,
			type = blob.type,
			blob_changed = false,
			object_url,
			target_view,
			get_object_url = function () {
				var object_url = get_URL().createObjectURL(blob);
				deletion_queue.push(object_url);
				return object_url;
			},
			dispatch_all = function () {
				dispatch(filesaver, "writestart progress write writeend".split(" "));
			}
			// on any filesys errors revert to saving with object URLs
		,
			fs_error = function () {
				// don't create more object URLs than needed
				if (blob_changed || !object_url) {
					object_url = get_object_url(blob);
				}
				if (target_view) {
					target_view.location.href = object_url;
				} else {
					window.open(object_url, "_blank");
				}
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
			},
			abortable = function (func) {
				return function () {
					if (filesaver.readyState !== filesaver.DONE) {
						return func.apply(this, arguments);
					}
				};
			},
			create_if_not_found = {
				create : true,
				exclusive : false
			},
			slice;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
					fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
							var save = function () {
								dir.getFile(name, create_if_not_found, abortable(function (file) {
										file.createWriter(abortable(function (writer) {
												writer.onwriteend = function (event) {
													target_view.location.href = file.toURL();
													deletion_queue.push(file);
													filesaver.readyState = filesaver.DONE;
													dispatch(filesaver, "writeend", event);
												};
												writer.onerror = function () {
													var error = writer.error;
													if (error.code !== error.ABORT_ERR) {
														fs_error();
													}
												};
												"writestart progress write abort".split(" ").forEach(function (event) {
													writer["on" + event] = filesaver["on" + event];
												});
												writer.write(blob);
												filesaver.abort = function () {
													writer.abort();
													filesaver.readyState = filesaver.DONE;
												};
												filesaver.readyState = filesaver.WRITING;
											}), fs_error);
									}), fs_error);
							};
							dir.getFile(name, {
								create : false
							}, abortable(function (file) {
									// delete file if it already exists
									file.remove();
									save();
								}), abortable(function (ex) {
									if (ex.code === ex.NOT_FOUND_ERR) {
										save();
									} else {
										fs_error();
									}
								}));
						}), fs_error);
				}), fs_error);
		},
		FS_proto = FileSaver.prototype,
		saveAs = function (blob, name) {
			return new FileSaver(blob, name);
		};
		FS_proto.abort = function () {
			var filesaver = this;
			filesaver.readyState = filesaver.DONE;
			dispatch(filesaver, "abort");
		};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;

		FS_proto.error =
			FS_proto.onwritestart =
			FS_proto.onprogress =
			FS_proto.onwrite =
			FS_proto.onabort =
			FS_proto.onerror =
			FS_proto.onwriteend =
			null;

		view.addEventListener("unload", process_deletion_queue, false);
		return saveAs;
	}(self));

//----------------------------------------------- Promise For IE --------------------------------

/** 
 * Source: https://msdn.microsoft.com/en-us/library/dn802826(v=vs.94).aspx 
 * Source: https://github.com/taylorhakes/promise-polyfill **/

(function (root) {

	  // Store setTimeout reference so promise-polyfill will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var setTimeoutFunc = setTimeout;

	  function noop() {
	  }

	  // Use polyfill for setImmediate for performance gains
	  var asap = (typeof setImmediate === 'function' && setImmediate) ||
	    function (fn) {
	      setTimeoutFunc(fn, 1);
	    };

	  var onUnhandledRejection = function onUnhandledRejection(err) {
	    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
	  };

	  // Polyfill for Function.prototype.bind
	  function bind(fn, thisArg) {
	    return function () {
	      fn.apply(thisArg, arguments);
	    };
	  }

	  var isArray = Array.isArray || function (value) {
	    return Object.prototype.toString.call(value) === '[object Array]';
	  };

	  function Promise(fn) {
	    if (typeof this !== 'object') throw new TypeError('Promises must be constructed via new');
	    if (typeof fn !== 'function') throw new TypeError('not a function');
	    this._state = 0;
	    this._handled = false;
	    this._value = undefined;
	    this._deferreds = [];

	    doResolve(fn, this);
	  }

	  function handle(self, deferred) {
	    while (self._state === 3) {
	      self = self._value;
	    }
	    if (self._state === 0) {
	      self._deferreds.push(deferred);
	      return;
	    }
	    self._handled = true;
	    asap(function () {
	      var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
	      if (cb === null) {
	        (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
	        return;
	      }
	      var ret;
	      try {
	        ret = cb(self._value);
	      } catch (e) {
	        reject(deferred.promise, e);
	        return;
	      }
	      resolve(deferred.promise, ret);
	    });
	  }

	  function resolve(self, newValue) {
	    try {
	      // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
	      if (newValue === self) throw new TypeError('A promise cannot be resolved with itself.');
	      if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
	        var then = newValue.then;
	        if (newValue instanceof Promise) {
	          self._state = 3;
	          self._value = newValue;
	          finale(self);
	          return;
	        } else if (typeof then === 'function') {
	          doResolve(bind(then, newValue), self);
	          return;
	        }
	      }
	      self._state = 1;
	      self._value = newValue;
	      finale(self);
	    } catch (e) {
	      reject(self, e);
	    }
	  }

	  function reject(self, newValue) {
	    self._state = 2;
	    self._value = newValue;
	    finale(self);
	  }

	  function finale(self) {
	    if (self._state === 2 && self._deferreds.length === 0) {
	      setTimeout(function() {
	        if (!self._handled) {
	          onUnhandledRejection(self._value);
	        }
	      }, 1);
	    }
	    
	    for (var i = 0, len = self._deferreds.length; i < len; i++) {
	      handle(self, self._deferreds[i]);
	    }
	    self._deferreds = null;
	  }

	  function Handler(onFulfilled, onRejected, promise) {
	    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
	    this.onRejected = typeof onRejected === 'function' ? onRejected : null;
	    this.promise = promise;
	  }

	  /**
	   * Take a potentially misbehaving resolver function and make sure
	   * onFulfilled and onRejected are only called once.
	   *
	   * Makes no guarantees about asynchrony.
	   */
	  function doResolve(fn, self) {
	    var done = false;
	    try {
	      fn(function (value) {
	        if (done) return;
	        done = true;
	        resolve(self, value);
	      }, function (reason) {
	        if (done) return;
	        done = true;
	        reject(self, reason);
	      });
	    } catch (ex) {
	      if (done) return;
	      done = true;
	      reject(self, ex);
	    }
	  }

	  Promise.prototype['catch'] = function (onRejected) {
	    return this.then(null, onRejected);
	  };

	  Promise.prototype.then = function (onFulfilled, onRejected) {
	    var prom = new Promise(noop);
	    handle(this, new Handler(onFulfilled, onRejected, prom));
	    return prom;
	  };

	  Promise.all = function () {
	    var args = Array.prototype.slice.call(arguments.length === 1 && isArray(arguments[0]) ? arguments[0] : arguments);

	    return new Promise(function (resolve, reject) {
	      if (args.length === 0) return resolve([]);
	      var remaining = args.length;

	      function res(i, val) {
	        try {
	          if (val && (typeof val === 'object' || typeof val === 'function')) {
	            var then = val.then;
	            if (typeof then === 'function') {
	              then.call(val, function (val) {
	                res(i, val);
	              }, reject);
	              return;
	            }
	          }
	          args[i] = val;
	          if (--remaining === 0) {
	            resolve(args);
	          }
	        } catch (ex) {
	          reject(ex);
	        }
	      }

	      for (var i = 0; i < args.length; i++) {
	        res(i, args[i]);
	      }
	    });
	  };

	  Promise.resolve = function (value) {
	    if (value && typeof value === 'object' && value.constructor === Promise) {
	      return value;
	    }

	    return new Promise(function (resolve) {
	      resolve(value);
	    });
	  };

	  Promise.reject = function (value) {
	    return new Promise(function (resolve, reject) {
	      reject(value);
	    });
	  };

	  Promise.race = function (values) {
	    return new Promise(function (resolve, reject) {
	      for (var i = 0, len = values.length; i < len; i++) {
	        values[i].then(resolve, reject);
	      }
	    });
	  };

	  /**
	   * Set the immediate function to execute callbacks
	   * @param fn {function} Function to execute
	   * @private
	   */
	  Promise._setImmediateFn = function _setImmediateFn(fn) {
	    asap = fn;
	  };
	  
	  Promise._setUnhandledRejectionFn = function _setUnhandledRejectionFn(fn) {
	    onUnhandledRejection = fn;
	  };

	  if (typeof module !== 'undefined' && module.exports) {
	    module.exports = Promise;
	  } else if (!root.Promise) {
	    root.Promise = Promise;
	  }

	})(this);

//-----------------------------------------------html2canvas.js file---------------------

/*
html2canvas 0.4.0 <http://html2canvas.hertzen.com>
Copyright (c) 2013 Niklas von Hertzen (@niklasvh)

Released under MIT License
 */
 
 /*
  html2canvas 0.5.0-beta3 <http://html2canvas.hertzen.com>
  Copyright (c) 2016 Niklas von Hertzen
  Released under  License
*/

/*!
 * html2canvas 1.0.0-alpha.11 <https://html2canvas.hertzen.com>
 * Copyright (c) 2018 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["html2canvas"] = factory();
	else
		root["html2canvas"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 27);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://dev.w3.org/csswg/css-color/

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var HEX3 = /^#([a-f0-9]{3})$/i;
var hex3 = function hex3(value) {
    var match = value.match(HEX3);
    if (match) {
        return [parseInt(match[1][0] + match[1][0], 16), parseInt(match[1][1] + match[1][1], 16), parseInt(match[1][2] + match[1][2], 16), null];
    }
    return false;
};

var HEX6 = /^#([a-f0-9]{6})$/i;
var hex6 = function hex6(value) {
    var match = value.match(HEX6);
    if (match) {
        return [parseInt(match[1].substring(0, 2), 16), parseInt(match[1].substring(2, 4), 16), parseInt(match[1].substring(4, 6), 16), null];
    }
    return false;
};

var RGB = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
var rgb = function rgb(value) {
    var match = value.match(RGB);
    if (match) {
        return [Number(match[1]), Number(match[2]), Number(match[3]), null];
    }
    return false;
};

var RGBA = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;
var rgba = function rgba(value) {
    var match = value.match(RGBA);
    if (match && match.length > 4) {
        return [Number(match[1]), Number(match[2]), Number(match[3]), Number(match[4])];
    }
    return false;
};

var fromArray = function fromArray(array) {
    return [Math.min(array[0], 255), Math.min(array[1], 255), Math.min(array[2], 255), array.length > 3 ? array[3] : null];
};

var namedColor = function namedColor(name) {
    var color = NAMED_COLORS[name.toLowerCase()];
    return color ? color : false;
};

var Color = function () {
    function Color(value) {
        _classCallCheck(this, Color);

        var _ref = Array.isArray(value) ? fromArray(value) : hex3(value) || rgb(value) || rgba(value) || namedColor(value) || hex6(value) || [0, 0, 0, null],
            _ref2 = _slicedToArray(_ref, 4),
            r = _ref2[0],
            g = _ref2[1],
            b = _ref2[2],
            a = _ref2[3];

        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
    }

    _createClass(Color, [{
        key: 'isTransparent',
        value: function isTransparent() {
            return this.a === 0;
        }
    }, {
        key: 'toString',
        value: function toString() {
            return this.a !== null && this.a !== 1 ? 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + this.a + ')' : 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';
        }
    }]);

    return Color;
}();

exports.default = Color;


var NAMED_COLORS = {
    transparent: [0, 0, 0, 0],
    aliceblue: [240, 248, 255, null],
    antiquewhite: [250, 235, 215, null],
    aqua: [0, 255, 255, null],
    aquamarine: [127, 255, 212, null],
    azure: [240, 255, 255, null],
    beige: [245, 245, 220, null],
    bisque: [255, 228, 196, null],
    black: [0, 0, 0, null],
    blanchedalmond: [255, 235, 205, null],
    blue: [0, 0, 255, null],
    blueviolet: [138, 43, 226, null],
    brown: [165, 42, 42, null],
    burlywood: [222, 184, 135, null],
    cadetblue: [95, 158, 160, null],
    chartreuse: [127, 255, 0, null],
    chocolate: [210, 105, 30, null],
    coral: [255, 127, 80, null],
    cornflowerblue: [100, 149, 237, null],
    cornsilk: [255, 248, 220, null],
    crimson: [220, 20, 60, null],
    cyan: [0, 255, 255, null],
    darkblue: [0, 0, 139, null],
    darkcyan: [0, 139, 139, null],
    darkgoldenrod: [184, 134, 11, null],
    darkgray: [169, 169, 169, null],
    darkgreen: [0, 100, 0, null],
    darkgrey: [169, 169, 169, null],
    darkkhaki: [189, 183, 107, null],
    darkmagenta: [139, 0, 139, null],
    darkolivegreen: [85, 107, 47, null],
    darkorange: [255, 140, 0, null],
    darkorchid: [153, 50, 204, null],
    darkred: [139, 0, 0, null],
    darksalmon: [233, 150, 122, null],
    darkseagreen: [143, 188, 143, null],
    darkslateblue: [72, 61, 139, null],
    darkslategray: [47, 79, 79, null],
    darkslategrey: [47, 79, 79, null],
    darkturquoise: [0, 206, 209, null],
    darkviolet: [148, 0, 211, null],
    deeppink: [255, 20, 147, null],
    deepskyblue: [0, 191, 255, null],
    dimgray: [105, 105, 105, null],
    dimgrey: [105, 105, 105, null],
    dodgerblue: [30, 144, 255, null],
    firebrick: [178, 34, 34, null],
    floralwhite: [255, 250, 240, null],
    forestgreen: [34, 139, 34, null],
    fuchsia: [255, 0, 255, null],
    gainsboro: [220, 220, 220, null],
    ghostwhite: [248, 248, 255, null],
    gold: [255, 215, 0, null],
    goldenrod: [218, 165, 32, null],
    gray: [128, 128, 128, null],
    green: [0, 128, 0, null],
    greenyellow: [173, 255, 47, null],
    grey: [128, 128, 128, null],
    honeydew: [240, 255, 240, null],
    hotpink: [255, 105, 180, null],
    indianred: [205, 92, 92, null],
    indigo: [75, 0, 130, null],
    ivory: [255, 255, 240, null],
    khaki: [240, 230, 140, null],
    lavender: [230, 230, 250, null],
    lavenderblush: [255, 240, 245, null],
    lawngreen: [124, 252, 0, null],
    lemonchiffon: [255, 250, 205, null],
    lightblue: [173, 216, 230, null],
    lightcoral: [240, 128, 128, null],
    lightcyan: [224, 255, 255, null],
    lightgoldenrodyellow: [250, 250, 210, null],
    lightgray: [211, 211, 211, null],
    lightgreen: [144, 238, 144, null],
    lightgrey: [211, 211, 211, null],
    lightpink: [255, 182, 193, null],
    lightsalmon: [255, 160, 122, null],
    lightseagreen: [32, 178, 170, null],
    lightskyblue: [135, 206, 250, null],
    lightslategray: [119, 136, 153, null],
    lightslategrey: [119, 136, 153, null],
    lightsteelblue: [176, 196, 222, null],
    lightyellow: [255, 255, 224, null],
    lime: [0, 255, 0, null],
    limegreen: [50, 205, 50, null],
    linen: [250, 240, 230, null],
    magenta: [255, 0, 255, null],
    maroon: [128, 0, 0, null],
    mediumaquamarine: [102, 205, 170, null],
    mediumblue: [0, 0, 205, null],
    mediumorchid: [186, 85, 211, null],
    mediumpurple: [147, 112, 219, null],
    mediumseagreen: [60, 179, 113, null],
    mediumslateblue: [123, 104, 238, null],
    mediumspringgreen: [0, 250, 154, null],
    mediumturquoise: [72, 209, 204, null],
    mediumvioletred: [199, 21, 133, null],
    midnightblue: [25, 25, 112, null],
    mintcream: [245, 255, 250, null],
    mistyrose: [255, 228, 225, null],
    moccasin: [255, 228, 181, null],
    navajowhite: [255, 222, 173, null],
    navy: [0, 0, 128, null],
    oldlace: [253, 245, 230, null],
    olive: [128, 128, 0, null],
    olivedrab: [107, 142, 35, null],
    orange: [255, 165, 0, null],
    orangered: [255, 69, 0, null],
    orchid: [218, 112, 214, null],
    palegoldenrod: [238, 232, 170, null],
    palegreen: [152, 251, 152, null],
    paleturquoise: [175, 238, 238, null],
    palevioletred: [219, 112, 147, null],
    papayawhip: [255, 239, 213, null],
    peachpuff: [255, 218, 185, null],
    peru: [205, 133, 63, null],
    pink: [255, 192, 203, null],
    plum: [221, 160, 221, null],
    powderblue: [176, 224, 230, null],
    purple: [128, 0, 128, null],
    rebeccapurple: [102, 51, 153, null],
    red: [255, 0, 0, null],
    rosybrown: [188, 143, 143, null],
    royalblue: [65, 105, 225, null],
    saddlebrown: [139, 69, 19, null],
    salmon: [250, 128, 114, null],
    sandybrown: [244, 164, 96, null],
    seagreen: [46, 139, 87, null],
    seashell: [255, 245, 238, null],
    sienna: [160, 82, 45, null],
    silver: [192, 192, 192, null],
    skyblue: [135, 206, 235, null],
    slateblue: [106, 90, 205, null],
    slategray: [112, 128, 144, null],
    slategrey: [112, 128, 144, null],
    snow: [255, 250, 250, null],
    springgreen: [0, 255, 127, null],
    steelblue: [70, 130, 180, null],
    tan: [210, 180, 140, null],
    teal: [0, 128, 128, null],
    thistle: [216, 191, 216, null],
    tomato: [255, 99, 71, null],
    turquoise: [64, 224, 208, null],
    violet: [238, 130, 238, null],
    wheat: [245, 222, 179, null],
    white: [255, 255, 255, null],
    whitesmoke: [245, 245, 245, null],
    yellow: [255, 255, 0, null],
    yellowgreen: [154, 205, 50, null]
};

var TRANSPARENT = exports.TRANSPARENT = new Color([0, 0, 0, 0]);

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.calculateLengthFromValueWithUnit = exports.LENGTH_TYPE = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NodeContainer = __webpack_require__(3);

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LENGTH_WITH_UNIT = /([\d.]+)(px|r?em|%)/i;

var LENGTH_TYPE = exports.LENGTH_TYPE = {
    PX: 0,
    PERCENTAGE: 1
};

var Length = function () {
    function Length(value) {
        _classCallCheck(this, Length);

        this.type = value.substr(value.length - 1) === '%' ? LENGTH_TYPE.PERCENTAGE : LENGTH_TYPE.PX;
        var parsedValue = parseFloat(value);
        if (true && isNaN(parsedValue)) {
            console.error('Invalid value given for Length: "' + value + '"');
        }
        this.value = isNaN(parsedValue) ? 0 : parsedValue;
    }

    _createClass(Length, [{
        key: 'isPercentage',
        value: function isPercentage() {
            return this.type === LENGTH_TYPE.PERCENTAGE;
        }
    }, {
        key: 'getAbsoluteValue',
        value: function getAbsoluteValue(parentLength) {
            return this.isPercentage() ? parentLength * (this.value / 100) : this.value;
        }
    }], [{
        key: 'create',
        value: function create(v) {
            return new Length(v);
        }
    }]);

    return Length;
}();

exports.default = Length;


var getRootFontSize = function getRootFontSize(container) {
    var parent = container.parent;
    return parent ? getRootFontSize(parent) : parseFloat(container.style.font.fontSize);
};

var calculateLengthFromValueWithUnit = exports.calculateLengthFromValueWithUnit = function calculateLengthFromValueWithUnit(container, value, unit) {
    switch (unit) {
        case 'px':
        case '%':
            return new Length(value + unit);
        case 'em':
        case 'rem':
            var length = new Length(value);
            length.value *= unit === 'em' ? parseFloat(container.style.font.fontSize) : getRootFontSize(container);
            return length;
        default:
            // TODO: handle correctly if unknown unit is used
            return new Length('0');
    }
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseBoundCurves = exports.calculatePaddingBoxPath = exports.calculateBorderBoxPath = exports.parsePathForBorder = exports.parseDocumentSize = exports.calculateContentBox = exports.calculatePaddingBox = exports.parseBounds = exports.Bounds = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Vector = __webpack_require__(7);

var _Vector2 = _interopRequireDefault(_Vector);

var _BezierCurve = __webpack_require__(32);

var _BezierCurve2 = _interopRequireDefault(_BezierCurve);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TOP = 0;
var RIGHT = 1;
var BOTTOM = 2;
var LEFT = 3;

var H = 0;
var V = 1;

var Bounds = exports.Bounds = function () {
    function Bounds(x, y, w, h) {
        _classCallCheck(this, Bounds);

        this.left = x;
        this.top = y;
        this.width = w;
        this.height = h;
    }

    _createClass(Bounds, null, [{
        key: 'fromClientRect',
        value: function fromClientRect(clientRect, scrollX, scrollY) {
            return new Bounds(clientRect.left + scrollX, clientRect.top + scrollY, clientRect.width, clientRect.height);
        }
    }]);

    return Bounds;
}();

var parseBounds = exports.parseBounds = function parseBounds(node, scrollX, scrollY) {
    return Bounds.fromClientRect(node.getBoundingClientRect(), scrollX, scrollY);
};

var calculatePaddingBox = exports.calculatePaddingBox = function calculatePaddingBox(bounds, borders) {
    return new Bounds(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth, bounds.width - (borders[RIGHT].borderWidth + borders[LEFT].borderWidth), bounds.height - (borders[TOP].borderWidth + borders[BOTTOM].borderWidth));
};

var calculateContentBox = exports.calculateContentBox = function calculateContentBox(bounds, padding, borders) {
    // TODO support percentage paddings
    var paddingTop = padding[TOP].value;
    var paddingRight = padding[RIGHT].value;
    var paddingBottom = padding[BOTTOM].value;
    var paddingLeft = padding[LEFT].value;

    return new Bounds(bounds.left + paddingLeft + borders[LEFT].borderWidth, bounds.top + paddingTop + borders[TOP].borderWidth, bounds.width - (borders[RIGHT].borderWidth + borders[LEFT].borderWidth + paddingLeft + paddingRight), bounds.height - (borders[TOP].borderWidth + borders[BOTTOM].borderWidth + paddingTop + paddingBottom));
};

var parseDocumentSize = exports.parseDocumentSize = function parseDocumentSize(document) {
    var body = document.body;
    var documentElement = document.documentElement;

    if (!body || !documentElement) {
        throw new Error( true ? 'Unable to get document size' : '');
    }
    var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));

    var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));

    return new Bounds(0, 0, width, height);
};

var parsePathForBorder = exports.parsePathForBorder = function parsePathForBorder(curves, borderSide) {
    switch (borderSide) {
        case TOP:
            return createPathFromCurves(curves.topLeftOuter, curves.topLeftInner, curves.topRightOuter, curves.topRightInner);
        case RIGHT:
            return createPathFromCurves(curves.topRightOuter, curves.topRightInner, curves.bottomRightOuter, curves.bottomRightInner);
        case BOTTOM:
            return createPathFromCurves(curves.bottomRightOuter, curves.bottomRightInner, curves.bottomLeftOuter, curves.bottomLeftInner);
        case LEFT:
        default:
            return createPathFromCurves(curves.bottomLeftOuter, curves.bottomLeftInner, curves.topLeftOuter, curves.topLeftInner);
    }
};

var createPathFromCurves = function createPathFromCurves(outer1, inner1, outer2, inner2) {
    var path = [];
    if (outer1 instanceof _BezierCurve2.default) {
        path.push(outer1.subdivide(0.5, false));
    } else {
        path.push(outer1);
    }

    if (outer2 instanceof _BezierCurve2.default) {
        path.push(outer2.subdivide(0.5, true));
    } else {
        path.push(outer2);
    }

    if (inner2 instanceof _BezierCurve2.default) {
        path.push(inner2.subdivide(0.5, true).reverse());
    } else {
        path.push(inner2);
    }

    if (inner1 instanceof _BezierCurve2.default) {
        path.push(inner1.subdivide(0.5, false).reverse());
    } else {
        path.push(inner1);
    }

    return path;
};

var calculateBorderBoxPath = exports.calculateBorderBoxPath = function calculateBorderBoxPath(curves) {
    return [curves.topLeftOuter, curves.topRightOuter, curves.bottomRightOuter, curves.bottomLeftOuter];
};

var calculatePaddingBoxPath = exports.calculatePaddingBoxPath = function calculatePaddingBoxPath(curves) {
    return [curves.topLeftInner, curves.topRightInner, curves.bottomRightInner, curves.bottomLeftInner];
};

var parseBoundCurves = exports.parseBoundCurves = function parseBoundCurves(bounds, borders, borderRadius) {
    var tlh = borderRadius[CORNER.TOP_LEFT][H].getAbsoluteValue(bounds.width);
    var tlv = borderRadius[CORNER.TOP_LEFT][V].getAbsoluteValue(bounds.height);
    var trh = borderRadius[CORNER.TOP_RIGHT][H].getAbsoluteValue(bounds.width);
    var trv = borderRadius[CORNER.TOP_RIGHT][V].getAbsoluteValue(bounds.height);
    var brh = borderRadius[CORNER.BOTTOM_RIGHT][H].getAbsoluteValue(bounds.width);
    var brv = borderRadius[CORNER.BOTTOM_RIGHT][V].getAbsoluteValue(bounds.height);
    var blh = borderRadius[CORNER.BOTTOM_LEFT][H].getAbsoluteValue(bounds.width);
    var blv = borderRadius[CORNER.BOTTOM_LEFT][V].getAbsoluteValue(bounds.height);

    var factors = [];
    factors.push((tlh + trh) / bounds.width);
    factors.push((blh + brh) / bounds.width);
    factors.push((tlv + blv) / bounds.height);
    factors.push((trv + brv) / bounds.height);
    var maxFactor = Math.max.apply(Math, factors);

    if (maxFactor > 1) {
        tlh /= maxFactor;
        tlv /= maxFactor;
        trh /= maxFactor;
        trv /= maxFactor;
        brh /= maxFactor;
        brv /= maxFactor;
        blh /= maxFactor;
        blv /= maxFactor;
    }

    var topWidth = bounds.width - trh;
    var rightHeight = bounds.height - brv;
    var bottomWidth = bounds.width - brh;
    var leftHeight = bounds.height - blv;

    return {
        topLeftOuter: tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new _Vector2.default(bounds.left, bounds.top),
        topLeftInner: tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth, Math.max(0, tlh - borders[LEFT].borderWidth), Math.max(0, tlv - borders[TOP].borderWidth), CORNER.TOP_LEFT) : new _Vector2.default(bounds.left + borders[LEFT].borderWidth, bounds.top + borders[TOP].borderWidth),
        topRightOuter: trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new _Vector2.default(bounds.left + bounds.width, bounds.top),
        topRightInner: trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borders[LEFT].borderWidth), bounds.top + borders[TOP].borderWidth, topWidth > bounds.width + borders[LEFT].borderWidth ? 0 : trh - borders[LEFT].borderWidth, trv - borders[TOP].borderWidth, CORNER.TOP_RIGHT) : new _Vector2.default(bounds.left + bounds.width - borders[RIGHT].borderWidth, bounds.top + borders[TOP].borderWidth),
        bottomRightOuter: brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new _Vector2.default(bounds.left + bounds.width, bounds.top + bounds.height),
        bottomRightInner: brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borders[LEFT].borderWidth), bounds.top + Math.min(rightHeight, bounds.height + borders[TOP].borderWidth), Math.max(0, brh - borders[RIGHT].borderWidth), brv - borders[BOTTOM].borderWidth, CORNER.BOTTOM_RIGHT) : new _Vector2.default(bounds.left + bounds.width - borders[RIGHT].borderWidth, bounds.top + bounds.height - borders[BOTTOM].borderWidth),
        bottomLeftOuter: blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new _Vector2.default(bounds.left, bounds.top + bounds.height),
        bottomLeftInner: blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borders[LEFT].borderWidth, bounds.top + leftHeight, Math.max(0, blh - borders[LEFT].borderWidth), blv - borders[BOTTOM].borderWidth, CORNER.BOTTOM_LEFT) : new _Vector2.default(bounds.left + borders[LEFT].borderWidth, bounds.top + bounds.height - borders[BOTTOM].borderWidth)
    };
};

var CORNER = {
    TOP_LEFT: 0,
    TOP_RIGHT: 1,
    BOTTOM_RIGHT: 2,
    BOTTOM_LEFT: 3
};

var getCurvePoints = function getCurvePoints(x, y, r1, r2, position) {
    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
    var ox = r1 * kappa; // control point offset horizontal
    var oy = r2 * kappa; // control point offset vertical
    var xm = x + r1; // x-middle
    var ym = y + r2; // y-middle

    switch (position) {
        case CORNER.TOP_LEFT:
            return new _BezierCurve2.default(new _Vector2.default(x, ym), new _Vector2.default(x, ym - oy), new _Vector2.default(xm - ox, y), new _Vector2.default(xm, y));
        case CORNER.TOP_RIGHT:
            return new _BezierCurve2.default(new _Vector2.default(x, y), new _Vector2.default(x + ox, y), new _Vector2.default(xm, ym - oy), new _Vector2.default(xm, ym));
        case CORNER.BOTTOM_RIGHT:
            return new _BezierCurve2.default(new _Vector2.default(xm, y), new _Vector2.default(xm, y + oy), new _Vector2.default(x + ox, ym), new _Vector2.default(x, ym));
        case CORNER.BOTTOM_LEFT:
        default:
            return new _BezierCurve2.default(new _Vector2.default(xm, ym), new _Vector2.default(xm - ox, ym), new _Vector2.default(x, y + oy), new _Vector2.default(x, y));
    }
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

var _Util = __webpack_require__(4);

var _background = __webpack_require__(5);

var _border = __webpack_require__(12);

var _borderRadius = __webpack_require__(33);

var _display = __webpack_require__(34);

var _float = __webpack_require__(35);

var _font = __webpack_require__(36);

var _letterSpacing = __webpack_require__(37);

var _lineBreak = __webpack_require__(38);

var _listStyle = __webpack_require__(8);

var _margin = __webpack_require__(39);

var _overflow = __webpack_require__(40);

var _overflowWrap = __webpack_require__(18);

var _padding = __webpack_require__(17);

var _position = __webpack_require__(19);

var _textDecoration = __webpack_require__(11);

var _textShadow = __webpack_require__(41);

var _textTransform = __webpack_require__(20);

var _transform = __webpack_require__(42);

var _visibility = __webpack_require__(43);

var _wordBreak = __webpack_require__(44);

var _zIndex = __webpack_require__(45);

var _Bounds = __webpack_require__(2);

var _Input = __webpack_require__(21);

var _ListItem = __webpack_require__(14);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var INPUT_TAGS = ['INPUT', 'TEXTAREA', 'SELECT'];

var NodeContainer = function () {
    function NodeContainer(node, parent, resourceLoader, index) {
        var _this = this;

        _classCallCheck(this, NodeContainer);

        this.parent = parent;
        this.tagName = node.tagName;
        this.index = index;
        this.childNodes = [];
        this.listItems = [];
        if (typeof node.start === 'number') {
            this.listStart = node.start;
        }
        var defaultView = node.ownerDocument.defaultView;
        var scrollX = defaultView.pageXOffset;
        var scrollY = defaultView.pageYOffset;
        var style = defaultView.getComputedStyle(node, null);
        var display = (0, _display.parseDisplay)(style.display);

        var IS_INPUT = node.type === 'radio' || node.type === 'checkbox';

        var position = (0, _position.parsePosition)(style.position);

        this.style = {
            background: IS_INPUT ? _Input.INPUT_BACKGROUND : (0, _background.parseBackground)(style, resourceLoader),
            border: IS_INPUT ? _Input.INPUT_BORDERS : (0, _border.parseBorder)(style),
            borderRadius: (node instanceof defaultView.HTMLInputElement || node instanceof HTMLInputElement) && IS_INPUT ? (0, _Input.getInputBorderRadius)(node) : (0, _borderRadius.parseBorderRadius)(style),
            color: IS_INPUT ? _Input.INPUT_COLOR : new _Color2.default(style.color),
            display: display,
            float: (0, _float.parseCSSFloat)(style.float),
            font: (0, _font.parseFont)(style),
            letterSpacing: (0, _letterSpacing.parseLetterSpacing)(style.letterSpacing),
            listStyle: display === _display.DISPLAY.LIST_ITEM ? (0, _listStyle.parseListStyle)(style) : null,
            lineBreak: (0, _lineBreak.parseLineBreak)(style.lineBreak),
            margin: (0, _margin.parseMargin)(style),
            opacity: parseFloat(style.opacity),
            overflow: INPUT_TAGS.indexOf(node.tagName) === -1 ? (0, _overflow.parseOverflow)(style.overflow) : _overflow.OVERFLOW.HIDDEN,
            overflowWrap: (0, _overflowWrap.parseOverflowWrap)(style.overflowWrap ? style.overflowWrap : style.wordWrap),
            padding: (0, _padding.parsePadding)(style),
            position: position,
            textDecoration: (0, _textDecoration.parseTextDecoration)(style),
            textShadow: (0, _textShadow.parseTextShadow)(style.textShadow),
            textTransform: (0, _textTransform.parseTextTransform)(style.textTransform),
            transform: (0, _transform.parseTransform)(style),
            visibility: (0, _visibility.parseVisibility)(style.visibility),
            wordBreak: (0, _wordBreak.parseWordBreak)(style.wordBreak),
            zIndex: (0, _zIndex.parseZIndex)(position !== _position.POSITION.STATIC ? style.zIndex : 'auto')
        };

        if (this.isTransformed()) {
            // getBoundingClientRect provides values post-transform, we want them without the transformation
            node.style.transform = 'matrix(1,0,0,1,0,0)';
        }

        if (display === _display.DISPLAY.LIST_ITEM) {
            var listOwner = (0, _ListItem.getListOwner)(this);
            if (listOwner) {
                var listIndex = listOwner.listItems.length;
                listOwner.listItems.push(this);
                this.listIndex = node.hasAttribute('value') && typeof node.value === 'number' ? node.value : listIndex === 0 ? typeof listOwner.listStart === 'number' ? listOwner.listStart : 1 : listOwner.listItems[listIndex - 1].listIndex + 1;
            }
        }

        // TODO move bound retrieval for all nodes to a later stage?
        if (node.tagName === 'IMG') {
            node.addEventListener('load', function () {
                _this.bounds = (0, _Bounds.parseBounds)(node, scrollX, scrollY);
                _this.curvedBounds = (0, _Bounds.parseBoundCurves)(_this.bounds, _this.style.border, _this.style.borderRadius);
            });
        }
        this.image = getImage(node, resourceLoader);
        this.bounds = IS_INPUT ? (0, _Input.reformatInputBounds)((0, _Bounds.parseBounds)(node, scrollX, scrollY)) : (0, _Bounds.parseBounds)(node, scrollX, scrollY);
        this.curvedBounds = (0, _Bounds.parseBoundCurves)(this.bounds, this.style.border, this.style.borderRadius);

        if (true) {
            this.name = '' + node.tagName.toLowerCase() + (node.id ? '#' + node.id : '') + node.className.toString().split(' ').map(function (s) {
                return s.length ? '.' + s : '';
            }).join('');
        }
    }

    _createClass(NodeContainer, [{
        key: 'getClipPaths',
        value: function getClipPaths() {
            var parentClips = this.parent ? this.parent.getClipPaths() : [];
            var isClipped = this.style.overflow !== _overflow.OVERFLOW.VISIBLE;

            return isClipped ? parentClips.concat([(0, _Bounds.calculatePaddingBoxPath)(this.curvedBounds)]) : parentClips;
        }
    }, {
        key: 'isInFlow',
        value: function isInFlow() {
            return this.isRootElement() && !this.isFloating() && !this.isAbsolutelyPositioned();
        }
    }, {
        key: 'isVisible',
        value: function isVisible() {
            return !(0, _Util.contains)(this.style.display, _display.DISPLAY.NONE) && this.style.opacity > 0 && this.style.visibility === _visibility.VISIBILITY.VISIBLE;
        }
    }, {
        key: 'isAbsolutelyPositioned',
        value: function isAbsolutelyPositioned() {
            return this.style.position !== _position.POSITION.STATIC && this.style.position !== _position.POSITION.RELATIVE;
        }
    }, {
        key: 'isPositioned',
        value: function isPositioned() {
            return this.style.position !== _position.POSITION.STATIC;
        }
    }, {
        key: 'isFloating',
        value: function isFloating() {
            return this.style.float !== _float.FLOAT.NONE;
        }
    }, {
        key: 'isRootElement',
        value: function isRootElement() {
            return this.parent === null;
        }
    }, {
        key: 'isTransformed',
        value: function isTransformed() {
            return this.style.transform !== null;
        }
    }, {
        key: 'isPositionedWithZIndex',
        value: function isPositionedWithZIndex() {
            return this.isPositioned() && !this.style.zIndex.auto;
        }
    }, {
        key: 'isInlineLevel',
        value: function isInlineLevel() {
            return (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_BLOCK) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_FLEX) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_GRID) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_LIST_ITEM) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_TABLE);
        }
    }, {
        key: 'isInlineBlockOrInlineTable',
        value: function isInlineBlockOrInlineTable() {
            return (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_BLOCK) || (0, _Util.contains)(this.style.display, _display.DISPLAY.INLINE_TABLE);
        }
    }]);

    return NodeContainer;
}();

exports.default = NodeContainer;


var getImage = function getImage(node, resourceLoader) {
    if (node instanceof node.ownerDocument.defaultView.SVGSVGElement || node instanceof SVGSVGElement) {
    	if( ((isIE = false || !!document.documentMode) || (isFirefox = typeof InstallTrigger !== 'undefined')) ){
    		try{
    			return resourceLoader.loadImage(replaceSvgWithCanvas(node.parentNode));
    		}catch(e){
    			console.log(e);
    			return resourceLoader.loadImage('data:image/svg+xml,' + encodeURIComponent((new XMLSerializer()).serializeToString(node)));
    		}
        }else{
        	return resourceLoader.loadImage('data:image/svg+xml,' + encodeURIComponent((new XMLSerializer()).serializeToString(node)));
        }
    }
    switch (node.tagName) {
        case 'IMG':
            // $FlowFixMe
            var img = node;
            return resourceLoader.loadImage(img.currentSrc || img.src);
        case 'CANVAS':
            // $FlowFixMe
            var canvas = node;
            return resourceLoader.loadCanvas(canvas);
        case 'IFRAME':
            var iframeKey = node.getAttribute('data-html2canvas-internal-iframe-key');
            if (iframeKey) {
                return iframeKey;
            }
            break;
    }

    return null;
};

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var contains = exports.contains = function contains(bit, value) {
    return (bit & value) !== 0;
};

var distance = exports.distance = function distance(a, b) {
    return Math.sqrt(a * a + b * b);
};

var copyCSSStyles = exports.copyCSSStyles = function copyCSSStyles(style, target) {
    // Edge does not provide value for cssText
    for (var i = style.length - 1; i >= 0; i--) {
        var property = style.item(i);
        // Safari shows pseudoelements if content is set
        if (property !== 'content') {
            target.style.setProperty(property, style.getPropertyValue(property));
        }
    }
    return target;
};

var SMALL_IMAGE = exports.SMALL_IMAGE = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseBackgroundImage = exports.parseBackground = exports.calculateBackgroundRepeatPath = exports.calculateBackgroundPosition = exports.calculateBackgroungPositioningArea = exports.calculateBackgroungPaintingArea = exports.calculateGradientBackgroundSize = exports.calculateBackgroundSize = exports.BACKGROUND_ORIGIN = exports.BACKGROUND_CLIP = exports.BACKGROUND_SIZE = exports.BACKGROUND_REPEAT = undefined;

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

var _Length = __webpack_require__(1);

var _Length2 = _interopRequireDefault(_Length);

var _Size = __webpack_require__(31);

var _Size2 = _interopRequireDefault(_Size);

var _Vector = __webpack_require__(7);

var _Vector2 = _interopRequireDefault(_Vector);

var _Bounds = __webpack_require__(2);

var _padding = __webpack_require__(17);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var BACKGROUND_REPEAT = exports.BACKGROUND_REPEAT = {
    REPEAT: 0,
    NO_REPEAT: 1,
    REPEAT_X: 2,
    REPEAT_Y: 3
};

var BACKGROUND_SIZE = exports.BACKGROUND_SIZE = {
    AUTO: 0,
    CONTAIN: 1,
    COVER: 2,
    LENGTH: 3
};

var BACKGROUND_CLIP = exports.BACKGROUND_CLIP = {
    BORDER_BOX: 0,
    PADDING_BOX: 1,
    CONTENT_BOX: 2
};

var BACKGROUND_ORIGIN = exports.BACKGROUND_ORIGIN = BACKGROUND_CLIP;

var AUTO = 'auto';

var BackgroundSize = function BackgroundSize(size) {
    _classCallCheck(this, BackgroundSize);

    switch (size) {
        case 'contain':
            this.size = BACKGROUND_SIZE.CONTAIN;
            break;
        case 'cover':
            this.size = BACKGROUND_SIZE.COVER;
            break;
        case 'auto':
            this.size = BACKGROUND_SIZE.AUTO;
            break;
        default:
            this.value = new _Length2.default(size);
    }
};

var calculateBackgroundSize = exports.calculateBackgroundSize = function calculateBackgroundSize(backgroundImage, image, bounds) {
    var width = 0;
    var height = 0;
    var size = backgroundImage.size;
    if (size[0].size === BACKGROUND_SIZE.CONTAIN || size[0].size === BACKGROUND_SIZE.COVER) {
        var targetRatio = bounds.width / bounds.height;
        var currentRatio = image.width / image.height;
        return targetRatio < currentRatio !== (size[0].size === BACKGROUND_SIZE.COVER) ? new _Size2.default(bounds.width, bounds.width / currentRatio) : new _Size2.default(bounds.height * currentRatio, bounds.height);
    }

    if (size[0].value) {
        width = size[0].value.getAbsoluteValue(bounds.width);
    }

    if (size[0].size === BACKGROUND_SIZE.AUTO && size[1].size === BACKGROUND_SIZE.AUTO) {
        height = image.height;
    } else if (size[1].size === BACKGROUND_SIZE.AUTO) {
        height = width / image.width * image.height;
    } else if (size[1].value) {
        height = size[1].value.getAbsoluteValue(bounds.height);
    }

    if (size[0].size === BACKGROUND_SIZE.AUTO) {
        width = height / image.height * image.width;
    }

    return new _Size2.default(width, height);
};

var calculateGradientBackgroundSize = exports.calculateGradientBackgroundSize = function calculateGradientBackgroundSize(backgroundImage, bounds) {
    var size = backgroundImage.size;
    var width = size[0].value ? size[0].value.getAbsoluteValue(bounds.width) : bounds.width;
    var height = size[1].value ? size[1].value.getAbsoluteValue(bounds.height) : size[0].value ? width : bounds.height;

    return new _Size2.default(width, height);
};

var AUTO_SIZE = new BackgroundSize(AUTO);

var calculateBackgroungPaintingArea = exports.calculateBackgroungPaintingArea = function calculateBackgroungPaintingArea(curves, clip) {
    switch (clip) {
        case BACKGROUND_CLIP.BORDER_BOX:
            return (0, _Bounds.calculateBorderBoxPath)(curves);
        case BACKGROUND_CLIP.PADDING_BOX:
        default:
            return (0, _Bounds.calculatePaddingBoxPath)(curves);
    }
};

var calculateBackgroungPositioningArea = exports.calculateBackgroungPositioningArea = function calculateBackgroungPositioningArea(backgroundOrigin, bounds, padding, border) {
    var paddingBox = (0, _Bounds.calculatePaddingBox)(bounds, border);

    switch (backgroundOrigin) {
        case BACKGROUND_ORIGIN.BORDER_BOX:
            return bounds;
        case BACKGROUND_ORIGIN.CONTENT_BOX:
            var paddingLeft = padding[_padding.PADDING_SIDES.LEFT].getAbsoluteValue(bounds.width);
            var paddingRight = padding[_padding.PADDING_SIDES.RIGHT].getAbsoluteValue(bounds.width);
            var paddingTop = padding[_padding.PADDING_SIDES.TOP].getAbsoluteValue(bounds.width);
            var paddingBottom = padding[_padding.PADDING_SIDES.BOTTOM].getAbsoluteValue(bounds.width);
            return new _Bounds.Bounds(paddingBox.left + paddingLeft, paddingBox.top + paddingTop, paddingBox.width - paddingLeft - paddingRight, paddingBox.height - paddingTop - paddingBottom);
        case BACKGROUND_ORIGIN.PADDING_BOX:
        default:
            return paddingBox;
    }
};

var calculateBackgroundPosition = exports.calculateBackgroundPosition = function calculateBackgroundPosition(position, size, bounds) {
    return new _Vector2.default(position[0].getAbsoluteValue(bounds.width - size.width), position[1].getAbsoluteValue(bounds.height - size.height));
};

var calculateBackgroundRepeatPath = exports.calculateBackgroundRepeatPath = function calculateBackgroundRepeatPath(background, position, size, backgroundPositioningArea, bounds) {
    var repeat = background.repeat;
    switch (repeat) {
        case BACKGROUND_REPEAT.REPEAT_X:
            return [new _Vector2.default(Math.round(bounds.left), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(size.height + backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(bounds.left), Math.round(size.height + backgroundPositioningArea.top + position.y))];
        case BACKGROUND_REPEAT.REPEAT_Y:
            return [new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(bounds.top)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(bounds.top)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(bounds.height + bounds.top)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(bounds.height + bounds.top))];
        case BACKGROUND_REPEAT.NO_REPEAT:
            return [new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(backgroundPositioningArea.top + position.y)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x + size.width), Math.round(backgroundPositioningArea.top + position.y + size.height)), new _Vector2.default(Math.round(backgroundPositioningArea.left + position.x), Math.round(backgroundPositioningArea.top + position.y + size.height))];
        default:
            return [new _Vector2.default(Math.round(bounds.left), Math.round(bounds.top)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(bounds.top)), new _Vector2.default(Math.round(bounds.left + bounds.width), Math.round(bounds.height + bounds.top)), new _Vector2.default(Math.round(bounds.left), Math.round(bounds.height + bounds.top))];
    }
};

var parseBackground = exports.parseBackground = function parseBackground(style, resourceLoader) {
    return {
        backgroundColor: new _Color2.default(style.backgroundColor),
        backgroundImage: parseBackgroundImages(style, resourceLoader),
        backgroundClip: parseBackgroundClip(style.backgroundClip),
        backgroundOrigin: parseBackgroundOrigin(style.backgroundOrigin)
    };
};

var parseBackgroundClip = function parseBackgroundClip(backgroundClip) {
    switch (backgroundClip) {
        case 'padding-box':
            return BACKGROUND_CLIP.PADDING_BOX;
        case 'content-box':
            return BACKGROUND_CLIP.CONTENT_BOX;
    }
    return BACKGROUND_CLIP.BORDER_BOX;
};

var parseBackgroundOrigin = function parseBackgroundOrigin(backgroundOrigin) {
    switch (backgroundOrigin) {
        case 'padding-box':
            return BACKGROUND_ORIGIN.PADDING_BOX;
        case 'content-box':
            return BACKGROUND_ORIGIN.CONTENT_BOX;
    }
    return BACKGROUND_ORIGIN.BORDER_BOX;
};

var parseBackgroundRepeat = function parseBackgroundRepeat(backgroundRepeat) {
    switch (backgroundRepeat.trim()) {
        case 'no-repeat':
            return BACKGROUND_REPEAT.NO_REPEAT;
        case 'repeat-x':
        case 'repeat no-repeat':
            return BACKGROUND_REPEAT.REPEAT_X;
        case 'repeat-y':
        case 'no-repeat repeat':
            return BACKGROUND_REPEAT.REPEAT_Y;
        case 'repeat':
            return BACKGROUND_REPEAT.REPEAT;
    }

    if (true) {
        console.error('Invalid background-repeat value "' + backgroundRepeat + '"');
    }

    return BACKGROUND_REPEAT.REPEAT;
};

var parseBackgroundImages = function parseBackgroundImages(style, resourceLoader) {
    var sources = parseBackgroundImage(style.backgroundImage).map(function (backgroundImage) {
        if (backgroundImage.method === 'url') {
            var key = resourceLoader.loadImage(backgroundImage.args[0]);
            backgroundImage.args = key ? [key] : [];
        }
        return backgroundImage;
    });
    var positions = style.backgroundPosition.split(',');
    var repeats = style.backgroundRepeat.split(',');
    var sizes = style.backgroundSize.split(',');

    return sources.map(function (source, index) {
        var size = (sizes[index] || AUTO).trim().split(' ').map(parseBackgroundSize);
        var position = (positions[index] || AUTO).trim().split(' ').map(parseBackgoundPosition);

        return {
            source: source,
            repeat: parseBackgroundRepeat(typeof repeats[index] === 'string' ? repeats[index] : repeats[0]),
            size: size.length < 2 ? [size[0], AUTO_SIZE] : [size[0], size[1]],
            position: position.length < 2 ? [position[0], position[0]] : [position[0], position[1]]
        };
    });
};

var parseBackgroundSize = function parseBackgroundSize(size) {
    return size === 'auto' ? AUTO_SIZE : new BackgroundSize(size);
};

var parseBackgoundPosition = function parseBackgoundPosition(position) {
    switch (position) {
        case 'bottom':
        case 'right':
            return new _Length2.default('100%');
        case 'left':
        case 'top':
            return new _Length2.default('0%');
        case 'auto':
            return new _Length2.default('0');
    }
    return new _Length2.default(position);
};

var parseBackgroundImage = exports.parseBackgroundImage = function parseBackgroundImage(image) {
    var whitespace = /^\s$/;
    var results = [];

    var args = [];
    var method = '';
    var quote = null;
    var definition = '';
    var mode = 0;
    var numParen = 0;

    var appendResult = function appendResult() {
        var prefix = '';
        if (method) {
            if (definition.substr(0, 1) === '"') {
                definition = definition.substr(1, definition.length - 2);
            }

            if (definition) {
                args.push(definition.trim());
            }

            var prefix_i = method.indexOf('-', 1) + 1;
            if (method.substr(0, 1) === '-' && prefix_i > 0) {
                prefix = method.substr(0, prefix_i).toLowerCase();
                method = method.substr(prefix_i);
            }
            method = method.toLowerCase();
            if (method !== 'none') {
                results.push({
                    prefix: prefix,
                    method: method,
                    args: args
                });
            }
        }
        args = [];
        method = definition = '';
    };

    image.split('').forEach(function (c) {
        if (mode === 0 && whitespace.test(c)) {
            return;
        }
        switch (c) {
            case '"':
                if (!quote) {
                    quote = c;
                } else if (quote === c) {
                    quote = null;
                }
                break;
            case '(':
                if (quote) {
                    break;
                } else if (mode === 0) {
                    mode = 1;
                    return;
                } else {
                    numParen++;
                }
                break;
            case ')':
                if (quote) {
                    break;
                } else if (mode === 1) {
                    if (numParen === 0) {
                        mode = 0;
                        appendResult();
                        return;
                    } else {
                        numParen--;
                    }
                }
                break;

            case ',':
                if (quote) {
                    break;
                } else if (mode === 0) {
                    appendResult();
                    return;
                } else if (mode === 1) {
                    if (numParen === 0 && !method.match(/^url$/i)) {
                        args.push(definition.trim());
                        definition = '';
                        return;
                    }
                }
                break;
        }

        if (mode === 0) {
            method += c;
        } else {
            definition += c;
        }
    });

    appendResult();
    return results;
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var PATH = exports.PATH = {
    VECTOR: 0,
    BEZIER_CURVE: 1,
    CIRCLE: 2
};

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Path = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Vector = function Vector(x, y) {
    _classCallCheck(this, Vector);

    this.type = _Path.PATH.VECTOR;
    this.x = x;
    this.y = y;
    if (true) {
        if (isNaN(x)) {
            console.error('Invalid x value given for Vector');
        }
        if (isNaN(y)) {
            console.error('Invalid y value given for Vector');
        }
    }
};

exports.default = Vector;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseListStyle = exports.parseListStyleType = exports.LIST_STYLE_TYPE = exports.LIST_STYLE_POSITION = undefined;

var _background = __webpack_require__(5);

var LIST_STYLE_POSITION = exports.LIST_STYLE_POSITION = {
    INSIDE: 0,
    OUTSIDE: 1
};

var LIST_STYLE_TYPE = exports.LIST_STYLE_TYPE = {
    NONE: -1,
    DISC: 0,
    CIRCLE: 1,
    SQUARE: 2,
    DECIMAL: 3,
    CJK_DECIMAL: 4,
    DECIMAL_LEADING_ZERO: 5,
    LOWER_ROMAN: 6,
    UPPER_ROMAN: 7,
    LOWER_GREEK: 8,
    LOWER_ALPHA: 9,
    UPPER_ALPHA: 10,
    ARABIC_INDIC: 11,
    ARMENIAN: 12,
    BENGALI: 13,
    CAMBODIAN: 14,
    CJK_EARTHLY_BRANCH: 15,
    CJK_HEAVENLY_STEM: 16,
    CJK_IDEOGRAPHIC: 17,
    DEVANAGARI: 18,
    ETHIOPIC_NUMERIC: 19,
    GEORGIAN: 20,
    GUJARATI: 21,
    GURMUKHI: 22,
    HEBREW: 22,
    HIRAGANA: 23,
    HIRAGANA_IROHA: 24,
    JAPANESE_FORMAL: 25,
    JAPANESE_INFORMAL: 26,
    KANNADA: 27,
    KATAKANA: 28,
    KATAKANA_IROHA: 29,
    KHMER: 30,
    KOREAN_HANGUL_FORMAL: 31,
    KOREAN_HANJA_FORMAL: 32,
    KOREAN_HANJA_INFORMAL: 33,
    LAO: 34,
    LOWER_ARMENIAN: 35,
    MALAYALAM: 36,
    MONGOLIAN: 37,
    MYANMAR: 38,
    ORIYA: 39,
    PERSIAN: 40,
    SIMP_CHINESE_FORMAL: 41,
    SIMP_CHINESE_INFORMAL: 42,
    TAMIL: 43,
    TELUGU: 44,
    THAI: 45,
    TIBETAN: 46,
    TRAD_CHINESE_FORMAL: 47,
    TRAD_CHINESE_INFORMAL: 48,
    UPPER_ARMENIAN: 49,
    DISCLOSURE_OPEN: 50,
    DISCLOSURE_CLOSED: 51
};

var parseListStyleType = exports.parseListStyleType = function parseListStyleType(type) {
    switch (type) {
        case 'disc':
            return LIST_STYLE_TYPE.DISC;
        case 'circle':
            return LIST_STYLE_TYPE.CIRCLE;
        case 'square':
            return LIST_STYLE_TYPE.SQUARE;
        case 'decimal':
            return LIST_STYLE_TYPE.DECIMAL;
        case 'cjk-decimal':
            return LIST_STYLE_TYPE.CJK_DECIMAL;
        case 'decimal-leading-zero':
            return LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO;
        case 'lower-roman':
            return LIST_STYLE_TYPE.LOWER_ROMAN;
        case 'upper-roman':
            return LIST_STYLE_TYPE.UPPER_ROMAN;
        case 'lower-greek':
            return LIST_STYLE_TYPE.LOWER_GREEK;
        case 'lower-alpha':
            return LIST_STYLE_TYPE.LOWER_ALPHA;
        case 'upper-alpha':
            return LIST_STYLE_TYPE.UPPER_ALPHA;
        case 'arabic-indic':
            return LIST_STYLE_TYPE.ARABIC_INDIC;
        case 'armenian':
            return LIST_STYLE_TYPE.ARMENIAN;
        case 'bengali':
            return LIST_STYLE_TYPE.BENGALI;
        case 'cambodian':
            return LIST_STYLE_TYPE.CAMBODIAN;
        case 'cjk-earthly-branch':
            return LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH;
        case 'cjk-heavenly-stem':
            return LIST_STYLE_TYPE.CJK_HEAVENLY_STEM;
        case 'cjk-ideographic':
            return LIST_STYLE_TYPE.CJK_IDEOGRAPHIC;
        case 'devanagari':
            return LIST_STYLE_TYPE.DEVANAGARI;
        case 'ethiopic-numeric':
            return LIST_STYLE_TYPE.ETHIOPIC_NUMERIC;
        case 'georgian':
            return LIST_STYLE_TYPE.GEORGIAN;
        case 'gujarati':
            return LIST_STYLE_TYPE.GUJARATI;
        case 'gurmukhi':
            return LIST_STYLE_TYPE.GURMUKHI;
        case 'hebrew':
            return LIST_STYLE_TYPE.HEBREW;
        case 'hiragana':
            return LIST_STYLE_TYPE.HIRAGANA;
        case 'hiragana-iroha':
            return LIST_STYLE_TYPE.HIRAGANA_IROHA;
        case 'japanese-formal':
            return LIST_STYLE_TYPE.JAPANESE_FORMAL;
        case 'japanese-informal':
            return LIST_STYLE_TYPE.JAPANESE_INFORMAL;
        case 'kannada':
            return LIST_STYLE_TYPE.KANNADA;
        case 'katakana':
            return LIST_STYLE_TYPE.KATAKANA;
        case 'katakana-iroha':
            return LIST_STYLE_TYPE.KATAKANA_IROHA;
        case 'khmer':
            return LIST_STYLE_TYPE.KHMER;
        case 'korean-hangul-formal':
            return LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL;
        case 'korean-hanja-formal':
            return LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL;
        case 'korean-hanja-informal':
            return LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL;
        case 'lao':
            return LIST_STYLE_TYPE.LAO;
        case 'lower-armenian':
            return LIST_STYLE_TYPE.LOWER_ARMENIAN;
        case 'malayalam':
            return LIST_STYLE_TYPE.MALAYALAM;
        case 'mongolian':
            return LIST_STYLE_TYPE.MONGOLIAN;
        case 'myanmar':
            return LIST_STYLE_TYPE.MYANMAR;
        case 'oriya':
            return LIST_STYLE_TYPE.ORIYA;
        case 'persian':
            return LIST_STYLE_TYPE.PERSIAN;
        case 'simp-chinese-formal':
            return LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL;
        case 'simp-chinese-informal':
            return LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL;
        case 'tamil':
            return LIST_STYLE_TYPE.TAMIL;
        case 'telugu':
            return LIST_STYLE_TYPE.TELUGU;
        case 'thai':
            return LIST_STYLE_TYPE.THAI;
        case 'tibetan':
            return LIST_STYLE_TYPE.TIBETAN;
        case 'trad-chinese-formal':
            return LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL;
        case 'trad-chinese-informal':
            return LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL;
        case 'upper-armenian':
            return LIST_STYLE_TYPE.UPPER_ARMENIAN;
        case 'disclosure-open':
            return LIST_STYLE_TYPE.DISCLOSURE_OPEN;
        case 'disclosure-closed':
            return LIST_STYLE_TYPE.DISCLOSURE_CLOSED;
        case 'none':
        default:
            return LIST_STYLE_TYPE.NONE;
    }
};

var parseListStyle = exports.parseListStyle = function parseListStyle(style) {
    var listStyleImage = (0, _background.parseBackgroundImage)(style.getPropertyValue('list-style-image'));
    return {
        listStyleType: parseListStyleType(style.getPropertyValue('list-style-type')),
        listStyleImage: listStyleImage.length ? listStyleImage[0] : null,
        listStylePosition: parseListStylePosition(style.getPropertyValue('list-style-position'))
    };
};

var parseListStylePosition = function parseListStylePosition(position) {
    switch (position) {
        case 'inside':
            return LIST_STYLE_POSITION.INSIDE;
        case 'outside':
        default:
            return LIST_STYLE_POSITION.OUTSIDE;
    }
};

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _textTransform = __webpack_require__(20);

var _TextBounds = __webpack_require__(22);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TextContainer = function () {
    function TextContainer(text, parent, bounds) {
        _classCallCheck(this, TextContainer);

        this.text = text;
        this.parent = parent;
        this.bounds = bounds;
    }

    _createClass(TextContainer, null, [{
        key: 'fromTextNode',
        value: function fromTextNode(node, parent) {
            var text = transform(node.data, parent.style.textTransform);
            return new TextContainer(text, parent, (0, _TextBounds.parseTextBounds)(text, parent, node));
        }
    }]);

    return TextContainer;
}();

exports.default = TextContainer;


var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;

var transform = function transform(text, _transform) {
    switch (_transform) {
        case _textTransform.TEXT_TRANSFORM.LOWERCASE:
            return text.toLowerCase();
        case _textTransform.TEXT_TRANSFORM.CAPITALIZE:
            return text.replace(CAPITALIZE, capitalize);
        case _textTransform.TEXT_TRANSFORM.UPPERCASE:
            return text.toUpperCase();
        default:
            return text;
    }
};

function capitalize(m, p1, p2) {
    if (m.length > 0) {
        return p1 + p2.toUpperCase();
    }

    return m;
}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _ForeignObjectRenderer = __webpack_require__(23);

var testRangeBounds = function testRangeBounds(document) {
    var TEST_HEIGHT = 123;

    if (document.createRange) {
        var range = document.createRange();
        if (range.getBoundingClientRect) {
            var testElement = document.createElement('boundtest');
            testElement.style.height = TEST_HEIGHT + 'px';
            testElement.style.display = 'block';
            document.body.appendChild(testElement);

            range.selectNode(testElement);
            var rangeBounds = range.getBoundingClientRect();
            var rangeHeight = Math.round(rangeBounds.height);
            document.body.removeChild(testElement);
            if (rangeHeight === TEST_HEIGHT) {
                return true;
            }
        }
    }

    return false;
};

// iOS 10.3 taints canvas with base64 images unless crossOrigin = 'anonymous'
var testBase64 = function testBase64(document, src) {
    var img = new Image();
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');

    return new Promise(function (resolve) {
        // Single pixel base64 image renders fine on iOS 10.3???
        img.src = src;

        var onload = function onload() {
            try {
                ctx.drawImage(img, 0, 0);
                canvas.toDataURL();
            } catch (e) {
                return resolve(false);
            }

            return resolve(true);
        };

        img.onload = onload;
        img.onerror = function () {
            return resolve(false);
        };

        if (img.complete === true) {
            setTimeout(function () {
                onload();
            }, 500);
        }
    });
};

var testCORS = function testCORS() {
    return typeof new Image().crossOrigin !== 'undefined';
};

var testResponseType = function testResponseType() {
    return typeof new XMLHttpRequest().responseType === 'string';
};

var testSVG = function testSVG(document) {
    var img = new Image();
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    img.src = 'data:image/svg+xml;charset=utf-8,<svg xmlns=\'http://www.w3.org/2000/svg\'></svg>';

    try {
        ctx.drawImage(img, 0, 0);
        canvas.toDataURL();
    } catch (e) {
        return false;
    }
    return true;
};

var isGreenPixel = function isGreenPixel(data) {
    return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
};

var testForeignObject = function testForeignObject(document) {
    var canvas = document.createElement('canvas');
    var size = 100;
    canvas.width = size;
    canvas.height = size;
    var ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgb(0, 255, 0)';
    ctx.fillRect(0, 0, size, size);

    var img = new Image();
    var greenImageSrc = canvas.toDataURL();
    img.src = greenImageSrc;
    var svg = (0, _ForeignObjectRenderer.createForeignObjectSVG)(size, size, 0, 0, img);
    ctx.fillStyle = 'red';
    ctx.fillRect(0, 0, size, size);

    return (0, _ForeignObjectRenderer.loadSerializedSVG)(svg).then(function (img) {
        ctx.drawImage(img, 0, 0);
        var data = ctx.getImageData(0, 0, size, size).data;
        ctx.fillStyle = 'red';
        ctx.fillRect(0, 0, size, size);

        var node = document.createElement('div');
        node.style.backgroundImage = 'url(' + greenImageSrc + ')';
        node.style.height = size + 'px';
        // Firefox 55 does not render inline <img /> tags
        return isGreenPixel(data) ? (0, _ForeignObjectRenderer.loadSerializedSVG)((0, _ForeignObjectRenderer.createForeignObjectSVG)(size, size, 0, 0, node)) : Promise.reject(false);
    }).then(function (img) {
        ctx.drawImage(img, 0, 0);
        // Edge does not render background-images
        return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
    }).catch(function (e) {
        return false;
    });
};

var FEATURES = {
    // $FlowFixMe - get/set properties not yet supported
    get SUPPORT_RANGE_BOUNDS() {
        'use strict';

        var value = testRangeBounds(document);
        Object.defineProperty(FEATURES, 'SUPPORT_RANGE_BOUNDS', { value: value });
        return value;
    },
    // $FlowFixMe - get/set properties not yet supported
    get SUPPORT_SVG_DRAWING() {
        'use strict';

        var value = testSVG(document);
        Object.defineProperty(FEATURES, 'SUPPORT_SVG_DRAWING', { value: value });
        return value;
    },
    // $FlowFixMe - get/set properties not yet supported
    get SUPPORT_BASE64_DRAWING() {
        'use strict';

        return function (src) {
            var _value = testBase64(document, src);
            Object.defineProperty(FEATURES, 'SUPPORT_BASE64_DRAWING', { value: function value() {
                    return _value;
                } });
            return _value;
        };
    },
    // $FlowFixMe - get/set properties not yet supported
    get SUPPORT_FOREIGNOBJECT_DRAWING() {
        'use strict';

        var value = typeof Array.from === 'function' && typeof window.fetch === 'function' ? testForeignObject(document) : Promise.resolve(false);
        Object.defineProperty(FEATURES, 'SUPPORT_FOREIGNOBJECT_DRAWING', { value: value });
        return value;
    },
    // $FlowFixMe - get/set properties not yet supported
    get SUPPORT_CORS_IMAGES() {
        'use strict';

        var value = testCORS();
        Object.defineProperty(FEATURES, 'SUPPORT_CORS_IMAGES', { value: value });
        return value;
    },
    // $FlowFixMe - get/set properties not yet supported
    get SUPPORT_RESPONSE_TYPE() {
        'use strict';

        var value = testResponseType();
        Object.defineProperty(FEATURES, 'SUPPORT_RESPONSE_TYPE', { value: value });
        return value;
    },
    // $FlowFixMe - get/set properties not yet supported
    get SUPPORT_CORS_XHR() {
        'use strict';

        var value = 'withCredentials' in new XMLHttpRequest();
        Object.defineProperty(FEATURES, 'SUPPORT_CORS_XHR', { value: value });
        return value;
    }
};

exports.default = FEATURES;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseTextDecoration = exports.TEXT_DECORATION_LINE = exports.TEXT_DECORATION = exports.TEXT_DECORATION_STYLE = undefined;

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TEXT_DECORATION_STYLE = exports.TEXT_DECORATION_STYLE = {
    SOLID: 0,
    DOUBLE: 1,
    DOTTED: 2,
    DASHED: 3,
    WAVY: 4
};

var TEXT_DECORATION = exports.TEXT_DECORATION = {
    NONE: null
};

var TEXT_DECORATION_LINE = exports.TEXT_DECORATION_LINE = {
    UNDERLINE: 1,
    OVERLINE: 2,
    LINE_THROUGH: 3,
    BLINK: 4
};

var parseLine = function parseLine(line) {
    switch (line) {
        case 'underline':
            return TEXT_DECORATION_LINE.UNDERLINE;
        case 'overline':
            return TEXT_DECORATION_LINE.OVERLINE;
        case 'line-through':
            return TEXT_DECORATION_LINE.LINE_THROUGH;
    }
    return TEXT_DECORATION_LINE.BLINK;
};

var parseTextDecorationLine = function parseTextDecorationLine(line) {
    if (line === 'none') {
        return null;
    }

    return line.split(' ').map(parseLine);
};

var parseTextDecorationStyle = function parseTextDecorationStyle(style) {
    switch (style) {
        case 'double':
            return TEXT_DECORATION_STYLE.DOUBLE;
        case 'dotted':
            return TEXT_DECORATION_STYLE.DOTTED;
        case 'dashed':
            return TEXT_DECORATION_STYLE.DASHED;
        case 'wavy':
            return TEXT_DECORATION_STYLE.WAVY;
    }
    return TEXT_DECORATION_STYLE.SOLID;
};

var parseTextDecoration = exports.parseTextDecoration = function parseTextDecoration(style) {
    var textDecorationLine = parseTextDecorationLine(style.textDecorationLine ? style.textDecorationLine : style.textDecoration);
    if (textDecorationLine === null) {
        return TEXT_DECORATION.NONE;
    }

    var textDecorationColor = style.textDecorationColor ? new _Color2.default(style.textDecorationColor) : null;
    var textDecorationStyle = parseTextDecorationStyle(style.textDecorationStyle);

    return {
        textDecorationLine: textDecorationLine,
        textDecorationColor: textDecorationColor,
        textDecorationStyle: textDecorationStyle
    };
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseBorder = exports.BORDER_SIDES = exports.BORDER_STYLE = undefined;

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BORDER_STYLE = exports.BORDER_STYLE = {
    NONE: 0,
    SOLID: 1
};

var BORDER_SIDES = exports.BORDER_SIDES = {
    TOP: 0,
    RIGHT: 1,
    BOTTOM: 2,
    LEFT: 3
};

var SIDES = Object.keys(BORDER_SIDES).map(function (s) {
    return s.toLowerCase();
});

var parseBorderStyle = function parseBorderStyle(style) {
    switch (style) {
        case 'none':
            return BORDER_STYLE.NONE;
    }
    return BORDER_STYLE.SOLID;
};

var parseBorder = exports.parseBorder = function parseBorder(style) {
    return SIDES.map(function (side) {
        var borderColor = new _Color2.default(style.getPropertyValue('border-' + side + '-color'));
        var borderStyle = parseBorderStyle(style.getPropertyValue('border-' + side + '-style'));
        var borderWidth = parseFloat(style.getPropertyValue('border-' + side + '-width'));
        return {
            borderColor: borderColor,
            borderStyle: borderStyle,
            borderWidth: isNaN(borderWidth) ? 0 : borderWidth
        };
    });
};

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var toCodePoints = exports.toCodePoints = function toCodePoints(str) {
    var codePoints = [];
    var i = 0;
    var length = str.length;
    while (i < length) {
        var value = str.charCodeAt(i++);
        if (value >= 0xd800 && value <= 0xdbff && i < length) {
            var extra = str.charCodeAt(i++);
            if ((extra & 0xfc00) === 0xdc00) {
                codePoints.push(((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000);
            } else {
                codePoints.push(value);
                i--;
            }
        } else {
            codePoints.push(value);
        }
    }
    return codePoints;
};

var fromCodePoint = exports.fromCodePoint = function fromCodePoint() {
    if (String.fromCodePoint) {
        return String.fromCodePoint.apply(String, arguments);
    }

    var length = arguments.length;
    if (!length) {
        return '';
    }

    var codeUnits = [];

    var index = -1;
    var result = '';
    while (++index < length) {
        var codePoint = arguments.length <= index ? undefined : arguments[index];
        if (codePoint <= 0xffff) {
            codeUnits.push(codePoint);
        } else {
            codePoint -= 0x10000;
            codeUnits.push((codePoint >> 10) + 0xd800, codePoint % 0x400 + 0xdc00);
        }
        if (index + 1 === length || codeUnits.length > 0x4000) {
            result += String.fromCharCode.apply(String, codeUnits);
            codeUnits.length = 0;
        }
    }
    return result;
};

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

// Use a lookup table to find the index.
var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
}

var decode = exports.decode = function decode(base64) {
    var bufferLength = base64.length * 0.75,
        len = base64.length,
        i = void 0,
        p = 0,
        encoded1 = void 0,
        encoded2 = void 0,
        encoded3 = void 0,
        encoded4 = void 0;

    if (base64[base64.length - 1] === '=') {
        bufferLength--;
        if (base64[base64.length - 2] === '=') {
            bufferLength--;
        }
    }

    var buffer = typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint8Array.prototype.slice !== 'undefined' ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
    var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);

    for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base64.charCodeAt(i)];
        encoded2 = lookup[base64.charCodeAt(i + 1)];
        encoded3 = lookup[base64.charCodeAt(i + 2)];
        encoded4 = lookup[base64.charCodeAt(i + 3)];

        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }

    return buffer;
};

var polyUint16Array = exports.polyUint16Array = function polyUint16Array(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var _i = 0; _i < length; _i += 2) {
        bytes.push(buffer[_i + 1] << 8 | buffer[_i]);
    }
    return bytes;
};

var polyUint32Array = exports.polyUint32Array = function polyUint32Array(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var _i2 = 0; _i2 < length; _i2 += 4) {
        bytes.push(buffer[_i2 + 3] << 24 | buffer[_i2 + 2] << 16 | buffer[_i2 + 1] << 8 | buffer[_i2]);
    }
    return bytes;
};

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createCounterText = exports.inlineListItemElement = exports.getListOwner = undefined;

var _Util = __webpack_require__(4);

var _NodeContainer = __webpack_require__(3);

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _TextContainer = __webpack_require__(9);

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _listStyle = __webpack_require__(8);

var _Unicode = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Margin between the enumeration and the list item content
var MARGIN_RIGHT = 7;

var ancestorTypes = ['OL', 'UL', 'MENU'];

var getListOwner = exports.getListOwner = function getListOwner(container) {
    var parent = container.parent;
    if (!parent) {
        return null;
    }

    do {
        var isAncestor = ancestorTypes.indexOf(parent.tagName) !== -1;
        if (isAncestor) {
            return parent;
        }
        parent = parent.parent;
    } while (parent);

    return container.parent;
};

var inlineListItemElement = exports.inlineListItemElement = function inlineListItemElement(node, container, resourceLoader) {
    var listStyle = container.style.listStyle;

    if (!listStyle) {
        return;
    }

    var style = node.ownerDocument.defaultView.getComputedStyle(node, null);
    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
    (0, _Util.copyCSSStyles)(style, wrapper);

    wrapper.style.position = 'absolute';
    wrapper.style.bottom = 'auto';
    wrapper.style.display = 'block';
    wrapper.style.letterSpacing = 'normal';

    switch (listStyle.listStylePosition) {
        case _listStyle.LIST_STYLE_POSITION.OUTSIDE:
            wrapper.style.left = 'auto';
            wrapper.style.right = node.ownerDocument.defaultView.innerWidth - container.bounds.left - container.style.margin[1].getAbsoluteValue(container.bounds.width) + MARGIN_RIGHT + 'px';
            wrapper.style.textAlign = 'right';
            break;
        case _listStyle.LIST_STYLE_POSITION.INSIDE:
            wrapper.style.left = container.bounds.left - container.style.margin[3].getAbsoluteValue(container.bounds.width) + 'px';
            wrapper.style.right = 'auto';
            wrapper.style.textAlign = 'left';
            break;
    }

    var text = void 0;
    var MARGIN_TOP = container.style.margin[0].getAbsoluteValue(container.bounds.width);
    var styleImage = listStyle.listStyleImage;
    if (styleImage) {
        if (styleImage.method === 'url') {
            var image = node.ownerDocument.createElement('img');
            image.src = styleImage.args[0];
            wrapper.style.top = container.bounds.top - MARGIN_TOP + 'px';
            wrapper.style.width = 'auto';
            wrapper.style.height = 'auto';
            wrapper.appendChild(image);
        } else {
            var size = parseFloat(container.style.font.fontSize) * 0.5;
            wrapper.style.top = container.bounds.top - MARGIN_TOP + container.bounds.height - 1.5 * size + 'px';
            wrapper.style.width = size + 'px';
            wrapper.style.height = size + 'px';
            wrapper.style.backgroundImage = style.listStyleImage;
        }
    } else if (typeof container.listIndex === 'number') {
        text = node.ownerDocument.createTextNode(createCounterText(container.listIndex, listStyle.listStyleType, true));
        wrapper.appendChild(text);
        wrapper.style.top = container.bounds.top - MARGIN_TOP + 'px';
    }

    // $FlowFixMe
    var body = node.ownerDocument.body;
    body.appendChild(wrapper);

    if (text) {
        container.childNodes.push(_TextContainer2.default.fromTextNode(text, container));
        body.removeChild(wrapper);
    } else {
        // $FlowFixMe
        container.childNodes.push(new _NodeContainer2.default(wrapper, container, resourceLoader, 0));
    }
};

var ROMAN_UPPER = {
    integers: [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
    values: ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I']
};

var ARMENIAN = {
    integers: [9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    values: ['Õ”', 'Õ“', 'Õ’', 'Õ‘', 'Õ�', 'Õ�', 'ÕŽ', 'Õ�', 'ÕŒ', 'Õ‹', 'ÕŠ', 'Õ‰', 'Õˆ', 'Õ‡', 'Õ†', 'Õ…', 'Õ„', 'Õƒ', 'Õ‚', 'Õ�', 'Õ€', 'Ô¿', 'Ô¾', 'Ô½', 'Ô¼', 'Ô»', 'Ôº', 'Ô¹', 'Ô¸', 'Ô·', 'Ô¶', 'Ôµ', 'Ô´', 'Ô³', 'Ô²', 'Ô±']
};

var HEBREW = {
    integers: [10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 19, 18, 17, 16, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    values: ['×™×³', '×˜×³', '×—×³', '×–×³', '×•×³', '×”×³', '×“×³', '×’×³', '×‘×³', '×�×³', '×ª', '×©', '×¨', '×§', '×¦', '×¤', '×¢', '×¡', '× ', '×ž', '×œ', '×›', '×™×˜', '×™×—', '×™×–', '×˜×–', '×˜×•', '×™', '×˜', '×—', '×–', '×•', '×”', '×“', '×’', '×‘', '×�']
};

var GEORGIAN = {
    integers: [10000, 9000, 8000, 7000, 6000, 5000, 4000, 3000, 2000, 1000, 900, 800, 700, 600, 500, 400, 300, 200, 100, 90, 80, 70, 60, 50, 40, 30, 20, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    values: ['áƒµ', 'áƒ°', 'áƒ¯', 'áƒ´', 'áƒ®', 'áƒ­', 'áƒ¬', 'áƒ«', 'áƒª', 'áƒ©', 'áƒ¨', 'áƒ§', 'áƒ¦', 'áƒ¥', 'áƒ¤', 'áƒ³', 'áƒ¢', 'áƒ¡', 'áƒ ', 'áƒŸ', 'áƒž', 'áƒ�', 'áƒ²', 'áƒœ', 'áƒ›', 'áƒš', 'áƒ™', 'áƒ˜', 'áƒ—', 'áƒ±', 'áƒ–', 'áƒ•', 'áƒ”', 'áƒ“', 'áƒ’', 'áƒ‘', 'áƒ�']
};

var createAdditiveCounter = function createAdditiveCounter(value, min, max, symbols, fallback, suffix) {
    if (value < min || value > max) {
        return createCounterText(value, fallback, suffix.length > 0);
    }

    return symbols.integers.reduce(function (string, integer, index) {
        while (value >= integer) {
            value -= integer;
            string += symbols.values[index];
        }
        return string;
    }, '') + suffix;
};

var createCounterStyleWithSymbolResolver = function createCounterStyleWithSymbolResolver(value, codePointRangeLength, isNumeric, resolver) {
    var string = '';

    do {
        if (!isNumeric) {
            value--;
        }
        string = resolver(value) + string;
        value /= codePointRangeLength;
    } while (value * codePointRangeLength >= codePointRangeLength);

    return string;
};

var createCounterStyleFromRange = function createCounterStyleFromRange(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
    var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;

    return (value < 0 ? '-' : '') + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function (codePoint) {
        return (0, _Unicode.fromCodePoint)(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
    }) + suffix);
};

var createCounterStyleFromSymbols = function createCounterStyleFromSymbols(value, symbols) {
    var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '. ';

    var codePointRangeLength = symbols.length;
    return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function (codePoint) {
        return symbols[Math.floor(codePoint % codePointRangeLength)];
    }) + suffix;
};

var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;

var createCJKCounter = function createCJKCounter(value, numbers, multipliers, negativeSign, suffix, flags) {
    if (value < -9999 || value > 9999) {
        return createCounterText(value, _listStyle.LIST_STYLE_TYPE.CJK_DECIMAL, suffix.length > 0);
    }
    var tmp = Math.abs(value);
    var string = suffix;

    if (tmp === 0) {
        return numbers[0] + string;
    }

    for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
        var coefficient = tmp % 10;

        if (coefficient === 0 && (0, _Util.contains)(flags, CJK_ZEROS) && string !== '') {
            string = numbers[coefficient] + string;
        } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && (0, _Util.contains)(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && (0, _Util.contains)(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && (0, _Util.contains)(flags, CJK_HUNDRED_COEFFICIENTS)) {
            string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : '') + string;
        } else if (coefficient === 1 && digit > 0) {
            string = multipliers[digit - 1] + string;
        }
        tmp = Math.floor(tmp / 10);
    }

    return (value < 0 ? negativeSign : '') + string;
};

var CHINESE_INFORMAL_MULTIPLIERS = 'å��ç™¾å�ƒè�¬';
var CHINESE_FORMAL_MULTIPLIERS = 'æ‹¾ä½°ä»Ÿè�¬';
var JAPANESE_NEGATIVE = 'ãƒžã‚¤ãƒŠã‚¹';
var KOREAN_NEGATIVE = 'ë§ˆì�´ë„ˆìŠ¤ ';

var createCounterText = exports.createCounterText = function createCounterText(value, type, appendSuffix) {
    var defaultSuffix = appendSuffix ? '. ' : '';
    var cjkSuffix = appendSuffix ? 'ã€�' : '';
    var koreanSuffix = appendSuffix ? ', ' : '';
    switch (type) {
        case _listStyle.LIST_STYLE_TYPE.DISC:
            return 'â€¢';
        case _listStyle.LIST_STYLE_TYPE.CIRCLE:
            return 'â—¦';
        case _listStyle.LIST_STYLE_TYPE.SQUARE:
            return 'â—¾';
        case _listStyle.LIST_STYLE_TYPE.DECIMAL_LEADING_ZERO:
            var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
            return string.length < 4 ? '0' + string : string;
        case _listStyle.LIST_STYLE_TYPE.CJK_DECIMAL:
            return createCounterStyleFromSymbols(value, 'ã€‡ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹�', cjkSuffix);
        case _listStyle.LIST_STYLE_TYPE.LOWER_ROMAN:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
        case _listStyle.LIST_STYLE_TYPE.UPPER_ROMAN:
            return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.LOWER_GREEK:
            return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.LOWER_ALPHA:
            return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.UPPER_ALPHA:
            return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.ARABIC_INDIC:
            return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.ARMENIAN:
        case _listStyle.LIST_STYLE_TYPE.UPPER_ARMENIAN:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.LOWER_ARMENIAN:
            return createAdditiveCounter(value, 1, 9999, ARMENIAN, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix).toLowerCase();
        case _listStyle.LIST_STYLE_TYPE.BENGALI:
            return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.CAMBODIAN:
        case _listStyle.LIST_STYLE_TYPE.KHMER:
            return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.CJK_EARTHLY_BRANCH:
            return createCounterStyleFromSymbols(value, 'å­�ä¸‘å¯…å�¯è¾°å·³å�ˆæœªç”³é…‰æˆŒäº¥', cjkSuffix);
        case _listStyle.LIST_STYLE_TYPE.CJK_HEAVENLY_STEM:
            return createCounterStyleFromSymbols(value, 'ç”²ä¹™ä¸™ä¸�æˆŠå·±åºšè¾›å£¬ç™¸', cjkSuffix);
        case _listStyle.LIST_STYLE_TYPE.CJK_IDEOGRAPHIC:
        case _listStyle.LIST_STYLE_TYPE.TRAD_CHINESE_INFORMAL:
            return createCJKCounter(value, 'é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹�', CHINESE_INFORMAL_MULTIPLIERS, 'è² ', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case _listStyle.LIST_STYLE_TYPE.TRAD_CHINESE_FORMAL:
            return createCJKCounter(value, 'é›¶å£¹è²³å�ƒè‚†ä¼�é™¸æŸ’æ�ŒçŽ–', CHINESE_FORMAL_MULTIPLIERS, 'è² ', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case _listStyle.LIST_STYLE_TYPE.SIMP_CHINESE_INFORMAL:
            return createCJKCounter(value, 'é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹�', CHINESE_INFORMAL_MULTIPLIERS, 'è´Ÿ', cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case _listStyle.LIST_STYLE_TYPE.SIMP_CHINESE_FORMAL:
            return createCJKCounter(value, 'é›¶å£¹è´°å��è‚†ä¼�é™†æŸ’æ�ŒçŽ–', CHINESE_FORMAL_MULTIPLIERS, 'è´Ÿ', cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
        case _listStyle.LIST_STYLE_TYPE.JAPANESE_INFORMAL:
            return createCJKCounter(value, 'ã€‡ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹�', 'å��ç™¾å�ƒä¸‡', JAPANESE_NEGATIVE, cjkSuffix, 0);
        case _listStyle.LIST_STYLE_TYPE.JAPANESE_FORMAL:
            return createCJKCounter(value, 'é›¶å£±å¼�å�‚å››ä¼�å…­ä¸ƒå…«ä¹�', 'æ‹¾ç™¾å�ƒä¸‡', JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case _listStyle.LIST_STYLE_TYPE.KOREAN_HANGUL_FORMAL:
            return createCJKCounter(value, 'ì˜�ì�¼ì�´ì‚¼ì‚¬ì˜¤ìœ¡ì¹ íŒ”êµ¬', 'ì‹­ë°±ì²œë§Œ', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case _listStyle.LIST_STYLE_TYPE.KOREAN_HANJA_INFORMAL:
            return createCJKCounter(value, 'é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹�', 'å��ç™¾å�ƒè�¬', KOREAN_NEGATIVE, koreanSuffix, 0);
        case _listStyle.LIST_STYLE_TYPE.KOREAN_HANJA_FORMAL:
            return createCJKCounter(value, 'é›¶å£¹è²³å�ƒå››äº”å…­ä¸ƒå…«ä¹�', 'æ‹¾ç™¾å�ƒ', KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
        case _listStyle.LIST_STYLE_TYPE.DEVANAGARI:
            return createCounterStyleFromRange(value, 0x966, 0x96f, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.GEORGIAN:
            return createAdditiveCounter(value, 1, 19999, GEORGIAN, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.GUJARATI:
            return createCounterStyleFromRange(value, 0xae6, 0xaef, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.GURMUKHI:
            return createCounterStyleFromRange(value, 0xa66, 0xa6f, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.HEBREW:
            return createAdditiveCounter(value, 1, 10999, HEBREW, _listStyle.LIST_STYLE_TYPE.DECIMAL, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.HIRAGANA:
            return createCounterStyleFromSymbols(value, 'ã�‚ã�„ã�†ã�ˆã�Šã�‹ã��ã��ã�‘ã�“ã�•ã�—ã�™ã�›ã��ã�Ÿã�¡ã�¤ã�¦ã�¨ã�ªã�«ã�¬ã�­ã�®ã�¯ã�²ã�µã�¸ã�»ã�¾ã�¿ã‚€ã‚�ã‚‚ã‚„ã‚†ã‚ˆã‚‰ã‚Šã‚‹ã‚Œã‚�ã‚�ã‚�ã‚‘ã‚’ã‚“');
        case _listStyle.LIST_STYLE_TYPE.HIRAGANA_IROHA:
            return createCounterStyleFromSymbols(value, 'ã�„ã‚�ã�¯ã�«ã�»ã�¸ã�¨ã�¡ã‚Šã�¬ã‚‹ã‚’ã‚�ã�‹ã‚ˆã�Ÿã‚Œã��ã�¤ã�­ã�ªã‚‰ã‚€ã�†ã‚�ã�®ã�Šã��ã‚„ã�¾ã�‘ã�µã�“ã�ˆã�¦ã�‚ã�•ã��ã‚†ã‚�ã�¿ã�—ã‚‘ã�²ã‚‚ã�›ã�™');
        case _listStyle.LIST_STYLE_TYPE.KANNADA:
            return createCounterStyleFromRange(value, 0xce6, 0xcef, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.KATAKANA:
            return createCounterStyleFromSymbols(value, 'ã‚¢ã‚¤ã‚¦ã‚¨ã‚ªã‚«ã‚­ã‚¯ã‚±ã‚³ã‚µã‚·ã‚¹ã‚»ã‚½ã‚¿ãƒ�ãƒ„ãƒ†ãƒˆãƒŠãƒ‹ãƒŒãƒ�ãƒŽãƒ�ãƒ’ãƒ•ãƒ˜ãƒ›ãƒžãƒŸãƒ ãƒ¡ãƒ¢ãƒ¤ãƒ¦ãƒ¨ãƒ©ãƒªãƒ«ãƒ¬ãƒ­ãƒ¯ãƒ°ãƒ±ãƒ²ãƒ³', cjkSuffix);
        case _listStyle.LIST_STYLE_TYPE.KATAKANA_IROHA:
            return createCounterStyleFromSymbols(value, 'ã‚¤ãƒ­ãƒ�ãƒ‹ãƒ›ãƒ˜ãƒˆãƒ�ãƒªãƒŒãƒ«ãƒ²ãƒ¯ã‚«ãƒ¨ã‚¿ãƒ¬ã‚½ãƒ„ãƒ�ãƒŠãƒ©ãƒ ã‚¦ãƒ°ãƒŽã‚ªã‚¯ãƒ¤ãƒžã‚±ãƒ•ã‚³ã‚¨ãƒ†ã‚¢ã‚µã‚­ãƒ¦ãƒ¡ãƒŸã‚·ãƒ±ãƒ’ãƒ¢ã‚»ã‚¹', cjkSuffix);
        case _listStyle.LIST_STYLE_TYPE.LAO:
            return createCounterStyleFromRange(value, 0xed0, 0xed9, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.MONGOLIAN:
            return createCounterStyleFromRange(value, 0x1810, 0x1819, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.MYANMAR:
            return createCounterStyleFromRange(value, 0x1040, 0x1049, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.ORIYA:
            return createCounterStyleFromRange(value, 0xb66, 0xb6f, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.PERSIAN:
            return createCounterStyleFromRange(value, 0x6f0, 0x6f9, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.TAMIL:
            return createCounterStyleFromRange(value, 0xbe6, 0xbef, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.TELUGU:
            return createCounterStyleFromRange(value, 0xc66, 0xc6f, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.THAI:
            return createCounterStyleFromRange(value, 0xe50, 0xe59, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.TIBETAN:
            return createCounterStyleFromRange(value, 0xf20, 0xf29, true, defaultSuffix);
        case _listStyle.LIST_STYLE_TYPE.DECIMAL:
        default:
            return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
    }
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Path = __webpack_require__(6);

var _textDecoration = __webpack_require__(11);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var addColorStops = function addColorStops(gradient, canvasGradient) {
    var maxStop = Math.max.apply(null, gradient.colorStops.map(function (colorStop) {
        return colorStop.stop;
    }));
    var f = 1 / Math.max(1, maxStop);
    gradient.colorStops.forEach(function (colorStop) {
        canvasGradient.addColorStop(f * colorStop.stop, colorStop.color.toString());
    });
};

var CanvasRenderer = function () {
    function CanvasRenderer(canvas) {
        _classCallCheck(this, CanvasRenderer);

        this.canvas = canvas ? canvas : document.createElement('canvas');
    }

    _createClass(CanvasRenderer, [{
        key: 'render',
        value: function render(options) {
            this.ctx = this.canvas.getContext('2d');
            this.options = options;
            this.canvas.width = Math.floor(options.width * options.scale);
            this.canvas.height = Math.floor(options.height * options.scale);
            this.canvas.style.width = options.width + 'px';
            this.canvas.style.height = options.height + 'px';

            this.ctx.scale(this.options.scale, this.options.scale);
            this.ctx.translate(-options.x, -options.y);
            this.ctx.textBaseline = 'bottom';
            options.logger.log('Canvas renderer initialized (' + options.width + 'x' + options.height + ' at ' + options.x + ',' + options.y + ') with scale ' + this.options.scale);
        }
    }, {
        key: 'clip',
        value: function clip(clipPaths, callback) {
            var _this = this;

            if (clipPaths.length) {
                this.ctx.save();
                clipPaths.forEach(function (path) {
                    _this.path(path);
                    _this.ctx.clip();
                });
            }

            callback();

            if (clipPaths.length) {
                this.ctx.restore();
            }
        }
    }, {
        key: 'drawImage',
        value: function drawImage(image, source, destination) {
            this.ctx.drawImage(image, source.left, source.top, source.width, source.height, destination.left, destination.top, destination.width, destination.height);
        }
    }, {
        key: 'drawShape',
        value: function drawShape(path, color) {
            this.path(path);
            this.ctx.fillStyle = color.toString();
            this.ctx.fill();
        }
    }, {
        key: 'fill',
        value: function fill(color) {
            this.ctx.fillStyle = color.toString();
            this.ctx.fill();
        }
    }, {
        key: 'getTarget',
        value: function getTarget() {
            this.canvas.getContext('2d').setTransform(1, 0, 0, 1, 0, 0);
            return Promise.resolve(this.canvas);
        }
    }, {
        key: 'path',
        value: function path(_path) {
            var _this2 = this;

            this.ctx.beginPath();
            if (Array.isArray(_path)) {
                _path.forEach(function (point, index) {
                    var start = point.type === _Path.PATH.VECTOR ? point : point.start;
                    if (index === 0) {
                        _this2.ctx.moveTo(start.x, start.y);
                    } else {
                        _this2.ctx.lineTo(start.x, start.y);
                    }

                    if (point.type === _Path.PATH.BEZIER_CURVE) {
                        _this2.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
                    }
                });
            } else {
                this.ctx.arc(_path.x + _path.radius, _path.y + _path.radius, _path.radius, 0, Math.PI * 2, true);
            }

            this.ctx.closePath();
        }
    }, {
        key: 'rectangle',
        value: function rectangle(x, y, width, height, color) {
            this.ctx.fillStyle = color.toString();
            this.ctx.fillRect(x, y, width, height);
        }
    }, {
        key: 'renderLinearGradient',
        value: function renderLinearGradient(bounds, gradient) {
            var linearGradient = this.ctx.createLinearGradient(bounds.left + gradient.direction.x1, bounds.top + gradient.direction.y1, bounds.left + gradient.direction.x0, bounds.top + gradient.direction.y0);

            addColorStops(gradient, linearGradient);
            this.ctx.fillStyle = linearGradient;
            this.ctx.fillRect(bounds.left, bounds.top, bounds.width, bounds.height);
        }
    }, {
        key: 'renderRadialGradient',
        value: function renderRadialGradient(bounds, gradient) {
            var _this3 = this;

            var x = bounds.left + gradient.center.x;
            var y = bounds.top + gradient.center.y;

            var radialGradient = this.ctx.createRadialGradient(x, y, 0, x, y, gradient.radius.x);
            if (!radialGradient) {
                return;
            }

            addColorStops(gradient, radialGradient);
            this.ctx.fillStyle = radialGradient;

            if (gradient.radius.x !== gradient.radius.y) {
                // transforms for elliptical radial gradient
                var midX = bounds.left + 0.5 * bounds.width;
                var midY = bounds.top + 0.5 * bounds.height;
                var f = gradient.radius.y / gradient.radius.x;
                var invF = 1 / f;

                this.transform(midX, midY, [1, 0, 0, f, 0, 0], function () {
                    return _this3.ctx.fillRect(bounds.left, invF * (bounds.top - midY) + midY, bounds.width, bounds.height * invF);
                });
            } else {
                this.ctx.fillRect(bounds.left, bounds.top, bounds.width, bounds.height);
            }
        }
    }, {
        key: 'renderRepeat',
        value: function renderRepeat(path, image, imageSize, offsetX, offsetY) {
            this.path(path);
            this.ctx.fillStyle = this.ctx.createPattern(this.resizeImage(image, imageSize), 'repeat');
            this.ctx.translate(offsetX, offsetY);
            this.ctx.fill();
            this.ctx.translate(-offsetX, -offsetY);
        }
    }, {
        key: 'renderTextNode',
        value: function renderTextNode(textBounds, color, font, textDecoration, textShadows) {
            var _this4 = this;

            this.ctx.font = [font.fontStyle, font.fontVariant, font.fontWeight, font.fontSize, font.fontFamily].join(' ');

            textBounds.forEach(function (text) {
                _this4.ctx.fillStyle = color.toString();
                if (textShadows && text.text.trim().length) {
                    textShadows.slice(0).reverse().forEach(function (textShadow) {
                        _this4.ctx.shadowColor = textShadow.color.toString();
                        _this4.ctx.shadowOffsetX = textShadow.offsetX * _this4.options.scale;
                        _this4.ctx.shadowOffsetY = textShadow.offsetY * _this4.options.scale;
                        _this4.ctx.shadowBlur = textShadow.blur;

                        _this4.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
                    });
                } else {
                    _this4.ctx.fillText(text.text, text.bounds.left, text.bounds.top + text.bounds.height);
                }

                if (textDecoration !== null) {
                    var textDecorationColor = textDecoration.textDecorationColor || color;
                    textDecoration.textDecorationLine.forEach(function (textDecorationLine) {
                        switch (textDecorationLine) {
                            case _textDecoration.TEXT_DECORATION_LINE.UNDERLINE:
                                // Draws a line at the baseline of the font
                                // TODO As some browsers display the line as more than 1px if the font-size is big,
                                // need to take that into account both in position and size
                                var _options$fontMetrics$ = _this4.options.fontMetrics.getMetrics(font),
                                    baseline = _options$fontMetrics$.baseline;

                                _this4.rectangle(text.bounds.left, Math.round(text.bounds.top + baseline), text.bounds.width, 1, textDecorationColor);
                                break;
                            case _textDecoration.TEXT_DECORATION_LINE.OVERLINE:
                                _this4.rectangle(text.bounds.left, Math.round(text.bounds.top), text.bounds.width, 1, textDecorationColor);
                                break;
                            case _textDecoration.TEXT_DECORATION_LINE.LINE_THROUGH:
                                // TODO try and find exact position for line-through
                                var _options$fontMetrics$2 = _this4.options.fontMetrics.getMetrics(font),
                                    middle = _options$fontMetrics$2.middle;

                                _this4.rectangle(text.bounds.left, Math.ceil(text.bounds.top + middle), text.bounds.width, 1, textDecorationColor);
                                break;
                        }
                    });
                }
            });
        }
    }, {
        key: 'resizeImage',
        value: function resizeImage(image, size) {
            if (image.width === size.width && image.height === size.height) {
                return image;
            }

            var canvas = this.canvas.ownerDocument.createElement('canvas');
            canvas.width = size.width;
            canvas.height = size.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, size.width, size.height);
            return canvas;
        }
    }, {
        key: 'setOpacity',
        value: function setOpacity(opacity) {
            this.ctx.globalAlpha = opacity;
        }
    }, {
        key: 'transform',
        value: function transform(offsetX, offsetY, matrix, callback) {
            this.ctx.save();
            this.ctx.translate(offsetX, offsetY);
            this.ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);
            this.ctx.translate(-offsetX, -offsetY);

            callback();

            this.ctx.restore();
        }
    }]);

    return CanvasRenderer;
}();

exports.default = CanvasRenderer;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Logger = function () {
    function Logger(enabled, id, start) {
        _classCallCheck(this, Logger);

        this.enabled = typeof window !== 'undefined' && enabled;
        this.start = start ? start : Date.now();
        this.id = id;
    }

    _createClass(Logger, [{
        key: 'child',
        value: function child(id) {
            return new Logger(this.enabled, id, this.start);
        }

        // eslint-disable-next-line flowtype/no-weak-types

    }, {
        key: 'log',
        value: function log() {
            if (this.enabled && window.console && window.console.log) {
                for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                }

                Function.prototype.bind.call(window.console.log, window.console).apply(window.console, [Date.now() - this.start + 'ms', this.id ? 'html2canvas (' + this.id + '):' : 'html2canvas:'].concat([].slice.call(args, 0)));
            }
        }

        // eslint-disable-next-line flowtype/no-weak-types

    }, {
        key: 'error',
        value: function error() {
            if (this.enabled && window.console && window.console.error) {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                    args[_key2] = arguments[_key2];
                }

                Function.prototype.bind.call(window.console.error, window.console).apply(window.console, [Date.now() - this.start + 'ms', this.id ? 'html2canvas (' + this.id + '):' : 'html2canvas:'].concat([].slice.call(args, 0)));
            }
        }
    }]);

    return Logger;
}();

exports.default = Logger;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parsePadding = exports.PADDING_SIDES = undefined;

var _Length = __webpack_require__(1);

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PADDING_SIDES = exports.PADDING_SIDES = {
    TOP: 0,
    RIGHT: 1,
    BOTTOM: 2,
    LEFT: 3
};

var SIDES = ['top', 'right', 'bottom', 'left'];

var parsePadding = exports.parsePadding = function parsePadding(style) {
    return SIDES.map(function (side) {
        return new _Length2.default(style.getPropertyValue('padding-' + side));
    });
};

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var OVERFLOW_WRAP = exports.OVERFLOW_WRAP = {
    NORMAL: 0,
    BREAK_WORD: 1
};

var parseOverflowWrap = exports.parseOverflowWrap = function parseOverflowWrap(overflow) {
    switch (overflow) {
        case 'break-word':
            return OVERFLOW_WRAP.BREAK_WORD;
        case 'normal':
        default:
            return OVERFLOW_WRAP.NORMAL;
    }
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var POSITION = exports.POSITION = {
    STATIC: 0,
    RELATIVE: 1,
    ABSOLUTE: 2,
    FIXED: 3,
    STICKY: 4
};

var parsePosition = exports.parsePosition = function parsePosition(position) {
    switch (position) {
        case 'relative':
            return POSITION.RELATIVE;
        case 'absolute':
            return POSITION.ABSOLUTE;
        case 'fixed':
            return POSITION.FIXED;
        case 'sticky':
            return POSITION.STICKY;
    }

    return POSITION.STATIC;
};

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var TEXT_TRANSFORM = exports.TEXT_TRANSFORM = {
    NONE: 0,
    LOWERCASE: 1,
    UPPERCASE: 2,
    CAPITALIZE: 3
};

var parseTextTransform = exports.parseTextTransform = function parseTextTransform(textTransform) {
    switch (textTransform) {
        case 'uppercase':
            return TEXT_TRANSFORM.UPPERCASE;
        case 'lowercase':
            return TEXT_TRANSFORM.LOWERCASE;
        case 'capitalize':
            return TEXT_TRANSFORM.CAPITALIZE;
    }

    return TEXT_TRANSFORM.NONE;
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.reformatInputBounds = exports.inlineSelectElement = exports.inlineTextAreaElement = exports.inlineInputElement = exports.getInputBorderRadius = exports.INPUT_BACKGROUND = exports.INPUT_BORDERS = exports.INPUT_COLOR = undefined;

var _TextContainer = __webpack_require__(9);

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _background = __webpack_require__(5);

var _border = __webpack_require__(12);

var _Circle = __webpack_require__(50);

var _Circle2 = _interopRequireDefault(_Circle);

var _Vector = __webpack_require__(7);

var _Vector2 = _interopRequireDefault(_Vector);

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

var _Length = __webpack_require__(1);

var _Length2 = _interopRequireDefault(_Length);

var _Bounds = __webpack_require__(2);

var _TextBounds = __webpack_require__(22);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var INPUT_COLOR = exports.INPUT_COLOR = new _Color2.default([42, 42, 42]);
var INPUT_BORDER_COLOR = new _Color2.default([165, 165, 165]);
var INPUT_BACKGROUND_COLOR = new _Color2.default([222, 222, 222]);
var INPUT_BORDER = {
    borderWidth: 1,
    borderColor: INPUT_BORDER_COLOR,
    borderStyle: _border.BORDER_STYLE.SOLID
};
var INPUT_BORDERS = exports.INPUT_BORDERS = [INPUT_BORDER, INPUT_BORDER, INPUT_BORDER, INPUT_BORDER];
var INPUT_BACKGROUND = exports.INPUT_BACKGROUND = {
    backgroundColor: INPUT_BACKGROUND_COLOR,
    backgroundImage: [],
    backgroundClip: _background.BACKGROUND_CLIP.PADDING_BOX,
    backgroundOrigin: _background.BACKGROUND_ORIGIN.PADDING_BOX
};

var RADIO_BORDER_RADIUS = new _Length2.default('50%');
var RADIO_BORDER_RADIUS_TUPLE = [RADIO_BORDER_RADIUS, RADIO_BORDER_RADIUS];
var INPUT_RADIO_BORDER_RADIUS = [RADIO_BORDER_RADIUS_TUPLE, RADIO_BORDER_RADIUS_TUPLE, RADIO_BORDER_RADIUS_TUPLE, RADIO_BORDER_RADIUS_TUPLE];

var CHECKBOX_BORDER_RADIUS = new _Length2.default('3px');
var CHECKBOX_BORDER_RADIUS_TUPLE = [CHECKBOX_BORDER_RADIUS, CHECKBOX_BORDER_RADIUS];
var INPUT_CHECKBOX_BORDER_RADIUS = [CHECKBOX_BORDER_RADIUS_TUPLE, CHECKBOX_BORDER_RADIUS_TUPLE, CHECKBOX_BORDER_RADIUS_TUPLE, CHECKBOX_BORDER_RADIUS_TUPLE];

var getInputBorderRadius = exports.getInputBorderRadius = function getInputBorderRadius(node) {
    return node.type === 'radio' ? INPUT_RADIO_BORDER_RADIUS : INPUT_CHECKBOX_BORDER_RADIUS;
};

var inlineInputElement = exports.inlineInputElement = function inlineInputElement(node, container) {
    if (node.type === 'radio' || node.type === 'checkbox') {
        if (node.checked) {
            var size = Math.min(container.bounds.width, container.bounds.height);
            container.childNodes.push(node.type === 'checkbox' ? [new _Vector2.default(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79), new _Vector2.default(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549), new _Vector2.default(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071), new _Vector2.default(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649), new _Vector2.default(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23), new _Vector2.default(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085), new _Vector2.default(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)] : new _Circle2.default(container.bounds.left + size / 4, container.bounds.top + size / 4, size / 4));
        }
    } else {
        inlineFormElement(getInputValue(node), node, container, false);
    }
};

var inlineTextAreaElement = exports.inlineTextAreaElement = function inlineTextAreaElement(node, container) {
    inlineFormElement(node.value, node, container, true);
};

var inlineSelectElement = exports.inlineSelectElement = function inlineSelectElement(node, container) {
    var option = node.options[node.selectedIndex || 0];
    inlineFormElement(option ? option.text || '' : '', node, container, false);
};

var reformatInputBounds = exports.reformatInputBounds = function reformatInputBounds(bounds) {
    if (bounds.width > bounds.height) {
        bounds.left += (bounds.width - bounds.height) / 2;
        bounds.width = bounds.height;
    } else if (bounds.width < bounds.height) {
        bounds.top += (bounds.height - bounds.width) / 2;
        bounds.height = bounds.width;
    }
    return bounds;
};

var inlineFormElement = function inlineFormElement(value, node, container, allowLinebreak) {
    var body = node.ownerDocument.body;
    if (value.length > 0 && body) {
        var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
        (0, _Util.copyCSSStyles)(node.ownerDocument.defaultView.getComputedStyle(node, null), wrapper);
        wrapper.style.position = 'absolute';
        wrapper.style.left = container.bounds.left + 'px';
        wrapper.style.top = container.bounds.top + 'px';
        if (!allowLinebreak) {
            wrapper.style.whiteSpace = 'nowrap';
        }
        var text = node.ownerDocument.createTextNode(value);
        wrapper.appendChild(text);
        body.appendChild(wrapper);
        container.childNodes.push(_TextContainer2.default.fromTextNode(text, container));
        body.removeChild(wrapper);
    }
};

var getInputValue = function getInputValue(node) {
    var value = node.type === 'password' ? new Array(node.value.length + 1).join('\u2022') : node.value;

    return value.length === 0 ? node.placeholder || '' : value;
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseTextBounds = exports.TextBounds = undefined;

var _Bounds = __webpack_require__(2);

var _textDecoration = __webpack_require__(11);

var _Feature = __webpack_require__(10);

var _Feature2 = _interopRequireDefault(_Feature);

var _Unicode = __webpack_require__(24);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TextBounds = exports.TextBounds = function TextBounds(text, bounds) {
    _classCallCheck(this, TextBounds);

    this.text = text;
    this.bounds = bounds;
};

var parseTextBounds = exports.parseTextBounds = function parseTextBounds(value, parent, node) {
    var letterRendering = parent.style.letterSpacing !== 0;
    var textList = letterRendering ? (0, _Unicode.toCodePoints)(value).map(function (i) {
        return (0, _Unicode.fromCodePoint)(i);
    }) : (0, _Unicode.breakWords)(value, parent);
    var length = textList.length;
    var defaultView = node.parentNode ? node.parentNode.ownerDocument.defaultView : null;
    var scrollX = defaultView ? defaultView.pageXOffset : 0;
    var scrollY = defaultView ? defaultView.pageYOffset : 0;
    var textBounds = [];
    var offset = 0;
    for (var i = 0; i < length; i++) {
        var text = textList[i];
        if (parent.style.textDecoration !== _textDecoration.TEXT_DECORATION.NONE || text.trim().length > 0) {
            if (_Feature2.default.SUPPORT_RANGE_BOUNDS) {
                textBounds.push(new TextBounds(text, getRangeBounds(node, offset, text.length, scrollX, scrollY)));
            } else {
                var replacementNode = node.splitText(text.length);
                textBounds.push(new TextBounds(text, getWrapperBounds(node, scrollX, scrollY)));
                node = replacementNode;
            }
        } else if (!_Feature2.default.SUPPORT_RANGE_BOUNDS) {
            node = node.splitText(text.length);
        }
        offset += text.length;
    }
    return textBounds;
};

var getWrapperBounds = function getWrapperBounds(node, scrollX, scrollY) {
    var wrapper = node.ownerDocument.createElement('html2canvaswrapper');
    wrapper.appendChild(node.cloneNode(true));
    var parentNode = node.parentNode;
    if (parentNode) {
        parentNode.replaceChild(wrapper, node);
        var bounds = (0, _Bounds.parseBounds)(wrapper, scrollX, scrollY);
        if (wrapper.firstChild) {
            parentNode.replaceChild(wrapper.firstChild, wrapper);
        }
        return bounds;
    }
    return new _Bounds.Bounds(0, 0, 0, 0);
};

var getRangeBounds = function getRangeBounds(node, offset, length, scrollX, scrollY) {
    var range = node.ownerDocument.createRange();
    range.setStart(node, offset);
    range.setEnd(node, offset + length);
    return _Bounds.Bounds.fromClientRect(range.getBoundingClientRect(), scrollX, scrollY);
};

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ForeignObjectRenderer = function () {
    function ForeignObjectRenderer(element) {
        _classCallCheck(this, ForeignObjectRenderer);

        this.element = element;
    }

    _createClass(ForeignObjectRenderer, [{
        key: 'render',
        value: function render(options) {
            var _this = this;

            this.options = options;
            this.canvas = document.createElement('canvas');
            this.ctx = this.canvas.getContext('2d');
            this.canvas.width = Math.floor(options.width) * options.scale;
            this.canvas.height = Math.floor(options.height) * options.scale;
            this.canvas.style.width = options.width + 'px';
            this.canvas.style.height = options.height + 'px';

            options.logger.log('ForeignObject renderer initialized (' + options.width + 'x' + options.height + ' at ' + options.x + ',' + options.y + ') with scale ' + options.scale);
            var svg = createForeignObjectSVG(Math.max(options.windowWidth, options.width) * options.scale, Math.max(options.windowHeight, options.height) * options.scale, options.scrollX * options.scale, options.scrollY * options.scale, this.element);

            return loadSerializedSVG(svg).then(function (img) {
                if (options.backgroundColor) {
                    _this.ctx.fillStyle = options.backgroundColor.toString();
                    _this.ctx.fillRect(0, 0, options.width * options.scale, options.height * options.scale);
                }

                _this.ctx.drawImage(img, -options.x * options.scale, -options.y * options.scale);
                return _this.canvas;
            });
        }
    }]);

    return ForeignObjectRenderer;
}();

exports.default = ForeignObjectRenderer;
var createForeignObjectSVG = exports.createForeignObjectSVG = function createForeignObjectSVG(width, height, x, y, node) {
    var xmlns = 'http://www.w3.org/2000/svg';
    var svg = document.createElementNS(xmlns, 'svg');
    var foreignObject = document.createElementNS(xmlns, 'foreignObject');
    svg.setAttributeNS(null, 'width', width);
    svg.setAttributeNS(null, 'height', height);

    foreignObject.setAttributeNS(null, 'width', '100%');
    foreignObject.setAttributeNS(null, 'height', '100%');
    foreignObject.setAttributeNS(null, 'x', x);
    foreignObject.setAttributeNS(null, 'y', y);
    foreignObject.setAttributeNS(null, 'externalResourcesRequired', 'true');
    svg.appendChild(foreignObject);

    foreignObject.appendChild(node);

    return svg;
};

var loadSerializedSVG = exports.loadSerializedSVG = function loadSerializedSVG(svg) {
    return new Promise(function (resolve, reject) {
        var img = new Image();
        img.onload = function () {
            return resolve(img);
        };
        img.onerror = reject;

        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(new XMLSerializer().serializeToString(svg));
    });
};

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.breakWords = exports.fromCodePoint = exports.toCodePoints = undefined;

var _cssLineBreak = __webpack_require__(46);

Object.defineProperty(exports, 'toCodePoints', {
    enumerable: true,
    get: function get() {
        return _cssLineBreak.toCodePoints;
    }
});
Object.defineProperty(exports, 'fromCodePoint', {
    enumerable: true,
    get: function get() {
        return _cssLineBreak.fromCodePoint;
    }
});

var _NodeContainer = __webpack_require__(3);

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _overflowWrap = __webpack_require__(18);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var breakWords = exports.breakWords = function breakWords(str, parent) {
    var breaker = (0, _cssLineBreak.LineBreaker)(str, {
        lineBreak: parent.style.lineBreak,
        wordBreak: parent.style.overflowWrap === _overflowWrap.OVERFLOW_WRAP.BREAK_WORD ? 'break-word' : parent.style.wordBreak
    });

    var words = [];
    var bk = void 0;

    while (!(bk = breaker.next()).done) {
        words.push(bk.value.slice());
    }

    return words;
};

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.FontMetrics = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = __webpack_require__(4);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SAMPLE_TEXT = 'Hidden Text';

var FontMetrics = exports.FontMetrics = function () {
    function FontMetrics(document) {
        _classCallCheck(this, FontMetrics);

        this._data = {};
        this._document = document;
    }

    _createClass(FontMetrics, [{
        key: '_parseMetrics',
        value: function _parseMetrics(font) {
            var container = this._document.createElement('div');
            var img = this._document.createElement('img');
            var span = this._document.createElement('span');

            var body = this._document.body;
            if (!body) {
                throw new Error( true ? 'No document found for font metrics' : '');
            }

            container.style.visibility = 'hidden';
            container.style.fontFamily = font.fontFamily;
            container.style.fontSize = font.fontSize;
            container.style.margin = '0';
            container.style.padding = '0';

            body.appendChild(container);

            img.src = _Util.SMALL_IMAGE;
            img.width = 1;
            img.height = 1;

            img.style.margin = '0';
            img.style.padding = '0';
            img.style.verticalAlign = 'baseline';

            span.style.fontFamily = font.fontFamily;
            span.style.fontSize = font.fontSize;
            span.style.margin = '0';
            span.style.padding = '0';

            span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
            container.appendChild(span);
            container.appendChild(img);
            var baseline = img.offsetTop - span.offsetTop + 2;

            container.removeChild(span);
            container.appendChild(this._document.createTextNode(SAMPLE_TEXT));

            container.style.lineHeight = 'normal';
            img.style.verticalAlign = 'super';

            var middle = img.offsetTop - container.offsetTop + 2;

            body.removeChild(container);

            return { baseline: baseline, middle: middle };
        }
    }, {
        key: 'getMetrics',
        value: function getMetrics(font) {
            var key = font.fontFamily + ' ' + font.fontSize;
            if (this._data[key] === undefined) {
                this._data[key] = this._parseMetrics(font);
            }

            return this._data[key];
        }
    }]);

    return FontMetrics;
}();

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Proxy = undefined;

var _Feature = __webpack_require__(10);

var _Feature2 = _interopRequireDefault(_Feature);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Proxy = exports.Proxy = function Proxy(src, options) {
    if (!options.proxy) {
        return Promise.reject( true ? 'No proxy defined' : null);
    }
    var proxy = options.proxy;

    return new Promise(function (resolve, reject) {
        var responseType = _Feature2.default.SUPPORT_CORS_XHR && _Feature2.default.SUPPORT_RESPONSE_TYPE ? 'blob' : 'text';
        var xhr = _Feature2.default.SUPPORT_CORS_XHR ? new XMLHttpRequest() : new XDomainRequest();
        xhr.onload = function () {
            if (xhr instanceof XMLHttpRequest) {
                if (xhr.status === 200) {
                    if (responseType === 'text') {
                        resolve(xhr.response);
                    } else {
                        var reader = new FileReader();
                        // $FlowFixMe
                        reader.addEventListener('load', function () {
                            return resolve(reader.result);
                        }, false);
                        // $FlowFixMe
                        reader.addEventListener('error', function (e) {
                            return reject(e);
                        }, false);
                        reader.readAsDataURL(xhr.response);
                    }
                } else {
                    reject( true ? 'Failed to proxy resource ' + src.substring(0, 256) + ' with status code ' + xhr.status : '');
                }
            } else {
                resolve(xhr.responseText);
            }
        };

        xhr.onerror = reject;
        xhr.open('GET', proxy + '?url=' + encodeURIComponent(src) + '&responseType=' + responseType);

        if (responseType !== 'text' && xhr instanceof XMLHttpRequest) {
            xhr.responseType = responseType;
        }

        if (options.imageTimeout) {
            var timeout = options.imageTimeout;
            xhr.timeout = timeout;
            xhr.ontimeout = function () {
                return reject( true ? 'Timed out (' + timeout + 'ms) proxying ' + src.substring(0, 256) : '');
            };
        }

        xhr.send();
    });
};

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _CanvasRenderer = __webpack_require__(15);

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _Logger = __webpack_require__(16);

var _Logger2 = _interopRequireDefault(_Logger);

var _Window = __webpack_require__(28);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var html2canvas = function html2canvas(element, conf) {
    var config = conf || {};
    var logger = new _Logger2.default(typeof config.logging === 'boolean' ? config.logging : true);
    logger.log('html2canvas ' + "1.0.0-alpha.11");

    if (true && typeof config.onrendered === 'function') {
        logger.error('onrendered option is deprecated, html2canvas returns a Promise with the canvas as the value');
    }

    var ownerDocument = element.ownerDocument;
    if (!ownerDocument) {
        return Promise.reject('Provided element is not within a Document');
    }
    var defaultView = ownerDocument.defaultView;

    var defaultOptions = {
        async: true,
        allowTaint: false,
        backgroundColor: '#ffffff',
        imageTimeout: 15000,
        logging: true,
        proxy: null,
        removeContainer: true,
        foreignObjectRendering: false,
        scale: defaultView.devicePixelRatio || 1,
        target: new _CanvasRenderer2.default(config.canvas),
        useCORS: false,
        windowWidth: defaultView.innerWidth,
        windowHeight: defaultView.innerHeight,
        scrollX: defaultView.pageXOffset,
        scrollY: defaultView.pageYOffset
    };

    var result = (0, _Window.renderElement)(element, _extends({}, defaultOptions, config), logger);

    if (true) {
        return result.catch(function (e) {
            logger.error(e);
            throw e;
        });
    }
    return result;
};

html2canvas.CanvasRenderer = _CanvasRenderer2.default;

module.exports = html2canvas;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.renderElement = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _Logger = __webpack_require__(16);

var _Logger2 = _interopRequireDefault(_Logger);

var _NodeParser = __webpack_require__(29);

var _Renderer = __webpack_require__(51);

var _Renderer2 = _interopRequireDefault(_Renderer);

var _ForeignObjectRenderer = __webpack_require__(23);

var _ForeignObjectRenderer2 = _interopRequireDefault(_ForeignObjectRenderer);

var _Feature = __webpack_require__(10);

var _Feature2 = _interopRequireDefault(_Feature);

var _Bounds = __webpack_require__(2);

var _Clone = __webpack_require__(54);

var _Font = __webpack_require__(25);

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var renderElement = exports.renderElement = function renderElement(element, options, logger) {
    var ownerDocument = element.ownerDocument;

    var windowBounds = new _Bounds.Bounds(options.scrollX, options.scrollY, options.windowWidth, options.windowHeight);

    // http://www.w3.org/TR/css3-background/#special-backgrounds
    var documentBackgroundColor = ownerDocument.documentElement ? new _Color2.default(getComputedStyle(ownerDocument.documentElement).backgroundColor) : _Color.TRANSPARENT;
    var bodyBackgroundColor = ownerDocument.body ? new _Color2.default(getComputedStyle(ownerDocument.body).backgroundColor) : _Color.TRANSPARENT;

    var backgroundColor = element === ownerDocument.documentElement ? documentBackgroundColor.isTransparent() ? bodyBackgroundColor.isTransparent() ? options.backgroundColor ? new _Color2.default(options.backgroundColor) : null : bodyBackgroundColor : documentBackgroundColor : options.backgroundColor ? new _Color2.default(options.backgroundColor) : null;

    return (options.foreignObjectRendering ? // $FlowFixMe
    _Feature2.default.SUPPORT_FOREIGNOBJECT_DRAWING : Promise.resolve(false)).then(function (supportForeignObject) {
        return supportForeignObject ? function (cloner) {
            if (true) {
                logger.log('Document cloned, using foreignObject rendering');
            }

            return cloner.inlineFonts(ownerDocument).then(function () {
                return cloner.resourceLoader.ready();
            }).then(function () {
                var renderer = new _ForeignObjectRenderer2.default(cloner.documentElement);

                var defaultView = ownerDocument.defaultView;
                var scrollX = defaultView.pageXOffset;
                var scrollY = defaultView.pageYOffset;

                var isDocument = element.tagName === 'HTML' || element.tagName === 'BODY';

                var _ref = isDocument ? (0, _Bounds.parseDocumentSize)(ownerDocument) : (0, _Bounds.parseBounds)(element, scrollX, scrollY),
                    width = _ref.width,
                    height = _ref.height,
                    left = _ref.left,
                    top = _ref.top;

                return renderer.render({
                    backgroundColor: backgroundColor,
                    logger: logger,
                    scale: options.scale,
                    x: typeof options.x === 'number' ? options.x : left,
                    y: typeof options.y === 'number' ? options.y : top,
                    width: typeof options.width === 'number' ? options.width : Math.ceil(width),
                    height: typeof options.height === 'number' ? options.height : Math.ceil(height),
                    windowWidth: options.windowWidth,
                    windowHeight: options.windowHeight,
                    scrollX: options.scrollX,
                    scrollY: options.scrollY
                });
            });
        }(new _Clone.DocumentCloner(element, options, logger, true, renderElement)) : (0, _Clone.cloneWindow)(ownerDocument, windowBounds, element, options, logger, renderElement).then(function (_ref2) {
            var _ref3 = _slicedToArray(_ref2, 3),
                container = _ref3[0],
                clonedElement = _ref3[1],
                resourceLoader = _ref3[2];

            if (true) {
                logger.log('Document cloned, using computed rendering');
            }

            var stack = (0, _NodeParser.NodeParser)(clonedElement, resourceLoader, logger);
            var clonedDocument = clonedElement.ownerDocument;

            if (backgroundColor === stack.container.style.background.backgroundColor) {
                stack.container.style.background.backgroundColor = _Color.TRANSPARENT;
            }

            return resourceLoader.ready().then(function (imageStore) {
                var fontMetrics = new _Font.FontMetrics(clonedDocument);
                if (true) {
                    logger.log('Starting renderer');
                }

                var defaultView = clonedDocument.defaultView;
                var scrollX = defaultView.pageXOffset;
                var scrollY = defaultView.pageYOffset;

                var isDocument = clonedElement.tagName === 'HTML' || clonedElement.tagName === 'BODY';

                var _ref4 = isDocument ? (0, _Bounds.parseDocumentSize)(ownerDocument) : (0, _Bounds.parseBounds)(clonedElement, scrollX, scrollY),
                    width = _ref4.width,
                    height = _ref4.height,
                    left = _ref4.left,
                    top = _ref4.top;

                var renderOptions = {
                    backgroundColor: backgroundColor,
                    fontMetrics: fontMetrics,
                    imageStore: imageStore,
                    logger: logger,
                    scale: options.scale,
                    x: typeof options.x === 'number' ? options.x : left,
                    y: typeof options.y === 'number' ? options.y : top,
                    width: typeof options.width === 'number' ? options.width : Math.ceil(width),
                    height: typeof options.height === 'number' ? options.height : Math.ceil(height)
                };

                if (Array.isArray(options.target)) {
                    return Promise.all(options.target.map(function (target) {
                        var renderer = new _Renderer2.default(target, renderOptions);
                        return renderer.render(stack);
                    }));
                } else {
                    var renderer = new _Renderer2.default(options.target, renderOptions);
                    var canvas = renderer.render(stack);
                    if (options.removeContainer === true) {
                        if (container.parentNode) {
                            container.parentNode.removeChild(container);
                        } else if (true) {
                            logger.log('Cannot detach cloned iframe as it is not in the DOM anymore');
                        }
                    }

                    return canvas;
                }
            });
        });
    });
};

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NodeParser = undefined;

var _StackingContext = __webpack_require__(30);

var _StackingContext2 = _interopRequireDefault(_StackingContext);

var _NodeContainer = __webpack_require__(3);

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _TextContainer = __webpack_require__(9);

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _Input = __webpack_require__(21);

var _ListItem = __webpack_require__(14);

var _listStyle = __webpack_require__(8);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NodeParser = exports.NodeParser = function NodeParser(node, resourceLoader, logger) {
    if (true) {
        logger.log('Starting node parsing');
    }

    var index = 0;

    var container = new _NodeContainer2.default(node, null, resourceLoader, index++);
    var stack = new _StackingContext2.default(container, null, true);

    parseNodeTree(node, container, stack, resourceLoader, index);

    if (true) {
        logger.log('Finished parsing node tree');
    }

    return stack;
};

var IGNORED_NODE_NAMES = ['SCRIPT', 'HEAD', 'TITLE', 'OBJECT', 'BR', 'OPTION'];

var parseNodeTree = function parseNodeTree(node, parent, stack, resourceLoader, index) {
    if (true && index > 50000) {
        throw new Error('Recursion error while parsing node tree');
    }

    for (var childNode = node.firstChild, nextNode; childNode; childNode = nextNode) {
        nextNode = childNode.nextSibling;
        var defaultView = childNode.ownerDocument.defaultView;
        if (childNode instanceof defaultView.Text || childNode instanceof Text || defaultView.parent && childNode instanceof defaultView.parent.Text) {
            if (childNode.data.trim().length > 0) {
                parent.childNodes.push(_TextContainer2.default.fromTextNode(childNode, parent));
            }
        } else if (childNode instanceof defaultView.HTMLElement || childNode instanceof HTMLElement || defaultView.parent && childNode instanceof defaultView.parent.HTMLElement) {
            if (IGNORED_NODE_NAMES.indexOf(childNode.nodeName) === -1) {
                var container = new _NodeContainer2.default(childNode, parent, resourceLoader, index++);
                if (container.isVisible()) {
                    if (childNode.tagName === 'INPUT') {
                        // $FlowFixMe
                        (0, _Input.inlineInputElement)(childNode, container);
                    } else if (childNode.tagName === 'TEXTAREA') {
                        // $FlowFixMe
                        (0, _Input.inlineTextAreaElement)(childNode, container);
                    } else if (childNode.tagName === 'SELECT') {
                        // $FlowFixMe
                        (0, _Input.inlineSelectElement)(childNode, container);
                    } else if (container.style.listStyle && container.style.listStyle.listStyleType !== _listStyle.LIST_STYLE_TYPE.NONE) {
                        (0, _ListItem.inlineListItemElement)(childNode, container, resourceLoader);
                    }

                    var SHOULD_TRAVERSE_CHILDREN = childNode.tagName !== 'TEXTAREA';
                    var treatAsRealStackingContext = createsRealStackingContext(container, childNode);
                    if (treatAsRealStackingContext || createsStackingContext(container)) {
                        // for treatAsRealStackingContext:false, any positioned descendants and descendants
                        // which actually create a new stacking context should be considered part of the parent stacking context
                        var parentStack = treatAsRealStackingContext || container.isPositioned() ? stack.getRealParentStackingContext() : stack;
                        var childStack = new _StackingContext2.default(container, parentStack, treatAsRealStackingContext);
                        parentStack.contexts.push(childStack);
                        if (SHOULD_TRAVERSE_CHILDREN) {
                            parseNodeTree(childNode, container, childStack, resourceLoader, index);
                        }
                    } else {
                        stack.children.push(container);
                        if (SHOULD_TRAVERSE_CHILDREN) {
                            parseNodeTree(childNode, container, stack, resourceLoader, index);
                        }
                    }
                }
            }
        } else if (childNode instanceof defaultView.SVGSVGElement || childNode instanceof SVGSVGElement || defaultView.parent && childNode instanceof defaultView.parent.SVGSVGElement) {
            var _container = new _NodeContainer2.default(childNode, parent, resourceLoader, index++);
            var _treatAsRealStackingContext = createsRealStackingContext(_container, childNode);
            if (_treatAsRealStackingContext || createsStackingContext(_container)) {
                // for treatAsRealStackingContext:false, any positioned descendants and descendants
                // which actually create a new stacking context should be considered part of the parent stacking context
                var _parentStack = _treatAsRealStackingContext || _container.isPositioned() ? stack.getRealParentStackingContext() : stack;
                var _childStack = new _StackingContext2.default(_container, _parentStack, _treatAsRealStackingContext);
                _parentStack.contexts.push(_childStack);
            } else {
                stack.children.push(_container);
            }
        }
    }
};

var createsRealStackingContext = function createsRealStackingContext(container, node) {
    return container.isRootElement() || container.isPositionedWithZIndex() || container.style.opacity < 1 || container.isTransformed() || isBodyWithTransparentRoot(container, node);
};

var createsStackingContext = function createsStackingContext(container) {
    return container.isPositioned() || container.isFloating();
};

var isBodyWithTransparentRoot = function isBodyWithTransparentRoot(container, node) {
    return node.nodeName === 'BODY' && container.parent instanceof _NodeContainer2.default && container.parent.style.background.backgroundColor.isTransparent();
};

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _NodeContainer = __webpack_require__(3);

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _position = __webpack_require__(19);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StackingContext = function () {
    function StackingContext(container, parent, treatAsRealStackingContext) {
        _classCallCheck(this, StackingContext);

        this.container = container;
        this.parent = parent;
        this.contexts = [];
        this.children = [];
        this.treatAsRealStackingContext = treatAsRealStackingContext;
    }

    _createClass(StackingContext, [{
        key: 'getOpacity',
        value: function getOpacity() {
            return this.parent ? this.container.style.opacity * this.parent.getOpacity() : this.container.style.opacity;
        }
    }, {
        key: 'getRealParentStackingContext',
        value: function getRealParentStackingContext() {
            return !this.parent || this.treatAsRealStackingContext ? this : this.parent.getRealParentStackingContext();
        }
    }]);

    return StackingContext;
}();

exports.default = StackingContext;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Size = function Size(width, height) {
    _classCallCheck(this, Size);

    this.width = width;
    this.height = height;
};

exports.default = Size;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Path = __webpack_require__(6);

var _Vector = __webpack_require__(7);

var _Vector2 = _interopRequireDefault(_Vector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var lerp = function lerp(a, b, t) {
    return new _Vector2.default(a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t);
};

var BezierCurve = function () {
    function BezierCurve(start, startControl, endControl, end) {
        _classCallCheck(this, BezierCurve);

        this.type = _Path.PATH.BEZIER_CURVE;
        this.start = start;
        this.startControl = startControl;
        this.endControl = endControl;
        this.end = end;
    }

    _createClass(BezierCurve, [{
        key: 'subdivide',
        value: function subdivide(t, firstHalf) {
            var ab = lerp(this.start, this.startControl, t);
            var bc = lerp(this.startControl, this.endControl, t);
            var cd = lerp(this.endControl, this.end, t);
            var abbc = lerp(ab, bc, t);
            var bccd = lerp(bc, cd, t);
            var dest = lerp(abbc, bccd, t);
            return firstHalf ? new BezierCurve(this.start, ab, abbc, dest) : new BezierCurve(dest, bccd, cd, this.end);
        }
    }, {
        key: 'reverse',
        value: function reverse() {
            return new BezierCurve(this.end, this.endControl, this.startControl, this.start);
        }
    }]);

    return BezierCurve;
}();

exports.default = BezierCurve;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseBorderRadius = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _Length = __webpack_require__(1);

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SIDES = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];

var parseBorderRadius = exports.parseBorderRadius = function parseBorderRadius(style) {
    return SIDES.map(function (side) {
        var value = style.getPropertyValue('border-' + side + '-radius');

        var _value$split$map = value.split(' ').map(_Length2.default.create),
            _value$split$map2 = _slicedToArray(_value$split$map, 2),
            horizontal = _value$split$map2[0],
            vertical = _value$split$map2[1];

        return typeof vertical === 'undefined' ? [horizontal, horizontal] : [horizontal, vertical];
    });
};

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var DISPLAY = exports.DISPLAY = {
    NONE: 1 << 0,
    BLOCK: 1 << 1,
    INLINE: 1 << 2,
    RUN_IN: 1 << 3,
    FLOW: 1 << 4,
    FLOW_ROOT: 1 << 5,
    TABLE: 1 << 6,
    FLEX: 1 << 7,
    GRID: 1 << 8,
    RUBY: 1 << 9,
    SUBGRID: 1 << 10,
    LIST_ITEM: 1 << 11,
    TABLE_ROW_GROUP: 1 << 12,
    TABLE_HEADER_GROUP: 1 << 13,
    TABLE_FOOTER_GROUP: 1 << 14,
    TABLE_ROW: 1 << 15,
    TABLE_CELL: 1 << 16,
    TABLE_COLUMN_GROUP: 1 << 17,
    TABLE_COLUMN: 1 << 18,
    TABLE_CAPTION: 1 << 19,
    RUBY_BASE: 1 << 20,
    RUBY_TEXT: 1 << 21,
    RUBY_BASE_CONTAINER: 1 << 22,
    RUBY_TEXT_CONTAINER: 1 << 23,
    CONTENTS: 1 << 24,
    INLINE_BLOCK: 1 << 25,
    INLINE_LIST_ITEM: 1 << 26,
    INLINE_TABLE: 1 << 27,
    INLINE_FLEX: 1 << 28,
    INLINE_GRID: 1 << 29
};

var parseDisplayValue = function parseDisplayValue(display) {
    switch (display) {
        case 'block':
            return DISPLAY.BLOCK;
        case 'inline':
            return DISPLAY.INLINE;
        case 'run-in':
            return DISPLAY.RUN_IN;
        case 'flow':
            return DISPLAY.FLOW;
        case 'flow-root':
            return DISPLAY.FLOW_ROOT;
        case 'table':
            return DISPLAY.TABLE;
        case 'flex':
            return DISPLAY.FLEX;
        case 'grid':
            return DISPLAY.GRID;
        case 'ruby':
            return DISPLAY.RUBY;
        case 'subgrid':
            return DISPLAY.SUBGRID;
        case 'list-item':
            return DISPLAY.LIST_ITEM;
        case 'table-row-group':
            return DISPLAY.TABLE_ROW_GROUP;
        case 'table-header-group':
            return DISPLAY.TABLE_HEADER_GROUP;
        case 'table-footer-group':
            return DISPLAY.TABLE_FOOTER_GROUP;
        case 'table-row':
            return DISPLAY.TABLE_ROW;
        case 'table-cell':
            return DISPLAY.TABLE_CELL;
        case 'table-column-group':
            return DISPLAY.TABLE_COLUMN_GROUP;
        case 'table-column':
            return DISPLAY.TABLE_COLUMN;
        case 'table-caption':
            return DISPLAY.TABLE_CAPTION;
        case 'ruby-base':
            return DISPLAY.RUBY_BASE;
        case 'ruby-text':
            return DISPLAY.RUBY_TEXT;
        case 'ruby-base-container':
            return DISPLAY.RUBY_BASE_CONTAINER;
        case 'ruby-text-container':
            return DISPLAY.RUBY_TEXT_CONTAINER;
        case 'contents':
            return DISPLAY.CONTENTS;
        case 'inline-block':
            return DISPLAY.INLINE_BLOCK;
        case 'inline-list-item':
            return DISPLAY.INLINE_LIST_ITEM;
        case 'inline-table':
            return DISPLAY.INLINE_TABLE;
        case 'inline-flex':
            return DISPLAY.INLINE_FLEX;
        case 'inline-grid':
            return DISPLAY.INLINE_GRID;
        case '-webkit-box':
        	return DISPLAY.BLOCK;
    }

    return DISPLAY.NONE;
};

var setDisplayBit = function setDisplayBit(bit, display) {
    return bit | parseDisplayValue(display);
};

var parseDisplay = exports.parseDisplay = function parseDisplay(display) {
    return display.split(' ').reduce(setDisplayBit, 0);
};

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var FLOAT = exports.FLOAT = {
    NONE: 0,
    LEFT: 1,
    RIGHT: 2,
    INLINE_START: 3,
    INLINE_END: 4
};

var parseCSSFloat = exports.parseCSSFloat = function parseCSSFloat(float) {
    switch (float) {
        case 'left':
            return FLOAT.LEFT;
        case 'right':
            return FLOAT.RIGHT;
        case 'inline-start':
            return FLOAT.INLINE_START;
        case 'inline-end':
            return FLOAT.INLINE_END;
    }
    return FLOAT.NONE;
};

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});


var parseFontWeight = function parseFontWeight(weight) {
    switch (weight) {
        case 'normal':
            return 400;
        case 'bold':
            return 700;
    }

    var value = parseInt(weight, 10);
    return isNaN(value) ? 400 : value;
};

var parseFont = exports.parseFont = function parseFont(style) {
    var fontFamily = style.fontFamily;
    var fontSize = style.fontSize;
    var fontStyle = style.fontStyle;
    var fontVariant = style.fontVariant;
    var fontWeight = parseFontWeight(style.fontWeight);

    return {
        fontFamily: fontFamily,
        fontSize: fontSize,
        fontStyle: fontStyle,
        fontVariant: fontVariant,
        fontWeight: fontWeight
    };
};

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var parseLetterSpacing = exports.parseLetterSpacing = function parseLetterSpacing(letterSpacing) {
    if (letterSpacing === 'normal') {
        return 0;
    }
    var value = parseFloat(letterSpacing);
    return isNaN(value) ? 0 : value;
};

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var LINE_BREAK = exports.LINE_BREAK = {
    NORMAL: 'normal',
    STRICT: 'strict'
};

var parseLineBreak = exports.parseLineBreak = function parseLineBreak(wordBreak) {
    switch (wordBreak) {
        case 'strict':
            return LINE_BREAK.STRICT;
        case 'normal':
        default:
            return LINE_BREAK.NORMAL;
    }
};

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseMargin = undefined;

var _Length = __webpack_require__(1);

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SIDES = ['top', 'right', 'bottom', 'left'];

var parseMargin = exports.parseMargin = function parseMargin(style) {
    return SIDES.map(function (side) {
        return new _Length2.default(style.getPropertyValue('margin-' + side));
    });
};

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var OVERFLOW = exports.OVERFLOW = {
    VISIBLE: 0,
    HIDDEN: 1,
    SCROLL: 2,
    AUTO: 3
};

var parseOverflow = exports.parseOverflow = function parseOverflow(overflow) {
    switch (overflow) {
        case 'hidden':
            return OVERFLOW.HIDDEN;
        case 'scroll':
            return OVERFLOW.SCROLL;
        case 'auto':
            return OVERFLOW.AUTO;
        case 'visible':
        default:
            return OVERFLOW.VISIBLE;
    }
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseTextShadow = undefined;

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NUMBER = /^([+-]|\d|\.)$/i;

var parseTextShadow = exports.parseTextShadow = function parseTextShadow(textShadow) {
    if (textShadow === 'none' || typeof textShadow !== 'string') {
        return null;
    }

    var currentValue = '';
    var isLength = false;
    var values = [];
    var shadows = [];
    var numParens = 0;
    var color = null;

    var appendValue = function appendValue() {
        if (currentValue.length) {
            if (isLength) {
                values.push(parseFloat(currentValue));
            } else {
                color = new _Color2.default(currentValue);
            }
        }
        isLength = false;
        currentValue = '';
    };

    var appendShadow = function appendShadow() {
        if (values.length && color !== null) {
            shadows.push({
                color: color,
                offsetX: values[0] || 0,
                offsetY: values[1] || 0,
                blur: values[2] || 0
            });
        }
        values.splice(0, values.length);
        color = null;
    };

    for (var i = 0; i < textShadow.length; i++) {
        var c = textShadow[i];
        switch (c) {
            case '(':
                currentValue += c;
                numParens++;
                break;
            case ')':
                currentValue += c;
                numParens--;
                break;
            case ',':
                if (numParens === 0) {
                    appendValue();
                    appendShadow();
                } else {
                    currentValue += c;
                }
                break;
            case ' ':
                if (numParens === 0) {
                    appendValue();
                } else {
                    currentValue += c;
                }
                break;
            default:
                if (currentValue.length === 0 && NUMBER.test(c)) {
                    isLength = true;
                }
                currentValue += c;
        }
    }

    appendValue();
    appendShadow();

    if (shadows.length === 0) {
        return null;
    }

    return shadows;
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseTransform = undefined;

var _Length = __webpack_require__(1);

var _Length2 = _interopRequireDefault(_Length);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var toFloat = function toFloat(s) {
    return parseFloat(s.trim());
};

var MATRIX = /(matrix|matrix3d)\((.+)\)/;

var parseTransform = exports.parseTransform = function parseTransform(style) {
    var transform = parseTransformMatrix(style.transform || style.webkitTransform || style.mozTransform ||
    // $FlowFixMe
    style.msTransform ||
    // $FlowFixMe
    style.oTransform);
    if (transform === null) {
        return null;
    }

    return {
        transform: transform,
        transformOrigin: parseTransformOrigin(style.transformOrigin || style.webkitTransformOrigin || style.mozTransformOrigin ||
        // $FlowFixMe
        style.msTransformOrigin ||
        // $FlowFixMe
        style.oTransformOrigin)
    };
};

// $FlowFixMe
var parseTransformOrigin = function parseTransformOrigin(origin) {
    if (typeof origin !== 'string') {
        var v = new _Length2.default('0');
        return [v, v];
    }
    var values = origin.split(' ').map(_Length2.default.create);
    return [values[0], values[1]];
};

// $FlowFixMe
var parseTransformMatrix = function parseTransformMatrix(transform) {
    if (transform === 'none' || typeof transform !== 'string') {
        return null;
    }

    var match = transform.match(MATRIX);
    if (match) {
        if (match[1] === 'matrix') {
            var matrix = match[2].split(',').map(toFloat);
            return [matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]];
        } else {
            var matrix3d = match[2].split(',').map(toFloat);
            return [matrix3d[0], matrix3d[1], matrix3d[4], matrix3d[5], matrix3d[12], matrix3d[13]];
        }
    }
    return null;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var VISIBILITY = exports.VISIBILITY = {
    VISIBLE: 0,
    HIDDEN: 1,
    COLLAPSE: 2
};

var parseVisibility = exports.parseVisibility = function parseVisibility(visibility) {
    switch (visibility) {
        case 'hidden':
            return VISIBILITY.HIDDEN;
        case 'collapse':
            return VISIBILITY.COLLAPSE;
        case 'visible':
        default:
            return VISIBILITY.VISIBLE;
    }
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var WORD_BREAK = exports.WORD_BREAK = {
    NORMAL: 'normal',
    BREAK_ALL: 'break-all',
    KEEP_ALL: 'keep-all'
};

var parseWordBreak = exports.parseWordBreak = function parseWordBreak(wordBreak) {
    switch (wordBreak) {
        case 'break-all':
            return WORD_BREAK.BREAK_ALL;
        case 'keep-all':
            return WORD_BREAK.KEEP_ALL;
        case 'normal':
        default:
            return WORD_BREAK.NORMAL;
    }
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var parseZIndex = exports.parseZIndex = function parseZIndex(zIndex) {
    var auto = zIndex === 'auto';
    return {
        auto: auto,
        order: auto ? 0 : parseInt(zIndex, 10)
    };
};

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Util = __webpack_require__(13);

Object.defineProperty(exports, 'toCodePoints', {
  enumerable: true,
  get: function get() {
    return _Util.toCodePoints;
  }
});
Object.defineProperty(exports, 'fromCodePoint', {
  enumerable: true,
  get: function get() {
    return _Util.fromCodePoint;
  }
});

var _LineBreak = __webpack_require__(47);

Object.defineProperty(exports, 'LineBreaker', {
  enumerable: true,
  get: function get() {
    return _LineBreak.LineBreaker;
  }
});

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LineBreaker = exports.inlineBreakOpportunities = exports.lineBreakAtIndex = exports.codePointsToCharacterClasses = exports.UnicodeTrie = exports.BREAK_ALLOWED = exports.BREAK_NOT_ALLOWED = exports.BREAK_MANDATORY = exports.classes = exports.LETTER_NUMBER_MODIFIER = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _Trie = __webpack_require__(48);

var _linebreakTrie = __webpack_require__(49);

var _linebreakTrie2 = _interopRequireDefault(_linebreakTrie);

var _Util = __webpack_require__(13);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var LETTER_NUMBER_MODIFIER = exports.LETTER_NUMBER_MODIFIER = 50;

// Non-tailorable Line Breaking Classes
var BK = 1; //  Cause a line break (after)
var CR = 2; //  Cause a line break (after), except between CR and LF
var LF = 3; //  Cause a line break (after)
var CM = 4; //  Prohibit a line break between the character and the preceding character
var NL = 5; //  Cause a line break (after)
var SG = 6; //  Do not occur in well-formed text
var WJ = 7; //  Prohibit line breaks before and after
var ZW = 8; //  Provide a break opportunity
var GL = 9; //  Prohibit line breaks before and after
var SP = 10; // Enable indirect line breaks
var ZWJ = 11; // Prohibit line breaks within joiner sequences
// Break Opportunities
var B2 = 12; //  Provide a line break opportunity before and after the character
var BA = 13; //  Generally provide a line break opportunity after the character
var BB = 14; //  Generally provide a line break opportunity before the character
var HY = 15; //  Provide a line break opportunity after the character, except in numeric context
var CB = 16; //   Provide a line break opportunity contingent on additional information
// Characters Prohibiting Certain Breaks
var CL = 17; //  Prohibit line breaks before
var CP = 18; //  Prohibit line breaks before
var EX = 19; //  Prohibit line breaks before
var IN = 20; //  Allow only indirect line breaks between pairs
var NS = 21; //  Allow only indirect line breaks before
var OP = 22; //  Prohibit line breaks after
var QU = 23; //  Act like they are both opening and closing
// Numeric Context
var IS = 24; //  Prevent breaks after any and before numeric
var NU = 25; //  Form numeric expressions for line breaking purposes
var PO = 26; //  Do not break following a numeric expression
var PR = 27; //  Do not break in front of a numeric expression
var SY = 28; //  Prevent a break before; and allow a break after
// Other Characters
var AI = 29; //  Act like AL when the resolvedEAW is N; otherwise; act as ID
var AL = 30; //  Are alphabetic characters or symbols that are used with alphabetic characters
var CJ = 31; //  Treat as NS or ID for strict or normal breaking.
var EB = 32; //  Do not break from following Emoji Modifier
var EM = 33; //  Do not break from preceding Emoji Base
var H2 = 34; //  Form Korean syllable blocks
var H3 = 35; //  Form Korean syllable blocks
var HL = 36; //  Do not break around a following hyphen; otherwise act as Alphabetic
var ID = 37; //  Break before or after; except in some numeric context
var JL = 38; //  Form Korean syllable blocks
var JV = 39; //  Form Korean syllable blocks
var JT = 40; //  Form Korean syllable blocks
var RI = 41; //  Keep pairs together. For pairs; break before and after other classes
var SA = 42; //  Provide a line break opportunity contingent on additional, language-specific context analysis
var XX = 43; //  Have as yet unknown line breaking behavior or unassigned code positions

var classes = exports.classes = {
    BK: BK,
    CR: CR,
    LF: LF,
    CM: CM,
    NL: NL,
    SG: SG,
    WJ: WJ,
    ZW: ZW,
    GL: GL,
    SP: SP,
    ZWJ: ZWJ,
    B2: B2,
    BA: BA,
    BB: BB,
    HY: HY,
    CB: CB,
    CL: CL,
    CP: CP,
    EX: EX,
    IN: IN,
    NS: NS,
    OP: OP,
    QU: QU,
    IS: IS,
    NU: NU,
    PO: PO,
    PR: PR,
    SY: SY,
    AI: AI,
    AL: AL,
    CJ: CJ,
    EB: EB,
    EM: EM,
    H2: H2,
    H3: H3,
    HL: HL,
    ID: ID,
    JL: JL,
    JV: JV,
    JT: JT,
    RI: RI,
    SA: SA,
    XX: XX
};

var BREAK_MANDATORY = exports.BREAK_MANDATORY = '!';
var BREAK_NOT_ALLOWED = exports.BREAK_NOT_ALLOWED = 'Ã—';
var BREAK_ALLOWED = exports.BREAK_ALLOWED = 'Ã·';
var UnicodeTrie = exports.UnicodeTrie = (0, _Trie.createTrieFromBase64)(_linebreakTrie2.default);

var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR, LF, NL];
var SPACE = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];

var codePointsToCharacterClasses = exports.codePointsToCharacterClasses = function codePointsToCharacterClasses(codePoints) {
    var lineBreak = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'strict';

    var types = [];
    var indicies = [];
    var categories = [];
    codePoints.forEach(function (codePoint, index) {
        var classType = UnicodeTrie.get(codePoint);
        if (classType > LETTER_NUMBER_MODIFIER) {
            categories.push(true);
            classType -= LETTER_NUMBER_MODIFIER;
        } else {
            categories.push(false);
        }

        if (['normal', 'auto', 'loose'].indexOf(lineBreak) !== -1) {
            // U+2010, â€“ U+2013, ã€œ U+301C, ã‚  U+30A0
            if ([0x2010, 0x2013, 0x301c, 0x30a0].indexOf(codePoint) !== -1) {
                indicies.push(index);
                return types.push(CB);
            }
        }

        if (classType === CM || classType === ZWJ) {
            // LB10 Treat any remaining combining mark or ZWJ as AL.
            if (index === 0) {
                indicies.push(index);
                return types.push(AL);
            }

            // LB9 Do not break a combining character sequence; treat it as if it has the line breaking class of
            // the base character in all of the following rules. Treat ZWJ as if it were CM.
            var prev = types[index - 1];
            if (LINE_BREAKS.indexOf(prev) === -1) {
                indicies.push(indicies[index - 1]);
                return types.push(prev);
            }
            indicies.push(index);
            return types.push(AL);
        }

        indicies.push(index);

        if (classType === CJ) {
            return types.push(lineBreak === 'strict' ? NS : ID);
        }

        if (classType === SA) {
            return types.push(AL);
        }

        if (classType === AI) {
            return types.push(AL);
        }

        // For supplementary characters, a useful default is to treat characters in the range 10000..1FFFD as AL
        // and characters in the ranges 20000..2FFFD and 30000..3FFFD as ID, until the implementation can be revised
        // to take into account the actual line breaking properties for these characters.
        if (classType === XX) {
            if (codePoint >= 0x20000 && codePoint <= 0x2fffd || codePoint >= 0x30000 && codePoint <= 0x3fffd) {
                return types.push(ID);
            } else {
                return types.push(AL);
            }
        }

        types.push(classType);
    });

    return [indicies, types, categories];
};

var isAdjacentWithSpaceIgnored = function isAdjacentWithSpaceIgnored(a, b, currentIndex, classTypes) {
    var current = classTypes[currentIndex];
    if (Array.isArray(a) ? a.indexOf(current) !== -1 : a === current) {
        var i = currentIndex;
        while (i <= classTypes.length) {
            i++;
            var next = classTypes[i];

            if (next === b) {
                return true;
            }

            if (next !== SP) {
                break;
            }
        }
    }

    if (current === SP) {
        var _i = currentIndex;

        while (_i > 0) {
            _i--;
            var prev = classTypes[_i];

            if (Array.isArray(a) ? a.indexOf(prev) !== -1 : a === prev) {
                var n = currentIndex;
                while (n <= classTypes.length) {
                    n++;
                    var _next = classTypes[n];

                    if (_next === b) {
                        return true;
                    }

                    if (_next !== SP) {
                        break;
                    }
                }
            }

            if (prev !== SP) {
                break;
            }
        }
    }
    return false;
};

var previousNonSpaceClassType = function previousNonSpaceClassType(currentIndex, classTypes) {
    var i = currentIndex;
    while (i >= 0) {
        var type = classTypes[i];
        if (type === SP) {
            i--;
        } else {
            return type;
        }
    }
    return 0;
};

var _lineBreakAtIndex = function _lineBreakAtIndex(codePoints, classTypes, indicies, index, forbiddenBreaks) {
    if (indicies[index] === 0) {
        return BREAK_NOT_ALLOWED;
    }

    var currentIndex = index - 1;
    if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
        return BREAK_NOT_ALLOWED;
    }

    var beforeIndex = currentIndex - 1;
    var afterIndex = currentIndex + 1;
    var current = classTypes[currentIndex];

    // LB4 Always break after hard line breaks.
    // LB5 Treat CR followed by LF, as well as CR, LF, and NL as hard line breaks.
    var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
    var next = classTypes[afterIndex];

    if (current === CR && next === LF) {
        return BREAK_NOT_ALLOWED;
    }

    if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
        return BREAK_MANDATORY;
    }

    // LB6 Do not break before hard line breaks.
    if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB7 Do not break before spaces or zero width space.
    if (SPACE.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB8 Break before any character following a zero-width space, even if one or more spaces intervene.
    if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
        return BREAK_ALLOWED;
    }

    // LB8a Do not break between a zero width joiner and an ideograph, emoji base or emoji modifier.
    if (UnicodeTrie.get(codePoints[currentIndex]) === ZWJ && (next === ID || next === EB || next === EM)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB11 Do not break before or after Word joiner and related characters.
    if (current === WJ || next === WJ) {
        return BREAK_NOT_ALLOWED;
    }

    // LB12 Do not break after NBSP and related characters.
    if (current === GL) {
        return BREAK_NOT_ALLOWED;
    }

    // LB12a Do not break before NBSP and related characters, except after spaces and hyphens.
    if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
        return BREAK_NOT_ALLOWED;
    }

    // LB13 Do not break before â€˜]â€™ or â€˜!â€™ or â€˜;â€™ or â€˜/â€™, even after spaces.
    if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB14 Do not break after â€˜[â€™, even after spaces.
    if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
        return BREAK_NOT_ALLOWED;
    }

    // LB15 Do not break within â€˜â€�[â€™, even with intervening spaces.
    if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB16 Do not break between closing punctuation and a nonstarter (lb=NS), even with intervening spaces.
    if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB17 Do not break within â€˜â€”â€”â€™, even with intervening spaces.
    if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
        return BREAK_NOT_ALLOWED;
    }

    // LB18 Break after spaces.
    if (current === SP) {
        return BREAK_ALLOWED;
    }

    // LB19 Do not break before or after quotation marks, such as â€˜ â€� â€™.
    if (current === QU || next === QU) {
        return BREAK_NOT_ALLOWED;
    }

    // LB20 Break before and after unresolved CB.
    if (next === CB || current === CB) {
        return BREAK_ALLOWED;
    }

    // LB21 Do not break before hyphen-minus, other hyphens, fixed-width spaces, small kana, and other non-starters, or after acute accents.
    if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
        return BREAK_NOT_ALLOWED;
    }

    // LB21a Don't break after Hebrew + Hyphen.
    if (before === HL && HYPHEN.indexOf(current) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB21b Donâ€™t break between Solidus and Hebrew letters.
    if (current === SY && next === HL) {
        return BREAK_NOT_ALLOWED;
    }

    // LB22 Do not break between two ellipses, or between letters, numbers or exclamations and ellipsis.
    if (next === IN && ALPHABETICS.concat(IN, EX, NU, ID, EB, EM).indexOf(current) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB23 Do not break between digits and letters.
    if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
        return BREAK_NOT_ALLOWED;
    }

    // LB23a Do not break between numeric prefixes and ideographs, or between ideographs and numeric postfixes.
    if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
        return BREAK_NOT_ALLOWED;
    }

    // LB24 Do not break between numeric prefix/postfix and letters, or between letters and prefix/postfix.
    if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB25 Do not break between the following pairs of classes relevant to numbers:
    if (
    // (PR | PO) Ã— ( OP | HY )? NU
    [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) ||
    // ( OP | HY ) Ã— NU
    [OP, HY].indexOf(current) !== -1 && next === NU ||
    // NU Ã—	(NU | SY | IS)
    current === NU && [NU, SY, IS].indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // NU (NU | SY | IS)* Ã— (NU | SY | IS | CL | CP)
    if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
        var prevIndex = currentIndex;
        while (prevIndex >= 0) {
            var type = classTypes[prevIndex];
            if (type === NU) {
                return BREAK_NOT_ALLOWED;
            } else if ([SY, IS].indexOf(type) !== -1) {
                prevIndex--;
            } else {
                break;
            }
        }
    }

    // NU (NU | SY | IS)* (CL | CP)? Ã— (PO | PR))
    if ([PR, PO].indexOf(next) !== -1) {
        var _prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
        while (_prevIndex >= 0) {
            var _type = classTypes[_prevIndex];
            if (_type === NU) {
                return BREAK_NOT_ALLOWED;
            } else if ([SY, IS].indexOf(_type) !== -1) {
                _prevIndex--;
            } else {
                break;
            }
        }
    }

    // LB26 Do not break a Korean syllable.
    if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
        return BREAK_NOT_ALLOWED;
    }

    // LB27 Treat a Korean Syllable Block the same as ID.
    if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
        return BREAK_NOT_ALLOWED;
    }

    // LB28 Do not break between alphabetics (â€œatâ€�).
    if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB29 Do not break between numeric punctuation and alphabetics (â€œe.g.â€�).
    if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
        return BREAK_NOT_ALLOWED;
    }

    // LB30 Do not break between letters, numbers, or ordinary symbols and opening or closing parentheses.
    if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
        return BREAK_NOT_ALLOWED;
    }

    // LB30a Break between two regional indicator symbols if and only if there are an even number of regional
    // indicators preceding the position of the break.
    if (current === RI && next === RI) {
        var i = indicies[currentIndex];
        var count = 1;
        while (i > 0) {
            i--;
            if (classTypes[i] === RI) {
                count++;
            } else {
                break;
            }
        }
        if (count % 2 !== 0) {
            return BREAK_NOT_ALLOWED;
        }
    }

    // LB30b Do not break between an emoji base and an emoji modifier.
    if (current === EB && next === EM) {
        return BREAK_NOT_ALLOWED;
    }

    return BREAK_ALLOWED;
};

var lineBreakAtIndex = exports.lineBreakAtIndex = function lineBreakAtIndex(codePoints, index) {
    // LB2 Never break at the start of text.
    if (index === 0) {
        return BREAK_NOT_ALLOWED;
    }

    // LB3 Always break at the end of text.
    if (index >= codePoints.length) {
        return BREAK_MANDATORY;
    }

    var _codePointsToCharacte = codePointsToCharacterClasses(codePoints),
        _codePointsToCharacte2 = _slicedToArray(_codePointsToCharacte, 2),
        indicies = _codePointsToCharacte2[0],
        classTypes = _codePointsToCharacte2[1];

    return _lineBreakAtIndex(codePoints, classTypes, indicies, index);
};

var cssFormattedClasses = function cssFormattedClasses(codePoints, options) {
    if (!options) {
        options = { lineBreak: 'normal', wordBreak: 'normal' };
    }

    var _codePointsToCharacte3 = codePointsToCharacterClasses(codePoints, options.lineBreak),
        _codePointsToCharacte4 = _slicedToArray(_codePointsToCharacte3, 3),
        indicies = _codePointsToCharacte4[0],
        classTypes = _codePointsToCharacte4[1],
        isLetterNumber = _codePointsToCharacte4[2];

    if (options.wordBreak === 'break-all' || options.wordBreak === 'break-word') {
        classTypes = classTypes.map(function (type) {
            return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
        });
    }

    var forbiddenBreakpoints = options.wordBreak === 'keep-all' ? isLetterNumber.map(function (isLetterNumber, i) {
        return isLetterNumber && codePoints[i] >= 0x4e00 && codePoints[i] <= 0x9fff;
    }) : null;

    return [indicies, classTypes, forbiddenBreakpoints];
};

var inlineBreakOpportunities = exports.inlineBreakOpportunities = function inlineBreakOpportunities(str, options) {
    var codePoints = (0, _Util.toCodePoints)(str);
    var output = BREAK_NOT_ALLOWED;

    var _cssFormattedClasses = cssFormattedClasses(codePoints, options),
        _cssFormattedClasses2 = _slicedToArray(_cssFormattedClasses, 3),
        indicies = _cssFormattedClasses2[0],
        classTypes = _cssFormattedClasses2[1],
        forbiddenBreakpoints = _cssFormattedClasses2[2];

    codePoints.forEach(function (codePoint, i) {
        output += (0, _Util.fromCodePoint)(codePoint) + (i >= codePoints.length - 1 ? BREAK_MANDATORY : _lineBreakAtIndex(codePoints, classTypes, indicies, i + 1, forbiddenBreakpoints));
    });

    return output;
};

var Break = function () {
    function Break(codePoints, lineBreak, start, end) {
        _classCallCheck(this, Break);

        this._codePoints = codePoints;
        this.required = lineBreak === BREAK_MANDATORY;
        this.start = start;
        this.end = end;
    }

    _createClass(Break, [{
        key: 'slice',
        value: function slice() {
            return _Util.fromCodePoint.apply(undefined, _toConsumableArray(this._codePoints.slice(this.start, this.end)));
        }
    }]);

    return Break;
}();

var LineBreaker = exports.LineBreaker = function LineBreaker(str, options) {
    var codePoints = (0, _Util.toCodePoints)(str);

    var _cssFormattedClasses3 = cssFormattedClasses(codePoints, options),
        _cssFormattedClasses4 = _slicedToArray(_cssFormattedClasses3, 3),
        indicies = _cssFormattedClasses4[0],
        classTypes = _cssFormattedClasses4[1],
        forbiddenBreakpoints = _cssFormattedClasses4[2];

    var length = codePoints.length;
    var lastEnd = 0;
    var nextIndex = 0;

    return {
        next: function next() {
            if (nextIndex >= length) {
                return { done: true };
            }
            var lineBreak = BREAK_NOT_ALLOWED;
            while (nextIndex < length && (lineBreak = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED) {}

            if (lineBreak !== BREAK_NOT_ALLOWED || nextIndex === length) {
                var value = new Break(codePoints, lineBreak, lastEnd, nextIndex);
                lastEnd = nextIndex;
                return { value: value, done: false };
            }

            return { done: true };
        }
    };
};

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Trie = exports.createTrieFromBase64 = exports.UTRIE2_INDEX_2_MASK = exports.UTRIE2_INDEX_2_BLOCK_LENGTH = exports.UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = exports.UTRIE2_INDEX_1_OFFSET = exports.UTRIE2_UTF8_2B_INDEX_2_LENGTH = exports.UTRIE2_UTF8_2B_INDEX_2_OFFSET = exports.UTRIE2_INDEX_2_BMP_LENGTH = exports.UTRIE2_LSCP_INDEX_2_LENGTH = exports.UTRIE2_DATA_MASK = exports.UTRIE2_DATA_BLOCK_LENGTH = exports.UTRIE2_LSCP_INDEX_2_OFFSET = exports.UTRIE2_SHIFT_1_2 = exports.UTRIE2_INDEX_SHIFT = exports.UTRIE2_SHIFT_1 = exports.UTRIE2_SHIFT_2 = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Util = __webpack_require__(13);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/** Shift size for getting the index-2 table offset. */
var UTRIE2_SHIFT_2 = exports.UTRIE2_SHIFT_2 = 5;

/** Shift size for getting the index-1 table offset. */
var UTRIE2_SHIFT_1 = exports.UTRIE2_SHIFT_1 = 6 + 5;

/**
 * Shift size for shifting left the index array values.
 * Increases possible data size with 16-bit index values at the cost
 * of compactability.
 * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
 */
var UTRIE2_INDEX_SHIFT = exports.UTRIE2_INDEX_SHIFT = 2;

/**
 * Difference between the two shift sizes,
 * for getting an index-1 offset from an index-2 offset. 6=11-5
 */
var UTRIE2_SHIFT_1_2 = exports.UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;

/**
 * The part of the index-2 table for U+D800..U+DBFF stores values for
 * lead surrogate code _units_ not code _points_.
 * Values for lead surrogate code _points_ are indexed with this portion of the table.
 * Length=32=0x20=0x400>>UTRIE2_SHIFT_2. (There are 1024=0x400 lead surrogates.)
 */
var UTRIE2_LSCP_INDEX_2_OFFSET = exports.UTRIE2_LSCP_INDEX_2_OFFSET = 0x10000 >> UTRIE2_SHIFT_2;

/** Number of entries in a data block. 32=0x20 */
var UTRIE2_DATA_BLOCK_LENGTH = exports.UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
/** Mask for getting the lower bits for the in-data-block offset. */
var UTRIE2_DATA_MASK = exports.UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;

var UTRIE2_LSCP_INDEX_2_LENGTH = exports.UTRIE2_LSCP_INDEX_2_LENGTH = 0x400 >> UTRIE2_SHIFT_2;
/** Count the lengths of both BMP pieces. 2080=0x820 */
var UTRIE2_INDEX_2_BMP_LENGTH = exports.UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
/**
 * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
 * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
 */
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = exports.UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = exports.UTRIE2_UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6; /* U+0800 is the first code point after 2-byte UTF-8 */
/**
 * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
 * Variable length, for code points up to highStart, where the last single-value range starts.
 * Maximum length 512=0x200=0x100000>>UTRIE2_SHIFT_1.
 * (For 0x100000 supplementary code points U+10000..U+10ffff.)
 *
 * The part of the index-2 table for supplementary code points starts
 * after this index-1 table.
 *
 * Both the index-1 table and the following part of the index-2 table
 * are omitted completely if there is only BMP data.
 */
var UTRIE2_INDEX_1_OFFSET = exports.UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;

/**
 * Number of index-1 entries for the BMP. 32=0x20
 * This part of the index-1 table is omitted from the serialized form.
 */
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = exports.UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> UTRIE2_SHIFT_1;

/** Number of entries in an index-2 block. 64=0x40 */
var UTRIE2_INDEX_2_BLOCK_LENGTH = exports.UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
/** Mask for getting the lower bits for the in-index-2-block offset. */
var UTRIE2_INDEX_2_MASK = exports.UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;

var createTrieFromBase64 = exports.createTrieFromBase64 = function createTrieFromBase64(base64) {
    var buffer = (0, _Util.decode)(base64);
    var view32 = Array.isArray(buffer) ? (0, _Util.polyUint32Array)(buffer) : new Uint32Array(buffer);
    var view16 = Array.isArray(buffer) ? (0, _Util.polyUint16Array)(buffer) : new Uint16Array(buffer);
    var headerLength = 24;

    var index = view16.slice(headerLength / 2, view32[4] / 2);
    var data = view32[5] === 2 ? view16.slice((headerLength + view32[4]) / 2) : view32.slice(Math.ceil((headerLength + view32[4]) / 4));

    return new Trie(view32[0], view32[1], view32[2], view32[3], index, data);
};

var Trie = exports.Trie = function () {
    function Trie(initialValue, errorValue, highStart, highValueIndex, index, data) {
        _classCallCheck(this, Trie);

        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index;
        this.data = data;
    }

    /**
     * Get the value for a code point as stored in the Trie.
     *
     * @param codePoint the code point
     * @return the value
     */


    _createClass(Trie, [{
        key: 'get',
        value: function get(codePoint) {
            var ix = void 0;
            if (codePoint >= 0) {
                if (codePoint < 0x0d800 || codePoint > 0x0dbff && codePoint <= 0x0ffff) {
                    // Ordinary BMP code point, excluding leading surrogates.
                    // BMP uses a single level lookup.  BMP index starts at offset 0 in the Trie2 index.
                    // 16 bit data is stored in the index array itself.
                    ix = this.index[codePoint >> UTRIE2_SHIFT_2];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }

                if (codePoint <= 0xffff) {
                    // Lead Surrogate Code Point.  A Separate index section is stored for
                    // lead surrogate code units and code points.
                    //   The main index has the code unit data.
                    //   For this function, we need the code point data.
                    // Note: this expression could be refactored for slightly improved efficiency, but
                    //       surrogate code points will be so rare in practice that it's not worth it.
                    ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 0xd800 >> UTRIE2_SHIFT_2)];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }

                if (codePoint < this.highStart) {
                    // Supplemental code point, use two-level lookup.
                    ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
                    ix = this.index[ix];
                    ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
                    ix = this.index[ix];
                    ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
                    return this.data[ix];
                }
                if (codePoint <= 0x10ffff) {
                    return this.data[this.highValueIndex];
                }
            }

            // Fall through.  The code point is outside of the legal range of 0..0x10ffff.
            return this.errorValue;
        }
    }]);

    return Trie;
}();

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = 'KwAAAAAAAAAACA4AIDoAAPAfAAACAAAAAAAIABAAGABAAEgAUABYAF4AZgBeAGYAYABoAHAAeABeAGYAfACEAIAAiACQAJgAoACoAK0AtQC9AMUAXgBmAF4AZgBeAGYAzQDVAF4AZgDRANkA3gDmAOwA9AD8AAQBDAEUARoBIgGAAIgAJwEvATcBPwFFAU0BTAFUAVwBZAFsAXMBewGDATAAiwGTAZsBogGkAawBtAG8AcIBygHSAdoB4AHoAfAB+AH+AQYCDgIWAv4BHgImAi4CNgI+AkUCTQJTAlsCYwJrAnECeQKBAk0CiQKRApkCoQKoArACuALAAsQCzAIwANQC3ALkAjAA7AL0AvwCAQMJAxADGAMwACADJgMuAzYDPgOAAEYDSgNSA1IDUgNaA1oDYANiA2IDgACAAGoDgAByA3YDfgOAAIQDgACKA5IDmgOAAIAAogOqA4AAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAK8DtwOAAIAAvwPHA88D1wPfAyAD5wPsA/QD/AOAAIAABAQMBBIEgAAWBB4EJgQuBDMEIAM7BEEEXgBJBCADUQRZBGEEaQQwADAAcQQ+AXkEgQSJBJEEgACYBIAAoASoBK8EtwQwAL8ExQSAAIAAgACAAIAAgACgAM0EXgBeAF4AXgBeAF4AXgBeANUEXgDZBOEEXgDpBPEE+QQBBQkFEQUZBSEFKQUxBTUFPQVFBUwFVAVcBV4AYwVeAGsFcwV7BYMFiwWSBV4AmgWgBacFXgBeAF4AXgBeAKsFXgCyBbEFugW7BcIFwgXIBcIFwgXQBdQF3AXkBesF8wX7BQMGCwYTBhsGIwYrBjMGOwZeAD8GRwZNBl4AVAZbBl4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAGMGXgBqBnEGXgBeAF4AXgBeAF4AXgBeAF4AXgB5BoAG4wSGBo4GkwaAAIADHgR5AF4AXgBeAJsGgABGA4AAowarBrMGswagALsGwwbLBjAA0wbaBtoG3QbaBtoG2gbaBtoG2gblBusG8wb7BgMHCwcTBxsHCwcjBysHMAc1BzUHOgdCB9oGSgdSB1oHYAfaBloHaAfaBlIH2gbaBtoG2gbaBtoG2gbaBjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHbQdeAF4ANQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQd1B30HNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B4MH2gaKB68EgACAAIAAgACAAIAAgACAAI8HlwdeAJ8HpweAAIAArwe3B14AXgC/B8UHygcwANAH2AfgB4AA6AfwBz4B+AcACFwBCAgPCBcIogEYAR8IJwiAAC8INwg/CCADRwhPCFcIXwhnCEoDGgSAAIAAgABvCHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIfQh3CHgIeQh6CHsIfAh9CHcIeAh5CHoIewh8CH0Idwh4CHkIegh7CHwIhAiLCI4IMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAANQc1BzUHNQc1BzUHNQc1BzUHNQc1B54INQc1B6II2gaqCLIIugiAAIAAvgjGCIAAgACAAIAAgACAAIAAgACAAIAAywiHAYAA0wiAANkI3QjlCO0I9Aj8CIAAgACAAAIJCgkSCRoJIgknCTYHLwk3CZYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiWCJYIlgiAAIAAAAFAAXgBeAGAAcABeAHwAQACQAKAArQC9AJ4AXgBeAE0A3gBRAN4A7AD8AMwBGgEAAKcBNwEFAUwBXAF4QkhCmEKnArcCgAHHAsABz4LAAcABwAHAAd+C6ABoAG+C/4LAAcABwAHAAc+DF4MAAcAB54M3gweDV4Nng3eDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEeDqABVg6WDqABoQ6gAaABoAHXDvcONw/3DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DvcO9w73DncPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB7cPPwlGCU4JMACAAIAAgABWCV4JYQmAAGkJcAl4CXwJgAkwADAAMAAwAIgJgACLCZMJgACZCZ8JowmrCYAAswkwAF4AXgB8AIAAuwkABMMJyQmAAM4JgADVCTAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAqwYWBNkIMAAwADAAMADdCeAJ6AnuCR4E9gkwAP4JBQoNCjAAMACAABUK0wiAAB0KJAosCjQKgAAwADwKQwqAAEsKvQmdCVMKWwowADAAgACAALcEMACAAGMKgABrCjAAMAAwADAAMAAwADAAMAAwADAAMAAeBDAAMAAwADAAMAAwADAAMAAwADAAMAAwAIkEPQFzCnoKiQSCCooKkAqJBJgKoAqkCokEGAGsCrQKvArBCjAAMADJCtEKFQHZCuEK/gHpCvEKMAAwADAAMACAAIwE+QowAIAAPwEBCzAAMAAwADAAMACAAAkLEQswAIAAPwEZCyELgAAOCCkLMAAxCzkLMAAwADAAMAAwADAAXgBeAEELMAAwADAAMAAwADAAMAAwAEkLTQtVC4AAXAtkC4AAiQkwADAAMAAwADAAMAAwADAAbAtxC3kLgAuFC4sLMAAwAJMLlwufCzAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAApwswADAAMACAAIAAgACvC4AAgACAAIAAgACAALcLMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAvwuAAMcLgACAAIAAgACAAIAAyguAAIAAgACAAIAA0QswADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAANkLgACAAIAA4AswADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACJCR4E6AswADAAhwHwC4AA+AsADAgMEAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMACAAIAAGAwdDCUMMAAwAC0MNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQw1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHPQwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADUHNQc1BzUHNQc1BzUHNQc2BzAAMAA5DDUHNQc1BzUHNQc1BzUHNQc1BzUHNQdFDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAgACAAIAATQxSDFoMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAF4AXgBeAF4AXgBeAF4AYgxeAGoMXgBxDHkMfwxeAIUMXgBeAI0MMAAwADAAMAAwAF4AXgCVDJ0MMAAwADAAMABeAF4ApQxeAKsMswy7DF4Awgy9DMoMXgBeAF4AXgBeAF4AXgBeAF4AXgDRDNkMeQBqCeAM3Ax8AOYM7Az0DPgMXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgBeAF4AXgCgAAANoAAHDQ4NFg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAeDSYNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIAAgACAAIAAgACAAC4NMABeAF4ANg0wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAD4NRg1ODVYNXg1mDTAAbQ0wADAAMAAwADAAMAAwADAA2gbaBtoG2gbaBtoG2gbaBnUNeg3CBYANwgWFDdoGjA3aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gaUDZwNpA2oDdoG2gawDbcNvw3HDdoG2gbPDdYN3A3fDeYN2gbsDfMN2gbaBvoN/g3aBgYODg7aBl4AXgBeABYOXgBeACUG2gYeDl4AJA5eACwO2w3aBtoGMQ45DtoG2gbaBtoGQQ7aBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDjUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B1EO2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQdZDjUHNQc1BzUHNQc1B2EONQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHaA41BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B3AO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gY1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1BzUHNQc1B2EO2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gZJDtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBtoG2gbaBkkOeA6gAKAAoAAwADAAMAAwAKAAoACgAKAAoACgAKAAgA4wADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAD//wQABAAEAAQABAAEAAQABAAEAA0AAwABAAEAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAKABMAFwAeABsAGgAeABcAFgASAB4AGwAYAA8AGAAcAEsASwBLAEsASwBLAEsASwBLAEsAGAAYAB4AHgAeABMAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAFgAbABIAHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYADQARAB4ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkAFgAaABsAGwAbAB4AHQAdAB4ATwAXAB4ADQAeAB4AGgAbAE8ATwAOAFAAHQAdAB0ATwBPABcATwBPAE8AFgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwArAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAAQABAANAA0ASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAUAArACsAKwArACsAKwArACsABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAGgAaAFAAUABQAFAAUABMAB4AGwBQAB4AKwArACsABAAEAAQAKwBQAFAAUABQAFAAUAArACsAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUAArAFAAUAArACsABAArAAQABAAEAAQABAArACsAKwArAAQABAArACsABAAEAAQAKwArACsABAArACsAKwArACsAKwArAFAAUABQAFAAKwBQACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwAEAAQAUABQAFAABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUAArACsABABQAAQABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQAKwArAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeABsAKwArACsAKwArACsAKwBQAAQABAAEAAQABAAEACsABAAEAAQAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArAAQABAArACsABAAEAAQAKwArACsAKwArACsAKwArAAQABAArACsAKwArAFAAUAArAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwAeAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwAEAFAAKwBQAFAAUABQAFAAUAArACsAKwBQAFAAUAArAFAAUABQAFAAKwArACsAUABQACsAUAArAFAAUAArACsAKwBQAFAAKwArACsAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQAKwArACsABAAEAAQAKwAEAAQABAAEACsAKwBQACsAKwArACsAKwArAAQAKwArACsAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAB4AHgAeAB4AHgAeABsAHgArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArAFAAUABQACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAB4AUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABAArACsAKwArACsAKwArAAQABAArACsAKwArACsAKwArAFAAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwArAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAKwBcAFwAKwBcACsAKwBcACsAKwArACsAKwArAFwAXABcAFwAKwBcAFwAXABcAFwAXABcACsAXABcAFwAKwBcACsAXAArACsAXABcACsAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgArACoAKgBcACsAKwBcAFwAXABcAFwAKwBcACsAKgAqACoAKgAqACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAFwAXABcAFwAUAAOAA4ADgAOAB4ADgAOAAkADgAOAA0ACQATABMAEwATABMACQAeABMAHgAeAB4ABAAEAB4AHgAeAB4AHgAeAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUAANAAQAHgAEAB4ABAAWABEAFgARAAQABABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAAQABAAEAAQABAANAAQABABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsADQANAB4AHgAeAB4AHgAeAAQAHgAeAB4AHgAeAB4AKwAeAB4ADgAOAA0ADgAeAB4AHgAeAB4ACQAJACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgAeAB4AHgBcAFwAXABcAFwAXAAqACoAKgAqAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAKgAqACoAKgAqACoAKgBcAFwAXAAqACoAKgAqAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAXAAqAEsASwBLAEsASwBLAEsASwBLAEsAKgAqACoAKgAqACoAUABQAFAAUABQAFAAKwBQACsAKwArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQACsAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwAEAAQABAAeAA0AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAEQArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAADQANAA0AUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAA0ADQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQACsABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoADQANABUAXAANAB4ADQAbAFwAKgArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAB4AHgATABMADQANAA4AHgATABMAHgAEAAQABAAJACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAUABQAFAAUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwAeACsAKwArABMAEwBLAEsASwBLAEsASwBLAEsASwBLAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwBcAFwAXABcAFwAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcACsAKwArACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwAeAB4AXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsABABLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKgAqACoAKgAqACoAKgBcACoAKgAqACoAKgAqACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAUABQAFAAUABQAFAAUAArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4ADQANAA0ADQAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAHgAeAB4AHgBQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwANAA0ADQANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwBQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsABAAEAAQAHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAABABQAFAAUABQAAQABAAEAFAAUAAEAAQABAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAKwBQACsAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAKwArAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAKwAeAB4AHgAeAB4AHgAeAA4AHgArAA0ADQANAA0ADQANAA0ACQANAA0ADQAIAAQACwAEAAQADQAJAA0ADQAMAB0AHQAeABcAFwAWABcAFwAXABYAFwAdAB0AHgAeABQAFAAUAA0AAQABAAQABAAEAAQABAAJABoAGgAaABoAGgAaABoAGgAeABcAFwAdABUAFQAeAB4AHgAeAB4AHgAYABYAEQAVABUAFQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgANAB4ADQANAA0ADQAeAA0ADQANAAcAHgAeAB4AHgArAAQABAAEAAQABAAEAAQABAAEAAQAUABQACsAKwBPAFAAUABQAFAAUAAeAB4AHgAWABEATwBQAE8ATwBPAE8AUABQAFAAUABQAB4AHgAeABYAEQArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAaABsAGwAbABsAGgAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgBQABoAHgAdAB4AUAAeABoAHgAeAB4AHgAeAB4AHgAeAB4ATwAeAFAAGwAeAB4AUABQAFAAUABQAB4AHgAeAB0AHQAeAFAAHgBQAB4AUAAeAFAATwBQAFAAHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AUABQAFAAUABPAE8AUABQAFAAUABQAE8AUABQAE8AUABPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAE8ATwBPAE8ATwBPAE8ATwBPAE8AUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAATwAeAB4AKwArACsAKwAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB0AHQAeAB4AHgAdAB0AHgAeAB0AHgAeAB4AHQAeAB0AGwAbAB4AHQAeAB4AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB0AHgAdAB4AHQAdAB0AHQAdAB0AHgAdAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAdAB0AHQAdAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAlACUAHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBQAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAeAB4AHgAeAB0AHQAeAB4AHgAeAB0AHQAdAB4AHgAdAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB0AHQAeAB4AHQAeAB4AHgAeAB0AHQAeAB4AHgAeACUAJQAdAB0AJQAeACUAJQAlACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAHgAeAB4AHgAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHQAdAB0AHgAdACUAHQAdAB4AHQAdAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHQAdAB0AHQAlAB4AJQAlACUAHQAlACUAHQAdAB0AJQAlAB0AHQAlAB0AHQAlACUAJQAeAB0AHgAeAB4AHgAdAB0AJQAdAB0AHQAdAB0AHQAlACUAJQAlACUAHQAlACUAIAAlAB0AHQAlACUAJQAlACUAJQAlACUAHgAeAB4AJQAlACAAIAAgACAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeABcAFwAXABcAFwAXAB4AEwATACUAHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACUAJQBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwArACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAE8ATwBPAE8ATwBPAE8ATwAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeACsAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUAArACsAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQBQAFAAUABQACsAKwArACsAUABQAFAAUABQAFAAUABQAA0AUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAABAAEAAQAKwAEAAQAKwArACsAKwArAAQABAAEAAQAUABQAFAAUAArAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsABAAEAAQAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsADQANAA0ADQANAA0ADQANAB4AKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAUABQAFAAUABQAA0ADQANAA0ADQANABQAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwANAA0ADQANAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAeAAQABAAEAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLACsADQArAB4AKwArAAQABAAEAAQAUABQAB4AUAArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwAEAAQABAAEAAQABAAEAAQABAAOAA0ADQATABMAHgAeAB4ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0AUABQAFAAUAAEAAQAKwArAAQADQANAB4AUAArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXABcAA0ADQANACoASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUAArACsAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANACsADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEcARwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQACsAKwAeAAQABAANAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAEAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUAArACsAUAArACsAUABQACsAKwBQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AKwArAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAeAB4ADQANAA0ADQAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAArAAQABAArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAEAAQABAAEAAQABAAEACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAFgAWAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAKwBQACsAKwArACsAKwArAFAAKwArACsAKwBQACsAUAArAFAAKwBQAFAAUAArAFAAUAArAFAAKwArAFAAKwBQACsAUAArAFAAKwBQACsAUABQACsAUAArACsAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAUABQAFAAUAArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUAArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAlACUAJQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeACUAJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeACUAJQAlACUAJQAeACUAJQAlACUAJQAgACAAIAAlACUAIAAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIQAhACEAIQAhACUAJQAgACAAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAIAAlACUAJQAlACAAJQAgACAAIAAgACAAIAAgACAAIAAlACUAJQAgACUAJQAlACUAIAAgACAAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeACUAHgAlAB4AJQAlACUAJQAlACAAJQAlACUAJQAeACUAHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAIAAgACAAIAAgAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFwAXABcAFQAVABUAHgAeAB4AHgAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAIAAgACAAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAlACAAIAAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsA';

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _Path = __webpack_require__(6);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Circle = function Circle(x, y, radius) {
    _classCallCheck(this, Circle);

    this.type = _Path.PATH.CIRCLE;
    this.x = x;
    this.y = y;
    this.radius = radius;
    if (true) {
        if (isNaN(x)) {
            console.error('Invalid x value given for Circle');
        }
        if (isNaN(y)) {
            console.error('Invalid y value given for Circle');
        }
        if (isNaN(radius)) {
            console.error('Invalid radius value given for Circle');
        }
    }
};

exports.default = Circle;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Bounds = __webpack_require__(2);

var _Font = __webpack_require__(25);

var _Gradient = __webpack_require__(52);

var _TextContainer = __webpack_require__(9);

var _TextContainer2 = _interopRequireDefault(_TextContainer);

var _background = __webpack_require__(5);

var _border = __webpack_require__(12);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Renderer = function () {
    function Renderer(target, options) {
        _classCallCheck(this, Renderer);

        this.target = target;
        this.options = options;
        target.render(options);
    }

    _createClass(Renderer, [{
        key: 'renderNode',
        value: function renderNode(container) {
            if (container.isVisible()) {
                this.renderNodeBackgroundAndBorders(container);
                this.renderNodeContent(container);
            }
        }
    }, {
        key: 'renderNodeContent',
        value: function renderNodeContent(container) {
            var _this = this;

            var callback = function callback() {
                if (container.childNodes.length) {
                    container.childNodes.forEach(function (child) {
                        if (child instanceof _TextContainer2.default) {
                            var style = child.parent.style;
                            _this.target.renderTextNode(child.bounds, style.color, style.font, style.textDecoration, style.textShadow);
                        } else {
                            _this.target.drawShape(child, container.style.color);
                        }
                    });
                }

                if (container.image) {
                    var _image = _this.options.imageStore.get(container.image);
                    if (_image) {
                        var contentBox = (0, _Bounds.calculateContentBox)(container.bounds, container.style.padding, container.style.border);
                        var _width = typeof _image.width === 'number' && _image.width > 0 ? _image.width : contentBox.width;
                        var _height = typeof _image.height === 'number' && _image.height > 0 ? _image.height : contentBox.height;
                        if (_width > 0 && _height > 0) {
                            _this.target.clip([(0, _Bounds.calculatePaddingBoxPath)(container.curvedBounds)], function () {
                                _this.target.drawImage(_image, new _Bounds.Bounds(0, 0, _width, _height), contentBox);
                            });
                        }
                    }
                }
            };
            var paths = container.getClipPaths();
            if (paths.length) {
                this.target.clip(paths, callback);
            } else {
                callback();
            }
        }
    }, {
        key: 'renderNodeBackgroundAndBorders',
        value: function renderNodeBackgroundAndBorders(container) {
            var _this2 = this;

            var HAS_BACKGROUND = !container.style.background.backgroundColor.isTransparent() || container.style.background.backgroundImage.length;

            var hasRenderableBorders = container.style.border.some(function (border) {
                return border.borderStyle !== _border.BORDER_STYLE.NONE && !border.borderColor.isTransparent();
            });

            var callback = function callback() {
                var backgroundPaintingArea = (0, _background.calculateBackgroungPaintingArea)(container.curvedBounds, container.style.background.backgroundClip);

                if (HAS_BACKGROUND) {
                    _this2.target.clip([backgroundPaintingArea], function () {
                        if (!container.style.background.backgroundColor.isTransparent()) {
                            _this2.target.fill(container.style.background.backgroundColor);
                        }

                        _this2.renderBackgroundImage(container);
                    });
                }

                container.style.border.forEach(function (border, side) {
                    if (border.borderStyle !== _border.BORDER_STYLE.NONE && !border.borderColor.isTransparent()) {
                        _this2.renderBorder(border, side, container.curvedBounds);
                    }
                });
            };

            if (HAS_BACKGROUND || hasRenderableBorders) {
                var paths = container.parent ? container.parent.getClipPaths() : [];
                if (paths.length) {
                    this.target.clip(paths, callback);
                } else {
                    callback();
                }
            }
        }
    }, {
        key: 'renderBackgroundImage',
        value: function renderBackgroundImage(container) {
            var _this3 = this;

            container.style.background.backgroundImage.slice(0).reverse().forEach(function (backgroundImage) {
                if (backgroundImage.source.method === 'url' && backgroundImage.source.args.length) {
                    _this3.renderBackgroundRepeat(container, backgroundImage);
                } else if (/gradient/i.test(backgroundImage.source.method)) {
                    _this3.renderBackgroundGradient(container, backgroundImage);
                }
            });
        }
    }, {
        key: 'renderBackgroundRepeat',
        value: function renderBackgroundRepeat(container, background) {
            var image = this.options.imageStore.get(background.source.args[0]);
            if (image) {
                var backgroundPositioningArea = (0, _background.calculateBackgroungPositioningArea)(container.style.background.backgroundOrigin, container.bounds, container.style.padding, container.style.border);
                var backgroundImageSize = (0, _background.calculateBackgroundSize)(background, image, backgroundPositioningArea);
                var position = (0, _background.calculateBackgroundPosition)(background.position, backgroundImageSize, backgroundPositioningArea);
                var _path = (0, _background.calculateBackgroundRepeatPath)(background, position, backgroundImageSize, backgroundPositioningArea, container.bounds);

                var _offsetX = Math.round(backgroundPositioningArea.left + position.x);
                var _offsetY = Math.round(backgroundPositioningArea.top + position.y);
                this.target.renderRepeat(_path, image, backgroundImageSize, _offsetX, _offsetY);
            }
        }
    }, {
        key: 'renderBackgroundGradient',
        value: function renderBackgroundGradient(container, background) {
            var backgroundPositioningArea = (0, _background.calculateBackgroungPositioningArea)(container.style.background.backgroundOrigin, container.bounds, container.style.padding, container.style.border);
            var backgroundImageSize = (0, _background.calculateGradientBackgroundSize)(background, backgroundPositioningArea);
            var position = (0, _background.calculateBackgroundPosition)(background.position, backgroundImageSize, backgroundPositioningArea);
            var gradientBounds = new _Bounds.Bounds(Math.round(backgroundPositioningArea.left + position.x), Math.round(backgroundPositioningArea.top + position.y), backgroundImageSize.width, backgroundImageSize.height);

            var gradient = (0, _Gradient.parseGradient)(container, background.source, gradientBounds);
            if (gradient) {
                switch (gradient.type) {
                    case _Gradient.GRADIENT_TYPE.LINEAR_GRADIENT:
                        // $FlowFixMe
                        this.target.renderLinearGradient(gradientBounds, gradient);
                        break;
                    case _Gradient.GRADIENT_TYPE.RADIAL_GRADIENT:
                        // $FlowFixMe
                        this.target.renderRadialGradient(gradientBounds, gradient);
                        break;
                }
            }
        }
    }, {
        key: 'renderBorder',
        value: function renderBorder(border, side, curvePoints) {
            this.target.drawShape((0, _Bounds.parsePathForBorder)(curvePoints, side), border.borderColor);
        }
    }, {
        key: 'renderStack',
        value: function renderStack(stack) {
            var _this4 = this;

            if (stack.container.isVisible()) {
                var _opacity = stack.getOpacity();
                if (_opacity !== this._opacity) {
                    this.target.setOpacity(stack.getOpacity());
                    this._opacity = _opacity;
                }

                var _transform = stack.container.style.transform;
                if (_transform !== null) {
                    this.target.transform(stack.container.bounds.left + _transform.transformOrigin[0].value, stack.container.bounds.top + _transform.transformOrigin[1].value, _transform.transform, function () {
                        return _this4.renderStackContent(stack);
                    });
                } else {
                    this.renderStackContent(stack);
                }
            }
        }
    }, {
        key: 'renderStackContent',
        value: function renderStackContent(stack) {
            var _splitStackingContext = splitStackingContexts(stack),
                _splitStackingContext2 = _slicedToArray(_splitStackingContext, 5),
                negativeZIndex = _splitStackingContext2[0],
                zeroOrAutoZIndexOrTransformedOrOpacity = _splitStackingContext2[1],
                positiveZIndex = _splitStackingContext2[2],
                nonPositionedFloats = _splitStackingContext2[3],
                nonPositionedInlineLevel = _splitStackingContext2[4];

            var _splitDescendants = splitDescendants(stack),
                _splitDescendants2 = _slicedToArray(_splitDescendants, 2),
                inlineLevel = _splitDescendants2[0],
                nonInlineLevel = _splitDescendants2[1];

            // https://www.w3.org/TR/css-position-3/#painting-order
            // 1. the background and borders of the element forming the stacking context.


            this.renderNodeBackgroundAndBorders(stack.container);
            // 2. the child stacking contexts with negative stack levels (most negative first).
            negativeZIndex.sort(sortByZIndex).forEach(this.renderStack, this);
            // 3. For all its in-flow, non-positioned, block-level descendants in tree order:
            this.renderNodeContent(stack.container);
            nonInlineLevel.forEach(this.renderNode, this);
            // 4. All non-positioned floating descendants, in tree order. For each one of these,
            // treat the element as if it created a new stacking context, but any positioned descendants and descendants
            // which actually create a new stacking context should be considered part of the parent stacking context,
            // not this new one.
            nonPositionedFloats.forEach(this.renderStack, this);
            // 5. the in-flow, inline-level, non-positioned descendants, including inline tables and inline blocks.
            nonPositionedInlineLevel.forEach(this.renderStack, this);
            inlineLevel.forEach(this.renderNode, this);
            // 6. All positioned, opacity or transform descendants, in tree order that fall into the following categories:
            //  All positioned descendants with 'z-index: auto' or 'z-index: 0', in tree order.
            //  For those with 'z-index: auto', treat the element as if it created a new stacking context,
            //  but any positioned descendants and descendants which actually create a new stacking context should be
            //  considered part of the parent stacking context, not this new one. For those with 'z-index: 0',
            //  treat the stacking context generated atomically.
            //
            //  All opacity descendants with opacity less than 1
            //
            //  All transform descendants with transform other than none
            zeroOrAutoZIndexOrTransformedOrOpacity.forEach(this.renderStack, this);
            // 7. Stacking contexts formed by positioned descendants with z-indices greater than or equal to 1 in z-index
            // order (smallest first) then tree order.
            positiveZIndex.sort(sortByZIndex).forEach(this.renderStack, this);
        }
    }, {
        key: 'render',
        value: function render(stack) {
            var _this5 = this;

            if (this.options.backgroundColor) {
                this.target.rectangle(this.options.x, this.options.y, this.options.width, this.options.height, this.options.backgroundColor);
            }
            this.renderStack(stack);
            var target = this.target.getTarget();
            if (true) {
                return target.then(function (output) {
                    _this5.options.logger.log('Render completed');
                    return output;
                });
            }
            return target;
        }
    }]);

    return Renderer;
}();

exports.default = Renderer;


var splitDescendants = function splitDescendants(stack) {
    var inlineLevel = [];
    var nonInlineLevel = [];

    var length = stack.children.length;
    for (var i = 0; i < length; i++) {
        var child = stack.children[i];
        if (child.isInlineLevel()) {
            inlineLevel.push(child);
        } else {
            nonInlineLevel.push(child);
        }
    }
    return [inlineLevel, nonInlineLevel];
};

var splitStackingContexts = function splitStackingContexts(stack) {
    var negativeZIndex = [];
    var zeroOrAutoZIndexOrTransformedOrOpacity = [];
    var positiveZIndex = [];
    var nonPositionedFloats = [];
    var nonPositionedInlineLevel = [];
    var length = stack.contexts.length;
    for (var i = 0; i < length; i++) {
        var child = stack.contexts[i];
        if (child.container.isPositioned() || child.container.style.opacity < 1 || child.container.isTransformed()) {
            if (child.container.style.zIndex.order < 0) {
                negativeZIndex.push(child);
            } else if (child.container.style.zIndex.order > 0) {
                positiveZIndex.push(child);
            } else {
                zeroOrAutoZIndexOrTransformedOrOpacity.push(child);
            }
        } else {
            if (child.container.isFloating()) {
                nonPositionedFloats.push(child);
            } else {
                nonPositionedInlineLevel.push(child);
            }
        }
    }
    return [negativeZIndex, zeroOrAutoZIndexOrTransformedOrOpacity, positiveZIndex, nonPositionedFloats, nonPositionedInlineLevel];
};

var sortByZIndex = function sortByZIndex(a, b) {
    if (a.container.style.zIndex.order > b.container.style.zIndex.order) {
        return 1;
    } else if (a.container.style.zIndex.order < b.container.style.zIndex.order) {
        return -1;
    }

    return a.container.index > b.container.index ? 1 : -1;
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.transformWebkitRadialGradientArgs = exports.parseGradient = exports.RadialGradient = exports.LinearGradient = exports.RADIAL_GRADIENT_SHAPE = exports.GRADIENT_TYPE = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _NodeContainer = __webpack_require__(3);

var _NodeContainer2 = _interopRequireDefault(_NodeContainer);

var _Angle = __webpack_require__(53);

var _Color = __webpack_require__(0);

var _Color2 = _interopRequireDefault(_Color);

var _Length = __webpack_require__(1);

var _Length2 = _interopRequireDefault(_Length);

var _Util = __webpack_require__(4);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SIDE_OR_CORNER = /^(to )?(left|top|right|bottom)( (left|top|right|bottom))?$/i;
var PERCENTAGE_ANGLES = /^([+-]?\d*\.?\d+)% ([+-]?\d*\.?\d+)%$/i;
var ENDS_WITH_LENGTH = /(px)|%|( 0)$/i;
var FROM_TO_COLORSTOP = /^(from|to|color-stop)\((?:([\d.]+)(%)?,\s*)?(.+?)\)$/i;
var RADIAL_SHAPE_DEFINITION = /^\s*(circle|ellipse)?\s*((?:([\d.]+)(px|r?em|%)\s*(?:([\d.]+)(px|r?em|%))?)|closest-side|closest-corner|farthest-side|farthest-corner)?\s*(?:at\s*(?:(left|center|right)|([\d.]+)(px|r?em|%))\s+(?:(top|center|bottom)|([\d.]+)(px|r?em|%)))?(?:\s|$)/i;

var GRADIENT_TYPE = exports.GRADIENT_TYPE = {
    LINEAR_GRADIENT: 0,
    RADIAL_GRADIENT: 1
};

var RADIAL_GRADIENT_SHAPE = exports.RADIAL_GRADIENT_SHAPE = {
    CIRCLE: 0,
    ELLIPSE: 1
};

var LENGTH_FOR_POSITION = {
    left: new _Length2.default('0%'),
    top: new _Length2.default('0%'),
    center: new _Length2.default('50%'),
    right: new _Length2.default('100%'),
    bottom: new _Length2.default('100%')
};

var LinearGradient = exports.LinearGradient = function LinearGradient(colorStops, direction) {
    _classCallCheck(this, LinearGradient);

    this.type = GRADIENT_TYPE.LINEAR_GRADIENT;
    this.colorStops = colorStops;
    this.direction = direction;
};

var RadialGradient = exports.RadialGradient = function RadialGradient(colorStops, shape, center, radius) {
    _classCallCheck(this, RadialGradient);

    this.type = GRADIENT_TYPE.RADIAL_GRADIENT;
    this.colorStops = colorStops;
    this.shape = shape;
    this.center = center;
    this.radius = radius;
};

var parseGradient = exports.parseGradient = function parseGradient(container, _ref, bounds) {
    var args = _ref.args,
        method = _ref.method,
        prefix = _ref.prefix;

    if (method === 'linear-gradient') {
        return parseLinearGradient(args, bounds, !!prefix);
    } else if (method === 'gradient' && args[0] === 'linear') {
        // TODO handle correct angle
        return parseLinearGradient(['to bottom'].concat(transformObsoleteColorStops(args.slice(3))), bounds, !!prefix);
    } else if (method === 'radial-gradient') {
        return parseRadialGradient(container, prefix === '-webkit-' ? transformWebkitRadialGradientArgs(args) : args, bounds);
    } else if (method === 'gradient' && args[0] === 'radial') {
        return parseRadialGradient(container, transformObsoleteColorStops(transformWebkitRadialGradientArgs(args.slice(1))), bounds);
    }
};

var parseColorStops = function parseColorStops(args, firstColorStopIndex, lineLength) {
    var colorStops = [];

    for (var i = firstColorStopIndex; i < args.length; i++) {
        var value = args[i];
        var HAS_LENGTH = ENDS_WITH_LENGTH.test(value);
        var lastSpaceIndex = value.lastIndexOf(' ');
        var _color = new _Color2.default(HAS_LENGTH ? value.substring(0, lastSpaceIndex) : value);
        var _stop = HAS_LENGTH ? new _Length2.default(value.substring(lastSpaceIndex + 1)) : i === firstColorStopIndex ? new _Length2.default('0%') : i === args.length - 1 ? new _Length2.default('100%') : null;
        colorStops.push({ color: _color, stop: _stop });
    }

    var absoluteValuedColorStops = colorStops.map(function (_ref2) {
        var color = _ref2.color,
            stop = _ref2.stop;

        var absoluteStop = lineLength === 0 ? 0 : stop ? stop.getAbsoluteValue(lineLength) / lineLength : null;

        return {
            color: color,
            // $FlowFixMe
            stop: absoluteStop
        };
    });

    var previousColorStop = absoluteValuedColorStops[0].stop;
    for (var _i = 0; _i < absoluteValuedColorStops.length; _i++) {
        if (previousColorStop !== null) {
            var _stop2 = absoluteValuedColorStops[_i].stop;
            if (_stop2 === null) {
                var n = _i;
                while (absoluteValuedColorStops[n].stop === null) {
                    n++;
                }
                var steps = n - _i + 1;
                var nextColorStep = absoluteValuedColorStops[n].stop;
                var stepSize = (nextColorStep - previousColorStop) / steps;
                for (; _i < n; _i++) {
                    previousColorStop = absoluteValuedColorStops[_i].stop = previousColorStop + stepSize;
                }
            } else {
                previousColorStop = _stop2;
            }
        }
    }

    return absoluteValuedColorStops;
};

var parseLinearGradient = function parseLinearGradient(args, bounds, hasPrefix) {
    var angle = (0, _Angle.parseAngle)(args[0]);
    var HAS_SIDE_OR_CORNER = SIDE_OR_CORNER.test(args[0]);
    var HAS_DIRECTION = HAS_SIDE_OR_CORNER || angle !== null || PERCENTAGE_ANGLES.test(args[0]);
    var direction = HAS_DIRECTION ? angle !== null ? calculateGradientDirection(
    // if there is a prefix, the 0Â° angle points due East (instead of North per W3C)
    hasPrefix ? angle - Math.PI * 0.5 : angle, bounds) : HAS_SIDE_OR_CORNER ? parseSideOrCorner(args[0], bounds) : parsePercentageAngle(args[0], bounds) : calculateGradientDirection(Math.PI, bounds);
    var firstColorStopIndex = HAS_DIRECTION ? 1 : 0;

    // TODO: Fix some inaccuracy with color stops with px values
    var lineLength = Math.min((0, _Util.distance)(Math.abs(direction.x0) + Math.abs(direction.x1), Math.abs(direction.y0) + Math.abs(direction.y1)), bounds.width * 2, bounds.height * 2);

    return new LinearGradient(parseColorStops(args, firstColorStopIndex, lineLength), direction);
};

var parseRadialGradient = function parseRadialGradient(container, args, bounds) {
    var m = args[0].match(RADIAL_SHAPE_DEFINITION);
    var shape = m && (m[1] === 'circle' || // explicit shape specification
    m[3] !== undefined && m[5] === undefined) // only one radius coordinate
    ? RADIAL_GRADIENT_SHAPE.CIRCLE : RADIAL_GRADIENT_SHAPE.ELLIPSE;
    var radius = {};
    var center = {};

    if (m) {
        // Radius
        if (m[3] !== undefined) {
            radius.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[3], m[4]).getAbsoluteValue(bounds.width);
        }

        if (m[5] !== undefined) {
            radius.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[5], m[6]).getAbsoluteValue(bounds.height);
        }

        // Position
        if (m[7]) {
            center.x = LENGTH_FOR_POSITION[m[7].toLowerCase()];
        } else if (m[8] !== undefined) {
            center.x = (0, _Length.calculateLengthFromValueWithUnit)(container, m[8], m[9]);
        }

        if (m[10]) {
            center.y = LENGTH_FOR_POSITION[m[10].toLowerCase()];
        } else if (m[11] !== undefined) {
            center.y = (0, _Length.calculateLengthFromValueWithUnit)(container, m[11], m[12]);
        }
    }

    var gradientCenter = {
        x: center.x === undefined ? bounds.width / 2 : center.x.getAbsoluteValue(bounds.width),
        y: center.y === undefined ? bounds.height / 2 : center.y.getAbsoluteValue(bounds.height)
    };
    var gradientRadius = calculateRadius(m && m[2] || 'farthest-corner', shape, gradientCenter, radius, bounds);

    return new RadialGradient(parseColorStops(args, m ? 1 : 0, Math.min(gradientRadius.x, gradientRadius.y)), shape, gradientCenter, gradientRadius);
};

var calculateGradientDirection = function calculateGradientDirection(radian, bounds) {
    var width = bounds.width;
    var height = bounds.height;
    var HALF_WIDTH = width * 0.5;
    var HALF_HEIGHT = height * 0.5;
    var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
    var HALF_LINE_LENGTH = lineLength / 2;

    var x0 = HALF_WIDTH + Math.sin(radian) * HALF_LINE_LENGTH;
    var y0 = HALF_HEIGHT - Math.cos(radian) * HALF_LINE_LENGTH;
    var x1 = width - x0;
    var y1 = height - y0;

    return { x0: x0, x1: x1, y0: y0, y1: y1 };
};

var parseTopRight = function parseTopRight(bounds) {
    return Math.acos(bounds.width / 2 / ((0, _Util.distance)(bounds.width, bounds.height) / 2));
};

var parseSideOrCorner = function parseSideOrCorner(side, bounds) {
    switch (side) {
        case 'bottom':
        case 'to top':
            return calculateGradientDirection(0, bounds);
        case 'left':
        case 'to right':
            return calculateGradientDirection(Math.PI / 2, bounds);
        case 'right':
        case 'to left':
            return calculateGradientDirection(3 * Math.PI / 2, bounds);
        case 'top right':
        case 'right top':
        case 'to bottom left':
        case 'to left bottom':
            return calculateGradientDirection(Math.PI + parseTopRight(bounds), bounds);
        case 'top left':
        case 'left top':
        case 'to bottom right':
        case 'to right bottom':
            return calculateGradientDirection(Math.PI - parseTopRight(bounds), bounds);
        case 'bottom left':
        case 'left bottom':
        case 'to top right':
        case 'to right top':
            return calculateGradientDirection(parseTopRight(bounds), bounds);
        case 'bottom right':
        case 'right bottom':
        case 'to top left':
        case 'to left top':
            return calculateGradientDirection(2 * Math.PI - parseTopRight(bounds), bounds);
        case 'top':
        case 'to bottom':
        default:
            return calculateGradientDirection(Math.PI, bounds);
    }
};

var parsePercentageAngle = function parsePercentageAngle(angle, bounds) {
    var _angle$split$map = angle.split(' ').map(parseFloat),
        _angle$split$map2 = _slicedToArray(_angle$split$map, 2),
        left = _angle$split$map2[0],
        top = _angle$split$map2[1];

    var ratio = left / 100 * bounds.width / (top / 100 * bounds.height);

    return calculateGradientDirection(Math.atan(isNaN(ratio) ? 1 : ratio) + Math.PI / 2, bounds);
};

var findCorner = function findCorner(bounds, x, y, closest) {
    var corners = [{ x: 0, y: 0 }, { x: 0, y: bounds.height }, { x: bounds.width, y: 0 }, { x: bounds.width, y: bounds.height }];

    // $FlowFixMe
    return corners.reduce(function (stat, corner) {
        var d = (0, _Util.distance)(x - corner.x, y - corner.y);
        if (closest ? d < stat.optimumDistance : d > stat.optimumDistance) {
            return {
                optimumCorner: corner,
                optimumDistance: d
            };
        }

        return stat;
    }, {
        optimumDistance: closest ? Infinity : -Infinity,
        optimumCorner: null
    }).optimumCorner;
};

var calculateRadius = function calculateRadius(extent, shape, center, radius, bounds) {
    var x = center.x;
    var y = center.y;
    var rx = 0;
    var ry = 0;

    switch (extent) {
        case 'closest-side':
            // The ending shape is sized so that that it exactly meets the side of the gradient box closest to the gradientâ€™s center.
            // If the shape is an ellipse, it exactly meets the closest side in each dimension.
            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
                rx = ry = Math.min(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));
            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
                rx = Math.min(Math.abs(x), Math.abs(x - bounds.width));
                ry = Math.min(Math.abs(y), Math.abs(y - bounds.height));
            }
            break;

        case 'closest-corner':
            // The ending shape is sized so that that it passes through the corner of the gradient box closest to the gradientâ€™s center.
            // If the shape is an ellipse, the ending shape is given the same aspect-ratio it would have if closest-side were specified.
            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
                rx = ry = Math.min((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));
            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
                // Compute the ratio ry/rx (which is to be the same as for "closest-side")
                var c = Math.min(Math.abs(y), Math.abs(y - bounds.height)) / Math.min(Math.abs(x), Math.abs(x - bounds.width));
                var corner = findCorner(bounds, x, y, true);
                rx = (0, _Util.distance)(corner.x - x, (corner.y - y) / c);
                ry = c * rx;
            }
            break;

        case 'farthest-side':
            // Same as closest-side, except the ending shape is sized based on the farthest side(s)
            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
                rx = ry = Math.max(Math.abs(x), Math.abs(x - bounds.width), Math.abs(y), Math.abs(y - bounds.height));
            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
                rx = Math.max(Math.abs(x), Math.abs(x - bounds.width));
                ry = Math.max(Math.abs(y), Math.abs(y - bounds.height));
            }
            break;

        case 'farthest-corner':
            // Same as closest-corner, except the ending shape is sized based on the farthest corner.
            // If the shape is an ellipse, the ending shape is given the same aspect ratio it would have if farthest-side were specified.
            if (shape === RADIAL_GRADIENT_SHAPE.CIRCLE) {
                rx = ry = Math.max((0, _Util.distance)(x, y), (0, _Util.distance)(x, y - bounds.height), (0, _Util.distance)(x - bounds.width, y), (0, _Util.distance)(x - bounds.width, y - bounds.height));
            } else if (shape === RADIAL_GRADIENT_SHAPE.ELLIPSE) {
                // Compute the ratio ry/rx (which is to be the same as for "farthest-side")
                var _c = Math.max(Math.abs(y), Math.abs(y - bounds.height)) / Math.max(Math.abs(x), Math.abs(x - bounds.width));
                var _corner = findCorner(bounds, x, y, false);
                rx = (0, _Util.distance)(_corner.x - x, (_corner.y - y) / _c);
                ry = _c * rx;
            }
            break;

        default:
            // pixel or percentage values
            rx = radius.x || 0;
            ry = radius.y !== undefined ? radius.y : rx;
            break;
    }

    return {
        x: rx,
        y: ry
    };
};

var transformWebkitRadialGradientArgs = exports.transformWebkitRadialGradientArgs = function transformWebkitRadialGradientArgs(args) {
    var shape = '';
    var radius = '';
    var extent = '';
    var position = '';
    var idx = 0;

    var POSITION = /^(left|center|right|\d+(?:px|r?em|%)?)(?:\s+(top|center|bottom|\d+(?:px|r?em|%)?))?$/i;
    var SHAPE_AND_EXTENT = /^(circle|ellipse)?\s*(closest-side|closest-corner|farthest-side|farthest-corner|contain|cover)?$/i;
    var RADIUS = /^\d+(px|r?em|%)?(?:\s+\d+(px|r?em|%)?)?$/i;

    var matchStartPosition = args[idx].match(POSITION);
    if (matchStartPosition) {
        idx++;
    }

    var matchShapeExtent = args[idx].match(SHAPE_AND_EXTENT);
    if (matchShapeExtent) {
        shape = matchShapeExtent[1] || '';
        extent = matchShapeExtent[2] || '';
        if (extent === 'contain') {
            extent = 'closest-side';
        } else if (extent === 'cover') {
            extent = 'farthest-corner';
        }
        idx++;
    }

    var matchStartRadius = args[idx].match(RADIUS);
    if (matchStartRadius) {
        idx++;
    }

    var matchEndPosition = args[idx].match(POSITION);
    if (matchEndPosition) {
        idx++;
    }

    var matchEndRadius = args[idx].match(RADIUS);
    if (matchEndRadius) {
        idx++;
    }

    var matchPosition = matchEndPosition || matchStartPosition;
    if (matchPosition && matchPosition[1]) {
        position = matchPosition[1] + (/^\d+$/.test(matchPosition[1]) ? 'px' : '');
        if (matchPosition[2]) {
            position += ' ' + matchPosition[2] + (/^\d+$/.test(matchPosition[2]) ? 'px' : '');
        }
    }

    var matchRadius = matchEndRadius || matchStartRadius;
    if (matchRadius) {
        radius = matchRadius[0];
        if (!matchRadius[1]) {
            radius += 'px';
        }
    }

    if (position && !shape && !radius && !extent) {
        radius = position;
        position = '';
    }

    if (position) {
        position = 'at ' + position;
    }

    return [[shape, extent, radius, position].filter(function (s) {
        return !!s;
    }).join(' ')].concat(args.slice(idx));
};

var transformObsoleteColorStops = function transformObsoleteColorStops(args) {
    return args.map(function (color) {
        return color.match(FROM_TO_COLORSTOP);
    })
    // $FlowFixMe
    .map(function (v, index) {
        if (!v) {
            return args[index];
        }

        switch (v[1]) {
            case 'from':
                return v[4] + ' 0%';
            case 'to':
                return v[4] + ' 100%';
            case 'color-stop':
                if (v[3] === '%') {
                    return v[4] + ' ' + v[2];
                }
                return v[4] + ' ' + parseFloat(v[2]) * 100 + '%';
        }
    });
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
var ANGLE = /([+-]?\d*\.?\d+)(deg|grad|rad|turn)/i;

var parseAngle = exports.parseAngle = function parseAngle(angle) {
    var match = angle.match(ANGLE);

    if (match) {
        var value = parseFloat(match[1]);
        switch (match[2].toLowerCase()) {
            case 'deg':
                return Math.PI * value / 180;
            case 'grad':
                return Math.PI / 200 * value;
            case 'rad':
                return value;
            case 'turn':
                return Math.PI * 2 * value;
        }
    }

    return null;
};

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.cloneWindow = exports.DocumentCloner = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Bounds = __webpack_require__(2);

var _Proxy = __webpack_require__(26);

var _ResourceLoader = __webpack_require__(55);

var _ResourceLoader2 = _interopRequireDefault(_ResourceLoader);

var _Util = __webpack_require__(4);

var _background = __webpack_require__(5);

var _CanvasRenderer = __webpack_require__(15);

var _CanvasRenderer2 = _interopRequireDefault(_CanvasRenderer);

var _PseudoNodeContent = __webpack_require__(56);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var IGNORE_ATTRIBUTE = 'data-html2canvas-ignore';

var DocumentCloner = exports.DocumentCloner = function () {
    function DocumentCloner(element, options, logger, copyInline, renderer) {
        _classCallCheck(this, DocumentCloner);

        this.referenceElement = element;
        this.scrolledElements = [];
        this.copyStyles = copyInline;
        this.inlineImages = copyInline;
        this.logger = logger;
        this.options = options;
        this.renderer = renderer;
        this.resourceLoader = new _ResourceLoader2.default(options, logger, window);
        this.pseudoContentData = {
            counters: {},
            quoteDepth: 0
        };
        // $FlowFixMe
        this.documentElement = this.cloneNode(element.ownerDocument.documentElement);
    }

    _createClass(DocumentCloner, [{
        key: 'inlineAllImages',
        value: function inlineAllImages(node) {
            var _this = this;

            if (this.inlineImages && node) {
                var style = node.style;
                Promise.all((0, _background.parseBackgroundImage)(style.backgroundImage).map(function (backgroundImage) {
                    if (backgroundImage.method === 'url') {
                        return _this.resourceLoader.inlineImage(backgroundImage.args[0]).then(function (img) {
                            return img && typeof img.src === 'string' ? 'url("' + img.src + '")' : 'none';
                        }).catch(function (e) {
                            if (true) {
                                _this.logger.log('Unable to load image', e);
                            }
                        });
                    }
                    return Promise.resolve('' + backgroundImage.prefix + backgroundImage.method + '(' + backgroundImage.args.join(',') + ')');
                })).then(function (backgroundImages) {
                    if (backgroundImages.length > 1) {
                        // TODO Multiple backgrounds somehow broken in Chrome
                        style.backgroundColor = '';
                    }
                    style.backgroundImage = backgroundImages.join(',');
                });

                if (node instanceof HTMLImageElement) {
                    this.resourceLoader.inlineImage(node.src).then(function (img) {
                        if (img && node instanceof HTMLImageElement && node.parentNode) {
                            var parentNode = node.parentNode;
                            var clonedChild = (0, _Util.copyCSSStyles)(node.style, img.cloneNode(false));
                            parentNode.replaceChild(clonedChild, node);
                        }
                    }).catch(function (e) {
                        if (true) {
                            _this.logger.log('Unable to load image', e);
                        }
                    });
                }
            }
        }
    }, {
        key: 'inlineFonts',
        value: function inlineFonts(document) {
            var _this2 = this;

            return Promise.all(Array.from(document.styleSheets).map(function (sheet) {
                if (sheet.href) {
                    return fetch(sheet.href).then(function (res) {
                        return res.text();
                    }).then(function (text) {
                        return createStyleSheetFontsFromText(text, sheet.href);
                    }).catch(function (e) {
                        if (true) {
                            _this2.logger.log('Unable to load stylesheet', e);
                        }
                        return [];
                    });
                }
                return getSheetFonts(sheet, document);
            })).then(function (fonts) {
                return fonts.reduce(function (acc, font) {
                    return acc.concat(font);
                }, []);
            }).then(function (fonts) {
                return Promise.all(fonts.map(function (font) {
                    return fetch(font.formats[0].src).then(function (response) {
                        return response.blob();
                    }).then(function (blob) {
                        return new Promise(function (resolve, reject) {
                            var reader = new FileReader();
                            reader.onerror = reject;
                            reader.onload = function () {
                                // $FlowFixMe
                                var result = reader.result;
                                resolve(result);
                            };
                            reader.readAsDataURL(blob);
                        });
                    }).then(function (dataUri) {
                        font.fontFace.setProperty('src', 'url("' + dataUri + '")');
                        return '@font-face {' + font.fontFace.cssText + ' ';
                    });
                }));
            }).then(function (fontCss) {
                var style = document.createElement('style');
                style.textContent = fontCss.join('\n');
                _this2.documentElement.appendChild(style);
            });
        }
    }, {
        key: 'createElementClone',
        value: function createElementClone(node) {
            var _this3 = this;

            if (this.copyStyles && node instanceof HTMLCanvasElement) {
                var img = node.ownerDocument.createElement('img');
                try {
                    img.src = node.toDataURL();
                    return img;
                } catch (e) {
                    if (true) {
                        this.logger.log('Unable to clone canvas contents, canvas is tainted');
                    }
                }
            }

            if (node instanceof HTMLIFrameElement) {
                var tempIframe = node.cloneNode(false);
                var iframeKey = generateIframeKey();
                tempIframe.setAttribute('data-html2canvas-internal-iframe-key', iframeKey);

                var _parseBounds = (0, _Bounds.parseBounds)(node, 0, 0),
                    width = _parseBounds.width,
                    height = _parseBounds.height;

                this.resourceLoader.cache[iframeKey] = getIframeDocumentElement(node, this.options).then(function (documentElement) {
                    return _this3.renderer(documentElement, {
                        async: _this3.options.async,
                        allowTaint: _this3.options.allowTaint,
                        backgroundColor: '#ffffff',
                        canvas: null,
                        imageTimeout: _this3.options.imageTimeout,
                        logging: _this3.options.logging,
                        proxy: _this3.options.proxy,
                        removeContainer: _this3.options.removeContainer,
                        scale: _this3.options.scale,
                        foreignObjectRendering: _this3.options.foreignObjectRendering,
                        useCORS: _this3.options.useCORS,
                        target: new _CanvasRenderer2.default(),
                        width: width,
                        height: height,
                        x: 0,
                        y: 0,
                        windowWidth: documentElement.ownerDocument.defaultView.innerWidth,
                        windowHeight: documentElement.ownerDocument.defaultView.innerHeight,
                        scrollX: documentElement.ownerDocument.defaultView.pageXOffset,
                        scrollY: documentElement.ownerDocument.defaultView.pageYOffset
                    }, _this3.logger.child(iframeKey));
                }).then(function (canvas) {
                    return new Promise(function (resolve, reject) {
                        var iframeCanvas = document.createElement('img');
                        iframeCanvas.onload = function () {
                            return resolve(canvas);
                        };
                        iframeCanvas.onerror = reject;
                        iframeCanvas.src = canvas.toDataURL();
                        if (tempIframe.parentNode) {
                            tempIframe.parentNode.replaceChild((0, _Util.copyCSSStyles)(node.ownerDocument.defaultView.getComputedStyle(node), iframeCanvas), tempIframe);
                        }
                    });
                });
                return tempIframe;
            }

            if (node instanceof HTMLStyleElement && node.sheet && node.sheet.cssRules) {
                var css = [].slice.call(node.sheet.cssRules, 0).reduce(function (css, rule) {
                    try {
                        if (rule && rule.cssText) {
                            return css + rule.cssText;
                        }
                        return css;
                    } catch (err) {
                        _this3.logger.log('Unable to access cssText property', rule.name);
                        return css;
                    }
                }, '');
                var style = node.cloneNode(false);
                style.textContent = css;
                return style;
            }

            return node.cloneNode(false);
        }
    }, {
        key: 'cloneNode',
        value: function cloneNode(node) {
            var clone = node.nodeType === Node.TEXT_NODE ? document.createTextNode(node.nodeValue) : this.createElementClone(node);

            var window = node.ownerDocument.defaultView;
            var style = node instanceof window.HTMLElement ? window.getComputedStyle(node) : null;
            var styleBefore = node instanceof window.HTMLElement ? window.getComputedStyle(node, ':before') : null;
            var styleAfter = node instanceof window.HTMLElement ? window.getComputedStyle(node, ':after') : null;

            if (this.referenceElement === node && clone instanceof window.HTMLElement) {
                this.clonedReferenceElement = clone;
            }

            if (clone instanceof window.HTMLBodyElement) {
                createPseudoHideStyles(clone);
            }

            var counters = (0, _PseudoNodeContent.parseCounterReset)(style, this.pseudoContentData);
            var contentBefore = (0, _PseudoNodeContent.resolvePseudoContent)(node, styleBefore, this.pseudoContentData);

            for (var child = node.firstChild; child; child = child.nextSibling) {
                if (child.nodeType !== Node.ELEMENT_NODE || child.nodeName !== 'SCRIPT' &&
                // $FlowFixMe
                !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== 'function' ||
                // $FlowFixMe
                !this.options.ignoreElements(child))) {
                    if (!this.copyStyles || child.nodeName !== 'STYLE') {
                        clone.appendChild(this.cloneNode(child));
                    }
                }
            }

            var contentAfter = (0, _PseudoNodeContent.resolvePseudoContent)(node, styleAfter, this.pseudoContentData);
            (0, _PseudoNodeContent.popCounters)(counters, this.pseudoContentData);

            if (node instanceof window.HTMLElement && clone instanceof window.HTMLElement) {
                if (styleBefore) {
                    this.inlineAllImages(inlinePseudoElement(node, clone, styleBefore, contentBefore, PSEUDO_BEFORE));
                }
                if (styleAfter) {
                    this.inlineAllImages(inlinePseudoElement(node, clone, styleAfter, contentAfter, PSEUDO_AFTER));
                }
                if (style && this.copyStyles && !(node instanceof HTMLIFrameElement)) {
                    (0, _Util.copyCSSStyles)(style, clone);
                }
                this.inlineAllImages(clone);
                if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
                    this.scrolledElements.push([clone, node.scrollLeft, node.scrollTop]);
                }
                switch (node.nodeName) {
                    case 'CANVAS':
                        if (!this.copyStyles) {
                            cloneCanvasContents(node, clone);
                        }
                        break;
                    case 'TEXTAREA':
                    case 'SELECT':
                        clone.value = node.value;
                        break;
                }
            }
            return clone;
        }
    }]);

    return DocumentCloner;
}();

var getSheetFonts = function getSheetFonts(sheet, document) {
    // $FlowFixMe
    return (sheet.cssRules ? Array.from(sheet.cssRules) : []).filter(function (rule) {
        return rule.type === CSSRule.FONT_FACE_RULE;
    }).map(function (rule) {
        var src = (0, _background.parseBackgroundImage)(rule.style.getPropertyValue('src'));
        var formats = [];
        for (var i = 0; i < src.length; i++) {
            if (src[i].method === 'url' && src[i + 1] && src[i + 1].method === 'format') {
                var a = document.createElement('a');
                a.href = src[i].args[0];
                if (document.body) {
                    document.body.appendChild(a);
                }

                var font = {
                    src: a.href,
                    format: src[i + 1].args[0]
                };
                formats.push(font);
            }
        }

        return {
            // TODO select correct format for browser),

            formats: formats.filter(function (font) {
                return (/^woff/i.test(font.format)
                );
            }),
            fontFace: rule.style
        };
    }).filter(function (font) {
        return font.formats.length;
    });
};

var createStyleSheetFontsFromText = function createStyleSheetFontsFromText(text, baseHref) {
    var doc = document.implementation.createHTMLDocument('');
    var base = document.createElement('base');
    // $FlowFixMe
    base.href = baseHref;
    var style = document.createElement('style');

    style.textContent = text;
    if (doc.head) {
        doc.head.appendChild(base);
    }
    if (doc.body) {
        doc.body.appendChild(style);
    }

    return style.sheet ? getSheetFonts(style.sheet, doc) : [];
};

var restoreOwnerScroll = function restoreOwnerScroll(ownerDocument, x, y) {
    if (ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
        ownerDocument.defaultView.scrollTo(x, y);
    }
};

var cloneCanvasContents = function cloneCanvasContents(canvas, clonedCanvas) {
    try {
        if (clonedCanvas) {
            clonedCanvas.width = canvas.width;
            clonedCanvas.height = canvas.height;
            var ctx = canvas.getContext('2d');
            var clonedCtx = clonedCanvas.getContext('2d');
            if (ctx) {
                clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            } else {
                clonedCtx.drawImage(canvas, 0, 0);
            }
        }
    } catch (e) {}
};

var inlinePseudoElement = function inlinePseudoElement(node, clone, style, contentItems, pseudoElt) {
    if (!style || !style.content || style.content === 'none' || style.content === '-moz-alt-content' || style.display === 'none') {
        return;
    }

    var anonymousReplacedElement = clone.ownerDocument.createElement('html2canvaspseudoelement');
    (0, _Util.copyCSSStyles)(style, anonymousReplacedElement);

    if (contentItems) {
        var len = contentItems.length;
        for (var i = 0; i < len; i++) {
            var item = contentItems[i];
            switch (item.type) {
                case _PseudoNodeContent.PSEUDO_CONTENT_ITEM_TYPE.IMAGE:
                    var img = clone.ownerDocument.createElement('img');
                    img.src = (0, _background.parseBackgroundImage)('url(' + item.value + ')')[0].args[0];
                    img.style.opacity = '1';
                    anonymousReplacedElement.appendChild(img);
                    break;
                case _PseudoNodeContent.PSEUDO_CONTENT_ITEM_TYPE.TEXT:
                    anonymousReplacedElement.appendChild(clone.ownerDocument.createTextNode(item.value));
                    break;
            }
        }
    }

    anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ' ' + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    clone.className += pseudoElt === PSEUDO_BEFORE ? ' ' + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : ' ' + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    if (pseudoElt === PSEUDO_BEFORE) {
        clone.insertBefore(anonymousReplacedElement, clone.firstChild);
    } else {
        clone.appendChild(anonymousReplacedElement);
    }

    return anonymousReplacedElement;
};

var URL_REGEXP = /^url\((.+)\)$/i;
var PSEUDO_BEFORE = ':before';
var PSEUDO_AFTER = ':after';
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before';
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after';

var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';

var createPseudoHideStyles = function createPseudoHideStyles(body) {
    createStyles(body, '.' + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + '\n         .' + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};

var createStyles = function createStyles(body, styles) {
    var style = body.ownerDocument.createElement('style');
    style.innerHTML = styles;
    body.appendChild(style);
};

var initNode = function initNode(_ref) {
    var _ref2 = _slicedToArray(_ref, 3),
        element = _ref2[0],
        x = _ref2[1],
        y = _ref2[2];

    element.scrollLeft = x;
    element.scrollTop = y;
};

var generateIframeKey = function generateIframeKey() {
    return Math.ceil(Date.now() + Math.random() * 10000000).toString(16);
};

var DATA_URI_REGEXP = /^data:text\/(.+);(base64)?,(.*)$/i;

var getIframeDocumentElement = function getIframeDocumentElement(node, options) {
    try {
        return Promise.resolve(node.contentWindow.document.documentElement);
    } catch (e) {
        return options.proxy ? (0, _Proxy.Proxy)(node.src, options).then(function (html) {
            var match = html.match(DATA_URI_REGEXP);
            if (!match) {
                return Promise.reject();
            }

            return match[2] === 'base64' ? window.atob(decodeURIComponent(match[3])) : decodeURIComponent(match[3]);
        }).then(function (html) {
            return createIframeContainer(node.ownerDocument, (0, _Bounds.parseBounds)(node, 0, 0)).then(function (cloneIframeContainer) {
                var cloneWindow = cloneIframeContainer.contentWindow;
                var documentClone = cloneWindow.document;

                documentClone.open();
                documentClone.write(html);
                var iframeLoad = iframeLoader(cloneIframeContainer).then(function () {
                    return documentClone.documentElement;
                });

                documentClone.close();
                return iframeLoad;
            });
        }) : Promise.reject();
    }
};

var createIframeContainer = function createIframeContainer(ownerDocument, bounds) {
    var cloneIframeContainer = ownerDocument.createElement('iframe');

    cloneIframeContainer.className = 'html2canvas-container';
    cloneIframeContainer.style.visibility = 'hidden';
    cloneIframeContainer.style.position = 'fixed';
    cloneIframeContainer.style.left = '-10000px';
    cloneIframeContainer.style.top = '0px';
    cloneIframeContainer.style.border = '0';
    cloneIframeContainer.width = bounds.width.toString();
    cloneIframeContainer.height = bounds.height.toString();
    cloneIframeContainer.scrolling = 'no'; // ios won't scroll without it
    cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, 'true');
    if (!ownerDocument.body) {
        return Promise.reject( true ? 'Body element not found in Document that is getting rendered' : '');
    }

    ownerDocument.body.appendChild(cloneIframeContainer);

    return Promise.resolve(cloneIframeContainer);
};

var iframeLoader = function iframeLoader(cloneIframeContainer) {
    var cloneWindow = cloneIframeContainer.contentWindow;
    var documentClone = cloneWindow.document;

    return new Promise(function (resolve, reject) {
        cloneWindow.onload = cloneIframeContainer.onload = documentClone.onreadystatechange = function () {
            var interval = setInterval(function () {
                if (documentClone.body.childNodes.length > 0 && documentClone.readyState === 'complete') {
                    clearInterval(interval);
                    resolve(cloneIframeContainer);
                }
            }, 50);
        };
    });
};

var cloneWindow = exports.cloneWindow = function cloneWindow(ownerDocument, bounds, referenceElement, options, logger, renderer) {
    var cloner = new DocumentCloner(referenceElement, options, logger, false, renderer);
    var scrollX = ownerDocument.defaultView.pageXOffset;
    var scrollY = ownerDocument.defaultView.pageYOffset;

    return createIframeContainer(ownerDocument, bounds).then(function (cloneIframeContainer) {
        var cloneWindow = cloneIframeContainer.contentWindow;
        var documentClone = cloneWindow.document;

        /* Chrome doesn't detect relative background-images assigned in inline <style> sheets when fetched through getComputedStyle
             if window url is about:blank, we can assign the url to current by writing onto the document
             */

        var iframeLoad = iframeLoader(cloneIframeContainer).then(function () {
            cloner.scrolledElements.forEach(initNode);
            cloneWindow.scrollTo(bounds.left, bounds.top);
            if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== bounds.top || cloneWindow.scrollX !== bounds.left)) {
                documentClone.documentElement.style.top = -bounds.top + 'px';
                documentClone.documentElement.style.left = -bounds.left + 'px';
                documentClone.documentElement.style.position = 'absolute';
            }

            var result = Promise.resolve([cloneIframeContainer, cloner.clonedReferenceElement, cloner.resourceLoader]);

            var onclone = options.onclone;

            return cloner.clonedReferenceElement instanceof cloneWindow.HTMLElement || cloner.clonedReferenceElement instanceof ownerDocument.defaultView.HTMLElement || cloner.clonedReferenceElement instanceof HTMLElement ? typeof onclone === 'function' ? Promise.resolve().then(function () {
                return onclone(documentClone);
            }).then(function () {
                return result;
            }) : result : Promise.reject( true ? 'Error finding the ' + referenceElement.nodeName + ' in the cloned document' : '');
        });

        documentClone.open();
        documentClone.write(serializeDoctype(document.doctype) + '<html></html>');
        // Chrome scrolls the parent document for some reason after the write to the cloned window???
        restoreOwnerScroll(referenceElement.ownerDocument, scrollX, scrollY);
        documentClone.replaceChild(documentClone.adoptNode(cloner.documentElement), documentClone.documentElement);
        documentClone.close();

        return iframeLoad;
    });
};

var serializeDoctype = function serializeDoctype(doctype) {
    var str = '';
    if (doctype) {
        str += '<!DOCTYPE ';
        if (doctype.name) {
            str += doctype.name;
        }

        if (doctype.internalSubset) {
            str += doctype.internalSubset;
        }

        if (doctype.publicId) {
            str += '"' + doctype.publicId + '"';
        }

        if (doctype.systemId) {
            str += '"' + doctype.systemId + '"';
        }

        str += '>';
    }

    return str;
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceStore = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Feature = __webpack_require__(10);

var _Feature2 = _interopRequireDefault(_Feature);

var _Proxy = __webpack_require__(26);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ResourceLoader = function () {
    function ResourceLoader(options, logger, window) {
        _classCallCheck(this, ResourceLoader);

        this.options = options;
        this._window = window;
        this.origin = this.getOrigin(window.location.href);
        this.cache = {};
        this.logger = logger;
        this._index = 0;
    }

    _createClass(ResourceLoader, [{
        key: 'loadImage',
        value: function loadImage(src) {
            var _this = this;

            if (this.hasResourceInCache(src)) {
                return src;
            }
            if (isBlobImage(src)) {
                this.cache[src] = _loadImage(src, this.options.imageTimeout || 0);
                return src;
            }

            if (!isSVG(src) || _Feature2.default.SUPPORT_SVG_DRAWING) {
                if (this.options.allowTaint === true || isInlineImage(src) || this.isSameOrigin(src)) {
                    return this.addImage(src, src, false);
                } else if (!this.isSameOrigin(src)) {
                    if (typeof this.options.proxy === 'string') {
                        this.cache[src] = (0, _Proxy.Proxy)(src, this.options).then(function (src) {
                            return _loadImage(src, _this.options.imageTimeout || 0);
                        });
                        return src;
                    } else if (this.options.useCORS === true && _Feature2.default.SUPPORT_CORS_IMAGES) {
                        return this.addImage(src, src, true);
                    }
                }
            }
        }
    }, {
        key: 'inlineImage',
        value: function inlineImage(src) {
            var _this2 = this;

            if (isInlineImage(src)) {
                return _loadImage(src, this.options.imageTimeout || 0);
            }
            if (this.hasResourceInCache(src)) {
                return this.cache[src];
            }
            if (!this.isSameOrigin(src) && typeof this.options.proxy === 'string') {
                return this.cache[src] = (0, _Proxy.Proxy)(src, this.options).then(function (src) {
                    return _loadImage(src, _this2.options.imageTimeout || 0);
                });
            }

            return this.xhrImage(src);
        }
    }, {
        key: 'xhrImage',
        value: function xhrImage(src) {
            var _this3 = this;

            this.cache[src] = new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.onreadystatechange = function () {
                    if (xhr.readyState === 4) {
                        if (xhr.status !== 200) {
                            reject('Failed to fetch image ' + src.substring(0, 256) + ' with status code ' + xhr.status);
                        } else {
                            var reader = new FileReader();
                            reader.addEventListener('load', function () {
                                // $FlowFixMe
                                var result = reader.result;
                                resolve(result);
                            }, false);
                            reader.addEventListener('error', function (e) {
                                return reject(e);
                            }, false);
                            reader.readAsDataURL(xhr.response);
                        }
                    }
                };
                xhr.responseType = 'blob';
                if (_this3.options.imageTimeout) {
                    var timeout = _this3.options.imageTimeout;
                    xhr.timeout = timeout;
                    xhr.ontimeout = function () {
                        return reject( true ? 'Timed out (' + timeout + 'ms) fetching ' + src.substring(0, 256) : '');
                    };
                }
                xhr.open('GET', src, true);
                xhr.send();
            }).then(function (src) {
                return _loadImage(src, _this3.options.imageTimeout || 0);
            });

            return this.cache[src];
        }
    }, {
        key: 'loadCanvas',
        value: function loadCanvas(node) {
            var key = String(this._index++);
            this.cache[key] = Promise.resolve(node);
            return key;
        }
    }, {
        key: 'hasResourceInCache',
        value: function hasResourceInCache(key) {
            return typeof this.cache[key] !== 'undefined';
        }
    }, {
        key: 'addImage',
        value: function addImage(key, src, useCORS) {
            var _this4 = this;

            if (true) {
                this.logger.log('Added image ' + key.substring(0, 256));
            }

            var imageLoadHandler = function imageLoadHandler(supportsDataImages) {
                return new Promise(function (resolve, reject) {
                    var img = new Image();
                    img.onload = function () {
                        return resolve(img);
                    };
                    //ios safari 10.3 taints canvas with data urls unless crossOrigin is set to anonymous
                    if (!supportsDataImages || useCORS) {
                        img.crossOrigin = 'anonymous';
                    }

                    img.onerror = reject;
                    img.src = src;
                    if (img.complete === true) {
                        // Inline XML images may fail to parse, throwing an Error later on
                        setTimeout(function () {
                            resolve(img);
                        }, 500);
                    }
                    if (_this4.options.imageTimeout) {
                        var timeout = _this4.options.imageTimeout;
                        setTimeout(function () {
                            return reject( true ? 'Timed out (' + timeout + 'ms) fetching ' + src.substring(0, 256) : '');
                        }, timeout);
                    }
                });
            };

            this.cache[key] = isInlineBase64Image(src) && !isSVG(src) ? // $FlowFixMe
            _Feature2.default.SUPPORT_BASE64_DRAWING(src).then(imageLoadHandler) : imageLoadHandler(true);
            return key;
        }
    }, {
        key: 'isSameOrigin',
        value: function isSameOrigin(url) {
            return this.getOrigin(url) === this.origin;
        }
    }, {
        key: 'getOrigin',
        value: function getOrigin(url) {
            var link = this._link || (this._link = this._window.document.createElement('a'));
            link.href = url;
            link.href = link.href; // IE9, LOL! - http://jsfiddle.net/niklasvh/2e48b/
            return link.protocol + link.hostname + link.port;
        }
    }, {
        key: 'ready',
        value: function ready() {
            var _this5 = this;

            var keys = Object.keys(this.cache);
            var values = keys.map(function (str) {
                return _this5.cache[str].catch(function (e) {
                    if (true) {
                        _this5.logger.log('Unable to load image', e);
                    }
                    return null;
                });
            });
            return Promise.all(values).then(function (images) {
                if (true) {
                    _this5.logger.log('Finished loading ' + images.length + ' images', images);
                }
                return new ResourceStore(keys, images);
            });
        }
    }]);

    return ResourceLoader;
}();

exports.default = ResourceLoader;

var ResourceStore = exports.ResourceStore = function () {
    function ResourceStore(keys, resources) {
        _classCallCheck(this, ResourceStore);

        this._keys = keys;
        this._resources = resources;
    }

    _createClass(ResourceStore, [{
        key: 'get',
        value: function get(key) {
            var index = this._keys.indexOf(key);
            return index === -1 ? null : this._resources[index];
        }
    }]);

    return ResourceStore;
}();

var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;

var isInlineImage = function isInlineImage(src) {
    return INLINE_IMG.test(src);
};
var isInlineBase64Image = function isInlineBase64Image(src) {
    return INLINE_BASE64.test(src);
};
var isBlobImage = function isBlobImage(src) {
    return src.substr(0, 4) === 'blob';
};

var isSVG = function isSVG(src) {
    return src.substr(-3).toLowerCase() === 'svg' || INLINE_SVG.test(src);
};

var _loadImage = function _loadImage(src, timeout) {
    return new Promise(function (resolve, reject) {
        var img = new Image();
        img.onload = function () {
            return resolve(img);
        };
        img.onerror = reject;
        img.src = src;
        if (img.complete === true) {
            // Inline XML images may fail to parse, throwing an Error later on
            setTimeout(function () {
                resolve(img);
            }, 500);
        }
        if (timeout) {
            setTimeout(function () {
                return reject( true ? 'Timed out (' + timeout + 'ms) loading image' : '');
            }, timeout);
        }
    });
};

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseContent = exports.resolvePseudoContent = exports.popCounters = exports.parseCounterReset = exports.TOKEN_TYPE = exports.PSEUDO_CONTENT_ITEM_TYPE = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _ListItem = __webpack_require__(14);

var _listStyle = __webpack_require__(8);

var PSEUDO_CONTENT_ITEM_TYPE = exports.PSEUDO_CONTENT_ITEM_TYPE = {
    TEXT: 0,
    IMAGE: 1
};

var TOKEN_TYPE = exports.TOKEN_TYPE = {
    STRING: 0,
    ATTRIBUTE: 1,
    URL: 2,
    COUNTER: 3,
    COUNTERS: 4,
    OPENQUOTE: 5,
    CLOSEQUOTE: 6
};

var parseCounterReset = exports.parseCounterReset = function parseCounterReset(style, data) {
    if (!style || !style.counterReset || style.counterReset === 'none') {
        return [];
    }

    var counterNames = [];
    var counterResets = style.counterReset.split(/\s*,\s*/);
    var lenCounterResets = counterResets.length;

    for (var i = 0; i < lenCounterResets; i++) {
        var _counterResets$i$spli = counterResets[i].split(/\s+/),
            _counterResets$i$spli2 = _slicedToArray(_counterResets$i$spli, 2),
            counterName = _counterResets$i$spli2[0],
            initialValue = _counterResets$i$spli2[1];

        counterNames.push(counterName);
        var counter = data.counters[counterName];
        if (!counter) {
            counter = data.counters[counterName] = [];
        }
        counter.push(parseInt(initialValue || 0, 10));
    }

    return counterNames;
};

var popCounters = exports.popCounters = function popCounters(counterNames, data) {
    var lenCounters = counterNames.length;
    for (var i = 0; i < lenCounters; i++) {
        data.counters[counterNames[i]].pop();
    }
};

var resolvePseudoContent = exports.resolvePseudoContent = function resolvePseudoContent(node, style, data) {
    if (!style || !style.content || style.content === 'none' || style.content === '-moz-alt-content' || style.display === 'none') {
        return null;
    }

    var tokens = parseContent(style.content);

    var len = tokens.length;
    var contentItems = [];
    var s = '';

    // increment the counter (if there is a "counter-increment" declaration)
    var counterIncrement = style.counterIncrement;
    if (counterIncrement && counterIncrement !== 'none') {
        var _counterIncrement$spl = counterIncrement.split(/\s+/),
            _counterIncrement$spl2 = _slicedToArray(_counterIncrement$spl, 2),
            counterName = _counterIncrement$spl2[0],
            incrementValue = _counterIncrement$spl2[1];

        var counter = data.counters[counterName];
        if (counter) {
            counter[counter.length - 1] += incrementValue === undefined ? 1 : parseInt(incrementValue, 10);
        }
    }

    // build the content string
    for (var i = 0; i < len; i++) {
        var token = tokens[i];
        switch (token.type) {
            case TOKEN_TYPE.STRING:
                s += token.value || '';
                break;

            case TOKEN_TYPE.ATTRIBUTE:
                if (node instanceof HTMLElement && token.value) {
                    s += node.getAttribute(token.value) || '';
                }
                break;

            case TOKEN_TYPE.COUNTER:
                var _counter = data.counters[token.name || ''];
                if (_counter) {
                    s += formatCounterValue([_counter[_counter.length - 1]], '', token.format);
                }
                break;

            case TOKEN_TYPE.COUNTERS:
                var _counters = data.counters[token.name || ''];
                if (_counters) {
                    s += formatCounterValue(_counters, token.glue, token.format);
                }
                break;

            case TOKEN_TYPE.OPENQUOTE:
                s += getQuote(style, true, data.quoteDepth);
                data.quoteDepth++;
                break;

            case TOKEN_TYPE.CLOSEQUOTE:
                data.quoteDepth--;
                s += getQuote(style, false, data.quoteDepth);
                break;

            case TOKEN_TYPE.URL:
                if (s) {
                    contentItems.push({ type: PSEUDO_CONTENT_ITEM_TYPE.TEXT, value: s });
                    s = '';
                }
                contentItems.push({ type: PSEUDO_CONTENT_ITEM_TYPE.IMAGE, value: token.value || '' });
                break;
        }
    }

    if (s) {
        contentItems.push({ type: PSEUDO_CONTENT_ITEM_TYPE.TEXT, value: s });
    }

    return contentItems;
};

var parseContent = exports.parseContent = function parseContent(content, cache) {
    if (cache && cache[content]) {
        return cache[content];
    }

    var tokens = [];
    var len = content.length;

    var isString = false;
    var isEscaped = false;
    var isFunction = false;
    var str = '';
    var functionName = '';
    var args = [];

    for (var i = 0; i < len; i++) {
        var c = content.charAt(i);

        switch (c) {
            case "'":
            case '"':
                if (isEscaped) {
                    str += c;
                } else {
                    isString = !isString;
                    if (!isFunction && !isString) {
                        tokens.push({ type: TOKEN_TYPE.STRING, value: str });
                        str = '';
                    }
                }
                break;

            case '\\':
                if (isEscaped) {
                    str += c;
                    isEscaped = false;
                } else {
                    isEscaped = true;
                }
                break;

            case '(':
                if (isString) {
                    str += c;
                } else {
                    isFunction = true;
                    functionName = str;
                    str = '';
                    args = [];
                }
                break;

            case ')':
                if (isString) {
                    str += c;
                } else if (isFunction) {
                    if (str) {
                        args.push(str);
                    }

                    switch (functionName) {
                        case 'attr':
                            if (args.length > 0) {
                                tokens.push({ type: TOKEN_TYPE.ATTRIBUTE, value: args[0] });
                            }
                            break;

                        case 'counter':
                            if (args.length > 0) {
                                var counter = {
                                    type: TOKEN_TYPE.COUNTER,
                                    name: args[0]
                                };
                                if (args.length > 1) {
                                    counter.format = args[1];
                                }
                                tokens.push(counter);
                            }
                            break;

                        case 'counters':
                            if (args.length > 0) {
                                var _counters2 = {
                                    type: TOKEN_TYPE.COUNTERS,
                                    name: args[0]
                                };
                                if (args.length > 1) {
                                    _counters2.glue = args[1];
                                }
                                if (args.length > 2) {
                                    _counters2.format = args[2];
                                }
                                tokens.push(_counters2);
                            }
                            break;

                        case 'url':
                            if (args.length > 0) {
                                tokens.push({ type: TOKEN_TYPE.URL, value: args[0] });
                            }
                            break;
                    }

                    isFunction = false;
                    str = '';
                }
                break;

            case ',':
                if (isString) {
                    str += c;
                } else if (isFunction) {
                    args.push(str);
                    str = '';
                }
                break;

            case ' ':
            case '\t':
                if (isString) {
                    str += c;
                } else if (str) {
                    addOtherToken(tokens, str);
                    str = '';
                }
                break;

            default:
                str += c;
        }

        if (c !== '\\') {
            isEscaped = false;
        }
    }

    if (str) {
        addOtherToken(tokens, str);
    }

    if (cache) {
        cache[content] = tokens;
    }

    return tokens;
};

var addOtherToken = function addOtherToken(tokens, identifier) {
    switch (identifier) {
        case 'open-quote':
            tokens.push({ type: TOKEN_TYPE.OPENQUOTE });
            break;
        case 'close-quote':
            tokens.push({ type: TOKEN_TYPE.CLOSEQUOTE });
            break;
    }
};

var getQuote = function getQuote(style, isOpening, quoteDepth) {
    var quotes = style.quotes ? style.quotes.split(/\s+/) : ["'\"'", "'\"'"];
    var idx = quoteDepth * 2;
    if (idx >= quotes.length) {
        idx = quotes.length - 2;
    }
    if (!isOpening) {
        ++idx;
    }
    return quotes[idx].replace(/^["']|["']$/g, '');
};

var formatCounterValue = function formatCounterValue(counter, glue, format) {
    var len = counter.length;
    var result = '';

    for (var i = 0; i < len; i++) {
        if (i > 0) {
            result += glue || '';
        }
        result += (0, _ListItem.createCounterText)(counter[i], (0, _listStyle.parseListStyleType)(format || 'decimal'), false);
    }

    return result;
};

/***/ })
/******/ ]);
});



//-----------------------------------------------XLSX EXPORTER------------------------------------

/*! FileSaver.js
 *  A saveAs() FileSaver implementation.
 *  2014-01-24
 *
 *  By Eli Grey, http://eligrey.com
 *  License: X11/MIT
 *    See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
	// IE 10+ (native saveAs)
	 || (typeof navigator !== "undefined" &&
		navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
	// Everyone else
	 || (function (view) {
		"use strict";
		// IE <10 is explicitly unsupported
		if (typeof navigator !== "undefined" &&
			/MSIE [1-9]\./.test(navigator.userAgent)) {
			return;
		}
		var
		doc = view.document
			// only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
	,
		get_URL = function () {
			return view.URL || view.webkitURL || view;
		},
		URL = view.URL || view.webkitURL || view,
		save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
		can_use_save_link = !view.externalHost && "download" in save_link,
		click = function (node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
			node.dispatchEvent(event);
		},
		webkit_req_fs = view.webkitRequestFileSystem,
		req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
		throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function () {
				throw ex;
			}, 0);
		},
		force_saveable_type = "application/octet-stream",
		fs_min_size = 0,
		deletion_queue = [],
		process_deletion_queue = function () {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					URL.revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		},
		dispatch = function (filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		},
		FileSaver = function (blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
			filesaver = this,
			type = blob.type,
			blob_changed = false,
			object_url,
			target_view,
			get_object_url = function () {
				var object_url = get_URL().createObjectURL(blob);
				deletion_queue.push(object_url);
				return object_url;
			},
			dispatch_all = function () {
				dispatch(filesaver, "writestart progress write writeend".split(" "));
			}
			// on any filesys errors revert to saving with object URLs
		,
			fs_error = function () {
				// don't create more object URLs than needed
				if (blob_changed || !object_url) {
					object_url = get_object_url(blob);
				}
				if (target_view) {
					target_view.location.href = object_url;
				} else {
					if (navigator.userAgent.match(/7\.[\d\s\.]+Safari/) // is Safari 7.x
						 && typeof window.FileReader !== "undefined" // can convert to base64
						 && blob.size <= 1024 * 1024 * 150 // file size max 150MB
					)
					{
						var reader = new window.FileReader();
						reader.readAsDataURL(blob);
						reader.onloadend = function () {
							var frame = doc.createElement("iframe");
							frame.src = reader.result;
							frame.style.display = "none";
							doc.body.appendChild(frame);
							dispatch_all();
							return;
						}
						filesaver.readyState = filesaver.DONE;
						filesaver.savedAs = filesaver.SAVEDASUNKNOWN;
						return;
					} else {
						window.open(object_url, "_blank");
						filesaver.readyState = filesaver.DONE;
						filesaver.savedAs = filesaver.SAVEDASBLOB;
						dispatch_all();
						return;
					}
				}
			},
			abortable = function (func) {
				return function () {
					if (filesaver.readyState !== filesaver.DONE) {
						return func.apply(this, arguments);
					}
				};
			},
			create_if_not_found = {
				create : true,
				exclusive : false
			},
			slice;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				// FF for Android has a nasty garbage collection mechanism
				// that turns all objects that are not pure javascript into 'deadObject'
				// this means `doc` and `save_link` are unusable and need to be recreated
				// `view` is usable though:
				doc = view.document;
				save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a");
				save_link.href = object_url;
				save_link.download = name;
				var event = doc.createEvent("MouseEvents");
				event.initMouseEvent(
					"click", true, false, view, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
				save_link.dispatchEvent(event);
				filesaver.readyState = filesaver.DONE;
				filesaver.savedAs = filesaver.SAVEDASBLOB;
				dispatch_all();
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function (fs) {
					fs.root.getDirectory("saved", create_if_not_found, abortable(function (dir) {
							var save = function () {
								dir.getFile(name, create_if_not_found, abortable(function (file) {
										file.createWriter(abortable(function (writer) {
												writer.onwriteend = function (event) {
													target_view.location.href = file.toURL();
													deletion_queue.push(file);
													filesaver.readyState = filesaver.DONE;
													filesaver.savedAs = filesaver.SAVEDASBLOB;
													dispatch(filesaver, "writeend", event);
												};
												writer.onerror = function () {
													var error = writer.error;
													if (error.code !== error.ABORT_ERR) {
														fs_error();
													}
												};
												"writestart progress write abort".split(" ").forEach(function (event) {
													writer["on" + event] = filesaver["on" + event];
												});
												writer.write(blob);
												filesaver.abort = function () {
													writer.abort();
													filesaver.readyState = filesaver.DONE;
													filesaver.savedAs = filesaver.FAILED;
												};
												filesaver.readyState = filesaver.WRITING;
											}), fs_error);
									}), fs_error);
							};
							dir.getFile(name, {
								create : false
							}, abortable(function (file) {
									// delete file if it already exists
									file.remove();
									save();
								}), abortable(function (ex) {
									if (ex.code === ex.NOT_FOUND_ERR) {
										save();
									} else {
										fs_error();
									}
								}));
						}), fs_error);
				}), fs_error);
		},
		FS_proto = FileSaver.prototype,
		saveAs = function (blob, name) {
			return new FileSaver(blob, name);
		};
		FS_proto.abort = function () {
			var filesaver = this;
			filesaver.readyState = filesaver.DONE;
			filesaver.savedAs = filesaver.FAILED;
			dispatch(filesaver, "abort");
		};
		FS_proto.readyState = FS_proto.INIT = 0;
		FS_proto.WRITING = 1;
		FS_proto.DONE = 2;
		FS_proto.FAILED = -1;
		FS_proto.SAVEDASBLOB = 1;
		FS_proto.SAVEDASURI = 2;
		FS_proto.SAVEDASUNKNOWN = 3;

		FS_proto.error =
			FS_proto.onwritestart =
			FS_proto.onprogress =
			FS_proto.onwrite =
			FS_proto.onabort =
			FS_proto.onerror =
			FS_proto.onwriteend =
			null;

		view.addEventListener("unload", process_deletion_queue, false);
		saveAs.unload = function () {
			process_deletion_queue();
			view.removeEventListener("unload", process_deletion_queue, false);
		};
		return saveAs;
	}(	typeof self !== "undefined" && self
			 || typeof window !== "undefined" && window
			 || this.content));
// `self` is undefined in Firefox for Android content script context
// while `this` is nsIContentFrameMessageManager
// with an attribute `content` that corresponds to the window

if (typeof module !== "undefined" && module !== null) {
	module.exports = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {
	define([], function () {
		return saveAs;
	});
} else if (typeof Meteor !== 'undefined') { // make it available for Meteor
	Meteor.saveAs = saveAs;
};

/* Blob.js
 * A Blob implementation.
 * 2014-05-27
 *
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

(function (view) {
	"use strict";

	view.URL = view.URL || view.webkitURL;

	if (view.Blob && view.URL) {
		try {
			new Blob;
			return;
		} catch (e) {}
	}

	// Internally we use a BlobBuilder implementation to base Blob off of
	// in order to support older browsers that only have BlobBuilder
	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || (function (view) {
			var
			get_class = function (object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			},
			FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			},
			FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			},
			FBB_proto = FakeBlobBuilder.prototype,
			FB_proto = FakeBlob.prototype,
			FileReaderSync = view.FileReaderSync,
			FileException = function (type) {
				this.code = this[this.name = type];
			},
			file_ex_codes = (
				"NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				 + "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR").split(" "),
			file_ex_code = file_ex_codes.length,
			real_URL = view.URL || view.webkitURL || view,
			real_create_object_URL = real_URL.createObjectURL,
			real_revoke_object_URL = real_URL.revokeObjectURL,
			URL = real_URL,
			btoa = view.btoa,
			atob = view.atob,
			ArrayBuffer = view.ArrayBuffer,
			Uint8Array = view.Uint8Array;
			FakeBlob.fake = FB_proto.fake = true;
			while (file_ex_code--) {
				FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
			}
			if (!real_URL.createObjectURL) {
				URL = view.URL = {};
			}
			URL.createObjectURL = function (blob) {
				var
				type = blob.type,
				data_URI_header;
				if (type === null) {
					type = "application/octet-stream";
				}
				if (blob instanceof FakeBlob) {
					data_URI_header = "data:" + type;
					if (blob.encoding === "base64") {
						return data_URI_header + ";base64," + blob.data;
					} else if (blob.encoding === "URI") {
						return data_URI_header + "," + decodeURIComponent(blob.data);
					}
					if (btoa) {
						return data_URI_header + ";base64," + btoa(blob.data);
					} else {
						return data_URI_header + "," + encodeURIComponent(blob.data);
					}
				} else if (real_create_object_URL) {
					return real_create_object_URL.call(real_URL, blob);
				}
			};
			URL.revokeObjectURL = function (object_URL) {
				if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
					real_revoke_object_URL.call(real_URL, object_URL);
				}
			};
			FBB_proto.append = function (data /*, endings*/
			) {
				var bb = this.data;
				// decode data to a binary string
				if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
					var
					str = "",
					buf = new Uint8Array(data),
					i = 0,
					buf_len = buf.length;
					for (; i < buf_len; i++) {
						str += String.fromCharCode(buf[i]);
					}
					bb.push(str);
				} else if (get_class(data) === "Blob" || get_class(data) === "File") {
					if (FileReaderSync) {
						var fr = new FileReaderSync;
						bb.push(fr.readAsBinaryString(data));
					} else {
						// async FileReader won't work as BlobBuilder is sync
						throw new FileException("NOT_READABLE_ERR");
					}
				} else if (data instanceof FakeBlob) {
					if (data.encoding === "base64" && atob) {
						bb.push(atob(data.data));
					} else if (data.encoding === "URI") {
						bb.push(decodeURIComponent(data.data));
					} else if (data.encoding === "raw") {
						bb.push(data.data);
					}
				} else {
					if (typeof data !== "string") {
						data += ""; // convert unsupported types to strings
					}
					// decode UTF-16 to binary string
					bb.push(unescape(encodeURIComponent(data)));
				}
			};
			FBB_proto.getBlob = function (type) {
				if (!arguments.length) {
					type = null;
				}
				return new FakeBlob(this.data.join(""), type, "raw");
			};
			FBB_proto.toString = function () {
				return "[object BlobBuilder]";
			};
			FB_proto.slice = function (start, end, type) {
				var args = arguments.length;
				if (args < 3) {
					type = null;
				}
				return new FakeBlob(
					this.data.slice(start, args > 1 ? end : this.data.length), type, this.encoding);
			};
			FB_proto.toString = function () {
				return "[object Blob]";
			};
			FB_proto.close = function () {
				this.size = this.data.length = 0;
			};
			return FakeBlobBuilder;
		}(view));

	view.Blob = function Blob(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				builder.append(blobParts[i]);
			}
		}
		return builder.getBlob(type);
	};
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content || this));

/* xlsx.js (C) 2013-2015 SheetJS -- http://sheetjs.com */
/* vim: set ts=2: */
/*jshint -W041 */
/*jshint funcscope:true, eqnull:true */
/*
Copyright (C) 2012-2015  SheetJS

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Except where noted, this license applies to any and all software programs and associated documentation files created by the Original Author and distributed with the Software:

'jszip.js' is a modified version of JSZip, Copyright (c) Stuart Knightley, David Duponchel, Franz Buchinger, Ant'onio Afonso.  JSZip is dual licensed and is used according to the terms of the MIT License.
 */
/* xlsx.js (C) 2013-2015 SheetJS -- http://sheetjs.com */
!function (e) {
	if ("object" == typeof exports && "undefined" != typeof module)
		module.exports = e();
	else if ("function" == typeof define && define.amd)
		define([], e);
	else {
		var f;
		"undefined" != typeof window ? f = window : "undefined" != typeof global ? f = global : "undefined" != typeof self && (f = self),
		f.JSZip = e()
	}
}(function () {
	var define,
	module,
	exports;
	return function e(t, n, r) {
		function s(o, u) {
			if (!n[o]) {
				if (!t[o]) {
					var a = typeof require == "function" && require;
					if (!u && a)
						return a(o, !0);
					if (i)
						return i(o, !0);
					throw new Error("Cannot find module '" + o + "'")
				}
				var f = n[o] = {
					exports : {}

				};
				t[o][0].call(f.exports, function (e) {
					var n = t[o][1][e];
					return s(n ? n : e)
				}, f, f.exports, e, t, n, r)
			}
			return n[o].exports
		}
		var i = typeof require == "function" && require;
		for (var o = 0; o < r.length; o++)
			s(r[o]);
		return s
	}({
		1 : [function (_dereq_, module, exports) {
				"use strict";
				var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
				exports.encode = function (input, utf8) {
					var output = "";
					var chr1,
					chr2,
					chr3,
					enc1,
					enc2,
					enc3,
					enc4;
					var i = 0;
					while (i < input.length) {
						chr1 = input.charCodeAt(i++);
						chr2 = input.charCodeAt(i++);
						chr3 = input.charCodeAt(i++);
						enc1 = chr1 >> 2;
						enc2 = (chr1 & 3) << 4 | chr2 >> 4;
						enc3 = (chr2 & 15) << 2 | chr3 >> 6;
						enc4 = chr3 & 63;
						if (isNaN(chr2)) {
							enc3 = enc4 = 64
						} else if (isNaN(chr3)) {
							enc4 = 64
						}
						output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4)
					}
					return output
				};
				exports.decode = function (input, utf8) {
					var output = "";
					var chr1,
					chr2,
					chr3;
					var enc1,
					enc2,
					enc3,
					enc4;
					var i = 0;
					input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
					while (i < input.length) {
						enc1 = _keyStr.indexOf(input.charAt(i++));
						enc2 = _keyStr.indexOf(input.charAt(i++));
						enc3 = _keyStr.indexOf(input.charAt(i++));
						enc4 = _keyStr.indexOf(input.charAt(i++));
						chr1 = enc1 << 2 | enc2 >> 4;
						chr2 = (enc2 & 15) << 4 | enc3 >> 2;
						chr3 = (enc3 & 3) << 6 | enc4;
						output = output + String.fromCharCode(chr1);
						if (enc3 != 64) {
							output = output + String.fromCharCode(chr2)
						}
						if (enc4 != 64) {
							output = output + String.fromCharCode(chr3)
						}
					}
					return output
				}
			}, {}

		],
		2 : [function (_dereq_, module, exports) {
				"use strict";
				function CompressedObject() {
					this.compressedSize = 0;
					this.uncompressedSize = 0;
					this.crc32 = 0;
					this.compressionMethod = null;
					this.compressedContent = null
				}
				CompressedObject.prototype = {
					getContent : function () {
						return null
					},
					getCompressedContent : function () {
						return null
					}
				};
				module.exports = CompressedObject
			}, {}

		],
		3 : [function (_dereq_, module, exports) {
				"use strict";
				exports.STORE = {
					magic : "\x00\x00",
					compress : function (content) {
						return content
					},
					uncompress : function (content) {
						return content
					},
					compressInputType : null,
					uncompressInputType : null
				};
				exports.DEFLATE = _dereq_("./flate")
			}, {
				"./flate" : 8
			}
		],
		4 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("./utils");
				var table = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
				module.exports = function crc32(input, crc) {
					if (typeof input === "undefined" || !input.length) {
						return 0
					}
					var isArray = utils.getTypeOf(input) !== "string";
					if (typeof crc == "undefined") {
						crc = 0
					}
					var x = 0;
					var y = 0;
					var b = 0;
					crc = crc^-1;
					for (var i = 0, iTop = input.length; i < iTop; i++) {
						b = isArray ? input[i] : input.charCodeAt(i);
						y = (crc^b) & 255;
						x = table[y];
						crc = crc >>> 8^x
					}
					return crc^-1
				}
			}, {
				"./utils" : 21
			}
		],
		5 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("./utils");
				function DataReader(data) {
					this.data = null;
					this.length = 0;
					this.index = 0
				}
				DataReader.prototype = {
					checkOffset : function (offset) {
						this.checkIndex(this.index + offset)
					},
					checkIndex : function (newIndex) {
						if (this.length < newIndex || newIndex < 0) {
							throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?")
						}
					},
					setIndex : function (newIndex) {
						this.checkIndex(newIndex);
						this.index = newIndex
					},
					skip : function (n) {
						this.setIndex(this.index + n)
					},
					byteAt : function (i) {},
					readInt : function (size) {
						var result = 0,
						i;
						this.checkOffset(size);
						for (i = this.index + size - 1; i >= this.index; i--) {
							result = (result << 8) + this.byteAt(i)
						}
						this.index += size;
						return result
					},
					readString : function (size) {
						return utils.transformTo("string", this.readData(size))
					},
					readData : function (size) {},
					lastIndexOfSignature : function (sig) {},
					readDate : function () {
						var dostime = this.readInt(4);
						return new Date((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (dostime & 31) << 1)
					}
				};
				module.exports = DataReader
			}, {
				"./utils" : 21
			}
		],
		6 : [function (_dereq_, module, exports) {
				"use strict";
				exports.base64 = false;
				exports.binary = false;
				exports.dir = false;
				exports.createFolders = false;
				exports.date = null;
				exports.compression = null;
				exports.comment = null
			}, {}

		],
		7 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("./utils");
				exports.string2binary = function (str) {
					return utils.string2binary(str)
				};
				exports.string2Uint8Array = function (str) {
					return utils.transformTo("uint8array", str)
				};
				exports.uint8Array2String = function (array) {
					return utils.transformTo("string", array)
				};
				exports.string2Blob = function (str) {
					var buffer = utils.transformTo("arraybuffer", str);
					return utils.arrayBuffer2Blob(buffer)
				};
				exports.arrayBuffer2Blob = function (buffer) {
					return utils.arrayBuffer2Blob(buffer)
				};
				exports.transformTo = function (outputType, input) {
					return utils.transformTo(outputType, input)
				};
				exports.getTypeOf = function (input) {
					return utils.getTypeOf(input)
				};
				exports.checkSupport = function (type) {
					return utils.checkSupport(type)
				};
				exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;
				exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;
				exports.pretty = function (str) {
					return utils.pretty(str)
				};
				exports.findCompression = function (compressionMethod) {
					return utils.findCompression(compressionMethod)
				};
				exports.isRegExp = function (object) {
					return utils.isRegExp(object)
				}
			}, {
				"./utils" : 21
			}
		],
		8 : [function (_dereq_, module, exports) {
				"use strict";
				var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
				var pako = _dereq_("pako");
				exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
				exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";
				exports.magic = "\b\x00";
				exports.compress = function (input) {
					return pako.deflateRaw(input)
				};
				exports.uncompress = function (input) {
					return pako.inflateRaw(input)
				}
			}, {
				pako : 24
			}
		],
		9 : [function (_dereq_, module, exports) {
				"use strict";
				var base64 = _dereq_("./base64");
				function JSZip(data, options) {
					if (!(this instanceof JSZip))
						return new JSZip(data, options);
					this.files = {};
					this.comment = null;
					this.root = "";
					if (data) {
						this.load(data, options)
					}
					this.clone = function () {
						var newObj = new JSZip;
						for (var i in this) {
							if (typeof this[i] !== "function") {
								newObj[i] = this[i]
							}
						}
						return newObj
					}
				}
				JSZip.prototype = _dereq_("./object");
				JSZip.prototype.load = _dereq_("./load");
				JSZip.support = _dereq_("./support");
				JSZip.defaults = _dereq_("./defaults");
				JSZip.utils = _dereq_("./deprecatedPublicUtils");
				JSZip.base64 = {
					encode : function (input) {
						return base64.encode(input)
					},
					decode : function (input) {
						return base64.decode(input)
					}
				};
				JSZip.compressions = _dereq_("./compressions");
				module.exports = JSZip
			}, {
				"./base64" : 1,
				"./compressions" : 3,
				"./defaults" : 6,
				"./deprecatedPublicUtils" : 7,
				"./load" : 10,
				"./object" : 13,
				"./support" : 17
			}
		],
		10 : [function (_dereq_, module, exports) {
				"use strict";
				var base64 = _dereq_("./base64");
				var ZipEntries = _dereq_("./zipEntries");
				module.exports = function (data, options) {
					var files,
					zipEntries,
					i,
					input;
					options = options || {};
					if (options.base64) {
						data = base64.decode(data)
					}
					zipEntries = new ZipEntries(data, options);
					files = zipEntries.files;
					for (i = 0; i < files.length; i++) {
						input = files[i];
						this.file(input.fileName, input.decompressed, {
							binary : true,
							optimizedBinaryString : true,
							date : input.date,
							dir : input.dir,
							comment : input.fileComment.length ? input.fileComment : null,
							createFolders : options.createFolders
						})
					}
					if (zipEntries.zipComment.length) {
						this.comment = zipEntries.zipComment
					}
					return this
				}
			}, {
				"./base64" : 1,
				"./zipEntries" : 22
			}
		],
		11 : [function (_dereq_, module, exports) {
				(function (Buffer) {
					"use strict";
					module.exports = function (data, encoding) {
						return new Buffer(data, encoding)
					};
					module.exports.test = function (b) {
						return Buffer.isBuffer(b)
					}
				}).call(this, typeof Buffer !== "undefined" ? Buffer : undefined)
			}, {}

		],
		12 : [function (_dereq_, module, exports) {
				"use strict";
				var Uint8ArrayReader = _dereq_("./uint8ArrayReader");
				function NodeBufferReader(data) {
					this.data = data;
					this.length = this.data.length;
					this.index = 0
				}
				NodeBufferReader.prototype = new Uint8ArrayReader;
				NodeBufferReader.prototype.readData = function (size) {
					this.checkOffset(size);
					var result = this.data.slice(this.index, this.index + size);
					this.index += size;
					return result
				};
				module.exports = NodeBufferReader
			}, {
				"./uint8ArrayReader" : 18
			}
		],
		13 : [function (_dereq_, module, exports) {
				"use strict";
				var support = _dereq_("./support");
				var utils = _dereq_("./utils");
				var crc32 = _dereq_("./crc32");
				var signature = _dereq_("./signature");
				var defaults = _dereq_("./defaults");
				var base64 = _dereq_("./base64");
				var compressions = _dereq_("./compressions");
				var CompressedObject = _dereq_("./compressedObject");
				var nodeBuffer = _dereq_("./nodeBuffer");
				var utf8 = _dereq_("./utf8");
				var StringWriter = _dereq_("./stringWriter");
				var Uint8ArrayWriter = _dereq_("./uint8ArrayWriter");
				var getRawData = function (file) {
					if (file._data instanceof CompressedObject) {
						file._data = file._data.getContent();
						file.options.binary = true;
						file.options.base64 = false;
						if (utils.getTypeOf(file._data) === "uint8array") {
							var copy = file._data;
							file._data = new Uint8Array(copy.length);
							if (copy.length !== 0) {
								file._data.set(copy, 0)
							}
						}
					}
					return file._data
				};
				var getBinaryData = function (file) {
					var result = getRawData(file),
					type = utils.getTypeOf(result);
					if (type === "string") {
						if (!file.options.binary) {
							if (support.nodebuffer) {
								return nodeBuffer(result, "utf-8")
							}
						}
						return file.asBinary()
					}
					return result
				};
				var dataToString = function (asUTF8) {
					var result = getRawData(this);
					if (result === null || typeof result === "undefined") {
						return ""
					}
					if (this.options.base64) {
						result = base64.decode(result)
					}
					if (asUTF8 && this.options.binary) {
						result = out.utf8decode(result)
					} else {
						result = utils.transformTo("string", result)
					}
					if (!asUTF8 && !this.options.binary) {
						result = utils.transformTo("string", out.utf8encode(result))
					}
					return result
				};
				var ZipObject = function (name, data, options) {
					this.name = name;
					this.dir = options.dir;
					this.date = options.date;
					this.comment = options.comment;
					this._data = data;
					this.options = options;
					this._initialMetadata = {
						dir : options.dir,
						date : options.date
					}
				};
				ZipObject.prototype = {
					asText : function () {
						return dataToString.call(this, true)
					},
					asBinary : function () {
						return dataToString.call(this, false)
					},
					asNodeBuffer : function () {
						var result = getBinaryData(this);
						return utils.transformTo("nodebuffer", result)
					},
					asUint8Array : function () {
						var result = getBinaryData(this);
						return utils.transformTo("uint8array", result)
					},
					asArrayBuffer : function () {
						return this.asUint8Array().buffer
					}
				};
				var decToHex = function (dec, bytes) {
					var hex = "",
					i;
					for (i = 0; i < bytes; i++) {
						hex += String.fromCharCode(dec & 255);
						dec = dec >>> 8
					}
					return hex
				};
				var extend = function () {
					var result = {},
					i,
					attr;
					for (i = 0; i < arguments.length; i++) {
						for (attr in arguments[i]) {
							if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {
								result[attr] = arguments[i][attr]
							}
						}
					}
					return result
				};
				var prepareFileAttrs = function (o) {
					o = o || {};
					if (o.base64 === true && (o.binary === null || o.binary === undefined)) {
						o.binary = true
					}
					o = extend(o, defaults);
					o.date = o.date || new Date;
					if (o.compression !== null)
						o.compression = o.compression.toUpperCase();
					return o
				};
				var fileAdd = function (name, data, o) {
					var dataType = utils.getTypeOf(data),
					parent;
					o = prepareFileAttrs(o);
					if (o.createFolders && (parent = parentFolder(name))) {
						folderAdd.call(this, parent, true)
					}
					if (o.dir || data === null || typeof data === "undefined") {
						o.base64 = false;
						o.binary = false;
						data = null
					} else if (dataType === "string") {
						if (o.binary && !o.base64) {
							if (o.optimizedBinaryString !== true) {
								data = utils.string2binary(data)
							}
						}
					} else {
						o.base64 = false;
						o.binary = true;
						if (!dataType && !(data instanceof CompressedObject)) {
							throw new Error("The data of '" + name + "' is in an unsupported format !")
						}
						if (dataType === "arraybuffer") {
							data = utils.transformTo("uint8array", data)
						}
					}
					var object = new ZipObject(name, data, o);
					this.files[name] = object;
					return object
				};
				var parentFolder = function (path) {
					if (path.slice(-1) == "/") {
						path = path.substring(0, path.length - 1)
					}
					var lastSlash = path.lastIndexOf("/");
					return lastSlash > 0 ? path.substring(0, lastSlash) : ""
				};
				var folderAdd = function (name, createFolders) {
					if (name.slice(-1) != "/") {
						name += "/"
					}
					createFolders = typeof createFolders !== "undefined" ? createFolders : false;
					if (!this.files[name]) {
						fileAdd.call(this, name, null, {
							dir : true,
							createFolders : createFolders
						})
					}
					return this.files[name]
				};
				var generateCompressedObjectFrom = function (file, compression) {
					var result = new CompressedObject,
					content;
					if (file._data instanceof CompressedObject) {
						result.uncompressedSize = file._data.uncompressedSize;
						result.crc32 = file._data.crc32;
						if (result.uncompressedSize === 0 || file.dir) {
							compression = compressions["STORE"];
							result.compressedContent = "";
							result.crc32 = 0
						} else if (file._data.compressionMethod === compression.magic) {
							result.compressedContent = file._data.getCompressedContent()
						} else {
							content = file._data.getContent();
							result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))
						}
					} else {
						content = getBinaryData(file);
						if (!content || content.length === 0 || file.dir) {
							compression = compressions["STORE"];
							content = ""
						}
						result.uncompressedSize = content.length;
						result.crc32 = crc32(content);
						result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content))
					}
					result.compressedSize = result.compressedContent.length;
					result.compressionMethod = compression.magic;
					return result
				};
				var generateZipParts = function (name, file, compressedObject, offset) {
					var data = compressedObject.compressedContent,
					utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
					comment = file.comment || "",
					utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
					useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
					useUTF8ForComment = utfEncodedComment.length !== comment.length,
					o = file.options,
					dosTime,
					dosDate,
					extraFields = "",
					unicodePathExtraField = "",
					unicodeCommentExtraField = "",
					dir,
					date;
					if (file._initialMetadata.dir !== file.dir) {
						dir = file.dir
					} else {
						dir = o.dir
					}
					if (file._initialMetadata.date !== file.date) {
						date = file.date
					} else {
						date = o.date
					}
					dosTime = date.getHours();
					dosTime = dosTime << 6;
					dosTime = dosTime | date.getMinutes();
					dosTime = dosTime << 5;
					dosTime = dosTime | date.getSeconds() / 2;
					dosDate = date.getFullYear() - 1980;
					dosDate = dosDate << 4;
					dosDate = dosDate | date.getMonth() + 1;
					dosDate = dosDate << 5;
					dosDate = dosDate | date.getDate();
					if (useUTF8ForFileName) {
						unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(utfEncodedFileName), 4) + utfEncodedFileName;
						extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField
					}
					if (useUTF8ForComment) {
						unicodeCommentExtraField = decToHex(1, 1) + decToHex(this.crc32(utfEncodedComment), 4) + utfEncodedComment;
						extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField
					}
					var header = "";
					header += "\n\x00";
					header += useUTF8ForFileName || useUTF8ForComment ? "\x00\b" : "\x00\x00";
					header += compressedObject.compressionMethod;
					header += decToHex(dosTime, 2);
					header += decToHex(dosDate, 2);
					header += decToHex(compressedObject.crc32, 4);
					header += decToHex(compressedObject.compressedSize, 4);
					header += decToHex(compressedObject.uncompressedSize, 4);
					header += decToHex(utfEncodedFileName.length, 2);
					header += decToHex(extraFields.length, 2);
					var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;
					var dirRecord = signature.CENTRAL_FILE_HEADER + "\x00" + header + decToHex(utfEncodedComment.length, 2) + "\x00\x00" + "\x00\x00" + (dir === true ? "\x00\x00\x00" : "\x00\x00\x00\x00") + decToHex(offset, 4) + utfEncodedFileName + extraFields + utfEncodedComment;
					return {
						fileRecord : fileRecord,
						dirRecord : dirRecord,
						compressedObject : compressedObject
					}
				};
				var out = {
					load : function (stream, options) {
						throw new Error("Load method is not defined. Is the file jszip-load.js included ?")
					},
					filter : function (search) {
						var result = [],
						filename,
						relativePath,
						file,
						fileClone;
						for (filename in this.files) {
							if (!this.files.hasOwnProperty(filename)) {
								continue
							}
							file = this.files[filename];
							fileClone = new ZipObject(file.name, file._data, extend(file.options));
							relativePath = filename.slice(this.root.length, filename.length);
							if (filename.slice(0, this.root.length) === this.root && search(relativePath, fileClone)) {
								result.push(fileClone)
							}
						}
						return result
					},
					file : function (name, data, o) {
						if (arguments.length === 1) {
							if (utils.isRegExp(name)) {
								var regexp = name;
								return this.filter(function (relativePath, file) {
									return !file.dir && regexp.test(relativePath)
								})
							} else {
								return this.filter(function (relativePath, file) {
									return !file.dir && relativePath === name
								})[0] || null
							}
						} else {
							name = this.root + name;
							fileAdd.call(this, name, data, o)
						}
						return this
					},
					folder : function (arg) {
						if (!arg) {
							return this
						}
						if (utils.isRegExp(arg)) {
							return this.filter(function (relativePath, file) {
								return file.dir && arg.test(relativePath)
							})
						}
						var name = this.root + arg;
						var newFolder = folderAdd.call(this, name);
						var ret = this.clone();
						ret.root = newFolder.name;
						return ret
					},
					remove : function (name) {
						name = this.root + name;
						var file = this.files[name];
						if (!file) {
							if (name.slice(-1) != "/") {
								name += "/"
							}
							file = this.files[name]
						}
						if (file && !file.dir) {
							delete this.files[name]
						} else {
							var kids = this.filter(function (relativePath, file) {
									return file.name.slice(0, name.length) === name
								});
							for (var i = 0; i < kids.length; i++) {
								delete this.files[kids[i].name]
							}
						}
						return this
					},
					generate : function (options) {
						options = extend(options || {}, {
								base64 : true,
								compression : "STORE",
								type : "base64",
								comment : null
							});
						utils.checkSupport(options.type);
						var zipData = [],
						localDirLength = 0,
						centralDirLength = 0,
						writer,
						i,
						utfEncodedComment = utils.transformTo("string", this.utf8encode(options.comment || this.comment || ""));
						for (var name in this.files) {
							if (!this.files.hasOwnProperty(name)) {
								continue
							}
							var file = this.files[name];
							var compressionName = file.options.compression || options.compression.toUpperCase();
							var compression = compressions[compressionName];
							if (!compression) {
								throw new Error(compressionName + " is not a valid compression method !")
							}
							var compressedObject = generateCompressedObjectFrom.call(this, file, compression);
							var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength);
							localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;
							centralDirLength += zipPart.dirRecord.length;
							zipData.push(zipPart)
						}
						var dirEnd = "";
						dirEnd = signature.CENTRAL_DIRECTORY_END + "\x00\x00" + "\x00\x00" + decToHex(zipData.length, 2) + decToHex(zipData.length, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(utfEncodedComment.length, 2) + utfEncodedComment;
						var typeName = options.type.toLowerCase();
						if (typeName === "uint8array" || typeName === "arraybuffer" || typeName === "blob" || typeName === "nodebuffer") {
							writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length)
						} else {
							writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length)
						}
						for (i = 0; i < zipData.length; i++) {
							writer.append(zipData[i].fileRecord);
							writer.append(zipData[i].compressedObject.compressedContent)
						}
						for (i = 0; i < zipData.length; i++) {
							writer.append(zipData[i].dirRecord)
						}
						writer.append(dirEnd);
						var zip = writer.finalize();
						switch (options.type.toLowerCase()) {
						case "uint8array":
						case "arraybuffer":
						case "nodebuffer":
							return utils.transformTo(options.type.toLowerCase(), zip);
						case "blob":
							return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip));
						case "base64":
							return options.base64 ? base64.encode(zip) : zip;
						default:
							return zip
						}
					},
					crc32 : function (input, crc) {
						return crc32(input, crc)
					},
					utf8encode : function (string) {
						return utils.transformTo("string", utf8.utf8encode(string))
					},
					utf8decode : function (input) {
						return utf8.utf8decode(input)
					}
				};
				module.exports = out
			}, {
				"./base64" : 1,
				"./compressedObject" : 2,
				"./compressions" : 3,
				"./crc32" : 4,
				"./defaults" : 6,
				"./nodeBuffer" : 11,
				"./signature" : 14,
				"./stringWriter" : 16,
				"./support" : 17,
				"./uint8ArrayWriter" : 19,
				"./utf8" : 20,
				"./utils" : 21
			}
		],
		14 : [function (_dereq_, module, exports) {
				"use strict";
				exports.LOCAL_FILE_HEADER = "PK";
				exports.CENTRAL_FILE_HEADER = "PK";
				exports.CENTRAL_DIRECTORY_END = "PK";
				exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK";
				exports.ZIP64_CENTRAL_DIRECTORY_END = "PK";
				exports.DATA_DESCRIPTOR = "PK\b"
			}, {}

		],
		15 : [function (_dereq_, module, exports) {
				"use strict";
				var DataReader = _dereq_("./dataReader");
				var utils = _dereq_("./utils");
				function StringReader(data, optimizedBinaryString) {
					this.data = data;
					if (!optimizedBinaryString) {
						this.data = utils.string2binary(this.data)
					}
					this.length = this.data.length;
					this.index = 0
				}
				StringReader.prototype = new DataReader;
				StringReader.prototype.byteAt = function (i) {
					return this.data.charCodeAt(i)
				};
				StringReader.prototype.lastIndexOfSignature = function (sig) {
					return this.data.lastIndexOf(sig)
				};
				StringReader.prototype.readData = function (size) {
					this.checkOffset(size);
					var result = this.data.slice(this.index, this.index + size);
					this.index += size;
					return result
				};
				module.exports = StringReader
			}, {
				"./dataReader" : 5,
				"./utils" : 21
			}
		],
		16 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("./utils");
				var StringWriter = function () {
					this.data = []
				};
				StringWriter.prototype = {
					append : function (input) {
						input = utils.transformTo("string", input);
						this.data.push(input)
					},
					finalize : function () {
						return this.data.join("")
					}
				};
				module.exports = StringWriter
			}, {
				"./utils" : 21
			}
		],
		17 : [function (_dereq_, module, exports) {
				(function (Buffer) {
					"use strict";
					exports.base64 = true;
					exports.array = true;
					exports.string = true;
					exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
					exports.nodebuffer = typeof Buffer !== "undefined";
					exports.uint8array = typeof Uint8Array !== "undefined";
					if (typeof ArrayBuffer === "undefined") {
						exports.blob = false
					} else {
						var buffer = new ArrayBuffer(0);
						try {
							exports.blob = new Blob([buffer], {
									type : "application/zip"
								}).size === 0
						} catch (e) {
							try {
								var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
								var builder = new Builder;
								builder.append(buffer);
								exports.blob = builder.getBlob("application/zip").size === 0
							} catch (e) {
								exports.blob = false
							}
						}
					}
				}).call(this, typeof Buffer !== "undefined" ? Buffer : undefined)
			}, {}

		],
		18 : [function (_dereq_, module, exports) {
				"use strict";
				var DataReader = _dereq_("./dataReader");
				function Uint8ArrayReader(data) {
					if (data) {
						this.data = data;
						this.length = this.data.length;
						this.index = 0
					}
				}
				Uint8ArrayReader.prototype = new DataReader;
				Uint8ArrayReader.prototype.byteAt = function (i) {
					return this.data[i]
				};
				Uint8ArrayReader.prototype.lastIndexOfSignature = function (sig) {
					var sig0 = sig.charCodeAt(0),
					sig1 = sig.charCodeAt(1),
					sig2 = sig.charCodeAt(2),
					sig3 = sig.charCodeAt(3);
					for (var i = this.length - 4; i >= 0; --i) {
						if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
							return i
						}
					}
					return -1
				};
				Uint8ArrayReader.prototype.readData = function (size) {
					this.checkOffset(size);
					if (size === 0) {
						return new Uint8Array(0)
					}
					var result = this.data.subarray(this.index, this.index + size);
					this.index += size;
					return result
				};
				module.exports = Uint8ArrayReader
			}, {
				"./dataReader" : 5
			}
		],
		19 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("./utils");
				var Uint8ArrayWriter = function (length) {
					this.data = new Uint8Array(length);
					this.index = 0
				};
				Uint8ArrayWriter.prototype = {
					append : function (input) {
						if (input.length !== 0) {
							input = utils.transformTo("uint8array", input);
							this.data.set(input, this.index);
							this.index += input.length
						}
					},
					finalize : function () {
						return this.data
					}
				};
				module.exports = Uint8ArrayWriter
			}, {
				"./utils" : 21
			}
		],
		20 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("./utils");
				var support = _dereq_("./support");
				var nodeBuffer = _dereq_("./nodeBuffer");
				var _utf8len = new Array(256);
				for (var i = 0; i < 256; i++) {
					_utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1
				}
				_utf8len[254] = _utf8len[254] = 1;
				var string2buf = function (str) {
					var buf,
					c,
					c2,
					m_pos,
					i,
					str_len = str.length,
					buf_len = 0;
					for (m_pos = 0; m_pos < str_len; m_pos++) {
						c = str.charCodeAt(m_pos);
						if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
							c2 = str.charCodeAt(m_pos + 1);
							if ((c2 & 64512) === 56320) {
								c = 65536 + (c - 55296 << 10) + (c2 - 56320);
								m_pos++
							}
						}
						buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
					}
					if (support.uint8array) {
						buf = new Uint8Array(buf_len)
					} else {
						buf = new Array(buf_len)
					}
					for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
						c = str.charCodeAt(m_pos);
						if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
							c2 = str.charCodeAt(m_pos + 1);
							if ((c2 & 64512) === 56320) {
								c = 65536 + (c - 55296 << 10) + (c2 - 56320);
								m_pos++
							}
						}
						if (c < 128) {
							buf[i++] = c
						} else if (c < 2048) {
							buf[i++] = 192 | c >>> 6;
							buf[i++] = 128 | c & 63
						} else if (c < 65536) {
							buf[i++] = 224 | c >>> 12;
							buf[i++] = 128 | c >>> 6 & 63;
							buf[i++] = 128 | c & 63
						} else {
							buf[i++] = 240 | c >>> 18;
							buf[i++] = 128 | c >>> 12 & 63;
							buf[i++] = 128 | c >>> 6 & 63;
							buf[i++] = 128 | c & 63
						}
					}
					return buf
				};
				var utf8border = function (buf, max) {
					var pos;
					max = max || buf.length;
					if (max > buf.length) {
						max = buf.length
					}
					pos = max - 1;
					while (pos >= 0 && (buf[pos] & 192) === 128) {
						pos--
					}
					if (pos < 0) {
						return max
					}
					if (pos === 0) {
						return max
					}
					return pos + _utf8len[buf[pos]] > max ? pos : max
				};
				var buf2string = function (buf) {
					var str,
					i,
					out,
					c,
					c_len;
					var len = buf.length;
					var utf16buf = new Array(len * 2);
					for (out = 0, i = 0; i < len; ) {
						c = buf[i++];
						if (c < 128) {
							utf16buf[out++] = c;
							continue
						}
						c_len = _utf8len[c];
						if (c_len > 4) {
							utf16buf[out++] = 65533;
							i += c_len - 1;
							continue
						}
						c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
						while (c_len > 1 && i < len) {
							c = c << 6 | buf[i++] & 63;
							c_len--
						}
						if (c_len > 1) {
							utf16buf[out++] = 65533;
							continue
						}
						if (c < 65536) {
							utf16buf[out++] = c
						} else {
							c -= 65536;
							utf16buf[out++] = 55296 | c >> 10 & 1023;
							utf16buf[out++] = 56320 | c & 1023
						}
					}
					if (utf16buf.length !== out) {
						if (utf16buf.subarray) {
							utf16buf = utf16buf.subarray(0, out)
						} else {
							utf16buf.length = out
						}
					}
					return utils.applyFromCharCode(utf16buf)
				};
				exports.utf8encode = function utf8encode(str) {
					if (support.nodebuffer) {
						return nodeBuffer(str, "utf-8")
					}
					return string2buf(str)
				};
				exports.utf8decode = function utf8decode(buf) {
					if (support.nodebuffer) {
						return utils.transformTo("nodebuffer", buf).toString("utf-8")
					}
					buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
					var result = [],
					k = 0,
					len = buf.length,
					chunk = 65536;
					while (k < len) {
						var nextBoundary = utf8border(buf, Math.min(k + chunk, len));
						if (support.uint8array) {
							result.push(buf2string(buf.subarray(k, nextBoundary)))
						} else {
							result.push(buf2string(buf.slice(k, nextBoundary)))
						}
						k = nextBoundary
					}
					return result.join("")
				}
			}, {
				"./nodeBuffer" : 11,
				"./support" : 17,
				"./utils" : 21
			}
		],
		21 : [function (_dereq_, module, exports) {
				"use strict";
				var support = _dereq_("./support");
				var compressions = _dereq_("./compressions");
				var nodeBuffer = _dereq_("./nodeBuffer");
				exports.string2binary = function (str) {
					var result = "";
					for (var i = 0; i < str.length; i++) {
						result += String.fromCharCode(str.charCodeAt(i) & 255)
					}
					return result
				};
				exports.arrayBuffer2Blob = function (buffer) {
					exports.checkSupport("blob");
					try {
						return new Blob([buffer], {
							type : "application/zip"
						})
					} catch (e) {
						try {
							var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
							var builder = new Builder;
							builder.append(buffer);
							return builder.getBlob("application/zip")
						} catch (e) {
							throw new Error("Bug : can't construct the Blob.")
						}
					}
				};
				function identity(input) {
					return input
				}
				function stringToArrayLike(str, array) {
					for (var i = 0; i < str.length; ++i) {
						array[i] = str.charCodeAt(i) & 255
					}
					return array
				}
				function arrayLikeToString(array) {
					var chunk = 65536;
					var result = [],
					len = array.length,
					type = exports.getTypeOf(array),
					k = 0,
					canUseApply = true;
					try {
						switch (type) {
						case "uint8array":
							String.fromCharCode.apply(null, new Uint8Array(0));
							break;
						case "nodebuffer":
							String.fromCharCode.apply(null, nodeBuffer(0));
							break
						}
					} catch (e) {
						canUseApply = false
					}
					if (!canUseApply) {
						var resultStr = "";
						for (var i = 0; i < array.length; i++) {
							resultStr += String.fromCharCode(array[i])
						}
						return resultStr
					}
					while (k < len && chunk > 1) {
						try {
							if (type === "array" || type === "nodebuffer") {
								result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))))
							} else {
								result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))))
							}
							k += chunk
						} catch (e) {
							chunk = Math.floor(chunk / 2)
						}
					}
					return result.join("")
				}
				exports.applyFromCharCode = arrayLikeToString;
				function arrayLikeToArrayLike(arrayFrom, arrayTo) {
					for (var i = 0; i < arrayFrom.length; i++) {
						arrayTo[i] = arrayFrom[i]
					}
					return arrayTo
				}
				var transform = {};
				transform["string"] = {
					string : identity,
					array : function (input) {
						return stringToArrayLike(input, new Array(input.length))
					},
					arraybuffer : function (input) {
						return transform["string"]["uint8array"](input).buffer
					},
					uint8array : function (input) {
						return stringToArrayLike(input, new Uint8Array(input.length))
					},
					nodebuffer : function (input) {
						return stringToArrayLike(input, nodeBuffer(input.length))
					}
				};
				transform["array"] = {
					string : arrayLikeToString,
					array : identity,
					arraybuffer : function (input) {
						return new Uint8Array(input).buffer
					},
					uint8array : function (input) {
						return new Uint8Array(input)
					},
					nodebuffer : function (input) {
						return nodeBuffer(input)
					}
				};
				transform["arraybuffer"] = {
					string : function (input) {
						return arrayLikeToString(new Uint8Array(input))
					},
					array : function (input) {
						return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))
					},
					arraybuffer : identity,
					uint8array : function (input) {
						return new Uint8Array(input)
					},
					nodebuffer : function (input) {
						return nodeBuffer(new Uint8Array(input))
					}
				};
				transform["uint8array"] = {
					string : arrayLikeToString,
					array : function (input) {
						return arrayLikeToArrayLike(input, new Array(input.length))
					},
					arraybuffer : function (input) {
						return input.buffer
					},
					uint8array : identity,
					nodebuffer : function (input) {
						return nodeBuffer(input)
					}
				};
				transform["nodebuffer"] = {
					string : arrayLikeToString,
					array : function (input) {
						return arrayLikeToArrayLike(input, new Array(input.length))
					},
					arraybuffer : function (input) {
						return transform["nodebuffer"]["uint8array"](input).buffer
					},
					uint8array : function (input) {
						return arrayLikeToArrayLike(input, new Uint8Array(input.length))
					},
					nodebuffer : identity
				};
				exports.transformTo = function (outputType, input) {
					if (!input) {
						input = ""
					}
					if (!outputType) {
						return input
					}
					exports.checkSupport(outputType);
					var inputType = exports.getTypeOf(input);
					var result = transform[inputType][outputType](input);
					return result
				};
				exports.getTypeOf = function (input) {
					if (typeof input === "string") {
						return "string"
					}
					if (Object.prototype.toString.call(input) === "[object Array]") {
						return "array"
					}
					if (support.nodebuffer && nodeBuffer.test(input)) {
						return "nodebuffer"
					}
					if (support.uint8array && input instanceof Uint8Array) {
						return "uint8array"
					}
					if (support.arraybuffer && input instanceof ArrayBuffer) {
						return "arraybuffer"
					}
				};
				exports.checkSupport = function (type) {
					var supported = support[type.toLowerCase()];
					if (!supported) {
						throw new Error(type + " is not supported by this browser")
					}
				};
				exports.MAX_VALUE_16BITS = 65535;
				exports.MAX_VALUE_32BITS = -1;
				exports.pretty = function (str) {
					var res = "",
					code,
					i;
					for (i = 0; i < (str || "").length; i++) {
						code = str.charCodeAt(i);
						res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase()
					}
					return res
				};
				exports.findCompression = function (compressionMethod) {
					for (var method in compressions) {
						if (!compressions.hasOwnProperty(method)) {
							continue
						}
						if (compressions[method].magic === compressionMethod) {
							return compressions[method]
						}
					}
					return null
				};
				exports.isRegExp = function (object) {
					return Object.prototype.toString.call(object) === "[object RegExp]"
				}
			}, {
				"./compressions" : 3,
				"./nodeBuffer" : 11,
				"./support" : 17
			}
		],
		22 : [function (_dereq_, module, exports) {
				"use strict";
				var StringReader = _dereq_("./stringReader");
				var NodeBufferReader = _dereq_("./nodeBufferReader");
				var Uint8ArrayReader = _dereq_("./uint8ArrayReader");
				var utils = _dereq_("./utils");
				var sig = _dereq_("./signature");
				var ZipEntry = _dereq_("./zipEntry");
				var support = _dereq_("./support");
				var jszipProto = _dereq_("./object");
				function ZipEntries(data, loadOptions) {
					this.files = [];
					this.loadOptions = loadOptions;
					if (data) {
						this.load(data)
					}
				}
				ZipEntries.prototype = {
					checkSignature : function (expectedSignature) {
						var signature = this.reader.readString(4);
						if (signature !== expectedSignature) {
							throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")")
						}
					},
					readBlockEndOfCentral : function () {
						this.diskNumber = this.reader.readInt(2);
						this.diskWithCentralDirStart = this.reader.readInt(2);
						this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
						this.centralDirRecords = this.reader.readInt(2);
						this.centralDirSize = this.reader.readInt(4);
						this.centralDirOffset = this.reader.readInt(4);
						this.zipCommentLength = this.reader.readInt(2);
						this.zipComment = this.reader.readString(this.zipCommentLength);
						this.zipComment = jszipProto.utf8decode(this.zipComment)
					},
					readBlockZip64EndOfCentral : function () {
						this.zip64EndOfCentralSize = this.reader.readInt(8);
						this.versionMadeBy = this.reader.readString(2);
						this.versionNeeded = this.reader.readInt(2);
						this.diskNumber = this.reader.readInt(4);
						this.diskWithCentralDirStart = this.reader.readInt(4);
						this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
						this.centralDirRecords = this.reader.readInt(8);
						this.centralDirSize = this.reader.readInt(8);
						this.centralDirOffset = this.reader.readInt(8);
						this.zip64ExtensibleData = {};
						var extraDataSize = this.zip64EndOfCentralSize - 44,
						index = 0,
						extraFieldId,
						extraFieldLength,
						extraFieldValue;
						while (index < extraDataSize) {
							extraFieldId = this.reader.readInt(2);
							extraFieldLength = this.reader.readInt(4);
							extraFieldValue = this.reader.readString(extraFieldLength);
							this.zip64ExtensibleData[extraFieldId] = {
								id : extraFieldId,
								length : extraFieldLength,
								value : extraFieldValue
							}
						}
					},
					readBlockZip64EndOfCentralLocator : function () {
						this.diskWithZip64CentralDirStart = this.reader.readInt(4);
						this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
						this.disksCount = this.reader.readInt(4);
						if (this.disksCount > 1) {
							throw new Error("Multi-volumes zip are not supported")
						}
					},
					readLocalFiles : function () {
						var i,
						file;
						for (i = 0; i < this.files.length; i++) {
							file = this.files[i];
							this.reader.setIndex(file.localHeaderOffset);
							this.checkSignature(sig.LOCAL_FILE_HEADER);
							file.readLocalPart(this.reader);
							file.handleUTF8()
						}
					},
					readCentralDir : function () {
						var file;
						this.reader.setIndex(this.centralDirOffset);
						while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {
							file = new ZipEntry({
									zip64 : this.zip64
								}, this.loadOptions);
							file.readCentralPart(this.reader);
							this.files.push(file)
						}
					},
					readEndOfCentral : function () {
						var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
						if (offset === -1) {
							throw new Error("Corrupted zip : can't find end of central directory")
						}
						this.reader.setIndex(offset);
						this.checkSignature(sig.CENTRAL_DIRECTORY_END);
						this.readBlockEndOfCentral();
						if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
							this.zip64 = true;
							offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
							if (offset === -1) {
								throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator")
							}
							this.reader.setIndex(offset);
							this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
							this.readBlockZip64EndOfCentralLocator();
							this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
							this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
							this.readBlockZip64EndOfCentral()
						}
					},
					prepareReader : function (data) {
						var type = utils.getTypeOf(data);
						if (type === "string" && !support.uint8array) {
							this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString)
						} else if (type === "nodebuffer") {
							this.reader = new NodeBufferReader(data)
						} else {
							this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data))
						}
					},
					load : function (data) {
						this.prepareReader(data);
						this.readEndOfCentral();
						this.readCentralDir();
						this.readLocalFiles()
					}
				};
				module.exports = ZipEntries
			}, {
				"./nodeBufferReader" : 12,
				"./object" : 13,
				"./signature" : 14,
				"./stringReader" : 15,
				"./support" : 17,
				"./uint8ArrayReader" : 18,
				"./utils" : 21,
				"./zipEntry" : 23
			}
		],
		23 : [function (_dereq_, module, exports) {
				"use strict";
				var StringReader = _dereq_("./stringReader");
				var utils = _dereq_("./utils");
				var CompressedObject = _dereq_("./compressedObject");
				var jszipProto = _dereq_("./object");
				function ZipEntry(options, loadOptions) {
					this.options = options;
					this.loadOptions = loadOptions
				}
				ZipEntry.prototype = {
					isEncrypted : function () {
						return (this.bitFlag & 1) === 1
					},
					useUTF8 : function () {
						return (this.bitFlag & 2048) === 2048
					},
					prepareCompressedContent : function (reader, from, length) {
						return function () {
							var previousIndex = reader.index;
							reader.setIndex(from);
							var compressedFileData = reader.readData(length);
							reader.setIndex(previousIndex);
							return compressedFileData
						}
					},
					prepareContent : function (reader, from, length, compression, uncompressedSize) {
						return function () {
							var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());
							var uncompressedFileData = compression.uncompress(compressedFileData);
							if (uncompressedFileData.length !== uncompressedSize) {
								throw new Error("Bug : uncompressed data size mismatch")
							}
							return uncompressedFileData
						}
					},
					readLocalPart : function (reader) {
						var compression,
						localExtraFieldsLength;
						reader.skip(22);
						this.fileNameLength = reader.readInt(2);
						localExtraFieldsLength = reader.readInt(2);
						this.fileName = reader.readString(this.fileNameLength);
						reader.skip(localExtraFieldsLength);
						if (this.compressedSize == -1 || this.uncompressedSize == -1) {
							throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)")
						}
						compression = utils.findCompression(this.compressionMethod);
						if (compression === null) {
							throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")")
						}
						this.decompressed = new CompressedObject;
						this.decompressed.compressedSize = this.compressedSize;
						this.decompressed.uncompressedSize = this.uncompressedSize;
						this.decompressed.crc32 = this.crc32;
						this.decompressed.compressionMethod = this.compressionMethod;
						this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
						this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
						if (this.loadOptions.checkCRC32) {
							this.decompressed = utils.transformTo("string", this.decompressed.getContent());
							if (jszipProto.crc32(this.decompressed) !== this.crc32) {
								throw new Error("Corrupted zip : CRC32 mismatch")
							}
						}
					},
					readCentralPart : function (reader) {
						this.versionMadeBy = reader.readString(2);
						this.versionNeeded = reader.readInt(2);
						this.bitFlag = reader.readInt(2);
						this.compressionMethod = reader.readString(2);
						this.date = reader.readDate();
						this.crc32 = reader.readInt(4);
						this.compressedSize = reader.readInt(4);
						this.uncompressedSize = reader.readInt(4);
						this.fileNameLength = reader.readInt(2);
						this.extraFieldsLength = reader.readInt(2);
						this.fileCommentLength = reader.readInt(2);
						this.diskNumberStart = reader.readInt(2);
						this.internalFileAttributes = reader.readInt(2);
						this.externalFileAttributes = reader.readInt(4);
						this.localHeaderOffset = reader.readInt(4);
						if (this.isEncrypted()) {
							throw new Error("Encrypted zip are not supported")
						}
						this.fileName = reader.readString(this.fileNameLength);
						this.readExtraFields(reader);
						this.parseZIP64ExtraField(reader);
						this.fileComment = reader.readString(this.fileCommentLength);
						this.dir = this.externalFileAttributes & 16 ? true : false
					},
					parseZIP64ExtraField : function (reader) {
						if (!this.extraFields[1]) {
							return
						}
						var extraReader = new StringReader(this.extraFields[1].value);
						if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
							this.uncompressedSize = extraReader.readInt(8)
						}
						if (this.compressedSize === utils.MAX_VALUE_32BITS) {
							this.compressedSize = extraReader.readInt(8)
						}
						if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
							this.localHeaderOffset = extraReader.readInt(8)
						}
						if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
							this.diskNumberStart = extraReader.readInt(4)
						}
					},
					readExtraFields : function (reader) {
						var start = reader.index,
						extraFieldId,
						extraFieldLength,
						extraFieldValue;
						this.extraFields = this.extraFields || {};
						while (reader.index < start + this.extraFieldsLength) {
							extraFieldId = reader.readInt(2);
							extraFieldLength = reader.readInt(2);
							extraFieldValue = reader.readString(extraFieldLength);
							this.extraFields[extraFieldId] = {
								id : extraFieldId,
								length : extraFieldLength,
								value : extraFieldValue
							}
						}
					},
					handleUTF8 : function () {
						if (this.useUTF8()) {
							this.fileName = jszipProto.utf8decode(this.fileName);
							this.fileComment = jszipProto.utf8decode(this.fileComment)
						} else {
							var upath = this.findExtraFieldUnicodePath();
							if (upath !== null) {
								this.fileName = upath
							}
							var ucomment = this.findExtraFieldUnicodeComment();
							if (ucomment !== null) {
								this.fileComment = ucomment
							}
						}
					},
					findExtraFieldUnicodePath : function () {
						var upathField = this.extraFields[28789];
						if (upathField) {
							var extraReader = new StringReader(upathField.value);
							if (extraReader.readInt(1) !== 1) {
								return null
							}
							if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {
								return null
							}
							return jszipProto.utf8decode(extraReader.readString(upathField.length - 5))
						}
						return null
					},
					findExtraFieldUnicodeComment : function () {
						var ucommentField = this.extraFields[25461];
						if (ucommentField) {
							var extraReader = new StringReader(ucommentField.value);
							if (extraReader.readInt(1) !== 1) {
								return null
							}
							if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {
								return null
							}
							return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5))
						}
						return null
					}
				};
				module.exports = ZipEntry
			}, {
				"./compressedObject" : 2,
				"./object" : 13,
				"./stringReader" : 15,
				"./utils" : 21
			}
		],
		24 : [function (_dereq_, module, exports) {
				"use strict";
				var assign = _dereq_("./lib/utils/common").assign;
				var deflate = _dereq_("./lib/deflate");
				var inflate = _dereq_("./lib/inflate");
				var constants = _dereq_("./lib/zlib/constants");
				var pako = {};
				assign(pako, deflate, inflate, constants);
				module.exports = pako
			}, {
				"./lib/deflate" : 25,
				"./lib/inflate" : 26,
				"./lib/utils/common" : 27,
				"./lib/zlib/constants" : 30
			}
		],
		25 : [function (_dereq_, module, exports) {
				"use strict";
				var zlib_deflate = _dereq_("./zlib/deflate.js");
				var utils = _dereq_("./utils/common");
				var strings = _dereq_("./utils/strings");
				var msg = _dereq_("./zlib/messages");
				var zstream = _dereq_("./zlib/zstream");
				var Z_NO_FLUSH = 0;
				var Z_FINISH = 4;
				var Z_OK = 0;
				var Z_STREAM_END = 1;
				var Z_DEFAULT_COMPRESSION = -1;
				var Z_DEFAULT_STRATEGY = 0;
				var Z_DEFLATED = 8;
				var Deflate = function (options) {
					this.options = utils.assign({
							level : Z_DEFAULT_COMPRESSION,
							method : Z_DEFLATED,
							chunkSize : 16384,
							windowBits : 15,
							memLevel : 8,
							strategy : Z_DEFAULT_STRATEGY,
							to : ""
						}, options || {});
					var opt = this.options;
					if (opt.raw && opt.windowBits > 0) {
						opt.windowBits = -opt.windowBits
					} else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
						opt.windowBits += 16
					}
					this.err = 0;
					this.msg = "";
					this.ended = false;
					this.chunks = [];
					this.strm = new zstream;
					this.strm.avail_out = 0;
					var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
					if (status !== Z_OK) {
						throw new Error(msg[status])
					}
					if (opt.header) {
						zlib_deflate.deflateSetHeader(this.strm, opt.header)
					}
				};
				Deflate.prototype.push = function (data, mode) {
					var strm = this.strm;
					var chunkSize = this.options.chunkSize;
					var status,
					_mode;
					if (this.ended) {
						return false
					}
					_mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
					if (typeof data === "string") {
						strm.input = strings.string2buf(data)
					} else {
						strm.input = data
					}
					strm.next_in = 0;
					strm.avail_in = strm.input.length;
					do {
						if (strm.avail_out === 0) {
							strm.output = new utils.Buf8(chunkSize);
							strm.next_out = 0;
							strm.avail_out = chunkSize
						}
						status = zlib_deflate.deflate(strm, _mode);
						if (status !== Z_STREAM_END && status !== Z_OK) {
							this.onEnd(status);
							this.ended = true;
							return false
						}
						if (strm.avail_out === 0 || strm.avail_in === 0 && _mode === Z_FINISH) {
							if (this.options.to === "string") {
								this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)))
							} else {
								this.onData(utils.shrinkBuf(strm.output, strm.next_out))
							}
						}
					} while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
					if (_mode === Z_FINISH) {
						status = zlib_deflate.deflateEnd(this.strm);
						this.onEnd(status);
						this.ended = true;
						return status === Z_OK
					}
					return true
				};
				Deflate.prototype.onData = function (chunk) {
					this.chunks.push(chunk)
				};
				Deflate.prototype.onEnd = function (status) {
					if (status === Z_OK) {
						if (this.options.to === "string") {
							this.result = this.chunks.join("")
						} else {
							this.result = utils.flattenChunks(this.chunks)
						}
					}
					this.chunks = [];
					this.err = status;
					this.msg = this.strm.msg
				};
				function deflate(input, options) {
					var deflator = new Deflate(options);
					deflator.push(input, true);
					if (deflator.err) {
						throw deflator.msg
					}
					return deflator.result
				}
				function deflateRaw(input, options) {
					options = options || {};
					options.raw = true;
					return deflate(input, options)
				}
				function gzip(input, options) {
					options = options || {};
					options.gzip = true;
					return deflate(input, options)
				}
				exports.Deflate = Deflate;
				exports.deflate = deflate;
				exports.deflateRaw = deflateRaw;
				exports.gzip = gzip
			}, {
				"./utils/common" : 27,
				"./utils/strings" : 28,
				"./zlib/deflate.js" : 32,
				"./zlib/messages" : 37,
				"./zlib/zstream" : 39
			}
		],
		26 : [function (_dereq_, module, exports) {
				"use strict";
				var zlib_inflate = _dereq_("./zlib/inflate.js");
				var utils = _dereq_("./utils/common");
				var strings = _dereq_("./utils/strings");
				var c = _dereq_("./zlib/constants");
				var msg = _dereq_("./zlib/messages");
				var zstream = _dereq_("./zlib/zstream");
				var gzheader = _dereq_("./zlib/gzheader");
				var Inflate = function (options) {
					this.options = utils.assign({
							chunkSize : 16384,
							windowBits : 0,
							to : ""
						}, options || {});
					var opt = this.options;
					if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
						opt.windowBits = -opt.windowBits;
						if (opt.windowBits === 0) {
							opt.windowBits = -15
						}
					}
					if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
						opt.windowBits += 32
					}
					if (opt.windowBits > 15 && opt.windowBits < 48) {
						if ((opt.windowBits & 15) === 0) {
							opt.windowBits |= 15
						}
					}
					this.err = 0;
					this.msg = "";
					this.ended = false;
					this.chunks = [];
					this.strm = new zstream;
					this.strm.avail_out = 0;
					var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
					if (status !== c.Z_OK) {
						throw new Error(msg[status])
					}
					this.header = new gzheader;
					zlib_inflate.inflateGetHeader(this.strm, this.header)
				};
				Inflate.prototype.push = function (data, mode) {
					var strm = this.strm;
					var chunkSize = this.options.chunkSize;
					var status,
					_mode;
					var next_out_utf8,
					tail,
					utf8str;
					if (this.ended) {
						return false
					}
					_mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
					if (typeof data === "string") {
						strm.input = strings.binstring2buf(data)
					} else {
						strm.input = data
					}
					strm.next_in = 0;
					strm.avail_in = strm.input.length;
					do {
						if (strm.avail_out === 0) {
							strm.output = new utils.Buf8(chunkSize);
							strm.next_out = 0;
							strm.avail_out = chunkSize
						}
						status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
						if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
							this.onEnd(status);
							this.ended = true;
							return false
						}
						if (strm.next_out) {
							if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && _mode === c.Z_FINISH) {
								if (this.options.to === "string") {
									next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
									tail = strm.next_out - next_out_utf8;
									utf8str = strings.buf2string(strm.output, next_out_utf8);
									strm.next_out = tail;
									strm.avail_out = chunkSize - tail;
									if (tail) {
										utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0)
									}
									this.onData(utf8str)
								} else {
									this.onData(utils.shrinkBuf(strm.output, strm.next_out))
								}
							}
						}
					} while (strm.avail_in > 0 && status !== c.Z_STREAM_END);
					if (status === c.Z_STREAM_END) {
						_mode = c.Z_FINISH
					}
					if (_mode === c.Z_FINISH) {
						status = zlib_inflate.inflateEnd(this.strm);
						this.onEnd(status);
						this.ended = true;
						return status === c.Z_OK
					}
					return true
				};
				Inflate.prototype.onData = function (chunk) {
					this.chunks.push(chunk)
				};
				Inflate.prototype.onEnd = function (status) {
					if (status === c.Z_OK) {
						if (this.options.to === "string") {
							this.result = this.chunks.join("")
						} else {
							this.result = utils.flattenChunks(this.chunks)
						}
					}
					this.chunks = [];
					this.err = status;
					this.msg = this.strm.msg
				};
				function inflate(input, options) {
					var inflator = new Inflate(options);
					inflator.push(input, true);
					if (inflator.err) {
						throw inflator.msg
					}
					return inflator.result
				}
				function inflateRaw(input, options) {
					options = options || {};
					options.raw = true;
					return inflate(input, options)
				}
				exports.Inflate = Inflate;
				exports.inflate = inflate;
				exports.inflateRaw = inflateRaw;
				exports.ungzip = inflate
			}, {
				"./utils/common" : 27,
				"./utils/strings" : 28,
				"./zlib/constants" : 30,
				"./zlib/gzheader" : 33,
				"./zlib/inflate.js" : 35,
				"./zlib/messages" : 37,
				"./zlib/zstream" : 39
			}
		],
		27 : [function (_dereq_, module, exports) {
				"use strict";
				var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
				exports.assign = function (obj) {
					var sources = Array.prototype.slice.call(arguments, 1);
					while (sources.length) {
						var source = sources.shift();
						if (!source) {
							continue
						}
						if (typeof source !== "object") {
							throw new TypeError(source + "must be non-object")
						}
						for (var p in source) {
							if (source.hasOwnProperty(p)) {
								obj[p] = source[p]
							}
						}
					}
					return obj
				};
				exports.shrinkBuf = function (buf, size) {
					if (buf.length === size) {
						return buf
					}
					if (buf.subarray) {
						return buf.subarray(0, size)
					}
					buf.length = size;
					return buf
				};
				var fnTyped = {
					arraySet : function (dest, src, src_offs, len, dest_offs) {
						if (src.subarray && dest.subarray) {
							dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
							return
						}
						for (var i = 0; i < len; i++) {
							dest[dest_offs + i] = src[src_offs + i]
						}
					},
					flattenChunks : function (chunks) {
						var i,
						l,
						len,
						pos,
						chunk,
						result;
						len = 0;
						for (i = 0, l = chunks.length; i < l; i++) {
							len += chunks[i].length
						}
						result = new Uint8Array(len);
						pos = 0;
						for (i = 0, l = chunks.length; i < l; i++) {
							chunk = chunks[i];
							result.set(chunk, pos);
							pos += chunk.length
						}
						return result
					}
				};
				var fnUntyped = {
					arraySet : function (dest, src, src_offs, len, dest_offs) {
						for (var i = 0; i < len; i++) {
							dest[dest_offs + i] = src[src_offs + i]
						}
					},
					flattenChunks : function (chunks) {
						return [].concat.apply([], chunks)
					}
				};
				exports.setTyped = function (on) {
					if (on) {
						exports.Buf8 = Uint8Array;
						exports.Buf16 = Uint16Array;
						exports.Buf32 = Int32Array;
						exports.assign(exports, fnTyped)
					} else {
						exports.Buf8 = Array;
						exports.Buf16 = Array;
						exports.Buf32 = Array;
						exports.assign(exports, fnUntyped)
					}
				};
				exports.setTyped(TYPED_OK)
			}, {}

		],
		28 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("./common");
				var STR_APPLY_OK = true;
				var STR_APPLY_UIA_OK = true;
				try {
					String.fromCharCode.apply(null, [0])
				} catch (__) {
					STR_APPLY_OK = false
				}
				try {
					String.fromCharCode.apply(null, new Uint8Array(1))
				} catch (__) {
					STR_APPLY_UIA_OK = false
				}
				var _utf8len = new utils.Buf8(256);
				for (var i = 0; i < 256; i++) {
					_utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1
				}
				_utf8len[254] = _utf8len[254] = 1;
				exports.string2buf = function (str) {
					var buf,
					c,
					c2,
					m_pos,
					i,
					str_len = str.length,
					buf_len = 0;
					for (m_pos = 0; m_pos < str_len; m_pos++) {
						c = str.charCodeAt(m_pos);
						if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
							c2 = str.charCodeAt(m_pos + 1);
							if ((c2 & 64512) === 56320) {
								c = 65536 + (c - 55296 << 10) + (c2 - 56320);
								m_pos++
							}
						}
						buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4
					}
					buf = new utils.Buf8(buf_len);
					for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
						c = str.charCodeAt(m_pos);
						if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
							c2 = str.charCodeAt(m_pos + 1);
							if ((c2 & 64512) === 56320) {
								c = 65536 + (c - 55296 << 10) + (c2 - 56320);
								m_pos++
							}
						}
						if (c < 128) {
							buf[i++] = c
						} else if (c < 2048) {
							buf[i++] = 192 | c >>> 6;
							buf[i++] = 128 | c & 63
						} else if (c < 65536) {
							buf[i++] = 224 | c >>> 12;
							buf[i++] = 128 | c >>> 6 & 63;
							buf[i++] = 128 | c & 63
						} else {
							buf[i++] = 240 | c >>> 18;
							buf[i++] = 128 | c >>> 12 & 63;
							buf[i++] = 128 | c >>> 6 & 63;
							buf[i++] = 128 | c & 63
						}
					}
					return buf
				};
				function buf2binstring(buf, len) {
					if (len < 65537) {
						if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
							return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len))
						}
					}
					var result = "";
					for (var i = 0; i < len; i++) {
						result += String.fromCharCode(buf[i])
					}
					return result
				}
				exports.buf2binstring = function (buf) {
					return buf2binstring(buf, buf.length)
				};
				exports.binstring2buf = function (str) {
					var buf = new utils.Buf8(str.length);
					for (var i = 0, len = buf.length; i < len; i++) {
						buf[i] = str.charCodeAt(i)
					}
					return buf
				};
				exports.buf2string = function (buf, max) {
					var i,
					out,
					c,
					c_len;
					var len = max || buf.length;
					var utf16buf = new Array(len * 2);
					for (out = 0, i = 0; i < len; ) {
						c = buf[i++];
						if (c < 128) {
							utf16buf[out++] = c;
							continue
						}
						c_len = _utf8len[c];
						if (c_len > 4) {
							utf16buf[out++] = 65533;
							i += c_len - 1;
							continue
						}
						c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
						while (c_len > 1 && i < len) {
							c = c << 6 | buf[i++] & 63;
							c_len--
						}
						if (c_len > 1) {
							utf16buf[out++] = 65533;
							continue
						}
						if (c < 65536) {
							utf16buf[out++] = c
						} else {
							c -= 65536;
							utf16buf[out++] = 55296 | c >> 10 & 1023;
							utf16buf[out++] = 56320 | c & 1023
						}
					}
					return buf2binstring(utf16buf, out)
				};
				exports.utf8border = function (buf, max) {
					var pos;
					max = max || buf.length;
					if (max > buf.length) {
						max = buf.length
					}
					pos = max - 1;
					while (pos >= 0 && (buf[pos] & 192) === 128) {
						pos--
					}
					if (pos < 0) {
						return max
					}
					if (pos === 0) {
						return max
					}
					return pos + _utf8len[buf[pos]] > max ? pos : max
				}
			}, {
				"./common" : 27
			}
		],
		29 : [function (_dereq_, module, exports) {
				"use strict";
				function adler32(adler, buf, len, pos) {
					var s1 = adler & 65535 | 0,
					s2 = adler >>> 16 & 65535 | 0,
					n = 0;
					while (len !== 0) {
						n = len > 2e3 ? 2e3 : len;
						len -= n;
						do {
							s1 = s1 + buf[pos++] | 0;
							s2 = s2 + s1 | 0
						} while (--n);
						s1 %= 65521;
						s2 %= 65521
					}
					return s1 | s2 << 16 | 0
				}
				module.exports = adler32
			}, {}

		],
		30 : [function (_dereq_, module, exports) {
				module.exports = {
					Z_NO_FLUSH : 0,
					Z_PARTIAL_FLUSH : 1,
					Z_SYNC_FLUSH : 2,
					Z_FULL_FLUSH : 3,
					Z_FINISH : 4,
					Z_BLOCK : 5,
					Z_TREES : 6,
					Z_OK : 0,
					Z_STREAM_END : 1,
					Z_NEED_DICT : 2,
					Z_ERRNO : -1,
					Z_STREAM_ERROR : -2,
					Z_DATA_ERROR : -3,
					Z_BUF_ERROR : -5,
					Z_NO_COMPRESSION : 0,
					Z_BEST_SPEED : 1,
					Z_BEST_COMPRESSION : 9,
					Z_DEFAULT_COMPRESSION : -1,
					Z_FILTERED : 1,
					Z_HUFFMAN_ONLY : 2,
					Z_RLE : 3,
					Z_FIXED : 4,
					Z_DEFAULT_STRATEGY : 0,
					Z_BINARY : 0,
					Z_TEXT : 1,
					Z_UNKNOWN : 2,
					Z_DEFLATED : 8
				}
			}, {}

		],
		31 : [function (_dereq_, module, exports) {
				"use strict";
				function makeTable() {
					var c,
					table = [];
					for (var n = 0; n < 256; n++) {
						c = n;
						for (var k = 0; k < 8; k++) {
							c = c & 1 ? 3988292384^c >>> 1 : c >>> 1
						}
						table[n] = c
					}
					return table
				}
				var crcTable = makeTable();
				function crc32(crc, buf, len, pos) {
					var t = crcTable,
					end = pos + len;
					crc = crc^-1;
					for (var i = pos; i < end; i++) {
						crc = crc >>> 8^t[(crc^buf[i]) & 255]
					}
					return crc^-1
				}
				module.exports = crc32
			}, {}

		],
		32 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("../utils/common");
				var trees = _dereq_("./trees");
				var adler32 = _dereq_("./adler32");
				var crc32 = _dereq_("./crc32");
				var msg = _dereq_("./messages");
				var Z_NO_FLUSH = 0;
				var Z_PARTIAL_FLUSH = 1;
				var Z_FULL_FLUSH = 3;
				var Z_FINISH = 4;
				var Z_BLOCK = 5;
				var Z_OK = 0;
				var Z_STREAM_END = 1;
				var Z_STREAM_ERROR = -2;
				var Z_DATA_ERROR = -3;
				var Z_BUF_ERROR = -5;
				var Z_DEFAULT_COMPRESSION = -1;
				var Z_FILTERED = 1;
				var Z_HUFFMAN_ONLY = 2;
				var Z_RLE = 3;
				var Z_FIXED = 4;
				var Z_DEFAULT_STRATEGY = 0;
				var Z_UNKNOWN = 2;
				var Z_DEFLATED = 8;
				var MAX_MEM_LEVEL = 9;
				var MAX_WBITS = 15;
				var DEF_MEM_LEVEL = 8;
				var LENGTH_CODES = 29;
				var LITERALS = 256;
				var L_CODES = LITERALS + 1 + LENGTH_CODES;
				var D_CODES = 30;
				var BL_CODES = 19;
				var HEAP_SIZE = 2 * L_CODES + 1;
				var MAX_BITS = 15;
				var MIN_MATCH = 3;
				var MAX_MATCH = 258;
				var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
				var PRESET_DICT = 32;
				var INIT_STATE = 42;
				var EXTRA_STATE = 69;
				var NAME_STATE = 73;
				var COMMENT_STATE = 91;
				var HCRC_STATE = 103;
				var BUSY_STATE = 113;
				var FINISH_STATE = 666;
				var BS_NEED_MORE = 1;
				var BS_BLOCK_DONE = 2;
				var BS_FINISH_STARTED = 3;
				var BS_FINISH_DONE = 4;
				var OS_CODE = 3;
				function err(strm, errorCode) {
					strm.msg = msg[errorCode];
					return errorCode
				}
				function rank(f) {
					return (f << 1) - (f > 4 ? 9 : 0)
				}
				function zero(buf) {
					var len = buf.length;
					while (--len >= 0) {
						buf[len] = 0
					}
				}
				function flush_pending(strm) {
					var s = strm.state;
					var len = s.pending;
					if (len > strm.avail_out) {
						len = strm.avail_out
					}
					if (len === 0) {
						return
					}
					utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
					strm.next_out += len;
					s.pending_out += len;
					strm.total_out += len;
					strm.avail_out -= len;
					s.pending -= len;
					if (s.pending === 0) {
						s.pending_out = 0
					}
				}
				function flush_block_only(s, last) {
					trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
					s.block_start = s.strstart;
					flush_pending(s.strm)
				}
				function put_byte(s, b) {
					s.pending_buf[s.pending++] = b
				}
				function putShortMSB(s, b) {
					s.pending_buf[s.pending++] = b >>> 8 & 255;
					s.pending_buf[s.pending++] = b & 255
				}
				function read_buf(strm, buf, start, size) {
					var len = strm.avail_in;
					if (len > size) {
						len = size
					}
					if (len === 0) {
						return 0
					}
					strm.avail_in -= len;
					utils.arraySet(buf, strm.input, strm.next_in, len, start);
					if (strm.state.wrap === 1) {
						strm.adler = adler32(strm.adler, buf, len, start)
					} else if (strm.state.wrap === 2) {
						strm.adler = crc32(strm.adler, buf, len, start)
					}
					strm.next_in += len;
					strm.total_in += len;
					return len
				}
				function longest_match(s, cur_match) {
					var chain_length = s.max_chain_length;
					var scan = s.strstart;
					var match;
					var len;
					var best_len = s.prev_length;
					var nice_match = s.nice_match;
					var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
					var _win = s.window;
					var wmask = s.w_mask;
					var prev = s.prev;
					var strend = s.strstart + MAX_MATCH;
					var scan_end1 = _win[scan + best_len - 1];
					var scan_end = _win[scan + best_len];
					if (s.prev_length >= s.good_match) {
						chain_length >>= 2
					}
					if (nice_match > s.lookahead) {
						nice_match = s.lookahead
					}
					do {
						match = cur_match;
						if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
							continue
						}
						scan += 2;
						match++;
						do {}
						while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
						len = MAX_MATCH - (strend - scan);
						scan = strend - MAX_MATCH;
						if (len > best_len) {
							s.match_start = cur_match;
							best_len = len;
							if (len >= nice_match) {
								break
							}
							scan_end1 = _win[scan + best_len - 1];
							scan_end = _win[scan + best_len]
						}
					} while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
					if (best_len <= s.lookahead) {
						return best_len
					}
					return s.lookahead
				}
				function fill_window(s) {
					var _w_size = s.w_size;
					var p,
					n,
					m,
					more,
					str;
					do {
						more = s.window_size - s.lookahead - s.strstart;
						if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
							utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
							s.match_start -= _w_size;
							s.strstart -= _w_size;
							s.block_start -= _w_size;
							n = s.hash_size;
							p = n;
							do {
								m = s.head[--p];
								s.head[p] = m >= _w_size ? m - _w_size : 0
							} while (--n);
							n = _w_size;
							p = n;
							do {
								m = s.prev[--p];
								s.prev[p] = m >= _w_size ? m - _w_size : 0
							} while (--n);
							more += _w_size
						}
						if (s.strm.avail_in === 0) {
							break
						}
						n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
						s.lookahead += n;
						if (s.lookahead + s.insert >= MIN_MATCH) {
							str = s.strstart - s.insert;
							s.ins_h = s.window[str];
							s.ins_h = (s.ins_h << s.hash_shift^s.window[str + 1]) & s.hash_mask;
							while (s.insert) {
								s.ins_h = (s.ins_h << s.hash_shift^s.window[str + MIN_MATCH - 1]) & s.hash_mask;
								s.prev[str & s.w_mask] = s.head[s.ins_h];
								s.head[s.ins_h] = str;
								str++;
								s.insert--;
								if (s.lookahead + s.insert < MIN_MATCH) {
									break
								}
							}
						}
					} while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)
				}
				function deflate_stored(s, flush) {
					var max_block_size = 65535;
					if (max_block_size > s.pending_buf_size - 5) {
						max_block_size = s.pending_buf_size - 5
					}
					for (; ; ) {
						if (s.lookahead <= 1) {
							fill_window(s);
							if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
								return BS_NEED_MORE
							}
							if (s.lookahead === 0) {
								break
							}
						}
						s.strstart += s.lookahead;
						s.lookahead = 0;
						var max_start = s.block_start + max_block_size;
						if (s.strstart === 0 || s.strstart >= max_start) {
							s.lookahead = s.strstart - max_start;
							s.strstart = max_start;
							flush_block_only(s, false);
							if (s.strm.avail_out === 0) {
								return BS_NEED_MORE
							}
						}
						if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
							flush_block_only(s, false);
							if (s.strm.avail_out === 0) {
								return BS_NEED_MORE
							}
						}
					}
					s.insert = 0;
					if (flush === Z_FINISH) {
						flush_block_only(s, true);
						if (s.strm.avail_out === 0) {
							return BS_FINISH_STARTED
						}
						return BS_FINISH_DONE
					}
					if (s.strstart > s.block_start) {
						flush_block_only(s, false);
						if (s.strm.avail_out === 0) {
							return BS_NEED_MORE
						}
					}
					return BS_NEED_MORE
				}
				function deflate_fast(s, flush) {
					var hash_head;
					var bflush;
					for (; ; ) {
						if (s.lookahead < MIN_LOOKAHEAD) {
							fill_window(s);
							if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
								return BS_NEED_MORE
							}
							if (s.lookahead === 0) {
								break
							}
						}
						hash_head = 0;
						if (s.lookahead >= MIN_MATCH) {
							s.ins_h = (s.ins_h << s.hash_shift^s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
							hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
							s.head[s.ins_h] = s.strstart
						}
						if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
							s.match_length = longest_match(s, hash_head)
						}
						if (s.match_length >= MIN_MATCH) {
							bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
							s.lookahead -= s.match_length;
							if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
								s.match_length--;
								do {
									s.strstart++;
									s.ins_h = (s.ins_h << s.hash_shift^s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
									hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
									s.head[s.ins_h] = s.strstart
								} while (--s.match_length !== 0);
								s.strstart++
							} else {
								s.strstart += s.match_length;
								s.match_length = 0;
								s.ins_h = s.window[s.strstart];
								s.ins_h = (s.ins_h << s.hash_shift^s.window[s.strstart + 1]) & s.hash_mask
							}
						} else {
							bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
							s.lookahead--;
							s.strstart++
						}
						if (bflush) {
							flush_block_only(s, false);
							if (s.strm.avail_out === 0) {
								return BS_NEED_MORE
							}
						}
					}
					s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
					if (flush === Z_FINISH) {
						flush_block_only(s, true);
						if (s.strm.avail_out === 0) {
							return BS_FINISH_STARTED
						}
						return BS_FINISH_DONE
					}
					if (s.last_lit) {
						flush_block_only(s, false);
						if (s.strm.avail_out === 0) {
							return BS_NEED_MORE
						}
					}
					return BS_BLOCK_DONE
				}
				function deflate_slow(s, flush) {
					var hash_head;
					var bflush;
					var max_insert;
					for (; ; ) {
						if (s.lookahead < MIN_LOOKAHEAD) {
							fill_window(s);
							if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
								return BS_NEED_MORE
							}
							if (s.lookahead === 0) {
								break
							}
						}
						hash_head = 0;
						if (s.lookahead >= MIN_MATCH) {
							s.ins_h = (s.ins_h << s.hash_shift^s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
							hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
							s.head[s.ins_h] = s.strstart
						}
						s.prev_length = s.match_length;
						s.prev_match = s.match_start;
						s.match_length = MIN_MATCH - 1;
						if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
							s.match_length = longest_match(s, hash_head);
							if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
								s.match_length = MIN_MATCH - 1
							}
						}
						if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
							max_insert = s.strstart + s.lookahead - MIN_MATCH;
							bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
							s.lookahead -= s.prev_length - 1;
							s.prev_length -= 2;
							do {
								if (++s.strstart <= max_insert) {
									s.ins_h = (s.ins_h << s.hash_shift^s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
									hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
									s.head[s.ins_h] = s.strstart
								}
							} while (--s.prev_length !== 0);
							s.match_available = 0;
							s.match_length = MIN_MATCH - 1;
							s.strstart++;
							if (bflush) {
								flush_block_only(s, false);
								if (s.strm.avail_out === 0) {
									return BS_NEED_MORE
								}
							}
						} else if (s.match_available) {
							bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
							if (bflush) {
								flush_block_only(s, false)
							}
							s.strstart++;
							s.lookahead--;
							if (s.strm.avail_out === 0) {
								return BS_NEED_MORE
							}
						} else {
							s.match_available = 1;
							s.strstart++;
							s.lookahead--
						}
					}
					if (s.match_available) {
						bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
						s.match_available = 0
					}
					s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
					if (flush === Z_FINISH) {
						flush_block_only(s, true);
						if (s.strm.avail_out === 0) {
							return BS_FINISH_STARTED
						}
						return BS_FINISH_DONE
					}
					if (s.last_lit) {
						flush_block_only(s, false);
						if (s.strm.avail_out === 0) {
							return BS_NEED_MORE
						}
					}
					return BS_BLOCK_DONE
				}
				function deflate_rle(s, flush) {
					var bflush;
					var prev;
					var scan,
					strend;
					var _win = s.window;
					for (; ; ) {
						if (s.lookahead <= MAX_MATCH) {
							fill_window(s);
							if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
								return BS_NEED_MORE
							}
							if (s.lookahead === 0) {
								break
							}
						}
						s.match_length = 0;
						if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
							scan = s.strstart - 1;
							prev = _win[scan];
							if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
								strend = s.strstart + MAX_MATCH;
								do {}
								while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
								s.match_length = MAX_MATCH - (strend - scan);
								if (s.match_length > s.lookahead) {
									s.match_length = s.lookahead
								}
							}
						}
						if (s.match_length >= MIN_MATCH) {
							bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
							s.lookahead -= s.match_length;
							s.strstart += s.match_length;
							s.match_length = 0
						} else {
							bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
							s.lookahead--;
							s.strstart++
						}
						if (bflush) {
							flush_block_only(s, false);
							if (s.strm.avail_out === 0) {
								return BS_NEED_MORE
							}
						}
					}
					s.insert = 0;
					if (flush === Z_FINISH) {
						flush_block_only(s, true);
						if (s.strm.avail_out === 0) {
							return BS_FINISH_STARTED
						}
						return BS_FINISH_DONE
					}
					if (s.last_lit) {
						flush_block_only(s, false);
						if (s.strm.avail_out === 0) {
							return BS_NEED_MORE
						}
					}
					return BS_BLOCK_DONE
				}
				function deflate_huff(s, flush) {
					var bflush;
					for (; ; ) {
						if (s.lookahead === 0) {
							fill_window(s);
							if (s.lookahead === 0) {
								if (flush === Z_NO_FLUSH) {
									return BS_NEED_MORE
								}
								break
							}
						}
						s.match_length = 0;
						bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
						s.lookahead--;
						s.strstart++;
						if (bflush) {
							flush_block_only(s, false);
							if (s.strm.avail_out === 0) {
								return BS_NEED_MORE
							}
						}
					}
					s.insert = 0;
					if (flush === Z_FINISH) {
						flush_block_only(s, true);
						if (s.strm.avail_out === 0) {
							return BS_FINISH_STARTED
						}
						return BS_FINISH_DONE
					}
					if (s.last_lit) {
						flush_block_only(s, false);
						if (s.strm.avail_out === 0) {
							return BS_NEED_MORE
						}
					}
					return BS_BLOCK_DONE
				}
				var Config = function (good_length, max_lazy, nice_length, max_chain, func) {
					this.good_length = good_length;
					this.max_lazy = max_lazy;
					this.nice_length = nice_length;
					this.max_chain = max_chain;
					this.func = func
				};
				var configuration_table;
				configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)];
				function lm_init(s) {
					s.window_size = 2 * s.w_size;
					zero(s.head);
					s.max_lazy_match = configuration_table[s.level].max_lazy;
					s.good_match = configuration_table[s.level].good_length;
					s.nice_match = configuration_table[s.level].nice_length;
					s.max_chain_length = configuration_table[s.level].max_chain;
					s.strstart = 0;
					s.block_start = 0;
					s.lookahead = 0;
					s.insert = 0;
					s.match_length = s.prev_length = MIN_MATCH - 1;
					s.match_available = 0;
					s.ins_h = 0
				}
				function DeflateState() {
					this.strm = null;
					this.status = 0;
					this.pending_buf = null;
					this.pending_buf_size = 0;
					this.pending_out = 0;
					this.pending = 0;
					this.wrap = 0;
					this.gzhead = null;
					this.gzindex = 0;
					this.method = Z_DEFLATED;
					this.last_flush = -1;
					this.w_size = 0;
					this.w_bits = 0;
					this.w_mask = 0;
					this.window = null;
					this.window_size = 0;
					this.prev = null;
					this.head = null;
					this.ins_h = 0;
					this.hash_size = 0;
					this.hash_bits = 0;
					this.hash_mask = 0;
					this.hash_shift = 0;
					this.block_start = 0;
					this.match_length = 0;
					this.prev_match = 0;
					this.match_available = 0;
					this.strstart = 0;
					this.match_start = 0;
					this.lookahead = 0;
					this.prev_length = 0;
					this.max_chain_length = 0;
					this.max_lazy_match = 0;
					this.level = 0;
					this.strategy = 0;
					this.good_match = 0;
					this.nice_match = 0;
					this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
					this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
					this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
					zero(this.dyn_ltree);
					zero(this.dyn_dtree);
					zero(this.bl_tree);
					this.l_desc = null;
					this.d_desc = null;
					this.bl_desc = null;
					this.bl_count = new utils.Buf16(MAX_BITS + 1);
					this.heap = new utils.Buf16(2 * L_CODES + 1);
					zero(this.heap);
					this.heap_len = 0;
					this.heap_max = 0;
					this.depth = new utils.Buf16(2 * L_CODES + 1);
					zero(this.depth);
					this.l_buf = 0;
					this.lit_bufsize = 0;
					this.last_lit = 0;
					this.d_buf = 0;
					this.opt_len = 0;
					this.static_len = 0;
					this.matches = 0;
					this.insert = 0;
					this.bi_buf = 0;
					this.bi_valid = 0
				}
				function deflateResetKeep(strm) {
					var s;
					if (!strm || !strm.state) {
						return err(strm, Z_STREAM_ERROR)
					}
					strm.total_in = strm.total_out = 0;
					strm.data_type = Z_UNKNOWN;
					s = strm.state;
					s.pending = 0;
					s.pending_out = 0;
					if (s.wrap < 0) {
						s.wrap = -s.wrap
					}
					s.status = s.wrap ? INIT_STATE : BUSY_STATE;
					strm.adler = s.wrap === 2 ? 0 : 1;
					s.last_flush = Z_NO_FLUSH;
					trees._tr_init(s);
					return Z_OK
				}
				function deflateReset(strm) {
					var ret = deflateResetKeep(strm);
					if (ret === Z_OK) {
						lm_init(strm.state)
					}
					return ret
				}
				function deflateSetHeader(strm, head) {
					if (!strm || !strm.state) {
						return Z_STREAM_ERROR
					}
					if (strm.state.wrap !== 2) {
						return Z_STREAM_ERROR
					}
					strm.state.gzhead = head;
					return Z_OK
				}
				function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
					if (!strm) {
						return Z_STREAM_ERROR
					}
					var wrap = 1;
					if (level === Z_DEFAULT_COMPRESSION) {
						level = 6
					}
					if (windowBits < 0) {
						wrap = 0;
						windowBits = -windowBits
					} else if (windowBits > 15) {
						wrap = 2;
						windowBits -= 16
					}
					if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
						return err(strm, Z_STREAM_ERROR)
					}
					if (windowBits === 8) {
						windowBits = 9
					}
					var s = new DeflateState;
					strm.state = s;
					s.strm = strm;
					s.wrap = wrap;
					s.gzhead = null;
					s.w_bits = windowBits;
					s.w_size = 1 << s.w_bits;
					s.w_mask = s.w_size - 1;
					s.hash_bits = memLevel + 7;
					s.hash_size = 1 << s.hash_bits;
					s.hash_mask = s.hash_size - 1;
					s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
					s.window = new utils.Buf8(s.w_size * 2);
					s.head = new utils.Buf16(s.hash_size);
					s.prev = new utils.Buf16(s.w_size);
					s.lit_bufsize = 1 << memLevel + 6;
					s.pending_buf_size = s.lit_bufsize * 4;
					s.pending_buf = new utils.Buf8(s.pending_buf_size);
					s.d_buf = s.lit_bufsize >> 1;
					s.l_buf = (1 + 2) * s.lit_bufsize;
					s.level = level;
					s.strategy = strategy;
					s.method = method;
					return deflateReset(strm)
				}
				function deflateInit(strm, level) {
					return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)
				}
				function deflate(strm, flush) {
					var old_flush,
					s;
					var beg,
					val;
					if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
						return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR
					}
					s = strm.state;
					if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
						return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)
					}
					s.strm = strm;
					old_flush = s.last_flush;
					s.last_flush = flush;
					if (s.status === INIT_STATE) {
						if (s.wrap === 2) {
							strm.adler = 0;
							put_byte(s, 31);
							put_byte(s, 139);
							put_byte(s, 8);
							if (!s.gzhead) {
								put_byte(s, 0);
								put_byte(s, 0);
								put_byte(s, 0);
								put_byte(s, 0);
								put_byte(s, 0);
								put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
								put_byte(s, OS_CODE);
								s.status = BUSY_STATE
							} else {
								put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
								put_byte(s, s.gzhead.time & 255);
								put_byte(s, s.gzhead.time >> 8 & 255);
								put_byte(s, s.gzhead.time >> 16 & 255);
								put_byte(s, s.gzhead.time >> 24 & 255);
								put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
								put_byte(s, s.gzhead.os & 255);
								if (s.gzhead.extra && s.gzhead.extra.length) {
									put_byte(s, s.gzhead.extra.length & 255);
									put_byte(s, s.gzhead.extra.length >> 8 & 255)
								}
								if (s.gzhead.hcrc) {
									strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)
								}
								s.gzindex = 0;
								s.status = EXTRA_STATE
							}
						} else {
							var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
							var level_flags = -1;
							if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
								level_flags = 0
							} else if (s.level < 6) {
								level_flags = 1
							} else if (s.level === 6) {
								level_flags = 2
							} else {
								level_flags = 3
							}
							header |= level_flags << 6;
							if (s.strstart !== 0) {
								header |= PRESET_DICT
							}
							header += 31 - header % 31;
							s.status = BUSY_STATE;
							putShortMSB(s, header);
							if (s.strstart !== 0) {
								putShortMSB(s, strm.adler >>> 16);
								putShortMSB(s, strm.adler & 65535)
							}
							strm.adler = 1
						}
					}
					if (s.status === EXTRA_STATE) {
						if (s.gzhead.extra) {
							beg = s.pending;
							while (s.gzindex < (s.gzhead.extra.length & 65535)) {
								if (s.pending === s.pending_buf_size) {
									if (s.gzhead.hcrc && s.pending > beg) {
										strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
									}
									flush_pending(strm);
									beg = s.pending;
									if (s.pending === s.pending_buf_size) {
										break
									}
								}
								put_byte(s, s.gzhead.extra[s.gzindex] & 255);
								s.gzindex++
							}
							if (s.gzhead.hcrc && s.pending > beg) {
								strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
							}
							if (s.gzindex === s.gzhead.extra.length) {
								s.gzindex = 0;
								s.status = NAME_STATE
							}
						} else {
							s.status = NAME_STATE
						}
					}
					if (s.status === NAME_STATE) {
						if (s.gzhead.name) {
							beg = s.pending;
							do {
								if (s.pending === s.pending_buf_size) {
									if (s.gzhead.hcrc && s.pending > beg) {
										strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
									}
									flush_pending(strm);
									beg = s.pending;
									if (s.pending === s.pending_buf_size) {
										val = 1;
										break
									}
								}
								if (s.gzindex < s.gzhead.name.length) {
									val = s.gzhead.name.charCodeAt(s.gzindex++) & 255
								} else {
									val = 0
								}
								put_byte(s, val)
							} while (val !== 0);
							if (s.gzhead.hcrc && s.pending > beg) {
								strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
							}
							if (val === 0) {
								s.gzindex = 0;
								s.status = COMMENT_STATE
							}
						} else {
							s.status = COMMENT_STATE
						}
					}
					if (s.status === COMMENT_STATE) {
						if (s.gzhead.comment) {
							beg = s.pending;
							do {
								if (s.pending === s.pending_buf_size) {
									if (s.gzhead.hcrc && s.pending > beg) {
										strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
									}
									flush_pending(strm);
									beg = s.pending;
									if (s.pending === s.pending_buf_size) {
										val = 1;
										break
									}
								}
								if (s.gzindex < s.gzhead.comment.length) {
									val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255
								} else {
									val = 0
								}
								put_byte(s, val)
							} while (val !== 0);
							if (s.gzhead.hcrc && s.pending > beg) {
								strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)
							}
							if (val === 0) {
								s.status = HCRC_STATE
							}
						} else {
							s.status = HCRC_STATE
						}
					}
					if (s.status === HCRC_STATE) {
						if (s.gzhead.hcrc) {
							if (s.pending + 2 > s.pending_buf_size) {
								flush_pending(strm)
							}
							if (s.pending + 2 <= s.pending_buf_size) {
								put_byte(s, strm.adler & 255);
								put_byte(s, strm.adler >> 8 & 255);
								strm.adler = 0;
								s.status = BUSY_STATE
							}
						} else {
							s.status = BUSY_STATE
						}
					}
					if (s.pending !== 0) {
						flush_pending(strm);
						if (strm.avail_out === 0) {
							s.last_flush = -1;
							return Z_OK
						}
					} else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
						return err(strm, Z_BUF_ERROR)
					}
					if (s.status === FINISH_STATE && strm.avail_in !== 0) {
						return err(strm, Z_BUF_ERROR)
					}
					if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
						var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
						if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
							s.status = FINISH_STATE
						}
						if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
							if (strm.avail_out === 0) {
								s.last_flush = -1
							}
							return Z_OK
						}
						if (bstate === BS_BLOCK_DONE) {
							if (flush === Z_PARTIAL_FLUSH) {
								trees._tr_align(s)
							} else if (flush !== Z_BLOCK) {
								trees._tr_stored_block(s, 0, 0, false);
								if (flush === Z_FULL_FLUSH) {
									zero(s.head);
									if (s.lookahead === 0) {
										s.strstart = 0;
										s.block_start = 0;
										s.insert = 0
									}
								}
							}
							flush_pending(strm);
							if (strm.avail_out === 0) {
								s.last_flush = -1;
								return Z_OK
							}
						}
					}
					if (flush !== Z_FINISH) {
						return Z_OK
					}
					if (s.wrap <= 0) {
						return Z_STREAM_END
					}
					if (s.wrap === 2) {
						put_byte(s, strm.adler & 255);
						put_byte(s, strm.adler >> 8 & 255);
						put_byte(s, strm.adler >> 16 & 255);
						put_byte(s, strm.adler >> 24 & 255);
						put_byte(s, strm.total_in & 255);
						put_byte(s, strm.total_in >> 8 & 255);
						put_byte(s, strm.total_in >> 16 & 255);
						put_byte(s, strm.total_in >> 24 & 255)
					} else {
						putShortMSB(s, strm.adler >>> 16);
						putShortMSB(s, strm.adler & 65535)
					}
					flush_pending(strm);
					if (s.wrap > 0) {
						s.wrap = -s.wrap
					}
					return s.pending !== 0 ? Z_OK : Z_STREAM_END
				}
				function deflateEnd(strm) {
					var status;
					if (!strm || !strm.state) {
						return Z_STREAM_ERROR
					}
					status = strm.state.status;
					if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
						return err(strm, Z_STREAM_ERROR)
					}
					strm.state = null;
					return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK
				}
				exports.deflateInit = deflateInit;
				exports.deflateInit2 = deflateInit2;
				exports.deflateReset = deflateReset;
				exports.deflateResetKeep = deflateResetKeep;
				exports.deflateSetHeader = deflateSetHeader;
				exports.deflate = deflate;
				exports.deflateEnd = deflateEnd;
				exports.deflateInfo = "pako deflate (from Nodeca project)"
			}, {
				"../utils/common" : 27,
				"./adler32" : 29,
				"./crc32" : 31,
				"./messages" : 37,
				"./trees" : 38
			}
		],
		33 : [function (_dereq_, module, exports) {
				"use strict";
				function GZheader() {
					this.text = 0;
					this.time = 0;
					this.xflags = 0;
					this.os = 0;
					this.extra = null;
					this.extra_len = 0;
					this.name = "";
					this.comment = "";
					this.hcrc = 0;
					this.done = false
				}
				module.exports = GZheader
			}, {}

		],
		34 : [function (_dereq_, module, exports) {
				"use strict";
				var BAD = 30;
				var TYPE = 12;
				module.exports = function inflate_fast(strm, start) {
					var state;
					var _in;
					var last;
					var _out;
					var beg;
					var end;
					var dmax;
					var wsize;
					var whave;
					var wnext;
					var window;
					var hold;
					var bits;
					var lcode;
					var dcode;
					var lmask;
					var dmask;
					var here;
					var op;
					var len;
					var dist;
					var from;
					var from_source;
					var input,
					output;
					state = strm.state;
					_in = strm.next_in;
					input = strm.input;
					last = _in + (strm.avail_in - 5);
					_out = strm.next_out;
					output = strm.output;
					beg = _out - (start - strm.avail_out);
					end = _out + (strm.avail_out - 257);
					dmax = state.dmax;
					wsize = state.wsize;
					whave = state.whave;
					wnext = state.wnext;
					window = state.window;
					hold = state.hold;
					bits = state.bits;
					lcode = state.lencode;
					dcode = state.distcode;
					lmask = (1 << state.lenbits) - 1;
					dmask = (1 << state.distbits) - 1;
					top : do {
						if (bits < 15) {
							hold += input[_in++] << bits;
							bits += 8;
							hold += input[_in++] << bits;
							bits += 8
						}
						here = lcode[hold & lmask];
						dolen : for (; ; ) {
							op = here >>> 24;
							hold >>>= op;
							bits -= op;
							op = here >>> 16 & 255;
							if (op === 0) {
								output[_out++] = here & 65535
							} else if (op & 16) {
								len = here & 65535;
								op &= 15;
								if (op) {
									if (bits < op) {
										hold += input[_in++] << bits;
										bits += 8
									}
									len += hold & (1 << op) - 1;
									hold >>>= op;
									bits -= op
								}
								if (bits < 15) {
									hold += input[_in++] << bits;
									bits += 8;
									hold += input[_in++] << bits;
									bits += 8
								}
								here = dcode[hold & dmask];
								dodist : for (; ; ) {
									op = here >>> 24;
									hold >>>= op;
									bits -= op;
									op = here >>> 16 & 255;
									if (op & 16) {
										dist = here & 65535;
										op &= 15;
										if (bits < op) {
											hold += input[_in++] << bits;
											bits += 8;
											if (bits < op) {
												hold += input[_in++] << bits;
												bits += 8
											}
										}
										dist += hold & (1 << op) - 1;
										if (dist > dmax) {
											strm.msg = "invalid distance too far back";
											state.mode = BAD;
											break top
										}
										hold >>>= op;
										bits -= op;
										op = _out - beg;
										if (dist > op) {
											op = dist - op;
											if (op > whave) {
												if (state.sane) {
													strm.msg = "invalid distance too far back";
													state.mode = BAD;
													break top
												}
											}
											from = 0;
											from_source = window;
											if (wnext === 0) {
												from += wsize - op;
												if (op < len) {
													len -= op;
													do {
														output[_out++] = window[from++]
													} while (--op);
													from = _out - dist;
													from_source = output
												}
											} else if (wnext < op) {
												from += wsize + wnext - op;
												op -= wnext;
												if (op < len) {
													len -= op;
													do {
														output[_out++] = window[from++]
													} while (--op);
													from = 0;
													if (wnext < len) {
														op = wnext;
														len -= op;
														do {
															output[_out++] = window[from++]
														} while (--op);
														from = _out - dist;
														from_source = output
													}
												}
											} else {
												from += wnext - op;
												if (op < len) {
													len -= op;
													do {
														output[_out++] = window[from++]
													} while (--op);
													from = _out - dist;
													from_source = output
												}
											}
											while (len > 2) {
												output[_out++] = from_source[from++];
												output[_out++] = from_source[from++];
												output[_out++] = from_source[from++];
												len -= 3
											}
											if (len) {
												output[_out++] = from_source[from++];
												if (len > 1) {
													output[_out++] = from_source[from++]
												}
											}
										} else {
											from = _out - dist;
											do {
												output[_out++] = output[from++];
												output[_out++] = output[from++];
												output[_out++] = output[from++];
												len -= 3
											} while (len > 2);
											if (len) {
												output[_out++] = output[from++];
												if (len > 1) {
													output[_out++] = output[from++]
												}
											}
										}
									} else if ((op & 64) === 0) {
										here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
										continue dodist
									} else {
										strm.msg = "invalid distance code";
										state.mode = BAD;
										break top
									}
									break
								}
							} else if ((op & 64) === 0) {
								here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
								continue dolen
							} else if (op & 32) {
								state.mode = TYPE;
								break top
							} else {
								strm.msg = "invalid literal/length code";
								state.mode = BAD;
								break top
							}
							break
						}
					} while (_in < last && _out < end);
					len = bits >> 3;
					_in -= len;
					bits -= len << 3;
					hold &= (1 << bits) - 1;
					strm.next_in = _in;
					strm.next_out = _out;
					strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
					strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
					state.hold = hold;
					state.bits = bits;
					return
				}
			}, {}

		],
		35 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("../utils/common");
				var adler32 = _dereq_("./adler32");
				var crc32 = _dereq_("./crc32");
				var inflate_fast = _dereq_("./inffast");
				var inflate_table = _dereq_("./inftrees");
				var CODES = 0;
				var LENS = 1;
				var DISTS = 2;
				var Z_FINISH = 4;
				var Z_BLOCK = 5;
				var Z_TREES = 6;
				var Z_OK = 0;
				var Z_STREAM_END = 1;
				var Z_NEED_DICT = 2;
				var Z_STREAM_ERROR = -2;
				var Z_DATA_ERROR = -3;
				var Z_MEM_ERROR = -4;
				var Z_BUF_ERROR = -5;
				var Z_DEFLATED = 8;
				var HEAD = 1;
				var FLAGS = 2;
				var TIME = 3;
				var OS = 4;
				var EXLEN = 5;
				var EXTRA = 6;
				var NAME = 7;
				var COMMENT = 8;
				var HCRC = 9;
				var DICTID = 10;
				var DICT = 11;
				var TYPE = 12;
				var TYPEDO = 13;
				var STORED = 14;
				var COPY_ = 15;
				var COPY = 16;
				var TABLE = 17;
				var LENLENS = 18;
				var CODELENS = 19;
				var LEN_ = 20;
				var LEN = 21;
				var LENEXT = 22;
				var DIST = 23;
				var DISTEXT = 24;
				var MATCH = 25;
				var LIT = 26;
				var CHECK = 27;
				var LENGTH = 28;
				var DONE = 29;
				var BAD = 30;
				var MEM = 31;
				var SYNC = 32;
				var ENOUGH_LENS = 852;
				var ENOUGH_DISTS = 592;
				var MAX_WBITS = 15;
				var DEF_WBITS = MAX_WBITS;
				function ZSWAP32(q) {
					return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24)
				}
				function InflateState() {
					this.mode = 0;
					this.last = false;
					this.wrap = 0;
					this.havedict = false;
					this.flags = 0;
					this.dmax = 0;
					this.check = 0;
					this.total = 0;
					this.head = null;
					this.wbits = 0;
					this.wsize = 0;
					this.whave = 0;
					this.wnext = 0;
					this.window = null;
					this.hold = 0;
					this.bits = 0;
					this.length = 0;
					this.offset = 0;
					this.extra = 0;
					this.lencode = null;
					this.distcode = null;
					this.lenbits = 0;
					this.distbits = 0;
					this.ncode = 0;
					this.nlen = 0;
					this.ndist = 0;
					this.have = 0;
					this.next = null;
					this.lens = new utils.Buf16(320);
					this.work = new utils.Buf16(288);
					this.lendyn = null;
					this.distdyn = null;
					this.sane = 0;
					this.back = 0;
					this.was = 0
				}
				function inflateResetKeep(strm) {
					var state;
					if (!strm || !strm.state) {
						return Z_STREAM_ERROR
					}
					state = strm.state;
					strm.total_in = strm.total_out = state.total = 0;
					strm.msg = "";
					if (state.wrap) {
						strm.adler = state.wrap & 1
					}
					state.mode = HEAD;
					state.last = 0;
					state.havedict = 0;
					state.dmax = 32768;
					state.head = null;
					state.hold = 0;
					state.bits = 0;
					state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
					state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
					state.sane = 1;
					state.back = -1;
					return Z_OK
				}
				function inflateReset(strm) {
					var state;
					if (!strm || !strm.state) {
						return Z_STREAM_ERROR
					}
					state = strm.state;
					state.wsize = 0;
					state.whave = 0;
					state.wnext = 0;
					return inflateResetKeep(strm)
				}
				function inflateReset2(strm, windowBits) {
					var wrap;
					var state;
					if (!strm || !strm.state) {
						return Z_STREAM_ERROR
					}
					state = strm.state;
					if (windowBits < 0) {
						wrap = 0;
						windowBits = -windowBits
					} else {
						wrap = (windowBits >> 4) + 1;
						if (windowBits < 48) {
							windowBits &= 15
						}
					}
					if (windowBits && (windowBits < 8 || windowBits > 15)) {
						return Z_STREAM_ERROR
					}
					if (state.window !== null && state.wbits !== windowBits) {
						state.window = null
					}
					state.wrap = wrap;
					state.wbits = windowBits;
					return inflateReset(strm)
				}
				function inflateInit2(strm, windowBits) {
					var ret;
					var state;
					if (!strm) {
						return Z_STREAM_ERROR
					}
					state = new InflateState;
					strm.state = state;
					state.window = null;
					ret = inflateReset2(strm, windowBits);
					if (ret !== Z_OK) {
						strm.state = null
					}
					return ret
				}
				function inflateInit(strm) {
					return inflateInit2(strm, DEF_WBITS)
				}
				var virgin = true;
				var lenfix,
				distfix;
				function fixedtables(state) {
					if (virgin) {
						var sym;
						lenfix = new utils.Buf32(512);
						distfix = new utils.Buf32(32);
						sym = 0;
						while (sym < 144) {
							state.lens[sym++] = 8
						}
						while (sym < 256) {
							state.lens[sym++] = 9
						}
						while (sym < 280) {
							state.lens[sym++] = 7
						}
						while (sym < 288) {
							state.lens[sym++] = 8
						}
						inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
							bits : 9
						});
						sym = 0;
						while (sym < 32) {
							state.lens[sym++] = 5
						}
						inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
							bits : 5
						});
						virgin = false
					}
					state.lencode = lenfix;
					state.lenbits = 9;
					state.distcode = distfix;
					state.distbits = 5
				}
				function updatewindow(strm, src, end, copy) {
					var dist;
					var state = strm.state;
					if (state.window === null) {
						state.wsize = 1 << state.wbits;
						state.wnext = 0;
						state.whave = 0;
						state.window = new utils.Buf8(state.wsize)
					}
					if (copy >= state.wsize) {
						utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
						state.wnext = 0;
						state.whave = state.wsize
					} else {
						dist = state.wsize - state.wnext;
						if (dist > copy) {
							dist = copy
						}
						utils.arraySet(state.window, src, end - copy, dist, state.wnext);
						copy -= dist;
						if (copy) {
							utils.arraySet(state.window, src, end - copy, copy, 0);
							state.wnext = copy;
							state.whave = state.wsize
						} else {
							state.wnext += dist;
							if (state.wnext === state.wsize) {
								state.wnext = 0
							}
							if (state.whave < state.wsize) {
								state.whave += dist
							}
						}
					}
					return 0
				}
				function inflate(strm, flush) {
					var state;
					var input,
					output;
					var next;
					var put;
					var have,
					left;
					var hold;
					var bits;
					var _in,
					_out;
					var copy;
					var from;
					var from_source;
					var here = 0;
					var here_bits,
					here_op,
					here_val;
					var last_bits,
					last_op,
					last_val;
					var len;
					var ret;
					var hbuf = new utils.Buf8(4);
					var opts;
					var n;
					var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
					if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
						return Z_STREAM_ERROR
					}
					state = strm.state;
					if (state.mode === TYPE) {
						state.mode = TYPEDO
					}
					put = strm.next_out;
					output = strm.output;
					left = strm.avail_out;
					next = strm.next_in;
					input = strm.input;
					have = strm.avail_in;
					hold = state.hold;
					bits = state.bits;
					_in = have;
					_out = left;
					ret = Z_OK;
					inf_leave : for (; ; ) {
						switch (state.mode) {
						case HEAD:
							if (state.wrap === 0) {
								state.mode = TYPEDO;
								break
							}
							while (bits < 16) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							if (state.wrap & 2 && hold === 35615) {
								state.check = 0;
								hbuf[0] = hold & 255;
								hbuf[1] = hold >>> 8 & 255;
								state.check = crc32(state.check, hbuf, 2, 0);
								hold = 0;
								bits = 0;
								state.mode = FLAGS;
								break
							}
							state.flags = 0;
							if (state.head) {
								state.head.done = false
							}
							if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
								strm.msg = "incorrect header check";
								state.mode = BAD;
								break
							}
							if ((hold & 15) !== Z_DEFLATED) {
								strm.msg = "unknown compression method";
								state.mode = BAD;
								break
							}
							hold >>>= 4;
							bits -= 4;
							len = (hold & 15) + 8;
							if (state.wbits === 0) {
								state.wbits = len
							} else if (len > state.wbits) {
								strm.msg = "invalid window size";
								state.mode = BAD;
								break
							}
							state.dmax = 1 << len;
							strm.adler = state.check = 1;
							state.mode = hold & 512 ? DICTID : TYPE;
							hold = 0;
							bits = 0;
							break;
						case FLAGS:
							while (bits < 16) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							state.flags = hold;
							if ((state.flags & 255) !== Z_DEFLATED) {
								strm.msg = "unknown compression method";
								state.mode = BAD;
								break
							}
							if (state.flags & 57344) {
								strm.msg = "unknown header flags set";
								state.mode = BAD;
								break
							}
							if (state.head) {
								state.head.text = hold >> 8 & 1
							}
							if (state.flags & 512) {
								hbuf[0] = hold & 255;
								hbuf[1] = hold >>> 8 & 255;
								state.check = crc32(state.check, hbuf, 2, 0)
							}
							hold = 0;
							bits = 0;
							state.mode = TIME;
						case TIME:
							while (bits < 32) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							if (state.head) {
								state.head.time = hold
							}
							if (state.flags & 512) {
								hbuf[0] = hold & 255;
								hbuf[1] = hold >>> 8 & 255;
								hbuf[2] = hold >>> 16 & 255;
								hbuf[3] = hold >>> 24 & 255;
								state.check = crc32(state.check, hbuf, 4, 0)
							}
							hold = 0;
							bits = 0;
							state.mode = OS;
						case OS:
							while (bits < 16) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							if (state.head) {
								state.head.xflags = hold & 255;
								state.head.os = hold >> 8
							}
							if (state.flags & 512) {
								hbuf[0] = hold & 255;
								hbuf[1] = hold >>> 8 & 255;
								state.check = crc32(state.check, hbuf, 2, 0)
							}
							hold = 0;
							bits = 0;
							state.mode = EXLEN;
						case EXLEN:
							if (state.flags & 1024) {
								while (bits < 16) {
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								state.length = hold;
								if (state.head) {
									state.head.extra_len = hold
								}
								if (state.flags & 512) {
									hbuf[0] = hold & 255;
									hbuf[1] = hold >>> 8 & 255;
									state.check = crc32(state.check, hbuf, 2, 0)
								}
								hold = 0;
								bits = 0
							} else if (state.head) {
								state.head.extra = null
							}
							state.mode = EXTRA;
						case EXTRA:
							if (state.flags & 1024) {
								copy = state.length;
								if (copy > have) {
									copy = have
								}
								if (copy) {
									if (state.head) {
										len = state.head.extra_len - state.length;
										if (!state.head.extra) {
											state.head.extra = new Array(state.head.extra_len)
										}
										utils.arraySet(state.head.extra, input, next, copy, len)
									}
									if (state.flags & 512) {
										state.check = crc32(state.check, input, copy, next)
									}
									have -= copy;
									next += copy;
									state.length -= copy
								}
								if (state.length) {
									break inf_leave
								}
							}
							state.length = 0;
							state.mode = NAME;
						case NAME:
							if (state.flags & 2048) {
								if (have === 0) {
									break inf_leave
								}
								copy = 0;
								do {
									len = input[next + copy++];
									if (state.head && len && state.length < 65536) {
										state.head.name += String.fromCharCode(len)
									}
								} while (len && copy < have);
								if (state.flags & 512) {
									state.check = crc32(state.check, input, copy, next)
								}
								have -= copy;
								next += copy;
								if (len) {
									break inf_leave
								}
							} else if (state.head) {
								state.head.name = null
							}
							state.length = 0;
							state.mode = COMMENT;
						case COMMENT:
							if (state.flags & 4096) {
								if (have === 0) {
									break inf_leave
								}
								copy = 0;
								do {
									len = input[next + copy++];
									if (state.head && len && state.length < 65536) {
										state.head.comment += String.fromCharCode(len)
									}
								} while (len && copy < have);
								if (state.flags & 512) {
									state.check = crc32(state.check, input, copy, next)
								}
								have -= copy;
								next += copy;
								if (len) {
									break inf_leave
								}
							} else if (state.head) {
								state.head.comment = null
							}
							state.mode = HCRC;
						case HCRC:
							if (state.flags & 512) {
								while (bits < 16) {
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								if (hold !== (state.check & 65535)) {
									strm.msg = "header crc mismatch";
									state.mode = BAD;
									break
								}
								hold = 0;
								bits = 0
							}
							if (state.head) {
								state.head.hcrc = state.flags >> 9 & 1;
								state.head.done = true
							}
							strm.adler = state.check = 0;
							state.mode = TYPE;
							break;
						case DICTID:
							while (bits < 32) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							strm.adler = state.check = ZSWAP32(hold);
							hold = 0;
							bits = 0;
							state.mode = DICT;
						case DICT:
							if (state.havedict === 0) {
								strm.next_out = put;
								strm.avail_out = left;
								strm.next_in = next;
								strm.avail_in = have;
								state.hold = hold;
								state.bits = bits;
								return Z_NEED_DICT
							}
							strm.adler = state.check = 1;
							state.mode = TYPE;
						case TYPE:
							if (flush === Z_BLOCK || flush === Z_TREES) {
								break inf_leave
							}
						case TYPEDO:
							if (state.last) {
								hold >>>= bits & 7;
								bits -= bits & 7;
								state.mode = CHECK;
								break
							}
							while (bits < 3) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							state.last = hold & 1;
							hold >>>= 1;
							bits -= 1;
							switch (hold & 3) {
							case 0:
								state.mode = STORED;
								break;
							case 1:
								fixedtables(state);
								state.mode = LEN_;
								if (flush === Z_TREES) {
									hold >>>= 2;
									bits -= 2;
									break inf_leave
								}
								break;
							case 2:
								state.mode = TABLE;
								break;
							case 3:
								strm.msg = "invalid block type";
								state.mode = BAD
							}
							hold >>>= 2;
							bits -= 2;
							break;
						case STORED:
							hold >>>= bits & 7;
							bits -= bits & 7;
							while (bits < 32) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							if ((hold & 65535) !== (hold >>> 16^65535)) {
								strm.msg = "invalid stored block lengths";
								state.mode = BAD;
								break
							}
							state.length = hold & 65535;
							hold = 0;
							bits = 0;
							state.mode = COPY_;
							if (flush === Z_TREES) {
								break inf_leave
							}
						case COPY_:
							state.mode = COPY;
						case COPY:
							copy = state.length;
							if (copy) {
								if (copy > have) {
									copy = have
								}
								if (copy > left) {
									copy = left
								}
								if (copy === 0) {
									break inf_leave
								}
								utils.arraySet(output, input, next, copy, put);
								have -= copy;
								next += copy;
								left -= copy;
								put += copy;
								state.length -= copy;
								break
							}
							state.mode = TYPE;
							break;
						case TABLE:
							while (bits < 14) {
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							state.nlen = (hold & 31) + 257;
							hold >>>= 5;
							bits -= 5;
							state.ndist = (hold & 31) + 1;
							hold >>>= 5;
							bits -= 5;
							state.ncode = (hold & 15) + 4;
							hold >>>= 4;
							bits -= 4;
							if (state.nlen > 286 || state.ndist > 30) {
								strm.msg = "too many length or distance symbols";
								state.mode = BAD;
								break
							}
							state.have = 0;
							state.mode = LENLENS;
						case LENLENS:
							while (state.have < state.ncode) {
								while (bits < 3) {
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								state.lens[order[state.have++]] = hold & 7;
								hold >>>= 3;
								bits -= 3
							}
							while (state.have < 19) {
								state.lens[order[state.have++]] = 0
							}
							state.lencode = state.lendyn;
							state.lenbits = 7;
							opts = {
								bits : state.lenbits
							};
							ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
							state.lenbits = opts.bits;
							if (ret) {
								strm.msg = "invalid code lengths set";
								state.mode = BAD;
								break
							}
							state.have = 0;
							state.mode = CODELENS;
						case CODELENS:
							while (state.have < state.nlen + state.ndist) {
								for (; ; ) {
									here = state.lencode[hold & (1 << state.lenbits) - 1];
									here_bits = here >>> 24;
									here_op = here >>> 16 & 255;
									here_val = here & 65535;
									if (here_bits <= bits) {
										break
									}
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								if (here_val < 16) {
									hold >>>= here_bits;
									bits -= here_bits;
									state.lens[state.have++] = here_val
								} else {
									if (here_val === 16) {
										n = here_bits + 2;
										while (bits < n) {
											if (have === 0) {
												break inf_leave
											}
											have--;
											hold += input[next++] << bits;
											bits += 8
										}
										hold >>>= here_bits;
										bits -= here_bits;
										if (state.have === 0) {
											strm.msg = "invalid bit length repeat";
											state.mode = BAD;
											break
										}
										len = state.lens[state.have - 1];
										copy = 3 + (hold & 3);
										hold >>>= 2;
										bits -= 2
									} else if (here_val === 17) {
										n = here_bits + 3;
										while (bits < n) {
											if (have === 0) {
												break inf_leave
											}
											have--;
											hold += input[next++] << bits;
											bits += 8
										}
										hold >>>= here_bits;
										bits -= here_bits;
										len = 0;
										copy = 3 + (hold & 7);
										hold >>>= 3;
										bits -= 3
									} else {
										n = here_bits + 7;
										while (bits < n) {
											if (have === 0) {
												break inf_leave
											}
											have--;
											hold += input[next++] << bits;
											bits += 8
										}
										hold >>>= here_bits;
										bits -= here_bits;
										len = 0;
										copy = 11 + (hold & 127);
										hold >>>= 7;
										bits -= 7
									}
									if (state.have + copy > state.nlen + state.ndist) {
										strm.msg = "invalid bit length repeat";
										state.mode = BAD;
										break
									}
									while (copy--) {
										state.lens[state.have++] = len
									}
								}
							}
							if (state.mode === BAD) {
								break
							}
							if (state.lens[256] === 0) {
								strm.msg = "invalid code -- missing end-of-block";
								state.mode = BAD;
								break
							}
							state.lenbits = 9;
							opts = {
								bits : state.lenbits
							};
							ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
							state.lenbits = opts.bits;
							if (ret) {
								strm.msg = "invalid literal/lengths set";
								state.mode = BAD;
								break
							}
							state.distbits = 6;
							state.distcode = state.distdyn;
							opts = {
								bits : state.distbits
							};
							ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
							state.distbits = opts.bits;
							if (ret) {
								strm.msg = "invalid distances set";
								state.mode = BAD;
								break
							}
							state.mode = LEN_;
							if (flush === Z_TREES) {
								break inf_leave
							}
						case LEN_:
							state.mode = LEN;
						case LEN:
							if (have >= 6 && left >= 258) {
								strm.next_out = put;
								strm.avail_out = left;
								strm.next_in = next;
								strm.avail_in = have;
								state.hold = hold;
								state.bits = bits;
								inflate_fast(strm, _out);
								put = strm.next_out;
								output = strm.output;
								left = strm.avail_out;
								next = strm.next_in;
								input = strm.input;
								have = strm.avail_in;
								hold = state.hold;
								bits = state.bits;
								if (state.mode === TYPE) {
									state.back = -1
								}
								break
							}
							state.back = 0;
							for (; ; ) {
								here = state.lencode[hold & (1 << state.lenbits) - 1];
								here_bits = here >>> 24;
								here_op = here >>> 16 & 255;
								here_val = here & 65535;
								if (here_bits <= bits) {
									break
								}
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							if (here_op && (here_op & 240) === 0) {
								last_bits = here_bits;
								last_op = here_op;
								last_val = here_val;
								for (; ; ) {
									here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
									here_bits = here >>> 24;
									here_op = here >>> 16 & 255;
									here_val = here & 65535;
									if (last_bits + here_bits <= bits) {
										break
									}
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								hold >>>= last_bits;
								bits -= last_bits;
								state.back += last_bits
							}
							hold >>>= here_bits;
							bits -= here_bits;
							state.back += here_bits;
							state.length = here_val;
							if (here_op === 0) {
								state.mode = LIT;
								break
							}
							if (here_op & 32) {
								state.back = -1;
								state.mode = TYPE;
								break
							}
							if (here_op & 64) {
								strm.msg = "invalid literal/length code";
								state.mode = BAD;
								break
							}
							state.extra = here_op & 15;
							state.mode = LENEXT;
						case LENEXT:
							if (state.extra) {
								n = state.extra;
								while (bits < n) {
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								state.length += hold & (1 << state.extra) - 1;
								hold >>>= state.extra;
								bits -= state.extra;
								state.back += state.extra
							}
							state.was = state.length;
							state.mode = DIST;
						case DIST:
							for (; ; ) {
								here = state.distcode[hold & (1 << state.distbits) - 1];
								here_bits = here >>> 24;
								here_op = here >>> 16 & 255;
								here_val = here & 65535;
								if (here_bits <= bits) {
									break
								}
								if (have === 0) {
									break inf_leave
								}
								have--;
								hold += input[next++] << bits;
								bits += 8
							}
							if ((here_op & 240) === 0) {
								last_bits = here_bits;
								last_op = here_op;
								last_val = here_val;
								for (; ; ) {
									here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
									here_bits = here >>> 24;
									here_op = here >>> 16 & 255;
									here_val = here & 65535;
									if (last_bits + here_bits <= bits) {
										break
									}
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								hold >>>= last_bits;
								bits -= last_bits;
								state.back += last_bits
							}
							hold >>>= here_bits;
							bits -= here_bits;
							state.back += here_bits;
							if (here_op & 64) {
								strm.msg = "invalid distance code";
								state.mode = BAD;
								break
							}
							state.offset = here_val;
							state.extra = here_op & 15;
							state.mode = DISTEXT;
						case DISTEXT:
							if (state.extra) {
								n = state.extra;
								while (bits < n) {
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								state.offset += hold & (1 << state.extra) - 1;
								hold >>>= state.extra;
								bits -= state.extra;
								state.back += state.extra
							}
							if (state.offset > state.dmax) {
								strm.msg = "invalid distance too far back";
								state.mode = BAD;
								break
							}
							state.mode = MATCH;
						case MATCH:
							if (left === 0) {
								break inf_leave
							}
							copy = _out - left;
							if (state.offset > copy) {
								copy = state.offset - copy;
								if (copy > state.whave) {
									if (state.sane) {
										strm.msg = "invalid distance too far back";
										state.mode = BAD;
										break
									}
								}
								if (copy > state.wnext) {
									copy -= state.wnext;
									from = state.wsize - copy
								} else {
									from = state.wnext - copy
								}
								if (copy > state.length) {
									copy = state.length
								}
								from_source = state.window
							} else {
								from_source = output;
								from = put - state.offset;
								copy = state.length
							}
							if (copy > left) {
								copy = left
							}
							left -= copy;
							state.length -= copy;
							do {
								output[put++] = from_source[from++]
							} while (--copy);
							if (state.length === 0) {
								state.mode = LEN
							}
							break;
						case LIT:
							if (left === 0) {
								break inf_leave
							}
							output[put++] = state.length;
							left--;
							state.mode = LEN;
							break;
						case CHECK:
							if (state.wrap) {
								while (bits < 32) {
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold |= input[next++] << bits;
									bits += 8
								}
								_out -= left;
								strm.total_out += _out;
								state.total += _out;
								if (_out) {
									strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)
								}
								_out = left;
								if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {
									strm.msg = "incorrect data check";
									state.mode = BAD;
									break
								}
								hold = 0;
								bits = 0
							}
							state.mode = LENGTH;
						case LENGTH:
							if (state.wrap && state.flags) {
								while (bits < 32) {
									if (have === 0) {
										break inf_leave
									}
									have--;
									hold += input[next++] << bits;
									bits += 8
								}
								if (hold !== (state.total & 4294967295)) {
									strm.msg = "incorrect length check";
									state.mode = BAD;
									break
								}
								hold = 0;
								bits = 0
							}
							state.mode = DONE;
						case DONE:
							ret = Z_STREAM_END;
							break inf_leave;
						case BAD:
							ret = Z_DATA_ERROR;
							break inf_leave;
						case MEM:
							return Z_MEM_ERROR;
						case SYNC:
						default:
							return Z_STREAM_ERROR
						}
					}
					strm.next_out = put;
					strm.avail_out = left;
					strm.next_in = next;
					strm.avail_in = have;
					state.hold = hold;
					state.bits = bits;
					if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
						if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
							state.mode = MEM;
							return Z_MEM_ERROR
						}
					}
					_in -= strm.avail_in;
					_out -= strm.avail_out;
					strm.total_in += _in;
					strm.total_out += _out;
					state.total += _out;
					if (state.wrap && _out) {
						strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)
					}
					strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
					if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
						ret = Z_BUF_ERROR
					}
					return ret
				}
				function inflateEnd(strm) {
					if (!strm || !strm.state) {
						return Z_STREAM_ERROR
					}
					var state = strm.state;
					if (state.window) {
						state.window = null
					}
					strm.state = null;
					return Z_OK
				}
				function inflateGetHeader(strm, head) {
					var state;
					if (!strm || !strm.state) {
						return Z_STREAM_ERROR
					}
					state = strm.state;
					if ((state.wrap & 2) === 0) {
						return Z_STREAM_ERROR
					}
					state.head = head;
					head.done = false;
					return Z_OK
				}
				exports.inflateReset = inflateReset;
				exports.inflateReset2 = inflateReset2;
				exports.inflateResetKeep = inflateResetKeep;
				exports.inflateInit = inflateInit;
				exports.inflateInit2 = inflateInit2;
				exports.inflate = inflate;
				exports.inflateEnd = inflateEnd;
				exports.inflateGetHeader = inflateGetHeader;
				exports.inflateInfo = "pako inflate (from Nodeca project)"
			}, {
				"../utils/common" : 27,
				"./adler32" : 29,
				"./crc32" : 31,
				"./inffast" : 34,
				"./inftrees" : 36
			}
		],
		36 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("../utils/common");
				var MAXBITS = 15;
				var ENOUGH_LENS = 852;
				var ENOUGH_DISTS = 592;
				var CODES = 0;
				var LENS = 1;
				var DISTS = 2;
				var lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
				var lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
				var dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
				var dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
				module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
					var bits = opts.bits;
					var len = 0;
					var sym = 0;
					var min = 0,
					max = 0;
					var root = 0;
					var curr = 0;
					var drop = 0;
					var left = 0;
					var used = 0;
					var huff = 0;
					var incr;
					var fill;
					var low;
					var mask;
					var next;
					var base = null;
					var base_index = 0;
					var end;
					var count = new utils.Buf16(MAXBITS + 1);
					var offs = new utils.Buf16(MAXBITS + 1);
					var extra = null;
					var extra_index = 0;
					var here_bits,
					here_op,
					here_val;
					for (len = 0; len <= MAXBITS; len++) {
						count[len] = 0
					}
					for (sym = 0; sym < codes; sym++) {
						count[lens[lens_index + sym]]++
					}
					root = bits;
					for (max = MAXBITS; max >= 1; max--) {
						if (count[max] !== 0) {
							break
						}
					}
					if (root > max) {
						root = max
					}
					if (max === 0) {
						table[table_index++] = 1 << 24 | 64 << 16 | 0;
						table[table_index++] = 1 << 24 | 64 << 16 | 0;
						opts.bits = 1;
						return 0
					}
					for (min = 1; min < max; min++) {
						if (count[min] !== 0) {
							break
						}
					}
					if (root < min) {
						root = min
					}
					left = 1;
					for (len = 1; len <= MAXBITS; len++) {
						left <<= 1;
						left -= count[len];
						if (left < 0) {
							return -1
						}
					}
					if (left > 0 && (type === CODES || max !== 1)) {
						return -1
					}
					offs[1] = 0;
					for (len = 1; len < MAXBITS; len++) {
						offs[len + 1] = offs[len] + count[len]
					}
					for (sym = 0; sym < codes; sym++) {
						if (lens[lens_index + sym] !== 0) {
							work[offs[lens[lens_index + sym]]++] = sym
						}
					}
					if (type === CODES) {
						base = extra = work;
						end = 19
					} else if (type === LENS) {
						base = lbase;
						base_index -= 257;
						extra = lext;
						extra_index -= 257;
						end = 256
					} else {
						base = dbase;
						extra = dext;
						end = -1
					}
					huff = 0;
					sym = 0;
					len = min;
					next = table_index;
					curr = root;
					drop = 0;
					low = -1;
					used = 1 << root;
					mask = used - 1;
					if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
						return 1
					}
					var i = 0;
					for (; ; ) {
						i++;
						here_bits = len - drop;
						if (work[sym] < end) {
							here_op = 0;
							here_val = work[sym]
						} else if (work[sym] > end) {
							here_op = extra[extra_index + work[sym]];
							here_val = base[base_index + work[sym]]
						} else {
							here_op = 32 + 64;
							here_val = 0
						}
						incr = 1 << len - drop;
						fill = 1 << curr;
						min = fill;
						do {
							fill -= incr;
							table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0
						} while (fill !== 0);
						incr = 1 << len - 1;
						while (huff & incr) {
							incr >>= 1
						}
						if (incr !== 0) {
							huff &= incr - 1;
							huff += incr
						} else {
							huff = 0
						}
						sym++;
						if (--count[len] === 0) {
							if (len === max) {
								break
							}
							len = lens[lens_index + work[sym]]
						}
						if (len > root && (huff & mask) !== low) {
							if (drop === 0) {
								drop = root
							}
							next += min;
							curr = len - drop;
							left = 1 << curr;
							while (curr + drop < max) {
								left -= count[curr + drop];
								if (left <= 0) {
									break
								}
								curr++;
								left <<= 1
							}
							used += 1 << curr;
							if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
								return 1
							}
							low = huff & mask;
							table[low] = root << 24 | curr << 16 | next - table_index | 0
						}
					}
					if (huff !== 0) {
						table[next + huff] = len - drop << 24 | 64 << 16 | 0
					}
					opts.bits = root;
					return 0
				}
			}, {
				"../utils/common" : 27
			}
		],
		37 : [function (_dereq_, module, exports) {
				"use strict";
				module.exports = {
					2 : "need dictionary",
					1 : "stream end",
					0 : "",
					"-1" : "file error",
					"-2" : "stream error",
					"-3" : "data error",
					"-4" : "insufficient memory",
					"-5" : "buffer error",
					"-6" : "incompatible version"
				}
			}, {}

		],
		38 : [function (_dereq_, module, exports) {
				"use strict";
				var utils = _dereq_("../utils/common");
				var Z_FIXED = 4;
				var Z_BINARY = 0;
				var Z_TEXT = 1;
				var Z_UNKNOWN = 2;
				function zero(buf) {
					var len = buf.length;
					while (--len >= 0) {
						buf[len] = 0
					}
				}
				var STORED_BLOCK = 0;
				var STATIC_TREES = 1;
				var DYN_TREES = 2;
				var MIN_MATCH = 3;
				var MAX_MATCH = 258;
				var LENGTH_CODES = 29;
				var LITERALS = 256;
				var L_CODES = LITERALS + 1 + LENGTH_CODES;
				var D_CODES = 30;
				var BL_CODES = 19;
				var HEAP_SIZE = 2 * L_CODES + 1;
				var MAX_BITS = 15;
				var Buf_size = 16;
				var MAX_BL_BITS = 7;
				var END_BLOCK = 256;
				var REP_3_6 = 16;
				var REPZ_3_10 = 17;
				var REPZ_11_138 = 18;
				var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
				var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
				var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
				var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
				var DIST_CODE_LEN = 512;
				var static_ltree = new Array((L_CODES + 2) * 2);
				zero(static_ltree);
				var static_dtree = new Array(D_CODES * 2);
				zero(static_dtree);
				var _dist_code = new Array(DIST_CODE_LEN);
				zero(_dist_code);
				var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
				zero(_length_code);
				var base_length = new Array(LENGTH_CODES);
				zero(base_length);
				var base_dist = new Array(D_CODES);
				zero(base_dist);
				var StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {
					this.static_tree = static_tree;
					this.extra_bits = extra_bits;
					this.extra_base = extra_base;
					this.elems = elems;
					this.max_length = max_length;
					this.has_stree = static_tree && static_tree.length
				};
				var static_l_desc;
				var static_d_desc;
				var static_bl_desc;
				var TreeDesc = function (dyn_tree, stat_desc) {
					this.dyn_tree = dyn_tree;
					this.max_code = 0;
					this.stat_desc = stat_desc
				};
				function d_code(dist) {
					return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
				}
				function put_short(s, w) {
					s.pending_buf[s.pending++] = w & 255;
					s.pending_buf[s.pending++] = w >>> 8 & 255
				}
				function send_bits(s, value, length) {
					if (s.bi_valid > Buf_size - length) {
						s.bi_buf |= value << s.bi_valid & 65535;
						put_short(s, s.bi_buf);
						s.bi_buf = value >> Buf_size - s.bi_valid;
						s.bi_valid += length - Buf_size
					} else {
						s.bi_buf |= value << s.bi_valid & 65535;
						s.bi_valid += length
					}
				}
				function send_code(s, c, tree) {
					send_bits(s, tree[c * 2], tree[c * 2 + 1])
				}
				function bi_reverse(code, len) {
					var res = 0;
					do {
						res |= code & 1;
						code >>>= 1;
						res <<= 1
					} while (--len > 0);
					return res >>> 1
				}
				function bi_flush(s) {
					if (s.bi_valid === 16) {
						put_short(s, s.bi_buf);
						s.bi_buf = 0;
						s.bi_valid = 0
					} else if (s.bi_valid >= 8) {
						s.pending_buf[s.pending++] = s.bi_buf & 255;
						s.bi_buf >>= 8;
						s.bi_valid -= 8
					}
				}
				function gen_bitlen(s, desc) {
					var tree = desc.dyn_tree;
					var max_code = desc.max_code;
					var stree = desc.stat_desc.static_tree;
					var has_stree = desc.stat_desc.has_stree;
					var extra = desc.stat_desc.extra_bits;
					var base = desc.stat_desc.extra_base;
					var max_length = desc.stat_desc.max_length;
					var h;
					var n,
					m;
					var bits;
					var xbits;
					var f;
					var overflow = 0;
					for (bits = 0; bits <= MAX_BITS; bits++) {
						s.bl_count[bits] = 0
					}
					tree[s.heap[s.heap_max] * 2 + 1] = 0;
					for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
						n = s.heap[h];
						bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
						if (bits > max_length) {
							bits = max_length;
							overflow++
						}
						tree[n * 2 + 1] = bits;
						if (n > max_code) {
							continue
						}
						s.bl_count[bits]++;
						xbits = 0;
						if (n >= base) {
							xbits = extra[n - base]
						}
						f = tree[n * 2];
						s.opt_len += f * (bits + xbits);
						if (has_stree) {
							s.static_len += f * (stree[n * 2 + 1] + xbits)
						}
					}
					if (overflow === 0) {
						return
					}
					do {
						bits = max_length - 1;
						while (s.bl_count[bits] === 0) {
							bits--
						}
						s.bl_count[bits]--;
						s.bl_count[bits + 1] += 2;
						s.bl_count[max_length]--;
						overflow -= 2
					} while (overflow > 0);
					for (bits = max_length; bits !== 0; bits--) {
						n = s.bl_count[bits];
						while (n !== 0) {
							m = s.heap[--h];
							if (m > max_code) {
								continue
							}
							if (tree[m * 2 + 1] !== bits) {
								s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
								tree[m * 2 + 1] = bits
							}
							n--
						}
					}
				}
				function gen_codes(tree, max_code, bl_count) {
					var next_code = new Array(MAX_BITS + 1);
					var code = 0;
					var bits;
					var n;
					for (bits = 1; bits <= MAX_BITS; bits++) {
						next_code[bits] = code = code + bl_count[bits - 1] << 1
					}
					for (n = 0; n <= max_code; n++) {
						var len = tree[n * 2 + 1];
						if (len === 0) {
							continue
						}
						tree[n * 2] = bi_reverse(next_code[len]++, len)
					}
				}
				function tr_static_init() {
					var n;
					var bits;
					var length;
					var code;
					var dist;
					var bl_count = new Array(MAX_BITS + 1);
					length = 0;
					for (code = 0; code < LENGTH_CODES - 1; code++) {
						base_length[code] = length;
						for (n = 0; n < 1 << extra_lbits[code]; n++) {
							_length_code[length++] = code
						}
					}
					_length_code[length - 1] = code;
					dist = 0;
					for (code = 0; code < 16; code++) {
						base_dist[code] = dist;
						for (n = 0; n < 1 << extra_dbits[code]; n++) {
							_dist_code[dist++] = code
						}
					}
					dist >>= 7;
					for (; code < D_CODES; code++) {
						base_dist[code] = dist << 7;
						for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
							_dist_code[256 + dist++] = code
						}
					}
					for (bits = 0; bits <= MAX_BITS; bits++) {
						bl_count[bits] = 0
					}
					n = 0;
					while (n <= 143) {
						static_ltree[n * 2 + 1] = 8;
						n++;
						bl_count[8]++
					}
					while (n <= 255) {
						static_ltree[n * 2 + 1] = 9;
						n++;
						bl_count[9]++
					}
					while (n <= 279) {
						static_ltree[n * 2 + 1] = 7;
						n++;
						bl_count[7]++
					}
					while (n <= 287) {
						static_ltree[n * 2 + 1] = 8;
						n++;
						bl_count[8]++
					}
					gen_codes(static_ltree, L_CODES + 1, bl_count);
					for (n = 0; n < D_CODES; n++) {
						static_dtree[n * 2 + 1] = 5;
						static_dtree[n * 2] = bi_reverse(n, 5)
					}
					static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
					static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
					static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)
				}
				function init_block(s) {
					var n;
					for (n = 0; n < L_CODES; n++) {
						s.dyn_ltree[n * 2] = 0
					}
					for (n = 0; n < D_CODES; n++) {
						s.dyn_dtree[n * 2] = 0
					}
					for (n = 0; n < BL_CODES; n++) {
						s.bl_tree[n * 2] = 0
					}
					s.dyn_ltree[END_BLOCK * 2] = 1;
					s.opt_len = s.static_len = 0;
					s.last_lit = s.matches = 0
				}
				function bi_windup(s) {
					if (s.bi_valid > 8) {
						put_short(s, s.bi_buf)
					} else if (s.bi_valid > 0) {
						s.pending_buf[s.pending++] = s.bi_buf
					}
					s.bi_buf = 0;
					s.bi_valid = 0
				}
				function copy_block(s, buf, len, header) {
					bi_windup(s);
					if (header) {
						put_short(s, len);
						put_short(s, ~len)
					}
					utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
					s.pending += len
				}
				function smaller(tree, n, m, depth) {
					var _n2 = n * 2;
					var _m2 = m * 2;
					return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
				}
				function pqdownheap(s, tree, k) {
					var v = s.heap[k];
					var j = k << 1;
					while (j <= s.heap_len) {
						if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
							j++
						}
						if (smaller(tree, v, s.heap[j], s.depth)) {
							break
						}
						s.heap[k] = s.heap[j];
						k = j;
						j <<= 1
					}
					s.heap[k] = v
				}
				function compress_block(s, ltree, dtree) {
					var dist;
					var lc;
					var lx = 0;
					var code;
					var extra;
					if (s.last_lit !== 0) {
						do {
							dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
							lc = s.pending_buf[s.l_buf + lx];
							lx++;
							if (dist === 0) {
								send_code(s, lc, ltree)
							} else {
								code = _length_code[lc];
								send_code(s, code + LITERALS + 1, ltree);
								extra = extra_lbits[code];
								if (extra !== 0) {
									lc -= base_length[code];
									send_bits(s, lc, extra)
								}
								dist--;
								code = d_code(dist);
								send_code(s, code, dtree);
								extra = extra_dbits[code];
								if (extra !== 0) {
									dist -= base_dist[code];
									send_bits(s, dist, extra)
								}
							}
						} while (lx < s.last_lit)
					}
					send_code(s, END_BLOCK, ltree)
				}
				function build_tree(s, desc) {
					var tree = desc.dyn_tree;
					var stree = desc.stat_desc.static_tree;
					var has_stree = desc.stat_desc.has_stree;
					var elems = desc.stat_desc.elems;
					var n,
					m;
					var max_code = -1;
					var node;
					s.heap_len = 0;
					s.heap_max = HEAP_SIZE;
					for (n = 0; n < elems; n++) {
						if (tree[n * 2] !== 0) {
							s.heap[++s.heap_len] = max_code = n;
							s.depth[n] = 0
						} else {
							tree[n * 2 + 1] = 0
						}
					}
					while (s.heap_len < 2) {
						node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
						tree[node * 2] = 1;
						s.depth[node] = 0;
						s.opt_len--;
						if (has_stree) {
							s.static_len -= stree[node * 2 + 1]
						}
					}
					desc.max_code = max_code;
					for (n = s.heap_len >> 1; n >= 1; n--) {
						pqdownheap(s, tree, n)
					}
					node = elems;
					do {
						n = s.heap[1];
						s.heap[1] = s.heap[s.heap_len--];
						pqdownheap(s, tree, 1);
						m = s.heap[1];
						s.heap[--s.heap_max] = n;
						s.heap[--s.heap_max] = m;
						tree[node * 2] = tree[n * 2] + tree[m * 2];
						s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
						tree[n * 2 + 1] = tree[m * 2 + 1] = node;
						s.heap[1] = node++;
						pqdownheap(s, tree, 1)
					} while (s.heap_len >= 2);
					s.heap[--s.heap_max] = s.heap[1];
					gen_bitlen(s, desc);
					gen_codes(tree, max_code, s.bl_count)
				}
				function scan_tree(s, tree, max_code) {
					var n;
					var prevlen = -1;
					var curlen;
					var nextlen = tree[0 * 2 + 1];
					var count = 0;
					var max_count = 7;
					var min_count = 4;
					if (nextlen === 0) {
						max_count = 138;
						min_count = 3
					}
					tree[(max_code + 1) * 2 + 1] = 65535;
					for (n = 0; n <= max_code; n++) {
						curlen = nextlen;
						nextlen = tree[(n + 1) * 2 + 1];
						if (++count < max_count && curlen === nextlen) {
							continue
						} else if (count < min_count) {
							s.bl_tree[curlen * 2] += count
						} else if (curlen !== 0) {
							if (curlen !== prevlen) {
								s.bl_tree[curlen * 2]++
							}
							s.bl_tree[REP_3_6 * 2]++
						} else if (count <= 10) {
							s.bl_tree[REPZ_3_10 * 2]++
						} else {
							s.bl_tree[REPZ_11_138 * 2]++
						}
						count = 0;
						prevlen = curlen;
						if (nextlen === 0) {
							max_count = 138;
							min_count = 3
						} else if (curlen === nextlen) {
							max_count = 6;
							min_count = 3
						} else {
							max_count = 7;
							min_count = 4
						}
					}
				}
				function send_tree(s, tree, max_code) {
					var n;
					var prevlen = -1;
					var curlen;
					var nextlen = tree[0 * 2 + 1];
					var count = 0;
					var max_count = 7;
					var min_count = 4;
					if (nextlen === 0) {
						max_count = 138;
						min_count = 3
					}
					for (n = 0; n <= max_code; n++) {
						curlen = nextlen;
						nextlen = tree[(n + 1) * 2 + 1];
						if (++count < max_count && curlen === nextlen) {
							continue
						} else if (count < min_count) {
							do {
								send_code(s, curlen, s.bl_tree)
							} while (--count !== 0)
						} else if (curlen !== 0) {
							if (curlen !== prevlen) {
								send_code(s, curlen, s.bl_tree);
								count--
							}
							send_code(s, REP_3_6, s.bl_tree);
							send_bits(s, count - 3, 2)
						} else if (count <= 10) {
							send_code(s, REPZ_3_10, s.bl_tree);
							send_bits(s, count - 3, 3)
						} else {
							send_code(s, REPZ_11_138, s.bl_tree);
							send_bits(s, count - 11, 7)
						}
						count = 0;
						prevlen = curlen;
						if (nextlen === 0) {
							max_count = 138;
							min_count = 3
						} else if (curlen === nextlen) {
							max_count = 6;
							min_count = 3
						} else {
							max_count = 7;
							min_count = 4
						}
					}
				}
				function build_bl_tree(s) {
					var max_blindex;
					scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
					scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
					build_tree(s, s.bl_desc);
					for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
						if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
							break
						}
					}
					s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
					return max_blindex
				}
				function send_all_trees(s, lcodes, dcodes, blcodes) {
					var rank;
					send_bits(s, lcodes - 257, 5);
					send_bits(s, dcodes - 1, 5);
					send_bits(s, blcodes - 4, 4);
					for (rank = 0; rank < blcodes; rank++) {
						send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3)
					}
					send_tree(s, s.dyn_ltree, lcodes - 1);
					send_tree(s, s.dyn_dtree, dcodes - 1)
				}
				function detect_data_type(s) {
					var black_mask = 4093624447;
					var n;
					for (n = 0; n <= 31; n++, black_mask >>>= 1) {
						if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
							return Z_BINARY
						}
					}
					if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
						return Z_TEXT
					}
					for (n = 32; n < LITERALS; n++) {
						if (s.dyn_ltree[n * 2] !== 0) {
							return Z_TEXT
						}
					}
					return Z_BINARY
				}
				var static_init_done = false;
				function _tr_init(s) {
					if (!static_init_done) {
						tr_static_init();
						static_init_done = true
					}
					s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
					s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
					s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
					s.bi_buf = 0;
					s.bi_valid = 0;
					init_block(s)
				}
				function _tr_stored_block(s, buf, stored_len, last) {
					send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
					copy_block(s, buf, stored_len, true)
				}
				function _tr_align(s) {
					send_bits(s, STATIC_TREES << 1, 3);
					send_code(s, END_BLOCK, static_ltree);
					bi_flush(s)
				}
				function _tr_flush_block(s, buf, stored_len, last) {
					var opt_lenb,
					static_lenb;
					var max_blindex = 0;
					if (s.level > 0) {
						if (s.strm.data_type === Z_UNKNOWN) {
							s.strm.data_type = detect_data_type(s)
						}
						build_tree(s, s.l_desc);
						build_tree(s, s.d_desc);
						max_blindex = build_bl_tree(s);
						opt_lenb = s.opt_len + 3 + 7 >>> 3;
						static_lenb = s.static_len + 3 + 7 >>> 3;
						if (static_lenb <= opt_lenb) {
							opt_lenb = static_lenb
						}
					} else {
						opt_lenb = static_lenb = stored_len + 5
					}
					if (stored_len + 4 <= opt_lenb && buf !== -1) {
						_tr_stored_block(s, buf, stored_len, last)
					} else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
						send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
						compress_block(s, static_ltree, static_dtree)
					} else {
						send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
						send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
						compress_block(s, s.dyn_ltree, s.dyn_dtree)
					}
					init_block(s);
					if (last) {
						bi_windup(s)
					}
				}
				function _tr_tally(s, dist, lc) {
					s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
					s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
					s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
					s.last_lit++;
					if (dist === 0) {
						s.dyn_ltree[lc * 2]++
					} else {
						s.matches++;
						dist--;
						s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
						s.dyn_dtree[d_code(dist) * 2]++
					}
					return s.last_lit === s.lit_bufsize - 1
				}
				exports._tr_init = _tr_init;
				exports._tr_stored_block = _tr_stored_block;
				exports._tr_flush_block = _tr_flush_block;
				exports._tr_tally = _tr_tally;
				exports._tr_align = _tr_align
			}, {
				"../utils/common" : 27
			}
		],
		39 : [function (_dereq_, module, exports) {
				"use strict";
				function ZStream() {
					this.input = null;
					this.next_in = 0;
					this.avail_in = 0;
					this.total_in = 0;
					this.output = null;
					this.next_out = 0;
					this.avail_out = 0;
					this.total_out = 0;
					this.msg = "";
					this.state = null;
					this.data_type = 2;
					this.adler = 0
				}
				module.exports = ZStream
			}, {}

		]
	}, {}, [9])(9)
});
var XLSX = {};
(function make_xlsx(XLSX) {
	XLSX.version = "0.8.0";
	var current_codepage = 1200,
	current_cptable;
	if (typeof module !== "undefined" && typeof require !== "undefined") {
		if (typeof cptable === "undefined")
			cptable = require("./dist/cpexcel");
		current_cptable = cptable[current_codepage]
	}
	function reset_cp() {
		set_cp(1200)
	}
	var set_cp = function (cp) {
		current_codepage = cp
	};
	function char_codes(data) {
		var o = [];
		for (var i = 0, len = data.length; i < len; ++i)
			o[i] = data.charCodeAt(i);
		return o
	}
	var debom_xml = function (data) {
		return data
	};
	var _getchar = function _gc1(x) {
		return String.fromCharCode(x)
	};
	if (typeof cptable !== "undefined") {
		set_cp = function (cp) {
			current_codepage = cp;
			current_cptable = cptable[cp]
		};
		debom_xml = function (data) {
			if (data.charCodeAt(0) === 255 && data.charCodeAt(1) === 254) {
				return cptable.utils.decode(1200, char_codes(data.substr(2)))
			}
			return data
		};
		_getchar = function _gc2(x) {
			if (current_codepage === 1200)
				return String.fromCharCode(x);
			return cptable.utils.decode(current_codepage, [x & 255, x >> 8])[0]
		}
	}
	var Base64 = function make_b64() {
		var map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
		return {
			encode : function (input, utf8) {
				var o = "";
				var c1,
				c2,
				c3,
				e1,
				e2,
				e3,
				e4;
				for (var i = 0; i < input.length; ) {
					c1 = input.charCodeAt(i++);
					c2 = input.charCodeAt(i++);
					c3 = input.charCodeAt(i++);
					e1 = c1 >> 2;
					e2 = (c1 & 3) << 4 | c2 >> 4;
					e3 = (c2 & 15) << 2 | c3 >> 6;
					e4 = c3 & 63;
					if (isNaN(c2)) {
						e3 = e4 = 64
					} else if (isNaN(c3)) {
						e4 = 64
					}
					o += map.charAt(e1) + map.charAt(e2) + map.charAt(e3) + map.charAt(e4)
				}
				return o
			},
			decode : function b64_decode(input, utf8) {
				var o = "";
				var c1,
				c2,
				c3;
				var e1,
				e2,
				e3,
				e4;
				input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
				for (var i = 0; i < input.length; ) {
					e1 = map.indexOf(input.charAt(i++));
					e2 = map.indexOf(input.charAt(i++));
					e3 = map.indexOf(input.charAt(i++));
					e4 = map.indexOf(input.charAt(i++));
					c1 = e1 << 2 | e2 >> 4;
					c2 = (e2 & 15) << 4 | e3 >> 2;
					c3 = (e3 & 3) << 6 | e4;
					o += String.fromCharCode(c1);
					if (e3 != 64) {
						o += String.fromCharCode(c2)
					}
					if (e4 != 64) {
						o += String.fromCharCode(c3)
					}
				}
				return o
			}
		}
	}();
	var has_buf = typeof Buffer !== "undefined";
	function new_raw_buf(len) {
		return new(has_buf ? Buffer : Array)(len)
	}
	function s2a(s) {
		if (has_buf)
			return new Buffer(s, "binary");
		return s.split("").map(function (x) {
			return x.charCodeAt(0) & 255
		})
	}
	var bconcat = function (bufs) {
		return [].concat.apply([], bufs)
	};
	var chr0 = /\u0000/g,
	chr1 = /[\u0001-\u0006]/;
	var SSF = {};
	var make_ssf = function make_ssf(SSF) {
		SSF.version = "0.8.1";
		function _strrev(x) {
			var o = "",
			i = x.length - 1;
			while (i >= 0)
				o += x.charAt(i--);
			return o
		}
		function fill(c, l) {
			var o = "";
			while (o.length < l)
				o += c;
			return o
		}
		function pad0(v, d) {
			var t = "" + v;
			return t.length >= d ? t : fill("0", d - t.length) + t
		}
		function pad_(v, d) {
			var t = "" + v;
			return t.length >= d ? t : fill(" ", d - t.length) + t
		}
		function rpad_(v, d) {
			var t = "" + v;
			return t.length >= d ? t : t + fill(" ", d - t.length)
		}
		function pad0r1(v, d) {
			var t = "" + Math.round(v);
			return t.length >= d ? t : fill("0", d - t.length) + t
		}
		function pad0r2(v, d) {
			var t = "" + v;
			return t.length >= d ? t : fill("0", d - t.length) + t
		}
		var p2_32 = Math.pow(2, 32);
		function pad0r(v, d) {
			if (v > p2_32 || v < -p2_32)
				return pad0r1(v, d);
			var i = Math.round(v);
			return pad0r2(i, d)
		}
		function isgeneral(s, i) {
			return s.length >= 7 + i && (s.charCodeAt(i) | 32) === 103 && (s.charCodeAt(i + 1) | 32) === 101 && (s.charCodeAt(i + 2) | 32) === 110 && (s.charCodeAt(i + 3) | 32) === 101 && (s.charCodeAt(i + 4) | 32) === 114 && (s.charCodeAt(i + 5) | 32) === 97 && (s.charCodeAt(i + 6) | 32) === 108
		}
		var opts_fmt = [["date1904", 0], ["output", ""], ["WTF", false]];
		function fixopts(o) {
			for (var y = 0; y != opts_fmt.length; ++y)
				if (o[opts_fmt[y][0]] === undefined)
					o[opts_fmt[y][0]] = opts_fmt[y][1]
		}
		SSF.opts = opts_fmt;
		var table_fmt = {
			0 : "General",
			1 : "0",
			2 : "0.00",
			3 : "#,##0",
			4 : "#,##0.00",
			9 : "0%",
			10 : "0.00%",
			11 : "0.00E+00",
			12 : "# ?/?",
			13 : "# ??/??",
			14 : "m/d/yy",
			15 : "d-mmm-yy",
			16 : "d-mmm",
			17 : "mmm-yy",
			18 : "h:mm AM/PM",
			19 : "h:mm:ss AM/PM",
			20 : "h:mm",
			21 : "h:mm:ss",
			22 : "m/d/yy h:mm",
			37 : "#,##0 ;(#,##0)",
			38 : "#,##0 ;[Red](#,##0)",
			39 : "#,##0.00;(#,##0.00)",
			40 : "#,##0.00;[Red](#,##0.00)",
			45 : "mm:ss",
			46 : "[h]:mm:ss",
			47 : "mmss.0",
			48 : "##0.0E+0",
			49 : "@",
			56 : '"ä¸Šå�ˆ/ä¸‹å�ˆ "hh"æ™‚"mm"åˆ†"ss"ç§’ "',
			65535 : "General"
		};
		var days = [["Sun", "Sunday"], ["Mon", "Monday"], ["Tue", "Tuesday"], ["Wed", "Wednesday"], ["Thu", "Thursday"], ["Fri", "Friday"], ["Sat", "Saturday"]];
		var months = [["J", "Jan", "January"], ["F", "Feb", "February"], ["M", "Mar", "March"], ["A", "Apr", "April"], ["M", "May", "May"], ["J", "Jun", "June"], ["J", "Jul", "July"], ["A", "Aug", "August"], ["S", "Sep", "September"], ["O", "Oct", "October"], ["N", "Nov", "November"], ["D", "Dec", "December"]];
		function frac(x, D, mixed) {
			var sgn = x < 0 ? -1 : 1;
			var B = x * sgn;
			var P_2 = 0,
			P_1 = 1,
			P = 0;
			var Q_2 = 1,
			Q_1 = 0,
			Q = 0;
			var A = Math.floor(B);
			while (Q_1 < D) {
				A = Math.floor(B);
				P = A * P_1 + P_2;
				Q = A * Q_1 + Q_2;
				if (B - A < 5e-10)
					break;
				B = 1 / (B - A);
				P_2 = P_1;
				P_1 = P;
				Q_2 = Q_1;
				Q_1 = Q
			}
			if (Q > D) {
				Q = Q_1;
				P = P_1
			}
			if (Q > D) {
				Q = Q_2;
				P = P_2
			}
			if (!mixed)
				return [0, sgn * P, Q];
			if (Q === 0)
				throw "Unexpected state: " + P + " " + P_1 + " " + P_2 + " " + Q + " " + Q_1 + " " + Q_2;
			var q = Math.floor(sgn * P / Q);
			return [q, sgn * P - q * Q, Q]
		}
		function general_fmt_int(v, opts) {
			return "" + v
		}
		SSF._general_int = general_fmt_int;
		var general_fmt_num = function make_general_fmt_num() {
			var gnr1 = /\.(\d*[1-9])0+$/,
			gnr2 = /\.0*$/,
			gnr4 = /\.(\d*[1-9])0+/,
			gnr5 = /\.0*[Ee]/,
			gnr6 = /(E[+-])(\d)$/;
			function gfn2(v) {
				var w = v < 0 ? 12 : 11;
				var o = gfn5(v.toFixed(12));
				if (o.length <= w)
					return o;
				o = v.toPrecision(10);
				if (o.length <= w)
					return o;
				return v.toExponential(5)
			}
			function gfn3(v) {
				var o = v.toFixed(11).replace(gnr1, ".$1");
				if (o.length > (v < 0 ? 12 : 11))
					o = v.toPrecision(6);
				return o
			}
			function gfn4(o) {
				for (var i = 0; i != o.length; ++i)
					if ((o.charCodeAt(i) | 32) === 101)
						return o.replace(gnr4, ".$1").replace(gnr5, "E").replace("e", "E").replace(gnr6, "$10$2");
				return o
			}
			function gfn5(o) {
				return o.indexOf(".") > -1 ? o.replace(gnr2, "").replace(gnr1, ".$1") : o
			}
			return function general_fmt_num(v, opts) {
				var V = Math.floor(Math.log(Math.abs(v)) * Math.LOG10E),
				o;
				if (V >= -4 && V <= -1)
					o = v.toPrecision(10 + V);
				else if (Math.abs(V) <= 9)
					o = gfn2(v);
				else if (V === 10)
					o = v.toFixed(10).substr(0, 12);
				else
					o = gfn3(v);
				return gfn5(gfn4(o))
			}
		}();
		SSF._general_num = general_fmt_num;
		function general_fmt(v, opts) {
			switch (typeof v) {
			case "string":
				return v;
			case "boolean":
				return v ? "TRUE" : "FALSE";
			case "number":
				return (v | 0) === v ? general_fmt_int(v, opts) : general_fmt_num(v, opts)
			}
			throw new Error("unsupported value in General format: " + v)
		}
		SSF._general = general_fmt;
		function fix_hijri(date, o) {
			return 0
		}
		function parse_date_code(v, opts, b2) {
			if (v > 2958465 || v < 0)
				return null;
			var date = v | 0,
			time = Math.floor(86400 * (v - date)),
			dow = 0;
			var dout = [];
			var out = {
				D : date,
				T : time,
				u : 86400 * (v - date) - time,
				y : 0,
				m : 0,
				d : 0,
				H : 0,
				M : 0,
				S : 0,
				q : 0
			};
			if (Math.abs(out.u) < 1e-6)
				out.u = 0;
			fixopts(opts != null ? opts : opts = []);
			if (opts.date1904)
				date += 1462;
			if (out.u > .999) {
				out.u = 0;
				if (++time == 86400) {
					time = 0;
					++date
				}
			}
			if (date === 60) {
				dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
				dow = 3
			} else if (date === 0) {
				dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
				dow = 6
			} else {
				if (date > 60)
					--date;
				var d = new Date(1900, 0, 1);
				d.setDate(d.getDate() + date - 1);
				dout = [d.getFullYear(), d.getMonth() + 1, d.getDate()];
				dow = d.getDay();
				if (date < 60)
					dow = (dow + 6) % 7;
				if (b2)
					dow = fix_hijri(d, dout)
			}
			out.y = dout[0];
			out.m = dout[1];
			out.d = dout[2];
			out.S = time % 60;
			time = Math.floor(time / 60);
			out.M = time % 60;
			time = Math.floor(time / 60);
			out.H = time;
			out.q = dow;
			return out
		}
		SSF.parse_date_code = parse_date_code;
		function write_date(type, fmt, val, ss0) {
			var o = "",
			ss = 0,
			tt = 0,
			y = val.y,
			out,
			outl = 0;
			switch (type) {
			case 98:
				y = val.y + 543;
			case 121:
				switch (fmt.length) {
				case 1:
				case 2:
					out = y % 100;
					outl = 2;
					break;
				default:
					out = y % 1e4;
					outl = 4;
					break
				}
				break;
			case 109:
				switch (fmt.length) {
				case 1:
				case 2:
					out = val.m;
					outl = fmt.length;
					break;
				case 3:
					return months[val.m - 1][1];
				case 5:
					return months[val.m - 1][0];
				default:
					return months[val.m - 1][2]
				}
				break;
			case 100:
				switch (fmt.length) {
				case 1:
				case 2:
					out = val.d;
					outl = fmt.length;
					break;
				case 3:
					return days[val.q][0];
				default:
					return days[val.q][1]
				}
				break;
			case 104:
				switch (fmt.length) {
				case 1:
				case 2:
					out = 1 + (val.H + 11) % 12;
					outl = fmt.length;
					break;
				default:
					throw "bad hour format: " + fmt
				}
				break;
			case 72:
				switch (fmt.length) {
				case 1:
				case 2:
					out = val.H;
					outl = fmt.length;
					break;
				default:
					throw "bad hour format: " + fmt
				}
				break;
			case 77:
				switch (fmt.length) {
				case 1:
				case 2:
					out = val.M;
					outl = fmt.length;
					break;
				default:
					throw "bad minute format: " + fmt
				}
				break;
			case 115:
				if (val.u === 0)
					switch (fmt) {
					case "s":
					case "ss":
						return pad0(val.S, fmt.length);
					case ".0":
					case ".00":
					case ".000":
					}
				switch (fmt) {
				case "s":
				case "ss":
				case ".0":
				case ".00":
				case ".000":
					if (ss0 >= 2)
						tt = ss0 === 3 ? 1e3 : 100;
					else
						tt = ss0 === 1 ? 10 : 1;
					ss = Math.round(tt * (val.S + val.u));
					if (ss >= 60 * tt)
						ss = 0;
					if (fmt === "s")
						return ss === 0 ? "0" : "" + ss / tt;
					o = pad0(ss, 2 + ss0);
					if (fmt === "ss")
						return o.substr(0, 2);
					return "." + o.substr(2, fmt.length - 1);
				default:
					throw "bad second format: " + fmt
				}
			case 90:
				switch (fmt) {
				case "[h]":
				case "[hh]":
					out = val.D * 24 + val.H;
					break;
				case "[m]":
				case "[mm]":
					out = (val.D * 24 + val.H) * 60 + val.M;
					break;
				case "[s]":
				case "[ss]":
					out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
					break;
				default:
					throw "bad abstime format: " + fmt
				}
				outl = fmt.length === 3 ? 1 : 2;
				break;
			case 101:
				out = y;
				outl = 1
			}
			if (outl > 0)
				return pad0(out, outl);
			else
				return ""
		}
		function commaify(s) {
			if (s.length <= 3)
				return s;
			var j = s.length % 3,
			o = s.substr(0, j);
			for (; j != s.length; j += 3)
				o += (o.length > 0 ? "," : "") + s.substr(j, 3);
			return o
		}
		var write_num = function make_write_num() {
			var pct1 = /%/g;
			function write_num_pct(type, fmt, val) {
				var sfmt = fmt.replace(pct1, ""),
				mul = fmt.length - sfmt.length;
				return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul)
			}
			function write_num_cm(type, fmt, val) {
				var idx = fmt.length - 1;
				while (fmt.charCodeAt(idx - 1) === 44)
					--idx;
				return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)))
			}
			function write_num_exp(fmt, val) {
				var o;
				var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
				if (fmt.match(/^#+0.0E\+0$/)) {
					var period = fmt.indexOf(".");
					if (period === -1)
						period = fmt.indexOf("E");
					var ee = Math.floor(Math.log(Math.abs(val)) * Math.LOG10E) % period;
					if (ee < 0)
						ee += period;
					o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
					if (o.indexOf("e") === -1) {
						var fakee = Math.floor(Math.log(Math.abs(val)) * Math.LOG10E);
						if (o.indexOf(".") === -1)
							o = o[0] + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
						else
							o += "E+" + (fakee - ee);
						while (o.substr(0, 2) === "0.") {
							o = o[0] + o.substr(2, period) + "." + o.substr(2 + period);
							o = o.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.")
						}
						o = o.replace(/\+-/, "-")
					}
					o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function ($$, $1, $2, $3) {
							return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E"
						})
				} else
					o = val.toExponential(idx);
				if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
					o = o.substr(0, o.length - 1) + "0" + o[o.length - 1];
				if (fmt.match(/E\-/) && o.match(/e\+/))
					o = o.replace(/e\+/, "e");
				return o.replace("e", "E")
			}
			var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
			function write_num_f1(r, aval, sign) {
				var den = parseInt(r[4]),
				rr = Math.round(aval * den),
				base = Math.floor(rr / den);
				var myn = rr - base * den,
				myd = den;
				return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r[1].length + 1 + r[4].length) : pad_(myn, r[1].length) + r[2] + "/" + r[3] + pad0(myd, r[4].length))
			}
			function write_num_f2(r, aval, sign) {
				return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r[1].length + 2 + r[4].length)
			}
			var dec1 = /^#*0*\.(0+)/;
			var closeparen = /\).*[0#]/;
			var phone = /\(###\) ###\\?-####/;
			function hashq(str) {
				var o = "",
				cc;
				for (var i = 0; i != str.length; ++i)
					switch (cc = str.charCodeAt(i)) {
					case 35:
						break;
					case 63:
						o += " ";
						break;
					case 48:
						o += "0";
						break;
					default:
						o += String.fromCharCode(cc)
					}
				return o
			}
			function rnd(val, d) {
				var dd = Math.pow(10, d);
				return "" + Math.round(val * dd) / dd
			}
			function dec(val, d) {
				return Math.round((val - Math.floor(val)) * Math.pow(10, d))
			}
			function flr(val) {
				if (val < 2147483647 && val > -2147483648)
					return "" + (val >= 0 ? val | 0 : val - 1 | 0);
				return "" + Math.floor(val)
			}
			function write_num_flt(type, fmt, val) {
				if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
					var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
					if (val >= 0)
						return write_num_flt("n", ffmt, val);
					return "(" + write_num_flt("n", ffmt, -val) + ")"
				}
				if (fmt.charCodeAt(fmt.length - 1) === 44)
					return write_num_cm(type, fmt, val);
				if (fmt.indexOf("%") !== -1)
					return write_num_pct(type, fmt, val);
				if (fmt.indexOf("E") !== -1)
					return write_num_exp(fmt, val);
				if (fmt.charCodeAt(0) === 36)
					return "$" + write_num_flt(type, fmt.substr(fmt[1] == " " ? 2 : 1), val);
				var o,
				oo;
				var r,
				ri,
				ff,
				aval = Math.abs(val),
				sign = val < 0 ? "-" : "";
				if (fmt.match(/^00+$/))
					return sign + pad0r(aval, fmt.length);
				if (fmt.match(/^[#?]+$/)) {
					o = pad0r(val, 0);
					if (o === "0")
						o = "";
					return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o
				}
				if ((r = fmt.match(frac1)) !== null)
					return write_num_f1(r, aval, sign);
				if (fmt.match(/^#+0+$/) !== null)
					return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
				if ((r = fmt.match(dec1)) !== null) {
					o = rnd(val, r[1].length).replace(/^([^\.]+)$/, "$1." + r[1]).replace(/\.$/, "." + r[1]).replace(/\.(\d*)$/, function ($$, $1) {
							return "." + $1 + fill("0", r[1].length - $1.length)
						});
					return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".")
				}
				fmt = fmt.replace(/^#+([0.])/, "$1");
				if ((r = fmt.match(/^(0*)\.(#*)$/)) !== null) {
					return sign + rnd(aval, r[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".")
				}
				if ((r = fmt.match(/^#,##0(\.?)$/)) !== null)
					return sign + commaify(pad0r(aval, 0));
				if ((r = fmt.match(/^#,##0\.([#0]*0)$/)) !== null) {
					return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + Math.floor(val)) + "." + pad0(dec(val, r[1].length), r[1].length)
				}
				if ((r = fmt.match(/^#,#*,#0/)) !== null)
					return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
				if ((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) !== null) {
					o = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
					ri = 0;
					return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function (x) {
							return ri < o.length ? o[ri++] : x === "0" ? "0" : ""
						}))
				}
				if (fmt.match(phone) !== null) {
					o = write_num_flt(type, "##########", val);
					return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6)
				}
				var oa = "";
				if ((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
					ri = Math.min(r[4].length, 7);
					ff = frac(aval, Math.pow(10, ri) - 1, false);
					o = "" + sign;
					oa = write_num("n", r[1], ff[1]);
					if (oa[oa.length - 1] == " ")
						oa = oa.substr(0, oa.length - 1) + "0";
					o += oa + r[2] + "/" + r[3];
					oa = rpad_(ff[2], ri);
					if (oa.length < r[4].length)
						oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
					o += oa;
					return o
				}
				if ((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
					ri = Math.min(Math.max(r[1].length, r[4].length), 7);
					ff = frac(aval, Math.pow(10, ri) - 1, true);
					return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length))
				}
				if ((r = fmt.match(/^[#0?]+$/)) !== null) {
					o = pad0r(val, 0);
					if (fmt.length <= o.length)
						return o;
					return hashq(fmt.substr(0, fmt.length - o.length)) + o
				}
				if ((r = fmt.match(/^([#0?]+)\.([#0]+)$/)) !== null) {
					o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
					ri = o.indexOf(".");
					var lres = fmt.indexOf(".") - ri,
					rres = fmt.length - o.length - lres;
					return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres))
				}
				if ((r = fmt.match(/^00,000\.([#0]*0)$/)) !== null) {
					ri = dec(val, r[1].length);
					return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function ($$) {
						return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$
					}) + "." + pad0(ri, r[1].length)
				}
				switch (fmt) {
				case "#,###":
					var x = commaify(pad0r(aval, 0));
					return x !== "0" ? sign + x : "";
				default:
				}
				throw new Error("unsupported format |" + fmt + "|")
			}
			function write_num_cm2(type, fmt, val) {
				var idx = fmt.length - 1;
				while (fmt.charCodeAt(idx - 1) === 44)
					--idx;
				return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)))
			}
			function write_num_pct2(type, fmt, val) {
				var sfmt = fmt.replace(pct1, ""),
				mul = fmt.length - sfmt.length;
				return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul)
			}
			function write_num_exp2(fmt, val) {
				var o;
				var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
				if (fmt.match(/^#+0.0E\+0$/)) {
					var period = fmt.indexOf(".");
					if (period === -1)
						period = fmt.indexOf("E");
					var ee = Math.floor(Math.log(Math.abs(val)) * Math.LOG10E) % period;
					if (ee < 0)
						ee += period;
					o = (val / Math.pow(10, ee)).toPrecision(idx + 1 + (period + ee) % period);
					if (!o.match(/[Ee]/)) {
						var fakee = Math.floor(Math.log(Math.abs(val)) * Math.LOG10E);
						if (o.indexOf(".") === -1)
							o = o[0] + "." + o.substr(1) + "E+" + (fakee - o.length + ee);
						else
							o += "E+" + (fakee - ee);
						o = o.replace(/\+-/, "-")
					}
					o = o.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function ($$, $1, $2, $3) {
							return $1 + $2 + $3.substr(0, (period + ee) % period) + "." + $3.substr(ee) + "E"
						})
				} else
					o = val.toExponential(idx);
				if (fmt.match(/E\+00$/) && o.match(/e[+-]\d$/))
					o = o.substr(0, o.length - 1) + "0" + o[o.length - 1];
				if (fmt.match(/E\-/) && o.match(/e\+/))
					o = o.replace(/e\+/, "e");
				return o.replace("e", "E")
			}
			function write_num_int(type, fmt, val) {
				if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
					var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
					if (val >= 0)
						return write_num_int("n", ffmt, val);
					return "(" + write_num_int("n", ffmt, -val) + ")"
				}
				if (fmt.charCodeAt(fmt.length - 1) === 44)
					return write_num_cm2(type, fmt, val);
				if (fmt.indexOf("%") !== -1)
					return write_num_pct2(type, fmt, val);
				if (fmt.indexOf("E") !== -1)
					return write_num_exp2(fmt, val);
				if (fmt.charCodeAt(0) === 36)
					return "$" + write_num_int(type, fmt.substr(fmt[1] == " " ? 2 : 1), val);
				var o;
				var r,
				ri,
				ff,
				aval = Math.abs(val),
				sign = val < 0 ? "-" : "";
				if (fmt.match(/^00+$/))
					return sign + pad0(aval, fmt.length);
				if (fmt.match(/^[#?]+$/)) {
					o = "" + val;
					if (val === 0)
						o = "";
					return o.length > fmt.length ? o : hashq(fmt.substr(0, fmt.length - o.length)) + o
				}
				if ((r = fmt.match(frac1)) !== null)
					return write_num_f2(r, aval, sign);
				if (fmt.match(/^#+0+$/) !== null)
					return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
				if ((r = fmt.match(dec1)) !== null) {
					o = ("" + val).replace(/^([^\.]+)$/, "$1." + r[1]).replace(/\.$/, "." + r[1]).replace(/\.(\d*)$/, function ($$, $1) {
						return "." + $1 + fill("0", r[1].length - $1.length)
					});
					return fmt.indexOf("0.") !== -1 ? o : o.replace(/^0\./, ".")
				}
				fmt = fmt.replace(/^#+([0.])/, "$1");
				if ((r = fmt.match(/^(0*)\.(#*)$/)) !== null) {
					return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r[1].length ? "0." : ".")
				}
				if ((r = fmt.match(/^#,##0(\.?)$/)) !== null)
					return sign + commaify("" + aval);
				if ((r = fmt.match(/^#,##0\.([#0]*0)$/)) !== null) {
					return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r[1].length)
				}
				if ((r = fmt.match(/^#,#*,#0/)) !== null)
					return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
				if ((r = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) !== null) {
					o = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
					ri = 0;
					return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function (x) {
							return ri < o.length ? o[ri++] : x === "0" ? "0" : ""
						}))
				}
				if (fmt.match(phone) !== null) {
					o = write_num_int(type, "##########", val);
					return "(" + o.substr(0, 3) + ") " + o.substr(3, 3) + "-" + o.substr(6)
				}
				var oa = "";
				if ((r = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
					ri = Math.min(r[4].length, 7);
					ff = frac(aval, Math.pow(10, ri) - 1, false);
					o = "" + sign;
					oa = write_num("n", r[1], ff[1]);
					if (oa[oa.length - 1] == " ")
						oa = oa.substr(0, oa.length - 1) + "0";
					o += oa + r[2] + "/" + r[3];
					oa = rpad_(ff[2], ri);
					if (oa.length < r[4].length)
						oa = hashq(r[4].substr(r[4].length - oa.length)) + oa;
					o += oa;
					return o
				}
				if ((r = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) !== null) {
					ri = Math.min(Math.max(r[1].length, r[4].length), 7);
					ff = frac(aval, Math.pow(10, ri) - 1, true);
					return sign + (ff[0] || (ff[1] ? "" : "0")) + " " + (ff[1] ? pad_(ff[1], ri) + r[2] + "/" + r[3] + rpad_(ff[2], ri) : fill(" ", 2 * ri + 1 + r[2].length + r[3].length))
				}
				if ((r = fmt.match(/^[#0?]+$/)) !== null) {
					o = "" + val;
					if (fmt.length <= o.length)
						return o;
					return hashq(fmt.substr(0, fmt.length - o.length)) + o
				}
				if ((r = fmt.match(/^([#0]+)\.([#0]+)$/)) !== null) {
					o = "" + val.toFixed(Math.min(r[2].length, 10)).replace(/([^0])0+$/, "$1");
					ri = o.indexOf(".");
					var lres = fmt.indexOf(".") - ri,
					rres = fmt.length - o.length - lres;
					return hashq(fmt.substr(0, lres) + o + fmt.substr(fmt.length - rres))
				}
				if ((r = fmt.match(/^00,000\.([#0]*0)$/)) !== null) {
					return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function ($$) {
						return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$
					}) + "." + pad0(0, r[1].length)
				}
				switch (fmt) {
				case "#,###":
					var x = commaify("" + aval);
					return x !== "0" ? sign + x : "";
				default:
				}
				throw new Error("unsupported format |" + fmt + "|")
			}
			return function write_num(type, fmt, val) {
				return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val)
			}
		}();
		function split_fmt(fmt) {
			var out = [];
			var in_str = false,
			cc;
			for (var i = 0, j = 0; i < fmt.length; ++i)
				switch (cc = fmt.charCodeAt(i)) {
				case 34:
					in_str = !in_str;
					break;
				case 95:
				case 42:
				case 92:
					++i;
					break;
				case 59:
					out[out.length] = fmt.substr(j, i - j);
					j = i + 1
				}
			out[out.length] = fmt.substr(j);
			if (in_str === true)
				throw new Error("Format |" + fmt + "| unterminated string ");
			return out
		}
		SSF._split = split_fmt;
		var abstime = /\[[HhMmSs]*\]/;
		function eval_fmt(fmt, v, opts, flen) {
			var out = [],
			o = "",
			i = 0,
			c = "",
			lst = "t",
			q,
			dt,
			j,
			cc;
			var hr = "H";
			while (i < fmt.length) {
				switch (c = fmt[i]) {
				case "G":
					if (!isgeneral(fmt, i))
						throw new Error("unrecognized character " + c + " in " + fmt);
					out[out.length] = {
						t : "G",
						v : "General"
					};
					i += 7;
					break;
				case '"':
					for (o = ""; (cc = fmt.charCodeAt(++i)) !== 34 && i < fmt.length; )
						o += String.fromCharCode(cc);
					out[out.length] = {
						t : "t",
						v : o
					};
					++i;
					break;
				case "\\":
					var w = fmt[++i],
					t = w === "(" || w === ")" ? w : "t";
					out[out.length] = {
						t : t,
						v : w
					};
					++i;
					break;
				case "_":
					out[out.length] = {
						t : "t",
						v : " "
					};
					i += 2;
					break;
				case "@":
					out[out.length] = {
						t : "T",
						v : v
					};
					++i;
					break;
				case "B":
				case "b":
					if (fmt[i + 1] === "1" || fmt[i + 1] === "2") {
						if (dt == null) {
							dt = parse_date_code(v, opts, fmt[i + 1] === "2");
							if (dt == null)
								return ""
						}
						out[out.length] = {
							t : "X",
							v : fmt.substr(i, 2)
						};
						lst = c;
						i += 2;
						break
					}
				case "M":
				case "D":
				case "Y":
				case "H":
				case "S":
				case "E":
					c = c.toLowerCase();
				case "m":
				case "d":
				case "y":
				case "h":
				case "s":
				case "e":
				case "g":
					if (v < 0)
						return "";
					if (dt == null) {
						dt = parse_date_code(v, opts);
						if (dt == null)
							return ""
					}
					o = c;
					while (++i < fmt.length && fmt[i].toLowerCase() === c)
						o += c;
					if (c === "m" && lst.toLowerCase() === "h")
						c = "M";
					if (c === "h")
						c = hr;
					out[out.length] = {
						t : c,
						v : o
					};
					lst = c;
					break;
				case "A":
					q = {
						t : c,
						v : "A"
					};
					if (dt == null)
						dt = parse_date_code(v, opts);
					if (fmt.substr(i, 3) === "A/P") {
						if (dt != null)
							q.v = dt.H >= 12 ? "P" : "A";
						q.t = "T";
						hr = "h";
						i += 3
					} else if (fmt.substr(i, 5) === "AM/PM") {
						if (dt != null)
							q.v = dt.H >= 12 ? "PM" : "AM";
						q.t = "T";
						i += 5;
						hr = "h"
					} else {
						q.t = "t";
						++i
					}
					if (dt == null && q.t === "T")
						return "";
					out[out.length] = q;
					lst = c;
					break;
				case "[":
					o = c;
					while (fmt[i++] !== "]" && i < fmt.length)
						o += fmt[i];
					if (o.substr(-1) !== "]")
						throw 'unterminated "[" block: |' + o + "|";
					if (o.match(abstime)) {
						if (dt == null) {
							dt = parse_date_code(v, opts);
							if (dt == null)
								return ""
						}
						out[out.length] = {
							t : "Z",
							v : o.toLowerCase()
						}
					} else {
						o = ""
					}
					break;
				case ".":
					if (dt != null) {
						o = c;
						while ((c = fmt[++i]) === "0")
							o += c;
						out[out.length] = {
							t : "s",
							v : o
						};
						break
					}
				case "0":
				case "#":
					o = c;
					while ("0#?.,E+-%".indexOf(c = fmt[++i]) > -1 || c == "\\" && fmt[i + 1] == "-" && "0#".indexOf(fmt[i + 2]) > -1)
						o += c;
					out[out.length] = {
						t : "n",
						v : o
					};
					break;
				case "?":
					o = c;
					while (fmt[++i] === c)
						o += c;
					q = {
						t : c,
						v : o
					};
					out[out.length] = q;
					lst = c;
					break;
				case "*":
					++i;
					if (fmt[i] == " " || fmt[i] == "*")
						++i;
					break;
				case "(":
				case ")":
					out[out.length] = {
						t : flen === 1 ? "t" : c,
						v : c
					};
					++i;
					break;
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
				case "7":
				case "8":
				case "9":
					o = c;
					while ("0123456789".indexOf(fmt[++i]) > -1)
						o += fmt[i];
					out[out.length] = {
						t : "D",
						v : o
					};
					break;
				case " ":
					out[out.length] = {
						t : c,
						v : c
					};
					++i;
					break;
				default:
					if (",$-+/():!^&'~{}<>=â‚¬acfijklopqrtuvwxz".indexOf(c) === -1)
						throw new Error("unrecognized character " + c + " in " + fmt);
					out[out.length] = {
						t : "t",
						v : c
					};
					++i;
					break
				}
			}
			var bt = 0,
			ss0 = 0,
			ssm;
			for (i = out.length - 1, lst = "t"; i >= 0; --i) {
				switch (out[i].t) {
				case "h":
				case "H":
					out[i].t = hr;
					lst = "h";
					if (bt < 1)
						bt = 1;
					break;
				case "s":
					if (ssm = out[i].v.match(/\.0+$/))
						ss0 = Math.max(ss0, ssm[0].length - 1);
					if (bt < 3)
						bt = 3;
				case "d":
				case "y":
				case "M":
				case "e":
					lst = out[i].t;
					break;
				case "m":
					if (lst === "s") {
						out[i].t = "M";
						if (bt < 2)
							bt = 2
					}
					break;
				case "X":
					if (out[i].v === "B2");
					break;
				case "Z":
					if (bt < 1 && out[i].v.match(/[Hh]/))
						bt = 1;
					if (bt < 2 && out[i].v.match(/[Mm]/))
						bt = 2;
					if (bt < 3 && out[i].v.match(/[Ss]/))
						bt = 3
				}
			}
			switch (bt) {
			case 0:
				break;
			case 1:
				if (dt.u >= .5) {
					dt.u = 0;
					++dt.S
				}
				if (dt.S >= 60) {
					dt.S = 0;
					++dt.M
				}
				if (dt.M >= 60) {
					dt.M = 0;
					++dt.H
				}
				break;
			case 2:
				if (dt.u >= .5) {
					dt.u = 0;
					++dt.S
				}
				if (dt.S >= 60) {
					dt.S = 0;
					++dt.M
				}
				break
			}
			var nstr = "",
			jj;
			for (i = 0; i < out.length; ++i) {
				switch (out[i].t) {
				case "t":
				case "T":
				case " ":
				case "D":
					break;
				case "X":
					out[i] = undefined;
					break;
				case "d":
				case "m":
				case "y":
				case "h":
				case "H":
				case "M":
				case "s":
				case "e":
				case "b":
				case "Z":
					out[i].v = write_date(out[i].t.charCodeAt(0), out[i].v, dt, ss0);
					out[i].t = "t";
					break;
				case "n":
				case "(":
				case "?":
					jj = i + 1;
					while (out[jj] != null && ((c = out[jj].t) === "?" || c === "D" || (c === " " || c === "t") && out[jj + 1] != null && (out[jj + 1].t === "?" || out[jj + 1].t === "t" && out[jj + 1].v === "/") || out[i].t === "(" && (c === " " || c === "n" || c === ")") || c === "t" && (out[jj].v === "/" || "$â‚¬".indexOf(out[jj].v) > -1 || out[jj].v === " " && out[jj + 1] != null && out[jj + 1].t == "?"))) {
						out[i].v += out[jj].v;
						out[jj] = undefined;
						++jj
					}
					nstr += out[i].v;
					i = jj - 1;
					break;
				case "G":
					out[i].t = "t";
					out[i].v = general_fmt(v, opts);
					break
				}
			}
			var vv = "",
			myv,
			ostr;
			if (nstr.length > 0) {
				myv = v < 0 && nstr.charCodeAt(0) === 45 ? -v : v;
				ostr = write_num(nstr.charCodeAt(0) === 40 ? "(" : "n", nstr, myv);
				jj = ostr.length - 1;
				var decpt = out.length;
				for (i = 0; i < out.length; ++i)
					if (out[i] != null && out[i].v.indexOf(".") > -1) {
						decpt = i;
						break
					}
				var lasti = out.length;
				if (decpt === out.length && ostr.indexOf("E") === -1) {
					for (i = out.length - 1; i >= 0; --i) {
						if (out[i] == null || "n?(".indexOf(out[i].t) === -1)
							continue;
						if (jj >= out[i].v.length - 1) {
							jj -= out[i].v.length;
							out[i].v = ostr.substr(jj + 1, out[i].v.length)
						} else if (jj < 0)
							out[i].v = "";
						else {
							out[i].v = ostr.substr(0, jj + 1);
							jj = -1
						}
						out[i].t = "t";
						lasti = i
					}
					if (jj >= 0 && lasti < out.length)
						out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v
				} else if (decpt !== out.length && ostr.indexOf("E") === -1) {
					jj = ostr.indexOf(".") - 1;
					for (i = decpt; i >= 0; --i) {
						if (out[i] == null || "n?(".indexOf(out[i].t) === -1)
							continue;
						j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") - 1 : out[i].v.length - 1;
						vv = out[i].v.substr(j + 1);
						for (; j >= 0; --j) {
							if (jj >= 0 && (out[i].v[j] === "0" || out[i].v[j] === "#"))
								vv = ostr[jj--] + vv
						}
						out[i].v = vv;
						out[i].t = "t";
						lasti = i
					}
					if (jj >= 0 && lasti < out.length)
						out[lasti].v = ostr.substr(0, jj + 1) + out[lasti].v;
					jj = ostr.indexOf(".") + 1;
					for (i = decpt; i < out.length; ++i) {
						if (out[i] == null || "n?(".indexOf(out[i].t) === -1 && i !== decpt)
							continue;
						j = out[i].v.indexOf(".") > -1 && i === decpt ? out[i].v.indexOf(".") + 1 : 0;
						vv = out[i].v.substr(0, j);
						for (; j < out[i].v.length; ++j) {
							if (jj < ostr.length)
								vv += ostr[jj++]
						}
						out[i].v = vv;
						out[i].t = "t";
						lasti = i
					}
				}
			}
			for (i = 0; i < out.length; ++i)
				if (out[i] != null && "n(?".indexOf(out[i].t) > -1) {
					myv = flen > 1 && v < 0 && i > 0 && out[i - 1].v === "-" ? -v : v;
					out[i].v = write_num(out[i].t, out[i].v, myv);
					out[i].t = "t"
				}
			var retval = "";
			for (i = 0; i !== out.length; ++i)
				if (out[i] != null)
					retval += out[i].v;
			return retval
		}
		SSF._eval = eval_fmt;
		var cfregex = /\[[=<>]/;
		var cfregex2 = /\[([=<>]*)(-?\d+\.?\d*)\]/;
		function chkcond(v, rr) {
			if (rr == null)
				return false;
			var thresh = parseFloat(rr[2]);
			switch (rr[1]) {
			case "=":
				if (v == thresh)
					return true;
				break;
			case ">":
				if (v > thresh)
					return true;
				break;
			case "<":
				if (v < thresh)
					return true;
				break;
			case "<>":
				if (v != thresh)
					return true;
				break;
			case ">=":
				if (v >= thresh)
					return true;
				break;
			case "<=":
				if (v <= thresh)
					return true;
				break
			}
			return false
		}
		function choose_fmt(f, v) {
			var fmt = split_fmt(f);
			var l = fmt.length,
			lat = fmt[l - 1].indexOf("@");
			if (l < 4 && lat > -1)
				--l;
			if (fmt.length > 4)
				throw "cannot find right format for |" + fmt + "|";
			if (typeof v !== "number")
				return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
			switch (fmt.length) {
			case 1:
				fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
				break;
			case 2:
				fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
				break;
			case 3:
				fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
				break;
			case 4:
				break
			}
			var ff = v > 0 ? fmt[0] : v < 0 ? fmt[1] : fmt[2];
			if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1)
				return [l, ff];
			if (fmt[0].match(cfregex) != null || fmt[1].match(cfregex) != null) {
				var m1 = fmt[0].match(cfregex2);
				var m2 = fmt[1].match(cfregex2);
				return chkcond(v, m1) ? [l, fmt[0]] : chkcond(v, m2) ? [l, fmt[1]] : [l, fmt[m1 != null && m2 != null ? 2 : 1]]
			}
			return [l, ff]
		}
		function format(fmt, v, o) {
			fixopts(o != null ? o : o = []);
			var sfmt = "";
			switch (typeof fmt) {
			case "string":
				sfmt = fmt;
				break;
			case "number":
				sfmt = (o.table != null ? o.table : table_fmt)[fmt];
				break
			}
			if (isgeneral(sfmt, 0))
				return general_fmt(v, o);
			var f = choose_fmt(sfmt, v);
			if (isgeneral(f[1]))
				return general_fmt(v, o);
			if (v === true)
				v = "TRUE";
			else if (v === false)
				v = "FALSE";
			else if (v === "" || v == null)
				return "";
			return eval_fmt(f[1], v, o, f[0])
		}
		SSF._table = table_fmt;
		SSF.load = function load_entry(fmt, idx) {
			table_fmt[idx] = fmt
		};
		SSF.format = format;
		SSF.get_table = function get_table() {
			return table_fmt
		};
		SSF.load_table = function load_table(tbl) {
			for (var i = 0; i != 392; ++i)
				if (tbl[i] !== undefined)
					SSF.load(tbl[i], i)
		}
	};
	make_ssf(SSF);
	var XLMLFormatMap = {
		"General Number" : "General",
		"General Date" : SSF._table[22],
		"Long Date" : "dddd, mmmm dd, yyyy",
		"Medium Date" : SSF._table[15],
		"Short Date" : SSF._table[14],
		"Long Time" : SSF._table[19],
		"Medium Time" : SSF._table[18],
		"Short Time" : SSF._table[20],
		Currency : '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
		Fixed : SSF._table[2],
		Standard : SSF._table[4],
		Percent : SSF._table[10],
		Scientific : SSF._table[11],
		"Yes/No" : '"Yes";"Yes";"No";@',
		"True/False" : '"True";"True";"False";@',
		"On/Off" : '"Yes";"Yes";"No";@'
	};
	var DO_NOT_EXPORT_CFB = true;
	var CFB = function _CFB() {
		var exports = {};
		exports.version = "0.10.2";
		function parse(file) {
			var mver = 3;
			var ssz = 512;
			var nmfs = 0;
			var ndfs = 0;
			var dir_start = 0;
			var minifat_start = 0;
			var difat_start = 0;
			var fat_addrs = [];
			var blob = file.slice(0, 512);
			prep_blob(blob, 0);
			var mv = check_get_mver(blob);
			mver = mv[0];
			switch (mver) {
			case 3:
				ssz = 512;
				break;
			case 4:
				ssz = 4096;
				break;
			default:
				throw "Major Version: Expected 3 or 4 saw " + mver
			}
			if (ssz !== 512) {
				blob = file.slice(0, ssz);
				prep_blob(blob, 28)
			}
			var header = file.slice(0, ssz);
			check_shifts(blob, mver);
			var nds = blob.read_shift(4, "i");
			if (mver === 3 && nds !== 0)
				throw "# Directory Sectors: Expected 0 saw " + nds;
			blob.l += 4;
			dir_start = blob.read_shift(4, "i");
			blob.l += 4;
			blob.chk("00100000", "Mini Stream Cutoff Size: ");
			minifat_start = blob.read_shift(4, "i");
			nmfs = blob.read_shift(4, "i");
			difat_start = blob.read_shift(4, "i");
			ndfs = blob.read_shift(4, "i");
			for (var q, j = 0; j < 109; ++j) {
				q = blob.read_shift(4, "i");
				if (q < 0)
					break;
				fat_addrs[j] = q
			}
			var sectors = sectorify(file, ssz);
			sleuth_fat(difat_start, ndfs, sectors, ssz, fat_addrs);
			var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
			sector_list[dir_start].name = "!Directory";
			if (nmfs > 0 && minifat_start !== ENDOFCHAIN)
				sector_list[minifat_start].name = "!MiniFAT";
			sector_list[fat_addrs[0]].name = "!FAT";
			sector_list.fat_addrs = fat_addrs;
			sector_list.ssz = ssz;
			var files = {},
			Paths = [],
			FileIndex = [],
			FullPaths = [],
			FullPathDir = {};
			read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex);
			build_full_paths(FileIndex, FullPathDir, FullPaths, Paths);
			var root_name = Paths.shift();
			Paths.root = root_name;
			var find_path = make_find_path(FullPaths, Paths, FileIndex, files, root_name);
			return {
				raw : {
					header : header,
					sectors : sectors
				},
				FileIndex : FileIndex,
				FullPaths : FullPaths,
				FullPathDir : FullPathDir,
				find : find_path
			}
		}
		function check_get_mver(blob) {
			blob.chk(HEADER_SIGNATURE, "Header Signature: ");
			blob.chk(HEADER_CLSID, "CLSID: ");
			var mver = blob.read_shift(2, "u");
			return [blob.read_shift(2, "u"), mver]
		}
		function check_shifts(blob, mver) {
			var shift = 9;
			blob.chk("feff", "Byte Order: ");
			switch (shift = blob.read_shift(2)) {
			case 9:
				if (mver !== 3)
					throw "MajorVersion/SectorShift Mismatch";
				break;
			case 12:
				if (mver !== 4)
					throw "MajorVersion/SectorShift Mismatch";
				break;
			default:
				throw "Sector Shift: Expected 9 or 12 saw " + shift
			}
			blob.chk("0600", "Mini Sector Shift: ");
			blob.chk("000000000000", "Reserved: ")
		}
		function sectorify(file, ssz) {
			var nsectors = Math.ceil(file.length / ssz) - 1;
			var sectors = new Array(nsectors);
			for (var i = 1; i < nsectors; ++i)
				sectors[i - 1] = file.slice(i * ssz, (i + 1) * ssz);
			sectors[nsectors - 1] = file.slice(nsectors * ssz);
			return sectors
		}
		function build_full_paths(FI, FPD, FP, Paths) {
			var i = 0,
			L = 0,
			R = 0,
			C = 0,
			j = 0,
			pl = Paths.length;
			var dad = new Array(pl),
			q = new Array(pl);
			for (; i < pl; ++i) {
				dad[i] = q[i] = i;
				FP[i] = Paths[i]
			}
			for (; j < q.length; ++j) {
				i = q[j];
				L = FI[i].L;
				R = FI[i].R;
				C = FI[i].C;
				if (dad[i] === i) {
					if (L !== -1 && dad[L] !== L)
						dad[i] = dad[L];
					if (R !== -1 && dad[R] !== R)
						dad[i] = dad[R]
				}
				if (C !== -1)
					dad[C] = i;
				if (L !== -1) {
					dad[L] = dad[i];
					q.push(L)
				}
				if (R !== -1) {
					dad[R] = dad[i];
					q.push(R)
				}
			}
			for (i = 1; i !== pl; ++i)
				if (dad[i] === i) {
					if (R !== -1 && dad[R] !== R)
						dad[i] = dad[R];
					else if (L !== -1 && dad[L] !== L)
						dad[i] = dad[L]
				}
			for (i = 1; i < pl; ++i) {
				if (FI[i].type === 0)
					continue;
				j = dad[i];
				if (j === 0)
					FP[i] = FP[0] + "/" + FP[i];
				else
					while (j !== 0) {
						FP[i] = FP[j] + "/" + FP[i];
						j = dad[j]
					}
				dad[i] = 0
			}
			FP[0] += "/";
			for (i = 1; i < pl; ++i) {
				if (FI[i].type !== 2)
					FP[i] += "/";
				FPD[FP[i]] = FI[i]
			}
		}
		function make_find_path(FullPaths, Paths, FileIndex, files, root_name) {
			var UCFullPaths = new Array(FullPaths.length);
			var UCPaths = new Array(Paths.length),
			i;
			for (i = 0; i < FullPaths.length; ++i)
				UCFullPaths[i] = FullPaths[i].toUpperCase().replace(chr0, "").replace(chr1, "!");
			for (i = 0; i < Paths.length; ++i)
				UCPaths[i] = Paths[i].toUpperCase().replace(chr0, "").replace(chr1, "!");
			return function find_path(path) {
				var k;
				if (path.charCodeAt(0) === 47) {
					k = true;
					path = root_name + path
				} else
					k = path.indexOf("/") !== -1;
				var UCPath = path.toUpperCase().replace(chr0, "").replace(chr1, "!");
				var w = k === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
				if (w === -1)
					return null;
				return k === true ? FileIndex[w] : files[Paths[w]]
			}
		}
		function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
			var q;
			if (idx === ENDOFCHAIN) {
				if (cnt !== 0)
					throw "DIFAT chain shorter than expected"
			} else if (idx !== -1) {
				var sector = sectors[idx],
				m = (ssz >>> 2) - 1;
				for (var i = 0; i < m; ++i) {
					if ((q = __readInt32LE(sector, i * 4)) === ENDOFCHAIN)
						break;
					fat_addrs.push(q)
				}
				sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs)
			}
		}
		function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
			var sl = sectors.length;
			var buf,
			buf_chain;
			if (!chkd)
				chkd = new Array(sl);
			var modulus = ssz - 1,
			j,
			jj;
			buf = [];
			buf_chain = [];
			for (j = start; j >= 0; ) {
				chkd[j] = true;
				buf[buf.length] = j;
				buf_chain.push(sectors[j]);
				var addr = fat_addrs[Math.floor(j * 4 / ssz)];
				jj = j * 4 & modulus;
				if (ssz < 4 + jj)
					throw "FAT boundary crossed: " + j + " 4 " + ssz;
				j = __readInt32LE(sectors[addr], jj)
			}
			return {
				nodes : buf,
				data : __toBuffer([buf_chain])
			}
		}
		function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
			var sl = sectors.length,
			sector_list = new Array(sl);
			var chkd = new Array(sl),
			buf,
			buf_chain;
			var modulus = ssz - 1,
			i,
			j,
			k,
			jj;
			for (i = 0; i < sl; ++i) {
				buf = [];
				k = i + dir_start;
				if (k >= sl)
					k -= sl;
				if (chkd[k] === true)
					continue;
				buf_chain = [];
				for (j = k; j >= 0; ) {
					chkd[j] = true;
					buf[buf.length] = j;
					buf_chain.push(sectors[j]);
					var addr = fat_addrs[Math.floor(j * 4 / ssz)];
					jj = j * 4 & modulus;
					if (ssz < 4 + jj)
						throw "FAT boundary crossed: " + j + " 4 " + ssz;
					j = __readInt32LE(sectors[addr], jj)
				}
				sector_list[k] = {
					nodes : buf,
					data : __toBuffer([buf_chain])
				}
			}
			return sector_list
		}
		function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex) {
			var blob;
			var minifat_store = 0,
			pl = Paths.length ? 2 : 0;
			var sector = sector_list[dir_start].data;
			var i = 0,
			namelen = 0,
			name,
			o,
			ctime,
			mtime;
			for (; i < sector.length; i += 128) {
				blob = sector.slice(i, i + 128);
				prep_blob(blob, 64);
				namelen = blob.read_shift(2);
				if (namelen === 0)
					continue;
				name = __utf16le(blob, 0, namelen - pl);
				Paths.push(name);
				o = {
					name : name,
					type : blob.read_shift(1),
					color : blob.read_shift(1),
					L : blob.read_shift(4, "i"),
					R : blob.read_shift(4, "i"),
					C : blob.read_shift(4, "i"),
					clsid : blob.read_shift(16),
					state : blob.read_shift(4, "i")
				};
				ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
				if (ctime !== 0) {
					o.ctime = ctime;
					o.ct = read_date(blob, blob.l - 8)
				}
				mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
				if (mtime !== 0) {
					o.mtime = mtime;
					o.mt = read_date(blob, blob.l - 8)
				}
				o.start = blob.read_shift(4, "i");
				o.size = blob.read_shift(4, "i");
				if (o.type === 5) {
					minifat_store = o.start;
					if (nmfs > 0 && minifat_store !== ENDOFCHAIN)
						sector_list[minifat_store].name = "!StreamData"
				} else if (o.size >= 4096) {
					o.storage = "fat";
					if (sector_list[o.start] === undefined)
						sector_list[o.start] = get_sector_list(sectors, o.start, sector_list.fat_addrs, sector_list.ssz);
					sector_list[o.start].name = o.name;
					o.content = sector_list[o.start].data.slice(0, o.size);
					prep_blob(o.content, 0)
				} else {
					o.storage = "minifat";
					if (minifat_store !== ENDOFCHAIN && o.start !== ENDOFCHAIN) {
						o.content = sector_list[minifat_store].data.slice(o.start * MSSZ, o.start * MSSZ + o.size);
						prep_blob(o.content, 0)
					}
				}
				files[name] = o;
				FileIndex.push(o)
			}
		}
		function read_date(blob, offset) {
			return new Date((__readUInt32LE(blob, offset + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset) / 1e7 - 11644473600) * 1e3)
		}
		var fs;
		function readFileSync(filename, options) {
			if (fs === undefined)
				fs = require("fs");
			return parse(fs.readFileSync(filename), options)
		}
		function readSync(blob, options) {
			switch (options !== undefined && options.type !== undefined ? options.type : "base64") {
			case "file":
				return readFileSync(blob, options);
			case "base64":
				return parse(s2a(Base64.decode(blob)), options);
			case "binary":
				return parse(s2a(blob), options)
			}
			return parse(blob)
		}
		var MSSZ = 64;
		var ENDOFCHAIN = -2;
		var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
		var HEADER_CLSID = "00000000000000000000000000000000";
		var consts = {
			MAXREGSECT : -6,
			DIFSECT : -4,
			FATSECT : -3,
			ENDOFCHAIN : ENDOFCHAIN,
			FREESECT : -1,
			HEADER_SIGNATURE : HEADER_SIGNATURE,
			HEADER_MINOR_VERSION : "3e00",
			MAXREGSID : -6,
			NOSTREAM : -1,
			HEADER_CLSID : HEADER_CLSID,
			EntryTypes : ["unknown", "storage", "stream", "lockbytes", "property", "root"]
		};
		exports.read = readSync;
		exports.parse = parse;
		exports.utils = {
			ReadShift : ReadShift,
			CheckField : CheckField,
			prep_blob : prep_blob,
			bconcat : bconcat,
			consts : consts
		};
		return exports
	}();
	if (typeof require !== "undefined" && typeof module !== "undefined" && typeof DO_NOT_EXPORT_CFB === "undefined") {
		module.exports = CFB
	}
	function isval(x) {
		return x !== undefined && x !== null
	}
	function keys(o) {
		return Object.keys(o)
	}
	function evert_key(obj, key) {
		var o = [],
		K = keys(obj);
		for (var i = 0; i !== K.length; ++i)
			o[obj[K[i]][key]] = K[i];
		return o
	}
	function evert(obj) {
		var o = [],
		K = keys(obj);
		for (var i = 0; i !== K.length; ++i)
			o[obj[K[i]]] = K[i];
		return o
	}
	function evert_num(obj) {
		var o = [],
		K = keys(obj);
		for (var i = 0; i !== K.length; ++i)
			o[obj[K[i]]] = parseInt(K[i], 10);
		return o
	}
	function evert_arr(obj) {
		var o = [],
		K = keys(obj);
		for (var i = 0; i !== K.length; ++i) {
			if (o[obj[K[i]]] == null)
				o[obj[K[i]]] = [];
			o[obj[K[i]]].push(K[i])
		}
		return o
	}
	function datenum(v, date1904) {
		if (date1904)
			v += 1462;
		var epoch = Date.parse(v);
		return (epoch + 22091616e5) / (24 * 60 * 60 * 1e3)
	}
	function cc2str(arr) {
		var o = "";
		for (var i = 0; i != arr.length; ++i)
			o += String.fromCharCode(arr[i]);
		return o
	}
	function getdata(data) {
		if (!data)
			return null;
		if (data.name.substr(-4) === ".bin") {
			if (data.data)
				return char_codes(data.data);
			if (data.asNodeBuffer && has_buf)
				return data.asNodeBuffer();
			if (data._data && data._data.getContent)
				return Array.prototype.slice.call(data._data.getContent())
		} else {
			if (data.data)
				return data.name.substr(-4) !== ".bin" ? debom_xml(data.data) : char_codes(data.data);
			if (data.asNodeBuffer && has_buf)
				return debom_xml(data.asNodeBuffer().toString("binary"));
			if (data.asBinary)
				return debom_xml(data.asBinary());
			if (data._data && data._data.getContent)
				return debom_xml(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)))
		}
		return null
	}
	function safegetzipfile(zip, file) {
		var f = file;
		if (zip.files[f])
			return zip.files[f];
		f = file.toLowerCase();
		if (zip.files[f])
			return zip.files[f];
		f = f.replace(/\//g, "\\");
		if (zip.files[f])
			return zip.files[f];
		return null
	}
	function getzipfile(zip, file) {
		var o = safegetzipfile(zip, file);
		if (o == null)
			throw new Error("Cannot find file " + file + " in zip");
		return o
	}
	function getzipdata(zip, file, safe) {
		if (!safe)
			return getdata(getzipfile(zip, file));
		if (!file)
			return null;
		try {
			return getzipdata(zip, file)
		} catch (e) {
			return null
		}
	}
	var _fs,
	jszip;
	if (typeof JSZip !== "undefined")
		jszip = JSZip;
	if (typeof exports !== "undefined") {
		if (typeof module !== "undefined" && module.exports) {
			if (has_buf && typeof jszip === "undefined")
				jszip = require("js" + "zip");
			if (typeof jszip === "undefined")
				jszip = require("./js" + "zip").JSZip;
			_fs = require("f" + "s")
		}
	}
	var attregexg = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
	var tagregex = /<[^>]*>/g;
	var nsregex = /<\w*:/,
	nsregex2 = /<(\/?)\w+:/;
	function parsexmltag(tag, skip_root) {
		var z = [];
		var eq = 0,
		c = 0;
		for (; eq !== tag.length; ++eq)
			if ((c = tag.charCodeAt(eq)) === 32 || c === 10 || c === 13)
				break;
		if (!skip_root)
			z[0] = tag.substr(0, eq);
		if (eq === tag.length)
			return z;
		var m = tag.match(attregexg),
		j = 0,
		w = "",
		v = "",
		i = 0,
		q = "",
		cc = "";
		if (m)
			for (i = 0; i != m.length; ++i) {
				cc = m[i];
				for (c = 0; c != cc.length; ++c)
					if (cc.charCodeAt(c) === 61)
						break;
				q = cc.substr(0, c);
				v = cc.substring(c + 2, cc.length - 1);
				for (j = 0; j != q.length; ++j)
					if (q.charCodeAt(j) === 58)
						break;
				if (j === q.length)
					z[q] = v;
				else
					z[(j === 5 && q.substr(0, 5) === "xmlns" ? "xmlns" : "") + q.substr(j + 1)] = v
			}
		return z
	}
	function strip_ns(x) {
		return x.replace(nsregex2, "<$1")
	}
	var encodings = {
		"&quot;" : '"',
		"&apos;" : "'",
		"&gt;" : ">",
		"&lt;" : "<",
		"&amp;" : "&"
	};
	var rencoding = evert(encodings);
	var rencstr = "&<>'\"".split("");
	var unescapexml = function () {
		var encregex = /&[a-z]*;/g,
		coderegex = /_x([\da-fA-F]+)_/g;
		return function unescapexml(text) {
			var s = text + "";
			return s.replace(encregex, function ($$) {
				return encodings[$$]
			}).replace(coderegex, function (m, c) {
				return String.fromCharCode(parseInt(c, 16))
			})
		}
	}();
	var decregex = /[&<>'"]/g,
	charegex = /[\u0000-\u0008\u000b-\u001f]/g;
	function escapexml(text) {
		var s = text + "";
		return s.replace(decregex, function (y) {
			return rencoding[y]
		}).replace(charegex, function (s) {
			return "_x" + ("000" + s.charCodeAt(0).toString(16)).substr(-4) + "_"
		})
	}
	var xlml_fixstr = function () {
		var entregex = /&#(\d+);/g;
		function entrepl($$, $1) {
			return String.fromCharCode(parseInt($1, 10))
		}
		return function xlml_fixstr(str) {
			return str.replace(entregex, entrepl)
		}
	}();
	function parsexmlbool(value, tag) {
		switch (value) {
		case "1":
		case "true":
		case "TRUE":
			return true;
		default:
			return false
		}
	}
	var utf8read = function utf8reada(orig) {
		var out = "",
		i = 0,
		c = 0,
		d = 0,
		e = 0,
		f = 0,
		w = 0;
		while (i < orig.length) {
			c = orig.charCodeAt(i++);
			if (c < 128) {
				out += String.fromCharCode(c);
				continue
			}
			d = orig.charCodeAt(i++);
			if (c > 191 && c < 224) {
				out += String.fromCharCode((c & 31) << 6 | d & 63);
				continue
			}
			e = orig.charCodeAt(i++);
			if (c < 240) {
				out += String.fromCharCode((c & 15) << 12 | (d & 63) << 6 | e & 63);
				continue
			}
			f = orig.charCodeAt(i++);
			w = ((c & 7) << 18 | (d & 63) << 12 | (e & 63) << 6 | f & 63) - 65536;
			out += String.fromCharCode(55296 + (w >>> 10 & 1023));
			out += String.fromCharCode(56320 + (w & 1023))
		}
		return out
	};
	if (has_buf) {
		var utf8readb = function utf8readb(data) {
			var out = new Buffer(2 * data.length),
			w,
			i,
			j = 1,
			k = 0,
			ww = 0,
			c;
			for (i = 0; i < data.length; i += j) {
				j = 1;
				if ((c = data.charCodeAt(i)) < 128)
					w = c;
				else if (c < 224) {
					w = (c & 31) * 64 + (data.charCodeAt(i + 1) & 63);
					j = 2
				} else if (c < 240) {
					w = (c & 15) * 4096 + (data.charCodeAt(i + 1) & 63) * 64 + (data.charCodeAt(i + 2) & 63);
					j = 3
				} else {
					j = 4;
					w = (c & 7) * 262144 + (data.charCodeAt(i + 1) & 63) * 4096 + (data.charCodeAt(i + 2) & 63) * 64 + (data.charCodeAt(i + 3) & 63);
					w -= 65536;
					ww = 55296 + (w >>> 10 & 1023);
					w = 56320 + (w & 1023)
				}
				if (ww !== 0) {
					out[k++] = ww & 255;
					out[k++] = ww >>> 8;
					ww = 0
				}
				out[k++] = w % 256;
				out[k++] = w >>> 8
			}
			out.length = k;
			return out.toString("ucs2")
		};
		var corpus = "foo bar bazÃ¢Â˜ÂƒÃ°ÂŸÂ�Â£";
		if (utf8read(corpus) == utf8readb(corpus))
			utf8read = utf8readb;
		var utf8readc = function utf8readc(data) {
			return Buffer(data, "binary").toString("utf8")
		};
		if (utf8read(corpus) == utf8readc(corpus))
			utf8read = utf8readc
	}
	var matchtag = function () {
		var mtcache = {};
		return function matchtag(f, g) {
			var t = f + "|" + g;
			if (mtcache[t] !== undefined)
				return mtcache[t];
			return mtcache[t] = new RegExp("<(?:\\w+:)?" + f + '(?: xml:space="preserve")?(?:[^>]*)>([^â˜ƒ]*)</(?:\\w+:)?' + f + ">", g || "")
		}
	}();
	var vtregex = function () {
		var vt_cache = {};
		return function vt_regex(bt) {
			if (vt_cache[bt] !== undefined)
				return vt_cache[bt];
			return vt_cache[bt] = new RegExp("<vt:" + bt + ">(.*?)</vt:" + bt + ">", "g")
		}
	}();
	var vtvregex = /<\/?vt:variant>/g,
	vtmregex = /<vt:([^>]*)>(.*)</;
	function parseVector(data) {
		var h = parsexmltag(data);
		var matches = data.match(vtregex(h.baseType)) || [];
		if (matches.length != h.size)
			throw "unexpected vector length " + matches.length + " != " + h.size;
		var res = [];
		matches.forEach(function (x) {
			var v = x.replace(vtvregex, "").match(vtmregex);
			res.push({
				v : v[2],
				t : v[1]
			})
		});
		return res
	}
	var wtregex = /(^\s|\s$|\n)/;
	function writetag(f, g) {
		return "<" + f + (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f + ">"
	}
	function wxt_helper(h) {
		return keys(h).map(function (k) {
			return " " + k + '="' + h[k] + '"'
		}).join("")
	}
	function writextag(f, g, h) {
		return "<" + f + (isval(h) ? wxt_helper(h) : "") + (isval(g) ? (g.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g + "</" + f : "/") + ">"
	}
	function write_w3cdtf(d, t) {
		try {
			return d.toISOString().replace(/\.\d*/, "")
		} catch (e) {
			if (t)
				throw e
		}
	}
	function write_vt(s) {
		switch (typeof s) {
		case "string":
			return writextag("vt:lpwstr", s);
		case "number":
			return writextag((s | 0) == s ? "vt:i4" : "vt:r8", String(s));
		case "boolean":
			return writextag("vt:bool", s ? "true" : "false")
		}
		if (s instanceof Date)
			return writextag("vt:filetime", write_w3cdtf(s));
		throw new Error("Unable to serialize " + s)
	}
	var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
	var XMLNS = {
		dc : "http://purl.org/dc/elements/1.1/",
		dcterms : "http://purl.org/dc/terms/",
		dcmitype : "http://purl.org/dc/dcmitype/",
		mx : "http://schemas.microsoft.com/office/mac/excel/2008/main",
		r : "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
		sjs : "http://schemas.openxmlformats.org/package/2006/sheetjs/core-properties",
		vt : "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
		xsi : "http://www.w3.org/2001/XMLSchema-instance",
		xsd : "http://www.w3.org/2001/XMLSchema"
	};
	XMLNS.main = ["http://schemas.openxmlformats.org/spreadsheetml/2006/main", "http://purl.oclc.org/ooxml/spreadsheetml/main", "http://schemas.microsoft.com/office/excel/2006/main", "http://schemas.microsoft.com/office/excel/2006/2"];
	function readIEEE754(buf, idx, isLE, nl, ml) {
		if (isLE === undefined)
			isLE = true;
		if (!nl)
			nl = 8;
		if (!ml && nl === 8)
			ml = 52;
		var e,
		m,
		el = nl * 8 - ml - 1,
		eMax = (1 << el) - 1,
		eBias = eMax >> 1;
		var bits = -7,
		d = isLE ? -1 : 1,
		i = isLE ? nl - 1 : 0,
		s = buf[idx + i];
		i += d;
		e = s & (1 << -bits) - 1;
		s >>>= -bits;
		bits += el;
		for (; bits > 0; e = e * 256 + buf[idx + i], i += d, bits -= 8);
		m = e & (1 << -bits) - 1;
		e >>>= -bits;
		bits += ml;
		for (; bits > 0; m = m * 256 + buf[idx + i], i += d, bits -= 8);
		if (e === eMax)
			return m ? NaN : (s ? -1 : 1) * Infinity;
		else if (e === 0)
			e = 1 - eBias;
		else {
			m = m + Math.pow(2, ml);
			e = e - eBias
		}
		return (s ? -1 : 1) * m * Math.pow(2, e - ml)
	}
	var __toBuffer,
	___toBuffer;
	__toBuffer = ___toBuffer = function toBuffer_(bufs) {
		var x = [];
		for (var i = 0; i < bufs[0].length; ++i) {
			x.push.apply(x, bufs[0][i])
		}
		return x
	};
	var __utf16le,
	___utf16le;
	__utf16le = ___utf16le = function utf16le_(b, s, e) {
		var ss = [];
		for (var i = s; i < e; i += 2)
			ss.push(String.fromCharCode(__readUInt16LE(b, i)));
		return ss.join("")
	};
	var __hexlify,
	___hexlify;
	__hexlify = ___hexlify = function hexlify_(b, s, l) {
		return b.slice(s, s + l).map(function (x) {
			return (x < 16 ? "0" : "") + x.toString(16)
		}).join("")
	};
	var __utf8,
	___utf8;
	__utf8 = ___utf8 = function (b, s, e) {
		var ss = [];
		for (var i = s; i < e; i++)
			ss.push(String.fromCharCode(__readUInt8(b, i)));
		return ss.join("")
	};
	var __lpstr,
	___lpstr;
	__lpstr = ___lpstr = function lpstr_(b, i) {
		var len = __readUInt32LE(b, i);
		return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : ""
	};
	var __lpwstr,
	___lpwstr;
	__lpwstr = ___lpwstr = function lpwstr_(b, i) {
		var len = 2 * __readUInt32LE(b, i);
		return len > 0 ? __utf8(b, i + 4, i + 4 + len - 1) : ""
	};
	var __double,
	___double;
	__double = ___double = function (b, idx) {
		return readIEEE754(b, idx)
	};
	var is_buf = function is_buf_a(a) {
		return Array.isArray(a)
	};
	if (has_buf) {
		__utf16le = function utf16le_b(b, s, e) {
			if (!Buffer.isBuffer(b))
				return ___utf16le(b, s, e);
			return b.toString("utf16le", s, e)
		};
		__hexlify = function (b, s, l) {
			return Buffer.isBuffer(b) ? b.toString("hex", s, s + l) : ___hexlify(b, s, l)
		};
		__lpstr = function lpstr_b(b, i) {
			if (!Buffer.isBuffer(b))
				return ___lpstr(b, i);
			var len = b.readUInt32LE(i);
			return len > 0 ? b.toString("utf8", i + 4, i + 4 + len - 1) : ""
		};
		__lpwstr = function lpwstr_b(b, i) {
			if (!Buffer.isBuffer(b))
				return ___lpwstr(b, i);
			var len = 2 * b.readUInt32LE(i);
			return b.toString("utf16le", i + 4, i + 4 + len - 1)
		};
		__utf8 = function utf8_b(s, e) {
			return this.toString("utf8", s, e)
		};
		__toBuffer = function (bufs) {
			return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0]) : ___toBuffer(bufs)
		};
		bconcat = function (bufs) {
			return Buffer.isBuffer(bufs[0]) ? Buffer.concat(bufs) : [].concat.apply([], bufs)
		};
		__double = function double_(b, i) {
			if (Buffer.isBuffer(b))
				return b.readDoubleLE(i);
			return ___double(b, i)
		};
		is_buf = function is_buf_b(a) {
			return Buffer.isBuffer(a) || Array.isArray(a)
		}
	}
	if (typeof cptable !== "undefined") {
		__utf16le = function (b, s, e) {
			return cptable.utils.decode(1200, b.slice(s, e))
		};
		__utf8 = function (b, s, e) {
			return cptable.utils.decode(65001, b.slice(s, e))
		};
		__lpstr = function (b, i) {
			var len = __readUInt32LE(b, i);
			return len > 0 ? cptable.utils.decode(current_codepage, b.slice(i + 4, i + 4 + len - 1)) : ""
		};
		__lpwstr = function (b, i) {
			var len = 2 * __readUInt32LE(b, i);
			return len > 0 ? cptable.utils.decode(1200, b.slice(i + 4, i + 4 + len - 1)) : ""
		}
	}
	var __readUInt8 = function (b, idx) {
		return b[idx]
	};
	var __readUInt16LE = function (b, idx) {
		return b[idx + 1] * (1 << 8) + b[idx]
	};
	var __readInt16LE = function (b, idx) {
		var u = b[idx + 1] * (1 << 8) + b[idx];
		return u < 32768 ? u : (65535 - u + 1) * -1
	};
	var __readUInt32LE = function (b, idx) {
		return b[idx + 3] * (1 << 24) + (b[idx + 2] << 16) + (b[idx + 1] << 8) + b[idx]
	};
	var __readInt32LE = function (b, idx) {
		return b[idx + 3] << 24 | b[idx + 2] << 16 | b[idx + 1] << 8 | b[idx]
	};
	var ___unhexlify = function (s) {
		return s.match(/../g).map(function (x) {
			return parseInt(x, 16)
		})
	};
	var __unhexlify = typeof Buffer !== "undefined" ? function (s) {
		return Buffer.isBuffer(s) ? new Buffer(s, "hex") : ___unhexlify(s)
	}
	 : ___unhexlify;
	function ReadShift(size, t) {
		var o = "",
		oI,
		oR,
		oo = [],
		w,
		vv,
		i,
		loc;
		switch (t) {
		case "dbcs":
			loc = this.l;
			if (has_buf && Buffer.isBuffer(this))
				o = this.slice(this.l, this.l + 2 * size).toString("utf16le");
			else
				for (i = 0; i != size; ++i) {
					o += String.fromCharCode(__readUInt16LE(this, loc));
					loc += 2
				}
			size *= 2;
			break;
		case "utf8":
			o = __utf8(this, this.l, this.l + size);
			break;
		case "utf16le":
			size *= 2;
			o = __utf16le(this, this.l, this.l + size);
			break;
		case "lpstr":
			o = __lpstr(this, this.l);
			size = 5 + o.length;
			break;
		case "lpwstr":
			o = __lpwstr(this, this.l);
			size = 5 + o.length;
			if (o[o.length - 1] == "\x00")
				size += 2;
			break;
		case "cstr":
			size = 0;
			o = "";
			while ((w = __readUInt8(this, this.l + size++)) !== 0)
				oo.push(_getchar(w));
			o = oo.join("");
			break;
		case "wstr":
			size = 0;
			o = "";
			while ((w = __readUInt16LE(this, this.l + size)) !== 0) {
				oo.push(_getchar(w));
				size += 2
			}
			size += 2;
			o = oo.join("");
			break;
		case "dbcs-cont":
			o = "";
			loc = this.l;
			for (i = 0; i != size; ++i) {
				if (this.lens && this.lens.indexOf(loc) !== -1) {
					w = __readUInt8(this, loc);
					this.l = loc + 1;
					vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
					return oo.join("") + vv
				}
				oo.push(_getchar(__readUInt16LE(this, loc)));
				loc += 2
			}
			o = oo.join("");
			size *= 2;
			break;
		case "sbcs-cont":
			o = "";
			loc = this.l;
			for (i = 0; i != size; ++i) {
				if (this.lens && this.lens.indexOf(loc) !== -1) {
					w = __readUInt8(this, loc);
					this.l = loc + 1;
					vv = ReadShift.call(this, size - i, w ? "dbcs-cont" : "sbcs-cont");
					return oo.join("") + vv
				}
				oo.push(_getchar(__readUInt8(this, loc)));
				loc += 1
			}
			o = oo.join("");
			break;
		default:
			switch (size) {
			case 1:
				oI = __readUInt8(this, this.l);
				this.l++;
				return oI;
			case 2:
				oI = (t === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
				this.l += 2;
				return oI;
			case 4:
				if (t === "i" || (this[this.l + 3] & 128) === 0) {
					oI = __readInt32LE(this, this.l);
					this.l += 4;
					return oI
				} else {
					oR = __readUInt32LE(this, this.l);
					this.l += 4;
					return oR
				}
				break;
			case 8:
				if (t === "f") {
					oR = __double(this, this.l);
					this.l += 8;
					return oR
				}
			case 16:
				o = __hexlify(this, this.l, size);
				break
			}
		}
		this.l += size;
		return o
	}
	function WriteShift(t, val, f) {
		var size,
		i;
		if (f === "dbcs") {
			for (i = 0; i != val.length; ++i)
				this.writeUInt16LE(val.charCodeAt(i), this.l + 2 * i);
			size = 2 * val.length
		} else
			switch (t) {
			case 1:
				size = 1;
				this[this.l] = val & 255;
				break;
			case 3:
				size = 3;
				this[this.l + 2] = val & 255;
				val >>>= 8;
				this[this.l + 1] = val & 255;
				val >>>= 8;
				this[this.l] = val & 255;
				break;
			case 4:
				size = 4;
				this.writeUInt32LE(val, this.l);
				break;
			case 8:
				size = 8;
				if (f === "f") {
					this.writeDoubleLE(val, this.l);
					break
				}
			case 16:
				break;
			case -4:
				size = 4;
				this.writeInt32LE(val, this.l);
				break
			}
		this.l += size;
		return this
	}
	function CheckField(hexstr, fld) {
		var m = __hexlify(this, this.l, hexstr.length >> 1);
		if (m !== hexstr)
			throw fld + "Expected " + hexstr + " saw " + m;
		this.l += hexstr.length >> 1
	}
	function prep_blob(blob, pos) {
		blob.l = pos;
		blob.read_shift = ReadShift;
		blob.chk = CheckField;
		blob.write_shift = WriteShift
	}
	function parsenoop(blob, length) {
		blob.l += length
	}
	function writenoop(blob, length) {
		blob.l += length
	}
	function new_buf(sz) {
		var o = new_raw_buf(sz);
		prep_blob(o, 0);
		return o
	}
	function recordhopper(data, cb, opts) {
		var tmpbyte,
		cntbyte,
		length;
		prep_blob(data, data.l || 0);
		while (data.l < data.length) {
			var RT = data.read_shift(1);
			if (RT & 128)
				RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
			var R = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
			tmpbyte = data.read_shift(1);
			length = tmpbyte & 127;
			for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte)
				length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
			var d = R.f(data, length, opts);
			if (cb(d, R, RT))
				return
		}
	}
	function buf_array() {
		var bufs = [],
		blksz = 2048;
		var newblk = function ba_newblk(sz) {
			var o = new_buf(sz);
			prep_blob(o, 0);
			return o
		};
		var curbuf = newblk(blksz);
		var endbuf = function ba_endbuf() {
			curbuf.length = curbuf.l;
			if (curbuf.length > 0)
				bufs.push(curbuf);
			curbuf = null
		};
		var next = function ba_next(sz) {
			if (sz < curbuf.length - curbuf.l)
				return curbuf;
			endbuf();
			return curbuf = newblk(Math.max(sz + 1, blksz))
		};
		var end = function ba_end() {
			endbuf();
			return __toBuffer([bufs])
		};
		var push = function ba_push(buf) {
			endbuf();
			curbuf = buf;
			next(blksz)
		};
		return {
			next : next,
			push : push,
			end : end,
			_bufs : bufs
		}
	}
	function write_record(ba, type, payload, length) {
		var t = evert_RE[type],
		l;
		if (!length)
			length = XLSBRecordEnum[t].p || (payload || []).length || 0;
		l = 1 + (t >= 128 ? 1 : 0) + 1 + length;
		if (length >= 128)
			++l;
		if (length >= 16384)
			++l;
		if (length >= 2097152)
			++l;
		var o = ba.next(l);
		if (t <= 127)
			o.write_shift(1, t);
		else {
			o.write_shift(1, (t & 127) + 128);
			o.write_shift(1, t >> 7)
		}
		for (var i = 0; i != 4; ++i) {
			if (length >= 128) {
				o.write_shift(1, (length & 127) + 128);
				length >>= 7
			} else {
				o.write_shift(1, length);
				break
			}
		}
		if (length > 0 && is_buf(payload))
			ba.push(payload)
	}
	function shift_cell_xls(cell, tgt) {
		if (tgt.s) {
			if (cell.cRel)
				cell.c += tgt.s.c;
			if (cell.rRel)
				cell.r += tgt.s.r
		} else {
			cell.c += tgt.c;
			cell.r += tgt.r
		}
		cell.cRel = cell.rRel = 0;
		while (cell.c >= 256)
			cell.c -= 256;
		while (cell.r >= 65536)
			cell.r -= 65536;
		return cell
	}
	function shift_range_xls(cell, range) {
		cell.s = shift_cell_xls(cell.s, range.s);
		cell.e = shift_cell_xls(cell.e, range.s);
		return cell
	}
	var OFFCRYPTO = {};
	var make_offcrypto = function (O, _crypto) {
		var crypto;
		if (typeof _crypto !== "undefined")
			crypto = _crypto;
		else if (typeof require !== "undefined") {
			try {
				crypto = require("cry" + "pto")
			} catch (e) {
				crypto = null
			}
		}
		O.rc4 = function (key, data) {
			var S = new Array(256);
			var c = 0,
			i = 0,
			j = 0,
			t = 0;
			for (i = 0; i != 256; ++i)
				S[i] = i;
			for (i = 0; i != 256; ++i) {
				j = j + S[i] + key[i % key.length].charCodeAt(0) & 255;
				t = S[i];
				S[i] = S[j];
				S[j] = t
			}
			i = j = 0;
			out = Buffer(data.length);
			for (c = 0; c != data.length; ++c) {
				i = i + 1 & 255;
				j = (j + S[i]) % 256;
				t = S[i];
				S[i] = S[j];
				S[j] = t;
				out[c] = data[c]^S[S[i] + S[j] & 255]
			}
			return out
		};
		if (crypto) {
			O.md5 = function (hex) {
				return crypto.createHash("md5").update(hex).digest("hex")
			}
		} else {
			O.md5 = function (hex) {
				throw "unimplemented"
			}
		}
	};
	make_offcrypto(OFFCRYPTO, typeof crypto !== "undefined" ? crypto : undefined);
	function parse_StrRun(data, length) {
		return {
			ich : data.read_shift(2),
			ifnt : data.read_shift(2)
		}
	}
	function parse_RichStr(data, length) {
		var start = data.l;
		var flags = data.read_shift(1);
		var str = parse_XLWideString(data);
		var rgsStrRun = [];
		var z = {
			t : str,
			h : str
		};
		if ((flags & 1) !== 0) {
			var dwSizeStrRun = data.read_shift(4);
			for (var i = 0; i != dwSizeStrRun; ++i)
				rgsStrRun.push(parse_StrRun(data));
			z.r = rgsStrRun
		} else
			z.r = "<t>" + escapexml(str) + "</t>";
		if ((flags & 2) !== 0) {}

		data.l = start + length;
		return z
	}
	function write_RichStr(str, o) {
		if (o == null)
			o = new_buf(5 + 2 * str.t.length);
		o.write_shift(1, 0);
		write_XLWideString(str.t, o);
		return o
	}
	function parse_XLSBCell(data) {
		var col = data.read_shift(4);
		var iStyleRef = data.read_shift(2);
		iStyleRef += data.read_shift(1) << 16;
		var fPhShow = data.read_shift(1);
		return {
			c : col,
			iStyleRef : iStyleRef
		}
	}
	function write_XLSBCell(cell, o) {
		if (o == null)
			o = new_buf(8);
		o.write_shift(-4, cell.c);
		o.write_shift(3, cell.iStyleRef === undefined ? cell.iStyleRef : cell.s);
		o.write_shift(1, 0);
		return o
	}
	function parse_XLSBCodeName(data, length) {
		return parse_XLWideString(data, length)
	}
	function parse_XLNullableWideString(data) {
		var cchCharacters = data.read_shift(4);
		return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs")
	}
	function write_XLNullableWideString(data, o) {
		if (!o)
			o = new_buf(127);
		o.write_shift(4, data.length > 0 ? data.length : 4294967295);
		if (data.length > 0)
			o.write_shift(0, data, "dbcs");
		return o
	}
	function parse_XLWideString(data) {
		var cchCharacters = data.read_shift(4);
		return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs")
	}
	function write_XLWideString(data, o) {
		if (o == null)
			o = new_buf(4 + 2 * data.length);
		o.write_shift(4, data.length);
		if (data.length > 0)
			o.write_shift(0, data, "dbcs");
		return o
	}
	var parse_RelID = parse_XLNullableWideString;
	var write_RelID = write_XLNullableWideString;
	function parse_RkNumber(data) {
		var b = data.slice(data.l, data.l + 4);
		var fX100 = b[0] & 1,
		fInt = b[0] & 2;
		data.l += 4;
		b[0] &= 252;
		var RK = fInt === 0 ? __double([0, 0, 0, 0, b[0], b[1], b[2], b[3]], 0) : __readInt32LE(b, 0) >> 2;
		return fX100 ? RK / 100 : RK
	}
	function parse_UncheckedRfX(data) {
		var cell = {
			s : {},
			e : {}

		};
		cell.s.r = data.read_shift(4);
		cell.e.r = data.read_shift(4);
		cell.s.c = data.read_shift(4);
		cell.e.c = data.read_shift(4);
		return cell
	}
	function write_UncheckedRfX(r, o) {
		if (!o)
			o = new_buf(16);
		o.write_shift(4, r.s.r);
		o.write_shift(4, r.e.r);
		o.write_shift(4, r.s.c);
		o.write_shift(4, r.e.c);
		return o
	}
	function parse_Xnum(data, length) {
		return data.read_shift(8, "f")
	}
	function write_Xnum(data, o) {
		return (o || new_buf(8)).write_shift(8, "f", data)
	}
	var BErr = {
		0 : "#NULL!",
		7 : "#DIV/0!",
		15 : "#VALUE!",
		23 : "#REF!",
		29 : "#NAME?",
		36 : "#NUM!",
		42 : "#N/A",
		43 : "#GETTING_DATA",
		255 : "#WTF?"
	};
	var RBErr = evert_num(BErr);
	function parse_BrtColor(data, length) {
		var out = {};
		var d = data.read_shift(1);
		out.fValidRGB = d & 1;
		out.xColorType = d >>> 1;
		out.index = data.read_shift(1);
		out.nTintAndShade = data.read_shift(2, "i");
		out.bRed = data.read_shift(1);
		out.bGreen = data.read_shift(1);
		out.bBlue = data.read_shift(1);
		out.bAlpha = data.read_shift(1)
	}
	function parse_FontFlags(data, length) {
		var d = data.read_shift(1);
		data.l++;
		var out = {
			fItalic : d & 2,
			fStrikeout : d & 8,
			fOutline : d & 16,
			fShadow : d & 32,
			fCondense : d & 64,
			fExtend : d & 128
		};
		return out
	} {
		var VT_EMPTY = 0;
		var VT_NULL = 1;
		var VT_I2 = 2;
		var VT_I4 = 3;
		var VT_R4 = 4;
		var VT_R8 = 5;
		var VT_CY = 6;
		var VT_DATE = 7;
		var VT_BSTR = 8;
		var VT_ERROR = 10;
		var VT_BOOL = 11;
		var VT_VARIANT = 12;
		var VT_DECIMAL = 14;
		var VT_I1 = 16;
		var VT_UI1 = 17;
		var VT_UI2 = 18;
		var VT_UI4 = 19;
		var VT_I8 = 20;
		var VT_UI8 = 21;
		var VT_INT = 22;
		var VT_UINT = 23;
		var VT_LPSTR = 30;
		var VT_LPWSTR = 31;
		var VT_FILETIME = 64;
		var VT_BLOB = 65;
		var VT_STREAM = 66;
		var VT_STORAGE = 67;
		var VT_STREAMED_Object = 68;
		var VT_STORED_Object = 69;
		var VT_BLOB_Object = 70;
		var VT_CF = 71;
		var VT_CLSID = 72;
		var VT_VERSIONED_STREAM = 73;
		var VT_VECTOR = 4096;
		var VT_ARRAY = 8192;
		var VT_STRING = 80;
		var VT_USTR = 81;
		var VT_CUSTOM = [VT_STRING, VT_USTR]
	}
	var DocSummaryPIDDSI = {
		1 : {
			n : "CodePage",
			t : VT_I2
		},
		2 : {
			n : "Category",
			t : VT_STRING
		},
		3 : {
			n : "PresentationFormat",
			t : VT_STRING
		},
		4 : {
			n : "ByteCount",
			t : VT_I4
		},
		5 : {
			n : "LineCount",
			t : VT_I4
		},
		6 : {
			n : "ParagraphCount",
			t : VT_I4
		},
		7 : {
			n : "SlideCount",
			t : VT_I4
		},
		8 : {
			n : "NoteCount",
			t : VT_I4
		},
		9 : {
			n : "HiddenCount",
			t : VT_I4
		},
		10 : {
			n : "MultimediaClipCount",
			t : VT_I4
		},
		11 : {
			n : "Scale",
			t : VT_BOOL
		},
		12 : {
			n : "HeadingPair",
			t : VT_VECTOR | VT_VARIANT
		},
		13 : {
			n : "DocParts",
			t : VT_VECTOR | VT_LPSTR
		},
		14 : {
			n : "Manager",
			t : VT_STRING
		},
		15 : {
			n : "Company",
			t : VT_STRING
		},
		16 : {
			n : "LinksDirty",
			t : VT_BOOL
		},
		17 : {
			n : "CharacterCount",
			t : VT_I4
		},
		19 : {
			n : "SharedDoc",
			t : VT_BOOL
		},
		22 : {
			n : "HLinksChanged",
			t : VT_BOOL
		},
		23 : {
			n : "AppVersion",
			t : VT_I4,
			p : "version"
		},
		26 : {
			n : "ContentType",
			t : VT_STRING
		},
		27 : {
			n : "ContentStatus",
			t : VT_STRING
		},
		28 : {
			n : "Language",
			t : VT_STRING
		},
		29 : {
			n : "Version",
			t : VT_STRING
		},
		255 : {}

	};
	var SummaryPIDSI = {
		1 : {
			n : "CodePage",
			t : VT_I2
		},
		2 : {
			n : "Title",
			t : VT_STRING
		},
		3 : {
			n : "Subject",
			t : VT_STRING
		},
		4 : {
			n : "Author",
			t : VT_STRING
		},
		5 : {
			n : "Keywords",
			t : VT_STRING
		},
		6 : {
			n : "Comments",
			t : VT_STRING
		},
		7 : {
			n : "Template",
			t : VT_STRING
		},
		8 : {
			n : "LastAuthor",
			t : VT_STRING
		},
		9 : {
			n : "RevNumber",
			t : VT_STRING
		},
		10 : {
			n : "EditTime",
			t : VT_FILETIME
		},
		11 : {
			n : "LastPrinted",
			t : VT_FILETIME
		},
		12 : {
			n : "CreatedDate",
			t : VT_FILETIME
		},
		13 : {
			n : "ModifiedDate",
			t : VT_FILETIME
		},
		14 : {
			n : "PageCount",
			t : VT_I4
		},
		15 : {
			n : "WordCount",
			t : VT_I4
		},
		16 : {
			n : "CharCount",
			t : VT_I4
		},
		17 : {
			n : "Thumbnail",
			t : VT_CF
		},
		18 : {
			n : "ApplicationName",
			t : VT_LPSTR
		},
		19 : {
			n : "DocumentSecurity",
			t : VT_I4
		},
		255 : {}

	};
	var SpecialProperties = {
		2147483648 : {
			n : "Locale",
			t : VT_UI4
		},
		2147483651 : {
			n : "Behavior",
			t : VT_UI4
		},
		1919054434 : {}

	};
	(function () {
		for (var y in SpecialProperties)
			if (SpecialProperties.hasOwnProperty(y))
				DocSummaryPIDDSI[y] = SummaryPIDSI[y] = SpecialProperties[y]
	})();
	var CountryEnum = {
		1 : "US",
		2 : "CA",
		3 : "",
		7 : "RU",
		20 : "EG",
		30 : "GR",
		31 : "NL",
		32 : "BE",
		33 : "FR",
		34 : "ES",
		36 : "HU",
		39 : "IT",
		41 : "CH",
		43 : "AT",
		44 : "GB",
		45 : "DK",
		46 : "SE",
		47 : "NO",
		48 : "PL",
		49 : "DE",
		52 : "MX",
		55 : "BR",
		61 : "AU",
		64 : "NZ",
		66 : "TH",
		81 : "JP",
		82 : "KR",
		84 : "VN",
		86 : "CN",
		90 : "TR",
		105 : "JS",
		213 : "DZ",
		216 : "MA",
		218 : "LY",
		351 : "PT",
		354 : "IS",
		358 : "FI",
		420 : "CZ",
		886 : "TW",
		961 : "LB",
		962 : "JO",
		963 : "SY",
		964 : "IQ",
		965 : "KW",
		966 : "SA",
		971 : "AE",
		972 : "IL",
		974 : "QA",
		981 : "IR",
		65535 : "US"
	};
	var XLSFillPattern = [null, "solid", "mediumGray", "darkGray", "lightGray", "darkHorizontal", "darkVertical", "darkDown", "darkUp", "darkGrid", "darkTrellis", "lightHorizontal", "lightVertical", "lightDown", "lightUp", "lightGrid", "lightTrellis", "gray125", "gray0625"];
	function rgbify(arr) {
		return arr.map(function (x) {
			return [x >> 16 & 255, x >> 8 & 255, x & 255]
		})
	}
	var XLSIcv = rgbify([0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 0, 16777215, 16711680, 65280, 255, 16776960, 16711935, 65535, 8388608, 32768, 128, 8421376, 8388736, 32896, 12632256, 8421504, 10066431, 10040166, 16777164, 13434879, 6684774, 16744576, 26316, 13421823, 128, 16711935, 16776960, 65535, 8388736, 8388608, 32896, 255, 52479, 13434879, 13434828, 16777113, 10079487, 16751052, 13408767, 16764057, 3368703, 3394764, 10079232, 16763904, 16750848, 16737792, 6710937, 9868950, 13158, 3381606, 13056, 3355392, 10040064, 10040166, 3355545, 3355443, 16777215, 0]);
	var ct2type = {
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" : "workbooks",
		"application/vnd.ms-excel.binIndexWs" : "TODO",
		"application/vnd.ms-excel.chartsheet" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml" : "TODO",
		"application/vnd.ms-excel.dialogsheet" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml" : "TODO",
		"application/vnd.ms-excel.macrosheet" : "TODO",
		"application/vnd.ms-excel.macrosheet+xml" : "TODO",
		"application/vnd.ms-excel.intlmacrosheet" : "TODO",
		"application/vnd.ms-excel.binIndexMs" : "TODO",
		"application/vnd.openxmlformats-package.core-properties+xml" : "coreprops",
		"application/vnd.openxmlformats-officedocument.custom-properties+xml" : "custprops",
		"application/vnd.openxmlformats-officedocument.extended-properties+xml" : "extprops",
		"application/vnd.openxmlformats-officedocument.customXmlProperties+xml" : "TODO",
		"application/vnd.ms-excel.comments" : "comments",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml" : "comments",
		"application/vnd.ms-excel.pivotTable" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml" : "TODO",
		"application/vnd.ms-excel.calcChain" : "calcchains",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml" : "calcchains",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings" : "TODO",
		"application/vnd.ms-office.activeX" : "TODO",
		"application/vnd.ms-office.activeX+xml" : "TODO",
		"application/vnd.ms-excel.attachedToolbars" : "TODO",
		"application/vnd.ms-excel.connections" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml" : "TODO",
		"application/vnd.ms-excel.externalLink" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml" : "TODO",
		"application/vnd.ms-excel.sheetMetadata" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml" : "TODO",
		"application/vnd.ms-excel.pivotCacheDefinition" : "TODO",
		"application/vnd.ms-excel.pivotCacheRecords" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml" : "TODO",
		"application/vnd.ms-excel.queryTable" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml" : "TODO",
		"application/vnd.ms-excel.userNames" : "TODO",
		"application/vnd.ms-excel.revisionHeaders" : "TODO",
		"application/vnd.ms-excel.revisionLog" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml" : "TODO",
		"application/vnd.ms-excel.tableSingleCells" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml" : "TODO",
		"application/vnd.ms-excel.slicer" : "TODO",
		"application/vnd.ms-excel.slicerCache" : "TODO",
		"application/vnd.ms-excel.slicer+xml" : "TODO",
		"application/vnd.ms-excel.slicerCache+xml" : "TODO",
		"application/vnd.ms-excel.wsSortMap" : "TODO",
		"application/vnd.ms-excel.table" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.theme+xml" : "themes",
		"application/vnd.ms-excel.Timeline+xml" : "TODO",
		"application/vnd.ms-excel.TimelineCache+xml" : "TODO",
		"application/vnd.ms-office.vbaProject" : "vba",
		"application/vnd.ms-office.vbaProjectSignature" : "vba",
		"application/vnd.ms-office.volatileDependencies" : "TODO",
		"application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml" : "TODO",
		"application/vnd.ms-excel.controlproperties+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.model+data" : "TODO",
		"application/vnd.ms-excel.Survey+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.drawing+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.drawingml.chart+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml" : "TODO",
		"application/vnd.openxmlformats-officedocument.vmlDrawing" : "TODO",
		"application/vnd.openxmlformats-package.relationships+xml" : "rels",
		"application/vnd.openxmlformats-officedocument.oleObject" : "TODO",
		sheet : "js"
	};
	var CT_LIST = function () {
		var o = {
			workbooks : {
				xlsx : "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
				xlsm : "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
				xlsb : "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
				xltx : "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
			},
			strs : {
				xlsx : "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
				xlsb : "application/vnd.ms-excel.sharedStrings"
			},
			sheets : {
				xlsx : "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
				xlsb : "application/vnd.ms-excel.worksheet"
			},
			styles : {
				xlsx : "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
				xlsb : "application/vnd.ms-excel.styles"
			}
		};
		keys(o).forEach(function (k) {
			if (!o[k].xlsm)
				o[k].xlsm = o[k].xlsx
		});
		keys(o).forEach(function (k) {
			keys(o[k]).forEach(function (v) {
				ct2type[o[k][v]] = k
			})
		});
		return o
	}();
	var type2ct = evert_arr(ct2type);
	XMLNS.CT = "http://schemas.openxmlformats.org/package/2006/content-types";
	function parse_ct(data, opts) {
		var ctext = {};
		if (!data || !data.match)
			return data;
		var ct = {
			workbooks : [],
			sheets : [],
			calcchains : [],
			themes : [],
			styles : [],
			coreprops : [],
			extprops : [],
			custprops : [],
			strs : [],
			comments : [],
			vba : [],
			TODO : [],
			rels : [],
			xmlns : ""
		};
		(data.match(tagregex) || []).forEach(function (x) {
			var y = parsexmltag(x);
			switch (y[0].replace(nsregex, "<")) {
			case "<?xml":
				break;
			case "<Types":
				ct.xmlns = y["xmlns" + (y[0].match(/<(\w+):/) || ["", ""])[1]];
				break;
			case "<Default":
				ctext[y.Extension] = y.ContentType;
				break;
			case "<Override":
				if (ct[ct2type[y.ContentType]] !== undefined)
					ct[ct2type[y.ContentType]].push(y.PartName);
				else if (opts.WTF)
					console.error(y);
				break
			}
		});
		if (ct.xmlns !== XMLNS.CT)
			throw new Error("Unknown Namespace: " + ct.xmlns);
		ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
		ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
		ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
		ct.defaults = ctext;
		delete ct.calcchains;
		return ct
	}
	var CTYPE_XML_ROOT = writextag("Types", null, {
			xmlns : XMLNS.CT,
			"xmlns:xsd" : XMLNS.xsd,
			"xmlns:xsi" : XMLNS.xsi
		});
	var CTYPE_DEFAULTS = [["xml", "application/xml"], ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"], ["rels", type2ct.rels[0]]].map(function (x) {
		return writextag("Default", null, {
			Extension : x[0],
			ContentType : x[1]
		})
	});
	function write_ct(ct, opts) {
		var o = [],
		v;
		o[o.length] = XML_HEADER;
		o[o.length] = CTYPE_XML_ROOT;
		o = o.concat(CTYPE_DEFAULTS);
		var f1 = function (w) {
			if (ct[w] && ct[w].length > 0) {
				v = ct[w][0];
				o[o.length] = writextag("Override", null, {
						PartName : (v[0] == "/" ? "" : "/") + v,
						ContentType : CT_LIST[w][opts.bookType || "xlsx"]
					})
			}
		};
		var f2 = function (w) {
			ct[w].forEach(function (v) {
				o[o.length] = writextag("Override", null, {
						PartName : (v[0] == "/" ? "" : "/") + v,
						ContentType : CT_LIST[w][opts.bookType || "xlsx"]
					})
			})
		};
		var f3 = function (t) {
			(ct[t] || []).forEach(function (v) {
				o[o.length] = writextag("Override", null, {
						PartName : (v[0] == "/" ? "" : "/") + v,
						ContentType : type2ct[t][0]
					})
			})
		};
		f1("workbooks");
		f2("sheets");
		f3("themes");
		["strs", "styles"].forEach(f1);
		["coreprops", "extprops", "custprops"].forEach(f3);
		if (o.length > 2) {
			o[o.length] = "</Types>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	var RELS = {
		WB : "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
		SHEET : "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument"
	};
	function parse_rels(data, currentFilePath) {
		if (!data)
			return data;
		if (currentFilePath.charAt(0) !== "/") {
			currentFilePath = "/" + currentFilePath
		}
		var rels = {};
		var hash = {};
		var resolveRelativePathIntoAbsolute = function (to) {
			var toksFrom = currentFilePath.split("/");
			toksFrom.pop();
			var toksTo = to.split("/");
			var reversed = [];
			while (toksTo.length !== 0) {
				var tokTo = toksTo.shift();
				if (tokTo === "..") {
					toksFrom.pop()
				} else if (tokTo !== ".") {
					toksFrom.push(tokTo)
				}
			}
			return toksFrom.join("/")
		};
		data.match(tagregex).forEach(function (x) {
			var y = parsexmltag(x);
			if (y[0] === "<Relationship") {
				var rel = {};
				rel.Type = y.Type;
				rel.Target = y.Target;
				rel.Id = y.Id;
				rel.TargetMode = y.TargetMode;
				var canonictarget = y.TargetMode === "External" ? y.Target : resolveRelativePathIntoAbsolute(y.Target);
				rels[canonictarget] = rel;
				hash[y.Id] = rel
			}
		});
		rels["!id"] = hash;
		return rels
	}
	XMLNS.RELS = "http://schemas.openxmlformats.org/package/2006/relationships";
	var RELS_ROOT = writextag("Relationships", null, {
			xmlns : XMLNS.RELS
		});
	function write_rels(rels) {
		var o = [];
		o[o.length] = XML_HEADER;
		o[o.length] = RELS_ROOT;
		keys(rels["!id"]).forEach(function (rid) {
			var rel = rels["!id"][rid];
			o[o.length] = writextag("Relationship", null, rel)
		});
		if (o.length > 2) {
			o[o.length] = "</Relationships>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	var CORE_PROPS = [["cp:category", "Category"], ["cp:contentStatus", "ContentStatus"], ["cp:keywords", "Keywords"], ["cp:lastModifiedBy", "LastAuthor"], ["cp:lastPrinted", "LastPrinted"], ["cp:revision", "RevNumber"], ["cp:version", "Version"], ["dc:creator", "Author"], ["dc:description", "Comments"], ["dc:identifier", "Identifier"], ["dc:language", "Language"], ["dc:subject", "Subject"], ["dc:title", "Title"], ["dcterms:created", "CreatedDate", "date"], ["dcterms:modified", "ModifiedDate", "date"]];
	XMLNS.CORE_PROPS = "http://schemas.openxmlformats.org/package/2006/metadata/core-properties";
	RELS.CORE_PROPS = "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties";
	var CORE_PROPS_REGEX = function () {
		var r = new Array(CORE_PROPS.length);
		for (var i = 0; i < CORE_PROPS.length; ++i) {
			var f = CORE_PROPS[i];
			var g = "(?:" + f[0].substr(0, f[0].indexOf(":")) + ":)" + f[0].substr(f[0].indexOf(":") + 1);
			r[i] = new RegExp("<" + g + "[^>]*>(.*)</" + g + ">")
		}
		return r
	}();
	function parse_core_props(data) {
		var p = {};
		for (var i = 0; i < CORE_PROPS.length; ++i) {
			var f = CORE_PROPS[i],
			cur = data.match(CORE_PROPS_REGEX[i]);
			if (cur != null && cur.length > 0)
				p[f[1]] = cur[1];
			if (f[2] === "date" && p[f[1]])
				p[f[1]] = new Date(p[f[1]])
		}
		return p
	}
	var CORE_PROPS_XML_ROOT = writextag("cp:coreProperties", null, {
			"xmlns:cp" : XMLNS.CORE_PROPS,
			"xmlns:dc" : XMLNS.dc,
			"xmlns:dcterms" : XMLNS.dcterms,
			"xmlns:dcmitype" : XMLNS.dcmitype,
			"xmlns:xsi" : XMLNS.xsi
		});
	function cp_doit(f, g, h, o, p) {
		if (p[f] != null || g == null || g === "")
			return;
		p[f] = g;
		o[o.length] = h ? writextag(f, g, h) : writetag(f, g)
	}
	function write_core_props(cp, opts) {
		var o = [XML_HEADER, CORE_PROPS_XML_ROOT],
		p = {};
		if (!cp)
			return o.join("");
		if (cp.CreatedDate != null)
			cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), {
				"xsi:type" : "dcterms:W3CDTF"
			}, o, p);
		if (cp.ModifiedDate != null)
			cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), {
				"xsi:type" : "dcterms:W3CDTF"
			}, o, p);
		for (var i = 0; i != CORE_PROPS.length; ++i) {
			var f = CORE_PROPS[i];
			cp_doit(f[0], cp[f[1]], null, o, p)
		}
		if (o.length > 2) {
			o[o.length] = "</cp:coreProperties>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	var EXT_PROPS = [["Application", "Application", "string"], ["AppVersion", "AppVersion", "string"], ["Company", "Company", "string"], ["DocSecurity", "DocSecurity", "string"], ["Manager", "Manager", "string"], ["HyperlinksChanged", "HyperlinksChanged", "bool"], ["SharedDoc", "SharedDoc", "bool"], ["LinksUpToDate", "LinksUpToDate", "bool"], ["ScaleCrop", "ScaleCrop", "bool"], ["HeadingPairs", "HeadingPairs", "raw"], ["TitlesOfParts", "TitlesOfParts", "raw"]];
	XMLNS.EXT_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties";
	RELS.EXT_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties";
	function parse_ext_props(data, p) {
		var q = {};
		if (!p)
			p = {};
		EXT_PROPS.forEach(function (f) {
			switch (f[2]) {
			case "string":
				p[f[1]] = (data.match(matchtag(f[0])) || [])[1];
				break;
			case "bool":
				p[f[1]] = (data.match(matchtag(f[0])) || [])[1] === "true";
				break;
			case "raw":
				var cur = data.match(new RegExp("<" + f[0] + "[^>]*>(.*)</" + f[0] + ">"));
				if (cur && cur.length > 0)
					q[f[1]] = cur[1];
				break
			}
		});
		if (q.HeadingPairs && q.TitlesOfParts) {
			var v = parseVector(q.HeadingPairs);
			var j = 0,
			widx = 0;
			for (var i = 0; i !== v.length; ++i) {
				switch (v[i].v) {
				case "Worksheets":
					widx = j;
					p.Worksheets = +v[++i].v;
					break;
				case "Named Ranges":
					++i;
					break
				}
			}
			var parts = parseVector(q.TitlesOfParts).map(function (x) {
					return utf8read(x.v)
				});
			p.SheetNames = parts.slice(widx, widx + p.Worksheets)
		}
		return p
	}
	var EXT_PROPS_XML_ROOT = writextag("Properties", null, {
			xmlns : XMLNS.EXT_PROPS,
			"xmlns:vt" : XMLNS.vt
		});
	function write_ext_props(cp, opts) {
		var o = [],
		p = {},
		W = writextag;
		if (!cp)
			cp = {};
		cp.Application = "SheetJS";
		o[o.length] = XML_HEADER;
		o[o.length] = EXT_PROPS_XML_ROOT;
		EXT_PROPS.forEach(function (f) {
			if (cp[f[1]] === undefined)
				return;
			var v;
			switch (f[2]) {
			case "string":
				v = cp[f[1]];
				break;
			case "bool":
				v = cp[f[1]] ? "true" : "false";
				break
			}
			if (v !== undefined)
				o[o.length] = W(f[0], v)
		});
		o[o.length] = W("HeadingPairs", W("vt:vector", W("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W("vt:variant", W("vt:i4", String(cp.Worksheets))), {
					size : 2,
					baseType : "variant"
				}));
		o[o.length] = W("TitlesOfParts", W("vt:vector", cp.SheetNames.map(function (s) {
						return "<vt:lpstr>" + s + "</vt:lpstr>"
					}).join(""), {
					size : cp.Worksheets,
					baseType : "lpstr"
				}));
		if (o.length > 2) {
			o[o.length] = "</Properties>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	XMLNS.CUST_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties";
	RELS.CUST_PROPS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties";
	var custregex = /<[^>]+>[^<]*/g;
	function parse_cust_props(data, opts) {
		var p = {},
		name;
		var m = data.match(custregex);
		if (m)
			for (var i = 0; i != m.length; ++i) {
				var x = m[i],
				y = parsexmltag(x);
				switch (y[0]) {
				case "<?xml":
					break;
				case "<Properties":
					if (y.xmlns !== XMLNS.CUST_PROPS)
						throw "unrecognized xmlns " + y.xmlns;
					if (y.xmlnsvt && y.xmlnsvt !== XMLNS.vt)
						throw "unrecognized vt " + y.xmlnsvt;
					break;
				case "<property":
					name = y.name;
					break;
				case "</property>":
					name = null;
					break;
				default:
					if (x.indexOf("<vt:") === 0) {
						var toks = x.split(">");
						var type = toks[0].substring(4),
						text = toks[1];
						switch (type) {
						case "lpstr":
						case "lpwstr":
						case "bstr":
						case "lpwstr":
							p[name] = unescapexml(text);
							break;
						case "bool":
							p[name] = parsexmlbool(text, "<vt:bool>");
							break;
						case "i1":
						case "i2":
						case "i4":
						case "i8":
						case "int":
						case "uint":
							p[name] = parseInt(text, 10);
							break;
						case "r4":
						case "r8":
						case "decimal":
							p[name] = parseFloat(text);
							break;
						case "filetime":
						case "date":
							p[name] = new Date(text);
							break;
						case "cy":
						case "error":
							p[name] = unescapexml(text);
							break;
						default:
							if (typeof console !== "undefined")
								console.warn("Unexpected", x, type, toks)
						}
					} else if (x.substr(0, 2) === "</") {}
					else if (opts.WTF)
						throw new Error(x)
				}
			}
		return p
	}
	var CUST_PROPS_XML_ROOT = writextag("Properties", null, {
			xmlns : XMLNS.CUST_PROPS,
			"xmlns:vt" : XMLNS.vt
		});
	function write_cust_props(cp, opts) {
		var o = [XML_HEADER, CUST_PROPS_XML_ROOT];
		if (!cp)
			return o.join("");
		var pid = 1;
		keys(cp).forEach(function custprop(k) {
			++pid;
			o[o.length] = writextag("property", write_vt(cp[k]), {
					fmtid : "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
					pid : pid,
					name : k
				})
		});
		if (o.length > 2) {
			o[o.length] = "</Properties>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	function xlml_set_prop(Props, tag, val) {
		switch (tag) {
		case "Description":
			tag = "Comments";
			break
		}
		Props[tag] = val
	}
	function parse_FILETIME(blob) {
		var dwLowDateTime = blob.read_shift(4),
		dwHighDateTime = blob.read_shift(4);
		return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "")
	}
	function parse_lpstr(blob, type, pad) {
		var str = blob.read_shift(0, "lpstr");
		if (pad)
			blob.l += 4 - (str.length + 1 & 3) & 3;
		return str
	}
	function parse_lpwstr(blob, type, pad) {
		var str = blob.read_shift(0, "lpwstr");
		if (pad)
			blob.l += 4 - (str.length + 1 & 3) & 3;
		return str
	}
	function parse_VtStringBase(blob, stringType, pad) {
		if (stringType === 31)
			return parse_lpwstr(blob);
		return parse_lpstr(blob, stringType, pad)
	}
	function parse_VtString(blob, t, pad) {
		return parse_VtStringBase(blob, t, pad === false ? 0 : 4)
	}
	function parse_VtUnalignedString(blob, t) {
		if (!t)
			throw new Error("dafuq?");
		return parse_VtStringBase(blob, t, 0)
	}
	function parse_VtVecUnalignedLpstrValue(blob) {
		var length = blob.read_shift(4);
		var ret = [];
		for (var i = 0; i != length; ++i)
			ret[i] = blob.read_shift(0, "lpstr");
		return ret
	}
	function parse_VtVecUnalignedLpstr(blob) {
		return parse_VtVecUnalignedLpstrValue(blob)
	}
	function parse_VtHeadingPair(blob) {
		var headingString = parse_TypedPropertyValue(blob, VT_USTR);
		var headerParts = parse_TypedPropertyValue(blob, VT_I4);
		return [headingString, headerParts]
	}
	function parse_VtVecHeadingPairValue(blob) {
		var cElements = blob.read_shift(4);
		var out = [];
		for (var i = 0; i != cElements / 2; ++i)
			out.push(parse_VtHeadingPair(blob));
		return out
	}
	function parse_VtVecHeadingPair(blob) {
		return parse_VtVecHeadingPairValue(blob)
	}
	function parse_dictionary(blob, CodePage) {
		var cnt = blob.read_shift(4);
		var dict = {};
		for (var j = 0; j != cnt; ++j) {
			var pid = blob.read_shift(4);
			var len = blob.read_shift(4);
			dict[pid] = blob.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!")
		}
		if (blob.l & 3)
			blob.l = blob.l >> 2 + 1 << 2;
		return dict
	}
	function parse_BLOB(blob) {
		var size = blob.read_shift(4);
		var bytes = blob.slice(blob.l, blob.l + size);
		if (size & 3 > 0)
			blob.l += 4 - (size & 3) & 3;
		return bytes
	}
	function parse_ClipboardData(blob) {
		var o = {};
		o.Size = blob.read_shift(4);
		blob.l += o.Size;
		return o
	}
	function parse_VtVector(blob, cb) {}

	function parse_TypedPropertyValue(blob, type, _opts) {
		var t = blob.read_shift(2),
		ret,
		opts = _opts || {};
		blob.l += 2;
		if (type !== VT_VARIANT)
			if (t !== type && VT_CUSTOM.indexOf(type) === -1)
				throw new Error("Expected type " + type + " saw " + t);
		switch (type === VT_VARIANT ? t : type) {
		case 2:
			ret = blob.read_shift(2, "i");
			if (!opts.raw)
				blob.l += 2;
			return ret;
		case 3:
			ret = blob.read_shift(4, "i");
			return ret;
		case 11:
			return blob.read_shift(4) !== 0;
		case 19:
			ret = blob.read_shift(4);
			return ret;
		case 30:
			return parse_lpstr(blob, t, 4).replace(chr0, "");
		case 31:
			return parse_lpwstr(blob);
		case 64:
			return parse_FILETIME(blob);
		case 65:
			return parse_BLOB(blob);
		case 71:
			return parse_ClipboardData(blob);
		case 80:
			return parse_VtString(blob, t, !opts.raw && 4).replace(chr0, "");
		case 81:
			return parse_VtUnalignedString(blob, t, 4).replace(chr0, "");
		case 4108:
			return parse_VtVecHeadingPair(blob);
		case 4126:
			return parse_VtVecUnalignedLpstr(blob);
		default:
			throw new Error("TypedPropertyValue unrecognized type " + type + " " + t)
		}
	}
	function parse_PropertySet(blob, PIDSI) {
		var start_addr = blob.l;
		var size = blob.read_shift(4);
		var NumProps = blob.read_shift(4);
		var Props = [],
		i = 0;
		var CodePage = 0;
		var Dictionary = -1,
		DictObj;
		for (i = 0; i != NumProps; ++i) {
			var PropID = blob.read_shift(4);
			var Offset = blob.read_shift(4);
			Props[i] = [PropID, Offset + start_addr]
		}
		var PropH = {};
		for (i = 0; i != NumProps; ++i) {
			if (blob.l !== Props[i][1]) {
				var fail = true;
				if (i > 0 && PIDSI)
					switch (PIDSI[Props[i - 1][0]].t) {
					case 2:
						if (blob.l + 2 === Props[i][1]) {
							blob.l += 2;
							fail = false
						}
						break;
					case 80:
						if (blob.l <= Props[i][1]) {
							blob.l = Props[i][1];
							fail = false
						}
						break;
					case 4108:
						if (blob.l <= Props[i][1]) {
							blob.l = Props[i][1];
							fail = false
						}
						break
					}
				if (!PIDSI && blob.l <= Props[i][1]) {
					fail = false;
					blob.l = Props[i][1]
				}
				if (fail)
					throw new Error("Read Error: Expected address " + Props[i][1] + " at " + blob.l + " :" + i)
			}
			if (PIDSI) {
				var piddsi = PIDSI[Props[i][0]];
				PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, {
						raw : true
					});
				if (piddsi.p === "version")
					PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + String(PropH[piddsi.n] & 65535);
				if (piddsi.n == "CodePage")
					switch (PropH[piddsi.n]) {
					case 0:
						PropH[piddsi.n] = 1252;
					case 1e4:
					case 1252:
					case 874:
					case 1250:
					case 1251:
					case 1253:
					case 1254:
					case 1255:
					case 1256:
					case 1257:
					case 1258:
					case 932:
					case 936:
					case 949:
					case 950:
					case 1200:
					case 1201:
					case 65e3:
					case -536:
					case 65001:
					case -535:
						set_cp(CodePage = PropH[piddsi.n]);
						break;
					default:
						throw new Error("Unsupported CodePage: " + PropH[piddsi.n])
					}
			} else {
				if (Props[i][0] === 1) {
					CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
					set_cp(CodePage);
					if (Dictionary !== -1) {
						var oldpos = blob.l;
						blob.l = Props[Dictionary][1];
						DictObj = parse_dictionary(blob, CodePage);
						blob.l = oldpos
					}
				} else if (Props[i][0] === 0) {
					if (CodePage === 0) {
						Dictionary = i;
						blob.l = Props[i + 1][1];
						continue
					}
					DictObj = parse_dictionary(blob, CodePage)
				} else {
					var name = DictObj[Props[i][0]];
					var val;
					switch (blob[blob.l]) {
					case 65:
						blob.l += 4;
						val = parse_BLOB(blob);
						break;
					case 30:
						blob.l += 4;
						val = parse_VtString(blob, blob[blob.l - 4]);
						break;
					case 31:
						blob.l += 4;
						val = parse_VtString(blob, blob[blob.l - 4]);
						break;
					case 3:
						blob.l += 4;
						val = blob.read_shift(4, "i");
						break;
					case 19:
						blob.l += 4;
						val = blob.read_shift(4);
						break;
					case 5:
						blob.l += 4;
						val = blob.read_shift(8, "f");
						break;
					case 11:
						blob.l += 4;
						val = parsebool(blob, 4);
						break;
					case 64:
						blob.l += 4;
						val = new Date(parse_FILETIME(blob));
						break;
					default:
						throw new Error("unparsed value: " + blob[blob.l])
					}
					PropH[name] = val
				}
			}
		}
		blob.l = start_addr + size;
		return PropH
	}
	function parse_PropertySetStream(file, PIDSI) {
		var blob = file.content;
		prep_blob(blob, 0);
		var NumSets,
		FMTID0,
		FMTID1,
		Offset0,
		Offset1;
		blob.chk("feff", "Byte Order: ");
		var vers = blob.read_shift(2);
		var SystemIdentifier = blob.read_shift(4);
		blob.chk(CFB.utils.consts.HEADER_CLSID, "CLSID: ");
		NumSets = blob.read_shift(4);
		if (NumSets !== 1 && NumSets !== 2)
			throw "Unrecognized #Sets: " + NumSets;
		FMTID0 = blob.read_shift(16);
		Offset0 = blob.read_shift(4);
		if (NumSets === 1 && Offset0 !== blob.l)
			throw "Length mismatch";
		else if (NumSets === 2) {
			FMTID1 = blob.read_shift(16);
			Offset1 = blob.read_shift(4)
		}
		var PSet0 = parse_PropertySet(blob, PIDSI);
		var rval = {
			SystemIdentifier : SystemIdentifier
		};
		for (var y in PSet0)
			rval[y] = PSet0[y];
		rval.FMTID = FMTID0;
		if (NumSets === 1)
			return rval;
		if (blob.l !== Offset1)
			throw "Length mismatch 2: " + blob.l + " !== " + Offset1;
		var PSet1;
		try {
			PSet1 = parse_PropertySet(blob, null)
		} catch (e) {}

		for (y in PSet1)
			rval[y] = PSet1[y];
		rval.FMTID = [FMTID0, FMTID1];
		return rval
	}
	function parsenoop2(blob, length) {
		blob.read_shift(length);
		return null
	}
	function parslurp(blob, length, cb) {
		var arr = [],
		target = blob.l + length;
		while (blob.l < target)
			arr.push(cb(blob, target - blob.l));
		if (target !== blob.l)
			throw new Error("Slurp error");
		return arr
	}
	function parslurp2(blob, length, cb) {
		var arr = [],
		target = blob.l + length,
		len = blob.read_shift(2);
		while (len-- !== 0)
			arr.push(cb(blob, target - blob.l));
		if (target !== blob.l)
			throw new Error("Slurp error");
		return arr
	}
	function parsebool(blob, length) {
		return blob.read_shift(length) === 1
	}
	function parseuint16(blob) {
		return blob.read_shift(2, "u")
	}
	function parseuint16a(blob, length) {
		return parslurp(blob, length, parseuint16)
	}
	var parse_Boolean = parsebool;
	function parse_Bes(blob) {
		var v = blob.read_shift(1),
		t = blob.read_shift(1);
		return t === 1 ? v : v === 1
	}
	function parse_ShortXLUnicodeString(blob, length, opts) {
		var cch = blob.read_shift(1);
		var width = 1,
		encoding = "sbcs-cont";
		var cp = current_codepage;
		if (opts && opts.biff >= 8)
			current_codepage = 1200;
		if (opts === undefined || opts.biff !== 5) {
			var fHighByte = blob.read_shift(1);
			if (fHighByte) {
				width = 2;
				encoding = "dbcs-cont"
			}
		}
		var o = cch ? blob.read_shift(cch, encoding) : "";
		current_codepage = cp;
		return o
	}
	function parse_XLUnicodeRichExtendedString(blob) {
		var cp = current_codepage;
		current_codepage = 1200;
		var cch = blob.read_shift(2),
		flags = blob.read_shift(1);
		var fHighByte = flags & 1,
		fExtSt = flags & 4,
		fRichSt = flags & 8;
		var width = 1 + (flags & 1);
		var cRun,
		cbExtRst;
		var z = {};
		if (fRichSt)
			cRun = blob.read_shift(2);
		if (fExtSt)
			cbExtRst = blob.read_shift(4);
		var encoding = flags & 1 ? "dbcs-cont" : "sbcs-cont";
		var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);
		if (fRichSt)
			blob.l += 4 * cRun;
		if (fExtSt)
			blob.l += cbExtRst;
		z.t = msg;
		if (!fRichSt) {
			z.raw = "<t>" + z.t + "</t>";
			z.r = z.t
		}
		current_codepage = cp;
		return z
	}
	function parse_XLUnicodeStringNoCch(blob, cch, opts) {
		var retval;
		var fHighByte = blob.read_shift(1);
		if (fHighByte === 0) {
			retval = blob.read_shift(cch, "sbcs-cont")
		} else {
			retval = blob.read_shift(cch, "dbcs-cont")
		}
		return retval
	}
	function parse_XLUnicodeString(blob, length, opts) {
		var cch = blob.read_shift(opts !== undefined && opts.biff > 0 && opts.biff < 8 ? 1 : 2);
		if (cch === 0) {
			blob.l++;
			return ""
		}
		return parse_XLUnicodeStringNoCch(blob, cch, opts)
	}
	function parse_XLUnicodeString2(blob, length, opts) {
		if (opts.biff !== 5 && opts.biff !== 2)
			return parse_XLUnicodeString(blob, length, opts);
		var cch = blob.read_shift(1);
		if (cch === 0) {
			blob.l++;
			return ""
		}
		return blob.read_shift(cch, "sbcs-cont")
	}
	var parse_ControlInfo = parsenoop;
	var parse_URLMoniker = function (blob, length) {
		var len = blob.read_shift(4),
		start = blob.l;
		var extra = false;
		if (len > 24) {
			blob.l += len - 24;
			if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763")
				extra = true;
			blob.l = start
		}
		var url = blob.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
		if (extra)
			blob.l += 24;
		return url
	};
	var parse_FileMoniker = function (blob, length) {
		var cAnti = blob.read_shift(2);
		var ansiLength = blob.read_shift(4);
		var ansiPath = blob.read_shift(ansiLength, "cstr");
		var endServer = blob.read_shift(2);
		var versionNumber = blob.read_shift(2);
		var cbUnicodePathSize = blob.read_shift(4);
		if (cbUnicodePathSize === 0)
			return ansiPath.replace(/\\/g, "/");
		var cbUnicodePathBytes = blob.read_shift(4);
		var usKeyValue = blob.read_shift(2);
		var unicodePath = blob.read_shift(cbUnicodePathBytes >> 1, "utf16le").replace(chr0, "");
		return unicodePath
	};
	var parse_HyperlinkMoniker = function (blob, length) {
		var clsid = blob.read_shift(16);
		length -= 16;
		switch (clsid) {
		case "e0c9ea79f9bace118c8200aa004ba90b":
			return parse_URLMoniker(blob, length);
		case "0303000000000000c000000000000046":
			return parse_FileMoniker(blob, length);
		default:
			throw "unsupported moniker " + clsid
		}
	};
	var parse_HyperlinkString = function (blob, length) {
		var len = blob.read_shift(4);
		var o = blob.read_shift(len, "utf16le").replace(chr0, "");
		return o
	};
	var parse_Hyperlink = function (blob, length) {
		var end = blob.l + length;
		var sVer = blob.read_shift(4);
		if (sVer !== 2)
			throw new Error("Unrecognized streamVersion: " + sVer);
		var flags = blob.read_shift(2);
		blob.l += 2;
		var displayName,
		targetFrameName,
		moniker,
		oleMoniker,
		location,
		guid,
		fileTime;
		if (flags & 16)
			displayName = parse_HyperlinkString(blob, end - blob.l);
		if (flags & 128)
			targetFrameName = parse_HyperlinkString(blob, end - blob.l);
		if ((flags & 257) === 257)
			moniker = parse_HyperlinkString(blob, end - blob.l);
		if ((flags & 257) === 1)
			oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
		if (flags & 8)
			location = parse_HyperlinkString(blob, end - blob.l);
		if (flags & 32)
			guid = blob.read_shift(16);
		if (flags & 64)
			fileTime = parse_FILETIME(blob, 8);
		blob.l = end;
		var target = targetFrameName || moniker || oleMoniker;
		if (location)
			target += "#" + location;
		return {
			Target : target
		}
	};
	function parse_LongRGBA(blob, length) {
		var r = blob.read_shift(1),
		g = blob.read_shift(1),
		b = blob.read_shift(1),
		a = blob.read_shift(1);
		return [r, g, b, a]
	}
	function parse_LongRGB(blob, length) {
		var x = parse_LongRGBA(blob, length);
		x[3] = 0;
		return x
	}
	function parse_XLSCell(blob, length) {
		var rw = blob.read_shift(2);
		var col = blob.read_shift(2);
		var ixfe = blob.read_shift(2);
		return {
			r : rw,
			c : col,
			ixfe : ixfe
		}
	}
	function parse_frtHeader(blob) {
		var rt = blob.read_shift(2);
		var flags = blob.read_shift(2);
		blob.l += 8;
		return {
			type : rt,
			flags : flags
		}
	}
	function parse_OptXLUnicodeString(blob, length, opts) {
		return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts)
	}
	var HIDEOBJENUM = ["SHOWALL", "SHOWPLACEHOLDER", "HIDEALL"];
	var parse_HideObjEnum = parseuint16;
	function parse_XTI(blob, length) {
		var iSupBook = blob.read_shift(2),
		itabFirst = blob.read_shift(2, "i"),
		itabLast = blob.read_shift(2, "i");
		return [iSupBook, itabFirst, itabLast]
	}
	function parse_RkRec(blob, length) {
		var ixfe = blob.read_shift(2);
		var RK = parse_RkNumber(blob);
		return [ixfe, RK]
	}
	function parse_AddinUdf(blob, length) {
		blob.l += 4;
		length -= 4;
		var l = blob.l + length;
		var udfName = parse_ShortXLUnicodeString(blob, length);
		var cb = blob.read_shift(2);
		l -= blob.l;
		if (cb !== l)
			throw "Malformed AddinUdf: padding = " + l + " != " + cb;
		blob.l += cb;
		return udfName
	}
	function parse_Ref8U(blob, length) {
		var rwFirst = blob.read_shift(2);
		var rwLast = blob.read_shift(2);
		var colFirst = blob.read_shift(2);
		var colLast = blob.read_shift(2);
		return {
			s : {
				c : colFirst,
				r : rwFirst
			},
			e : {
				c : colLast,
				r : rwLast
			}
		}
	}
	function parse_RefU(blob, length) {
		var rwFirst = blob.read_shift(2);
		var rwLast = blob.read_shift(2);
		var colFirst = blob.read_shift(1);
		var colLast = blob.read_shift(1);
		return {
			s : {
				c : colFirst,
				r : rwFirst
			},
			e : {
				c : colLast,
				r : rwLast
			}
		}
	}
	var parse_Ref = parse_RefU;
	function parse_FtCmo(blob, length) {
		blob.l += 4;
		var ot = blob.read_shift(2);
		var id = blob.read_shift(2);
		var flags = blob.read_shift(2);
		blob.l += 12;
		return [id, ot, flags]
	}
	function parse_FtNts(blob, length) {
		var out = {};
		blob.l += 4;
		blob.l += 16;
		out.fSharedNote = blob.read_shift(2);
		blob.l += 4;
		return out
	}
	function parse_FtCf(blob, length) {
		var out = {};
		blob.l += 4;
		blob.cf = blob.read_shift(2);
		return out
	}
	var FtTab = {
		21 : parse_FtCmo,
		19 : parsenoop,
		18 : function (blob, length) {
			blob.l += 12
		},
		17 : function (blob, length) {
			blob.l += 8
		},
		16 : parsenoop,
		15 : parsenoop,
		13 : parse_FtNts,
		12 : function (blob, length) {
			blob.l += 24
		},
		11 : function (blob, length) {
			blob.l += 10
		},
		10 : function (blob, length) {
			blob.l += 16
		},
		9 : parsenoop,
		8 : function (blob, length) {
			blob.l += 6
		},
		7 : parse_FtCf,
		6 : function (blob, length) {
			blob.l += 6
		},
		4 : parsenoop,
		0 : function (blob, length) {
			blob.l += 4
		}
	};
	function parse_FtArray(blob, length, ot) {
		var s = blob.l;
		var fts = [];
		while (blob.l < s + length) {
			var ft = blob.read_shift(2);
			blob.l -= 2;
			try {
				fts.push(FtTab[ft](blob, s + length - blob.l))
			} catch (e) {
				blob.l = s + length;
				return fts
			}
		}
		if (blob.l != s + length)
			blob.l = s + length;
		return fts
	}
	var parse_FontIndex = parseuint16;
	function parse_BOF(blob, length) {
		var o = {};
		o.BIFFVer = blob.read_shift(2);
		length -= 2;
		switch (o.BIFFVer) {
		case 1536:
		case 1280:
		case 2:
		case 7:
			break;
		default:
			throw "Unexpected BIFF Ver " + o.BIFFVer
		}
		blob.read_shift(length);
		return o
	}
	function parse_InterfaceHdr(blob, length) {
		if (length === 0)
			return 1200;
		var q;
		if ((q = blob.read_shift(2)) !== 1200)
			throw "InterfaceHdr codePage " + q;
		return 1200
	}
	function parse_WriteAccess(blob, length, opts) {
		if (opts.enc) {
			blob.l += length;
			return ""
		}
		var l = blob.l;
		var UserName = parse_XLUnicodeString(blob, 0, opts);
		blob.read_shift(length + l - blob.l);
		return UserName
	}
	function parse_BoundSheet8(blob, length, opts) {
		var pos = blob.read_shift(4);
		var hidden = blob.read_shift(1) >> 6;
		var dt = blob.read_shift(1);
		switch (dt) {
		case 0:
			dt = "Worksheet";
			break;
		case 1:
			dt = "Macrosheet";
			break;
		case 2:
			dt = "Chartsheet";
			break;
		case 6:
			dt = "VBAModule";
			break
		}
		var name = parse_ShortXLUnicodeString(blob, 0, opts);
		if (name.length === 0)
			name = "Sheet1";
		return {
			pos : pos,
			hs : hidden,
			dt : dt,
			name : name
		}
	}
	function parse_SST(blob, length) {
		var cnt = blob.read_shift(4);
		var ucnt = blob.read_shift(4);
		var strs = [];
		for (var i = 0; i != ucnt; ++i) {
			strs.push(parse_XLUnicodeRichExtendedString(blob))
		}
		strs.Count = cnt;
		strs.Unique = ucnt;
		return strs
	}
	function parse_ExtSST(blob, length) {
		var extsst = {};
		extsst.dsst = blob.read_shift(2);
		blob.l += length - 2;
		return extsst
	}
	function parse_Row(blob, length) {
		var rw = blob.read_shift(2),
		col = blob.read_shift(2),
		Col = blob.read_shift(2),
		rht = blob.read_shift(2);
		blob.read_shift(4);
		var flags = blob.read_shift(1);
		blob.read_shift(1);
		blob.read_shift(2);
		return {
			r : rw,
			c : col,
			cnt : Col - col
		}
	}
	function parse_ForceFullCalculation(blob, length) {
		var header = parse_frtHeader(blob);
		if (header.type != 2211)
			throw "Invalid Future Record " + header.type;
		var fullcalc = blob.read_shift(4);
		return fullcalc !== 0
	}
	var parse_CompressPictures = parsenoop2;
	function parse_RecalcId(blob, length) {
		blob.read_shift(2);
		return blob.read_shift(4)
	}
	function parse_DefaultRowHeight(blob, length) {
		var f = blob.read_shift(2),
		miyRw;
		miyRw = blob.read_shift(2);
		var fl = {
			Unsynced : f & 1,
			DyZero : (f & 2) >> 1,
			ExAsc : (f & 4) >> 2,
			ExDsc : (f & 8) >> 3
		};
		return [fl, miyRw]
	}
	function parse_Window1(blob, length) {
		var xWn = blob.read_shift(2),
		yWn = blob.read_shift(2),
		dxWn = blob.read_shift(2),
		dyWn = blob.read_shift(2);
		var flags = blob.read_shift(2),
		iTabCur = blob.read_shift(2),
		iTabFirst = blob.read_shift(2);
		var ctabSel = blob.read_shift(2),
		wTabRatio = blob.read_shift(2);
		return {
			Pos : [xWn, yWn],
			Dim : [dxWn, dyWn],
			Flags : flags,
			CurTab : iTabCur,
			FirstTab : iTabFirst,
			Selected : ctabSel,
			TabRatio : wTabRatio
		}
	}
	function parse_Font(blob, length, opts) {
		blob.l += 14;
		var name = parse_ShortXLUnicodeString(blob, 0, opts);
		return name
	}
	function parse_LabelSst(blob, length) {
		var cell = parse_XLSCell(blob);
		cell.isst = blob.read_shift(4);
		return cell
	}
	function parse_Label(blob, length, opts) {
		var cell = parse_XLSCell(blob, 6);
		var str = parse_XLUnicodeString(blob, length - 6, opts);
		cell.val = str;
		return cell
	}
	function parse_Format(blob, length, opts) {
		var ifmt = blob.read_shift(2);
		var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
		return [ifmt, fmtstr]
	}
	function parse_Dimensions(blob, length) {
		var w = length === 10 ? 2 : 4;
		var r = blob.read_shift(w),
		R = blob.read_shift(w),
		c = blob.read_shift(2),
		C = blob.read_shift(2);
		blob.l += 2;
		return {
			s : {
				r : r,
				c : c
			},
			e : {
				r : R,
				c : C
			}
		}
	}
	function parse_RK(blob, length) {
		var rw = blob.read_shift(2),
		col = blob.read_shift(2);
		var rkrec = parse_RkRec(blob);
		return {
			r : rw,
			c : col,
			ixfe : rkrec[0],
			rknum : rkrec[1]
		}
	}
	function parse_MulRk(blob, length) {
		var target = blob.l + length - 2;
		var rw = blob.read_shift(2),
		col = blob.read_shift(2);
		var rkrecs = [];
		while (blob.l < target)
			rkrecs.push(parse_RkRec(blob));
		if (blob.l !== target)
			throw "MulRK read error";
		var lastcol = blob.read_shift(2);
		if (rkrecs.length != lastcol - col + 1)
			throw "MulRK length mismatch";
		return {
			r : rw,
			c : col,
			C : lastcol,
			rkrec : rkrecs
		}
	}
	function parse_CellStyleXF(blob, length, style) {
		var o = {};
		var a = blob.read_shift(4),
		b = blob.read_shift(4);
		var c = blob.read_shift(4),
		d = blob.read_shift(2);
		o.patternType = XLSFillPattern[c >> 26];
		o.icvFore = d & 127;
		o.icvBack = d >> 7 & 127;
		return o
	}
	function parse_CellXF(blob, length) {
		return parse_CellStyleXF(blob, length, 0)
	}
	function parse_StyleXF(blob, length) {
		return parse_CellStyleXF(blob, length, 1)
	}
	function parse_XF(blob, length) {
		var o = {};
		o.ifnt = blob.read_shift(2);
		o.ifmt = blob.read_shift(2);
		o.flags = blob.read_shift(2);
		o.fStyle = o.flags >> 2 & 1;
		length -= 6;
		o.data = parse_CellStyleXF(blob, length, o.fStyle);
		return o
	}
	function parse_Guts(blob, length) {
		blob.l += 4;
		var out = [blob.read_shift(2), blob.read_shift(2)];
		if (out[0] !== 0)
			out[0]--;
		if (out[1] !== 0)
			out[1]--;
		if (out[0] > 7 || out[1] > 7)
			throw "Bad Gutters: " + out;
		return out
	}
	function parse_BoolErr(blob, length) {
		var cell = parse_XLSCell(blob, 6);
		var val = parse_Bes(blob, 2);
		cell.val = val;
		cell.t = val === true || val === false ? "b" : "e";
		return cell
	}
	function parse_Number(blob, length) {
		var cell = parse_XLSCell(blob, 6);
		var xnum = parse_Xnum(blob, 8);
		cell.val = xnum;
		return cell
	}
	var parse_XLHeaderFooter = parse_OptXLUnicodeString;
	function parse_SupBook(blob, length, opts) {
		var end = blob.l + length;
		var ctab = blob.read_shift(2);
		var cch = blob.read_shift(2);
		var virtPath;
		if (cch >= 1 && cch <= 255)
			virtPath = parse_XLUnicodeStringNoCch(blob, cch);
		var rgst = blob.read_shift(end - blob.l);
		opts.sbcch = cch;
		return [cch, ctab, virtPath, rgst]
	}
	function parse_ExternName(blob, length, opts) {
		var flags = blob.read_shift(2);
		var body;
		var o = {
			fBuiltIn : flags & 1,
			fWantAdvise : flags >>> 1 & 1,
			fWantPict : flags >>> 2 & 1,
			fOle : flags >>> 3 & 1,
			fOleLink : flags >>> 4 & 1,
			cf : flags >>> 5 & 1023,
			fIcon : flags >>> 15 & 1
		};
		if (opts.sbcch === 14849)
			body = parse_AddinUdf(blob, length - 2);
		o.body = body || blob.read_shift(length - 2);
		return o
	}
	function parse_Lbl(blob, length, opts) {
		if (opts.biff < 8)
			return parse_Label(blob, length, opts);
		var target = blob.l + length;
		var flags = blob.read_shift(2);
		var chKey = blob.read_shift(1);
		var cch = blob.read_shift(1);
		var cce = blob.read_shift(2);
		blob.l += 2;
		var itab = blob.read_shift(2);
		blob.l += 4;
		var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
		var rgce = parse_NameParsedFormula(blob, target - blob.l, opts, cce);
		return {
			chKey : chKey,
			Name : name,
			rgce : rgce
		}
	}
	function parse_ExternSheet(blob, length, opts) {
		if (opts.biff < 8)
			return parse_ShortXLUnicodeString(blob, length, opts);
		var o = parslurp2(blob, length, parse_XTI);
		var oo = [];
		if (opts.sbcch === 1025) {
			for (var i = 0; i != o.length; ++i)
				oo.push(opts.snames[o[i][1]]);
			return oo
		} else
			return o
	}
	function parse_ShrFmla(blob, length, opts) {
		var ref = parse_RefU(blob, 6);
		blob.l++;
		var cUse = blob.read_shift(1);
		length -= 8;
		return [parse_SharedParsedFormula(blob, length, opts), cUse]
	}
	function parse_Array(blob, length, opts) {
		var ref = parse_Ref(blob, 6);
		blob.l += 6;
		length -= 12;
		return [ref, parse_ArrayParsedFormula(blob, length, opts, ref)]
	}
	function parse_MTRSettings(blob, length) {
		var fMTREnabled = blob.read_shift(4) !== 0;
		var fUserSetThreadCount = blob.read_shift(4) !== 0;
		var cUserThreadCount = blob.read_shift(4);
		return [fMTREnabled, fUserSetThreadCount, cUserThreadCount]
	}
	function parse_NoteSh(blob, length, opts) {
		if (opts.biff < 8)
			return;
		var row = blob.read_shift(2),
		col = blob.read_shift(2);
		var flags = blob.read_shift(2),
		idObj = blob.read_shift(2);
		var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
		if (opts.biff < 8)
			blob.read_shift(1);
		return [{
				r : row,
				c : col
			}, stAuthor, idObj, flags]
	}
	function parse_Note(blob, length, opts) {
		return parse_NoteSh(blob, length, opts)
	}
	function parse_MergeCells(blob, length) {
		var merges = [];
		var cmcs = blob.read_shift(2);
		while (cmcs--)
			merges.push(parse_Ref8U(blob, length));
		return merges
	}
	function parse_Obj(blob, length) {
		var cmo = parse_FtCmo(blob, 22);
		var fts = parse_FtArray(blob, length - 22, cmo[1]);
		return {
			cmo : cmo,
			ft : fts
		}
	}
	function parse_TxO(blob, length, opts) {
		var s = blob.l;
		try {
			blob.l += 4;
			var ot = (opts.lastobj || {
				cmo : [0, 0]
			}).cmo[1];
			var controlInfo;
			if ([0, 5, 7, 11, 12, 14].indexOf(ot) == -1)
				blob.l += 6;
			else
				controlInfo = parse_ControlInfo(blob, 6, opts);
			var cchText = blob.read_shift(2);
			var cbRuns = blob.read_shift(2);
			var ifntEmpty = parse_FontIndex(blob, 2);
			var len = blob.read_shift(2);
			blob.l += len;
			var texts = "";
			for (var i = 1; i < blob.lens.length - 1; ++i) {
				if (blob.l - s != blob.lens[i])
					throw "TxO: bad continue record";
				var hdr = blob[blob.l];
				var t = parse_XLUnicodeStringNoCch(blob, blob.lens[i + 1] - blob.lens[i] - 1);
				texts += t;
				if (texts.length >= (hdr ? cchText : 2 * cchText))
					break
			}
			if (texts.length !== cchText && texts.length !== cchText * 2) {
				throw "cchText: " + cchText + " != " + texts.length
			}
			blob.l = s + length;
			return {
				t : texts
			}
		} catch (e) {
			blob.l = s + length;
			return {
				t : texts || ""
			}
		}
	}
	var parse_HLink = function (blob, length) {
		var ref = parse_Ref8U(blob, 8);
		blob.l += 16;
		var hlink = parse_Hyperlink(blob, length - 24);
		return [ref, hlink]
	};
	var parse_HLinkTooltip = function (blob, length) {
		var end = blob.l + length;
		blob.read_shift(2);
		var ref = parse_Ref8U(blob, 8);
		var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
		wzTooltip = wzTooltip.replace(chr0, "");
		return [ref, wzTooltip]
	};
	function parse_Country(blob, length) {
		var o = [],
		d;
		d = blob.read_shift(2);
		o[0] = CountryEnum[d] || d;
		d = blob.read_shift(2);
		o[1] = CountryEnum[d] || d;
		return o
	}
	function parse_ClrtClient(blob, length) {
		var ccv = blob.read_shift(2);
		var o = [];
		while (ccv-- > 0)
			o.push(parse_LongRGB(blob, 8));
		return o
	}
	function parse_Palette(blob, length) {
		var ccv = blob.read_shift(2);
		var o = [];
		while (ccv-- > 0)
			o.push(parse_LongRGB(blob, 8));
		return o
	}
	function parse_XFCRC(blob, length) {
		blob.l += 2;
		var o = {
			cxfs : 0,
			crc : 0
		};
		o.cxfs = blob.read_shift(2);
		o.crc = blob.read_shift(4);
		return o
	}
	var parse_Style = parsenoop;
	var parse_StyleExt = parsenoop;
	var parse_ColInfo = parsenoop;
	var parse_Window2 = parsenoop;
	var parse_Backup = parsebool;
	var parse_Blank = parse_XLSCell;
	var parse_BottomMargin = parse_Xnum;
	var parse_BuiltInFnGroupCount = parseuint16;
	var parse_CalcCount = parseuint16;
	var parse_CalcDelta = parse_Xnum;
	var parse_CalcIter = parsebool;
	var parse_CalcMode = parseuint16;
	var parse_CalcPrecision = parsebool;
	var parse_CalcRefMode = parsenoop2;
	var parse_CalcSaveRecalc = parsebool;
	var parse_CodePage = parseuint16;
	var parse_Compat12 = parsebool;
	var parse_Date1904 = parsebool;
	var parse_DefColWidth = parseuint16;
	var parse_DSF = parsenoop2;
	var parse_EntExU2 = parsenoop2;
	var parse_EOF = parsenoop2;
	var parse_Excel9File = parsenoop2;
	var parse_FeatHdr = parsenoop2;
	var parse_FontX = parseuint16;
	var parse_Footer = parse_XLHeaderFooter;
	var parse_GridSet = parseuint16;
	var parse_HCenter = parsebool;
	var parse_Header = parse_XLHeaderFooter;
	var parse_HideObj = parse_HideObjEnum;
	var parse_InterfaceEnd = parsenoop2;
	var parse_LeftMargin = parse_Xnum;
	var parse_Mms = parsenoop2;
	var parse_ObjProtect = parsebool;
	var parse_Password = parseuint16;
	var parse_PrintGrid = parsebool;
	var parse_PrintRowCol = parsebool;
	var parse_PrintSize = parseuint16;
	var parse_Prot4Rev = parsebool;
	var parse_Prot4RevPass = parseuint16;
	var parse_Protect = parsebool;
	var parse_RefreshAll = parsebool;
	var parse_RightMargin = parse_Xnum;
	var parse_RRTabId = parseuint16a;
	var parse_ScenarioProtect = parsebool;
	var parse_Scl = parseuint16a;
	var parse_String = parse_XLUnicodeString;
	var parse_SxBool = parsebool;
	var parse_TopMargin = parse_Xnum;
	var parse_UsesELFs = parsebool;
	var parse_VCenter = parsebool;
	var parse_WinProtect = parsebool;
	var parse_WriteProtect = parsenoop;
	var parse_VerticalPageBreaks = parsenoop;
	var parse_HorizontalPageBreaks = parsenoop;
	var parse_Selection = parsenoop;
	var parse_Continue = parsenoop;
	var parse_Pane = parsenoop;
	var parse_Pls = parsenoop;
	var parse_DCon = parsenoop;
	var parse_DConRef = parsenoop;
	var parse_DConName = parsenoop;
	var parse_XCT = parsenoop;
	var parse_CRN = parsenoop;
	var parse_FileSharing = parsenoop;
	var parse_Uncalced = parsenoop;
	var parse_Template = parsenoop;
	var parse_Intl = parsenoop;
	var parse_WsBool = parsenoop;
	var parse_Sort = parsenoop;
	var parse_Sync = parsenoop;
	var parse_LPr = parsenoop;
	var parse_DxGCol = parsenoop;
	var parse_FnGroupName = parsenoop;
	var parse_FilterMode = parsenoop;
	var parse_AutoFilterInfo = parsenoop;
	var parse_AutoFilter = parsenoop;
	var parse_Setup = parsenoop;
	var parse_ScenMan = parsenoop;
	var parse_SCENARIO = parsenoop;
	var parse_SxView = parsenoop;
	var parse_Sxvd = parsenoop;
	var parse_SXVI = parsenoop;
	var parse_SxIvd = parsenoop;
	var parse_SXLI = parsenoop;
	var parse_SXPI = parsenoop;
	var parse_DocRoute = parsenoop;
	var parse_RecipName = parsenoop;
	var parse_MulBlank = parsenoop;
	var parse_SXDI = parsenoop;
	var parse_SXDB = parsenoop;
	var parse_SXFDB = parsenoop;
	var parse_SXDBB = parsenoop;
	var parse_SXNum = parsenoop;
	var parse_SxErr = parsenoop;
	var parse_SXInt = parsenoop;
	var parse_SXString = parsenoop;
	var parse_SXDtr = parsenoop;
	var parse_SxNil = parsenoop;
	var parse_SXTbl = parsenoop;
	var parse_SXTBRGIITM = parsenoop;
	var parse_SxTbpg = parsenoop;
	var parse_ObProj = parsenoop;
	var parse_SXStreamID = parsenoop;
	var parse_DBCell = parsenoop;
	var parse_SXRng = parsenoop;
	var parse_SxIsxoper = parsenoop;
	var parse_BookBool = parsenoop;
	var parse_DbOrParamQry = parsenoop;
	var parse_OleObjectSize = parsenoop;
	var parse_SXVS = parsenoop;
	var parse_BkHim = parsenoop;
	var parse_MsoDrawingGroup = parsenoop;
	var parse_MsoDrawing = parsenoop;
	var parse_MsoDrawingSelection = parsenoop;
	var parse_PhoneticInfo = parsenoop;
	var parse_SxRule = parsenoop;
	var parse_SXEx = parsenoop;
	var parse_SxFilt = parsenoop;
	var parse_SxDXF = parsenoop;
	var parse_SxItm = parsenoop;
	var parse_SxName = parsenoop;
	var parse_SxSelect = parsenoop;
	var parse_SXPair = parsenoop;
	var parse_SxFmla = parsenoop;
	var parse_SxFormat = parsenoop;
	var parse_SXVDEx = parsenoop;
	var parse_SXFormula = parsenoop;
	var parse_SXDBEx = parsenoop;
	var parse_RRDInsDel = parsenoop;
	var parse_RRDHead = parsenoop;
	var parse_RRDChgCell = parsenoop;
	var parse_RRDRenSheet = parsenoop;
	var parse_RRSort = parsenoop;
	var parse_RRDMove = parsenoop;
	var parse_RRFormat = parsenoop;
	var parse_RRAutoFmt = parsenoop;
	var parse_RRInsertSh = parsenoop;
	var parse_RRDMoveBegin = parsenoop;
	var parse_RRDMoveEnd = parsenoop;
	var parse_RRDInsDelBegin = parsenoop;
	var parse_RRDInsDelEnd = parsenoop;
	var parse_RRDConflict = parsenoop;
	var parse_RRDDefName = parsenoop;
	var parse_RRDRstEtxp = parsenoop;
	var parse_LRng = parsenoop;
	var parse_CUsr = parsenoop;
	var parse_CbUsr = parsenoop;
	var parse_UsrInfo = parsenoop;
	var parse_UsrExcl = parsenoop;
	var parse_FileLock = parsenoop;
	var parse_RRDInfo = parsenoop;
	var parse_BCUsrs = parsenoop;
	var parse_UsrChk = parsenoop;
	var parse_UserBView = parsenoop;
	var parse_UserSViewBegin = parsenoop;
	var parse_UserSViewEnd = parsenoop;
	var parse_RRDUserView = parsenoop;
	var parse_Qsi = parsenoop;
	var parse_CondFmt = parsenoop;
	var parse_CF = parsenoop;
	var parse_DVal = parsenoop;
	var parse_DConBin = parsenoop;
	var parse_Lel = parsenoop;
	var parse_XLSCodeName = parse_XLUnicodeString;
	var parse_SXFDBType = parsenoop;
	var parse_ObNoMacros = parsenoop;
	var parse_Dv = parsenoop;
	var parse_Index = parsenoop;
	var parse_Table = parsenoop;
	var parse_BigName = parsenoop;
	var parse_ContinueBigName = parsenoop;
	var parse_WebPub = parsenoop;
	var parse_QsiSXTag = parsenoop;
	var parse_DBQueryExt = parsenoop;
	var parse_ExtString = parsenoop;
	var parse_TxtQry = parsenoop;
	var parse_Qsir = parsenoop;
	var parse_Qsif = parsenoop;
	var parse_RRDTQSIF = parsenoop;
	var parse_OleDbConn = parsenoop;
	var parse_WOpt = parsenoop;
	var parse_SXViewEx = parsenoop;
	var parse_SXTH = parsenoop;
	var parse_SXPIEx = parsenoop;
	var parse_SXVDTEx = parsenoop;
	var parse_SXViewEx9 = parsenoop;
	var parse_ContinueFrt = parsenoop;
	var parse_RealTimeData = parsenoop;
	var parse_ChartFrtInfo = parsenoop;
	var parse_FrtWrapper = parsenoop;
	var parse_StartBlock = parsenoop;
	var parse_EndBlock = parsenoop;
	var parse_StartObject = parsenoop;
	var parse_EndObject = parsenoop;
	var parse_CatLab = parsenoop;
	var parse_YMult = parsenoop;
	var parse_SXViewLink = parsenoop;
	var parse_PivotChartBits = parsenoop;
	var parse_FrtFontList = parsenoop;
	var parse_SheetExt = parsenoop;
	var parse_BookExt = parsenoop;
	var parse_SXAddl = parsenoop;
	var parse_CrErr = parsenoop;
	var parse_HFPicture = parsenoop;
	var parse_Feat = parsenoop;
	var parse_DataLabExt = parsenoop;
	var parse_DataLabExtContents = parsenoop;
	var parse_CellWatch = parsenoop;
	var parse_FeatHdr11 = parsenoop;
	var parse_Feature11 = parsenoop;
	var parse_DropDownObjIds = parsenoop;
	var parse_ContinueFrt11 = parsenoop;
	var parse_DConn = parsenoop;
	var parse_List12 = parsenoop;
	var parse_Feature12 = parsenoop;
	var parse_CondFmt12 = parsenoop;
	var parse_CF12 = parsenoop;
	var parse_CFEx = parsenoop;
	var parse_AutoFilter12 = parsenoop;
	var parse_ContinueFrt12 = parsenoop;
	var parse_MDTInfo = parsenoop;
	var parse_MDXStr = parsenoop;
	var parse_MDXTuple = parsenoop;
	var parse_MDXSet = parsenoop;
	var parse_MDXProp = parsenoop;
	var parse_MDXKPI = parsenoop;
	var parse_MDB = parsenoop;
	var parse_PLV = parsenoop;
	var parse_DXF = parsenoop;
	var parse_TableStyles = parsenoop;
	var parse_TableStyle = parsenoop;
	var parse_TableStyleElement = parsenoop;
	var parse_NamePublish = parsenoop;
	var parse_NameCmt = parsenoop;
	var parse_SortData = parsenoop;
	var parse_GUIDTypeLib = parsenoop;
	var parse_FnGrp12 = parsenoop;
	var parse_NameFnGrp12 = parsenoop;
	var parse_HeaderFooter = parsenoop;
	var parse_CrtLayout12 = parsenoop;
	var parse_CrtMlFrt = parsenoop;
	var parse_CrtMlFrtContinue = parsenoop;
	var parse_ShapePropsStream = parsenoop;
	var parse_TextPropsStream = parsenoop;
	var parse_RichTextStream = parsenoop;
	var parse_CrtLayout12A = parsenoop;
	var parse_Units = parsenoop;
	var parse_Chart = parsenoop;
	var parse_Series = parsenoop;
	var parse_DataFormat = parsenoop;
	var parse_LineFormat = parsenoop;
	var parse_MarkerFormat = parsenoop;
	var parse_AreaFormat = parsenoop;
	var parse_PieFormat = parsenoop;
	var parse_AttachedLabel = parsenoop;
	var parse_SeriesText = parsenoop;
	var parse_ChartFormat = parsenoop;
	var parse_Legend = parsenoop;
	var parse_SeriesList = parsenoop;
	var parse_Bar = parsenoop;
	var parse_Line = parsenoop;
	var parse_Pie = parsenoop;
	var parse_Area = parsenoop;
	var parse_Scatter = parsenoop;
	var parse_CrtLine = parsenoop;
	var parse_Axis = parsenoop;
	var parse_Tick = parsenoop;
	var parse_ValueRange = parsenoop;
	var parse_CatSerRange = parsenoop;
	var parse_AxisLine = parsenoop;
	var parse_CrtLink = parsenoop;
	var parse_DefaultText = parsenoop;
	var parse_Text = parsenoop;
	var parse_ObjectLink = parsenoop;
	var parse_Frame = parsenoop;
	var parse_Begin = parsenoop;
	var parse_End = parsenoop;
	var parse_PlotArea = parsenoop;
	var parse_Chart3d = parsenoop;
	var parse_PicF = parsenoop;
	var parse_DropBar = parsenoop;
	var parse_Radar = parsenoop;
	var parse_Surf = parsenoop;
	var parse_RadarArea = parsenoop;
	var parse_AxisParent = parsenoop;
	var parse_LegendException = parsenoop;
	var parse_ShtProps = parsenoop;
	var parse_SerToCrt = parsenoop;
	var parse_AxesUsed = parsenoop;
	var parse_SBaseRef = parsenoop;
	var parse_SerParent = parsenoop;
	var parse_SerAuxTrend = parsenoop;
	var parse_IFmtRecord = parsenoop;
	var parse_Pos = parsenoop;
	var parse_AlRuns = parsenoop;
	var parse_BRAI = parsenoop;
	var parse_SerAuxErrBar = parsenoop;
	var parse_SerFmt = parsenoop;
	var parse_Chart3DBarShape = parsenoop;
	var parse_Fbi = parsenoop;
	var parse_BopPop = parsenoop;
	var parse_AxcExt = parsenoop;
	var parse_Dat = parsenoop;
	var parse_PlotGrowth = parsenoop;
	var parse_SIIndex = parsenoop;
	var parse_GelFrame = parsenoop;
	var parse_BopPopCustom = parsenoop;
	var parse_Fbi2 = parsenoop;
	function parse_BIFF5String(blob) {
		var len = blob.read_shift(1);
		return blob.read_shift(len, "sbcs-cont")
	}
	function parse_BIFF2STR(blob, length, opts) {
		var cell = parse_XLSCell(blob, 6);
		++blob.l;
		var str = parse_XLUnicodeString2(blob, length - 7, opts);
		cell.val = str;
		return cell
	}
	function parse_BIFF2NUM(blob, length, opts) {
		var cell = parse_XLSCell(blob, 6);
		++blob.l;
		var num = parse_Xnum(blob, 8);
		cell.val = num;
		return cell
	}
	var CS2CP = {
		0 : 1252,
		1 : 65001,
		2 : 65001,
		77 : 1e4,
		128 : 932,
		129 : 949,
		130 : 1361,
		134 : 936,
		136 : 950,
		161 : 1253,
		162 : 1254,
		163 : 1258,
		177 : 1255,
		178 : 1256,
		186 : 1257,
		204 : 1251,
		222 : 874,
		238 : 1250,
		255 : 1252,
		69 : 6969
	};
	var parse_rs = function parse_rs_factory() {
		var tregex = matchtag("t"),
		rpregex = matchtag("rPr"),
		rregex = /<r>/g,
		rend = /<\/r>/,
		nlregex = /\r\n/g;
		var parse_rpr = function parse_rpr(rpr, intro, outro) {
			var font = {},
			cp = 65001;
			var m = rpr.match(tagregex),
			i = 0;
			if (m)
				for (; i != m.length; ++i) {
					var y = parsexmltag(m[i]);
					switch (y[0]) {
					case "<condense":
						break;
					case "<extend":
						break;
					case "<shadow":
					case "<shadow/>":
						break;
					case "<charset":
						if (y.val == "1")
							break;
						cp = CS2CP[parseInt(y.val, 10)];
						break;
					case "<outline":
					case "<outline/>":
						break;
					case "<rFont":
						font.name = y.val;
						break;
					case "<sz":
						font.sz = y.val;
						break;
					case "<strike":
						if (!y.val)
							break;
					case "<strike/>":
						font.strike = 1;
						break;
					case "</strike>":
						break;
					case "<u":
						if (!y.val)
							break;
					case "<u/>":
						font.u = 1;
						break;
					case "</u>":
						break;
					case "<b":
						if (!y.val)
							break;
					case "<b/>":
						font.b = 1;
						break;
					case "</b>":
						break;
					case "<i":
						if (!y.val)
							break;
					case "<i/>":
						font.i = 1;
						break;
					case "</i>":
						break;
					case "<color":
						if (y.rgb)
							font.color = y.rgb.substr(2, 6);
						break;
					case "<family":
						font.family = y.val;
						break;
					case "<vertAlign":
						break;
					case "<scheme":
						break;
					default:
						if (y[0].charCodeAt(1) !== 47)
							throw "Unrecognized rich format " + y[0]
					}
				}
			var style = [];
			if (font.b)
				style.push("font-weight: bold;");
			if (font.i)
				style.push("font-style: italic;");
			intro.push('<span style="' + style.join("") + '">');
			outro.push("</span>");
			return cp
		};
		function parse_r(r) {
			var terms = [[], "", []];
			var t = r.match(tregex),
			cp = 65001;
			if (!isval(t))
				return "";
			terms[1] = t[1];
			var rpr = r.match(rpregex);
			if (isval(rpr))
				cp = parse_rpr(rpr[1], terms[0], terms[2]);
			return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("")
		}
		return function parse_rs(rs) {
			return rs.replace(rregex, "").split(rend).map(parse_r).join("")
		}
	}();
	var sitregex = /<t[^>]*>([^<]*)<\/t>/g,
	sirregex = /<r>/;
	function parse_si(x, opts) {
		var html = opts ? opts.cellHTML : true;
		var z = {};
		if (!x)
			return null;
		var y;
		if (x.charCodeAt(1) === 116) {
			z.t = utf8read(unescapexml(x.substr(x.indexOf(">") + 1).split(/<\/t>/)[0]));
			z.r = x;
			if (html)
				z.h = z.t
		} else if (y = x.match(sirregex)) {
			z.r = x;
			z.t = utf8read(unescapexml(x.match(sitregex).join("").replace(tagregex, "")));
			if (html)
				z.h = parse_rs(x)
		}
		return z
	}
	var sstr0 = /<sst([^>]*)>([\s\S]*)<\/sst>/;
	var sstr1 = /<(?:si|sstItem)>/g;
	var sstr2 = /<\/(?:si|sstItem)>/;
	function parse_sst_xml(data, opts) {
		var s = [],
		ss;
		var sst = data.match(sstr0);
		if (isval(sst)) {
			ss = sst[2].replace(sstr1, "").split(sstr2);
			for (var i = 0; i != ss.length; ++i) {
				var o = parse_si(ss[i], opts);
				if (o != null)
					s[s.length] = o
			}
			sst = parsexmltag(sst[1]);
			s.Count = sst.count;
			s.Unique = sst.uniqueCount
		}
		return s
	}
	RELS.SST = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings";
	var straywsregex = /^\s|\s$|[\t\n\r]/;
	function write_sst_xml(sst, opts) {
		if (!opts.bookSST)
			return "";
		var o = [XML_HEADER];
		o[o.length] = writextag("sst", null, {
				xmlns : XMLNS.main[0],
				count : sst.Count,
				uniqueCount : sst.Unique
			});
		for (var i = 0; i != sst.length; ++i) {
			if (sst[i] == null)
				continue;
			var s = sst[i];
			var sitag = "<si>";
			if (s.r)
				sitag += s.r;
			else {
				sitag += "<t";
				if (s.t.match(straywsregex))
					sitag += ' xml:space="preserve"';
				sitag += ">" + escapexml(s.t) + "</t>"
			}
			sitag += "</si>";
			o[o.length] = sitag
		}
		if (o.length > 2) {
			o[o.length] = "</sst>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	function parse_BrtBeginSst(data, length) {
		return [data.read_shift(4), data.read_shift(4)]
	}
	function parse_sst_bin(data, opts) {
		var s = [];
		var pass = false;
		recordhopper(data, function hopper_sst(val, R, RT) {
			switch (R.n) {
			case "BrtBeginSst":
				s.Count = val[0];
				s.Unique = val[1];
				break;
			case "BrtSSTItem":
				s.push(val);
				break;
			case "BrtEndSst":
				return true;
			case "BrtFRTBegin":
				pass = true;
				break;
			case "BrtFRTEnd":
				pass = false;
				break;
			default:
				if (!pass || opts.WTF)
					throw new Error("Unexpected record " + RT + " " + R.n)
			}
		});
		return s
	}
	function write_BrtBeginSst(sst, o) {
		if (!o)
			o = new_buf(8);
		o.write_shift(4, sst.Count);
		o.write_shift(4, sst.Unique);
		return o
	}
	var write_BrtSSTItem = write_RichStr;
	function write_sst_bin(sst, opts) {
		var ba = buf_array();
		write_record(ba, "BrtBeginSst", write_BrtBeginSst(sst));
		for (var i = 0; i < sst.length; ++i)
			write_record(ba, "BrtSSTItem", write_BrtSSTItem(sst[i]));
		write_record(ba, "BrtEndSst");
		return ba.end()
	}
	function _JS2ANSI(str) {
		if (typeof cptable !== "undefined")
			return cptable.utils.encode(1252, str);
		return str.split("").map(function (x) {
			return x.charCodeAt(0)
		})
	}
	function parse_Version(blob, length) {
		var o = {};
		o.Major = blob.read_shift(2);
		o.Minor = blob.read_shift(2);
		return o
	}
	function parse_EncryptionHeader(blob, length) {
		var o = {};
		o.Flags = blob.read_shift(4);
		var tmp = blob.read_shift(4);
		if (tmp !== 0)
			throw "Unrecognized SizeExtra: " + tmp;
		o.AlgID = blob.read_shift(4);
		switch (o.AlgID) {
		case 0:
		case 26625:
		case 26126:
		case 26127:
		case 26128:
			break;
		default:
			throw "Unrecognized encryption algorithm: " + o.AlgID
		}
		parsenoop(blob, length - 12);
		return o
	}
	function parse_EncryptionVerifier(blob, length) {
		return parsenoop(blob, length)
	}
	function parse_RC4CryptoHeader(blob, length) {
		var o = {};
		var vers = o.EncryptionVersionInfo = parse_Version(blob, 4);
		length -= 4;
		if (vers.Minor != 2)
			throw "unrecognized minor version code: " + vers.Minor;
		if (vers.Major > 4 || vers.Major < 2)
			throw "unrecognized major version code: " + vers.Major;
		o.Flags = blob.read_shift(4);
		length -= 4;
		var sz = blob.read_shift(4);
		length -= 4;
		o.EncryptionHeader = parse_EncryptionHeader(blob, sz);
		length -= sz;
		o.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
		return o
	}
	function parse_RC4Header(blob, length) {
		var o = {};
		var vers = o.EncryptionVersionInfo = parse_Version(blob, 4);
		length -= 4;
		if (vers.Major != 1 || vers.Minor != 1)
			throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
		o.Salt = blob.read_shift(16);
		o.EncryptedVerifier = blob.read_shift(16);
		o.EncryptedVerifierHash = blob.read_shift(16);
		return o
	}
	function crypto_CreatePasswordVerifier_Method1(Password) {
		var Verifier = 0,
		PasswordArray;
		var PasswordDecoded = _JS2ANSI(Password);
		var len = PasswordDecoded.length + 1,
		i,
		PasswordByte;
		var Intermediate1,
		Intermediate2,
		Intermediate3;
		PasswordArray = new_raw_buf(len);
		PasswordArray[0] = PasswordDecoded.length;
		for (i = 1; i != len; ++i)
			PasswordArray[i] = PasswordDecoded[i - 1];
		for (i = len - 1; i >= 0; --i) {
			PasswordByte = PasswordArray[i];
			Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
			Intermediate2 = Verifier << 1 & 32767;
			Intermediate3 = Intermediate1 | Intermediate2;
			Verifier = Intermediate3^PasswordByte
		}
		return Verifier^52811
	}
	var crypto_CreateXorArray_Method1 = function () {
		var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
		var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
		var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
		var Ror = function (Byte) {
			return (Byte / 2 | Byte * 128) & 255
		};
		var XorRor = function (byte1, byte2) {
			return Ror(byte1^byte2)
		};
		var CreateXorKey_Method1 = function (Password) {
			var XorKey = InitialCode[Password.length - 1];
			var CurrentElement = 104;
			for (var i = Password.length - 1; i >= 0; --i) {
				var Char = Password[i];
				for (var j = 0; j != 7; ++j) {
					if (Char & 64)
						XorKey ^= XorMatrix[CurrentElement];
					Char *= 2;
					--CurrentElement
				}
			}
			return XorKey
		};
		return function (password) {
			var Password = _JS2ANSI(password);
			var XorKey = CreateXorKey_Method1(Password);
			var Index = Password.length;
			var ObfuscationArray = new_raw_buf(16);
			for (var i = 0; i != 16; ++i)
				ObfuscationArray[i] = 0;
			var Temp,
			PasswordLastChar,
			PadIndex;
			if ((Index & 1) === 1) {
				Temp = XorKey >> 8;
				ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
				--Index;
				Temp = XorKey & 255;
				PasswordLastChar = Password[Password.length - 1];
				ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp)
			}
			while (Index > 0) {
				--Index;
				Temp = XorKey >> 8;
				ObfuscationArray[Index] = XorRor(Password[Index], Temp);
				--Index;
				Temp = XorKey & 255;
				ObfuscationArray[Index] = XorRor(Password[Index], Temp)
			}
			Index = 15;
			PadIndex = 15 - Password.length;
			while (PadIndex > 0) {
				Temp = XorKey >> 8;
				ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
				--Index;
				--PadIndex;
				Temp = XorKey & 255;
				ObfuscationArray[Index] = XorRor(Password[Index], Temp);
				--Index;
				--PadIndex
			}
			return ObfuscationArray
		}
	}();
	var crypto_DecryptData_Method1 = function (password, Data, XorArrayIndex, XorArray, O) {
		if (!O)
			O = Data;
		if (!XorArray)
			XorArray = crypto_CreateXorArray_Method1(password);
		var Index,
		Value;
		for (Index = 0; Index != Data.length; ++Index) {
			Value = Data[Index];
			Value ^= XorArray[XorArrayIndex];
			Value = (Value >> 5 | Value << 3) & 255;
			O[Index] = Value;
			++XorArrayIndex
		}
		return [O, XorArrayIndex, XorArray]
	};
	var crypto_MakeXorDecryptor = function (password) {
		var XorArrayIndex = 0,
		XorArray = crypto_CreateXorArray_Method1(password);
		return function (Data) {
			var O = crypto_DecryptData_Method1(null, Data, XorArrayIndex, XorArray);
			XorArrayIndex = O[1];
			return O[0]
		}
	};
	function parse_XORObfuscation(blob, length, opts, out) {
		var o = {
			key : parseuint16(blob),
			verificationBytes : parseuint16(blob)
		};
		if (opts.password)
			o.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
		out.valid = o.verificationBytes === o.verifier;
		if (out.valid)
			out.insitu_decrypt = crypto_MakeXorDecryptor(opts.password);
		return o
	}
	function parse_FilePassHeader(blob, length, oo) {
		var o = oo || {};
		o.Info = blob.read_shift(2);
		blob.l -= 2;
		if (o.Info === 1)
			o.Data = parse_RC4Header(blob, length);
		else
			o.Data = parse_RC4CryptoHeader(blob, length);
		return o
	}
	function parse_FilePass(blob, length, opts) {
		var o = {
			Type : blob.read_shift(2)
		};
		if (o.Type)
			parse_FilePassHeader(blob, length - 2, o);
		else
			parse_XORObfuscation(blob, length - 2, opts, o);
		return o
	}
	function hex2RGB(h) {
		var o = h.substr(h[0] === "#" ? 1 : 0, 6);
		return [parseInt(o.substr(0, 2), 16), parseInt(o.substr(0, 2), 16), parseInt(o.substr(0, 2), 16)]
	}
	function rgb2Hex(rgb) {
		for (var i = 0, o = 1; i != 3; ++i)
			o = o * 256 + (rgb[i] > 255 ? 255 : rgb[i] < 0 ? 0 : rgb[i]);
		return o.toString(16).toUpperCase().substr(1)
	}
	function rgb2HSL(rgb) {
		var R = rgb[0] / 255,
		G = rgb[1] / 255,
		B = rgb[2] / 255;
		var M = Math.max(R, G, B),
		m = Math.min(R, G, B),
		C = M - m;
		if (C === 0)
			return [0, 0, R];
		var H6 = 0,
		S = 0,
		L2 = M + m;
		S = C / (L2 > 1 ? 2 - L2 : L2);
		switch (M) {
		case R:
			H6 = ((G - B) / C + 6) % 6;
			break;
		case G:
			H6 = (B - R) / C + 2;
			break;
		case B:
			H6 = (R - G) / C + 4;
			break
		}
		return [H6 / 6, S, L2 / 2]
	}
	function hsl2RGB(hsl) {
		var H = hsl[0],
		S = hsl[1],
		L = hsl[2];
		var C = S * 2 * (L < .5 ? L : 1 - L),
		m = L - C / 2;
		var rgb = [m, m, m],
		h6 = 6 * H;
		var X;
		if (S !== 0)
			switch (h6 | 0) {
			case 0:
			case 6:
				X = C * h6;
				rgb[0] += C;
				rgb[1] += X;
				break;
			case 1:
				X = C * (2 - h6);
				rgb[0] += X;
				rgb[1] += C;
				break;
			case 2:
				X = C * (h6 - 2);
				rgb[1] += C;
				rgb[2] += X;
				break;
			case 3:
				X = C * (4 - h6);
				rgb[1] += X;
				rgb[2] += C;
				break;
			case 4:
				X = C * (h6 - 4);
				rgb[2] += C;
				rgb[0] += X;
				break;
			case 5:
				X = C * (6 - h6);
				rgb[2] += X;
				rgb[0] += C;
				break
			}
		for (var i = 0; i != 3; ++i)
			rgb[i] = Math.round(rgb[i] * 255);
		return rgb
	}
	function rgb_tint(hex, tint) {
		if (tint === 0)
			return hex;
		var hsl = rgb2HSL(hex2RGB(hex));
		if (tint < 0)
			hsl[2] = hsl[2] * (1 + tint);
		else
			hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
		return rgb2Hex(hsl2RGB(hsl))
	}
	var DEF_MDW = 7,
	MAX_MDW = 15,
	MIN_MDW = 1,
	MDW = DEF_MDW;
	function width2px(width) {
		return (width + (128 / MDW | 0) / 256) * MDW | 0
	}
	function px2char(px) {
		return ((px - 5) / MDW * 100 + .5 | 0) / 100
	}
	function char2width(chr) {
		return ((chr * MDW + 5) / MDW * 256 | 0) / 256
	}
	function cycle_width(collw) {
		return char2width(px2char(width2px(collw)))
	}
	function find_mdw(collw, coll) {
		if (cycle_width(collw) != collw) {
			for (MDW = DEF_MDW; MDW > MIN_MDW; --MDW)
				if (cycle_width(collw) === collw)
					break;
			if (MDW === MIN_MDW)
				for (MDW = DEF_MDW + 1; MDW < MAX_MDW; ++MDW)
					if (cycle_width(collw) === collw)
						break;
			if (MDW === MAX_MDW)
				MDW = DEF_MDW
		}
	}
	var XLMLPatternTypeMap = {
		None : "none",
		Solid : "solid",
		Gray50 : "mediumGray",
		Gray75 : "darkGray",
		Gray25 : "lightGray",
		HorzStripe : "darkHorizontal",
		VertStripe : "darkVertical",
		ReverseDiagStripe : "darkDown",
		DiagStripe : "darkUp",
		DiagCross : "darkGrid",
		ThickDiagCross : "darkTrellis",
		ThinHorzStripe : "lightHorizontal",
		ThinVertStripe : "lightVertical",
		ThinReverseDiagStripe : "lightDown",
		ThinHorzCross : "lightGrid"
	};
	var styles = {};
	var themes = {};
	function parse_fills(t, opts) {
		styles.Fills = [];
		var fill = {};
		t[0].match(tagregex).forEach(function (x) {
			var y = parsexmltag(x);
			switch (y[0]) {
			case "<fills":
			case "<fills>":
			case "</fills>":
				break;
			case "<fill>":
				break;
			case "</fill>":
				styles.Fills.push(fill);
				fill = {};
				break;
			case "<patternFill":
				if (y.patternType)
					fill.patternType = y.patternType;
				break;
			case "<patternFill/>":
			case "</patternFill>":
				break;
			case "<bgColor":
				if (!fill.bgColor)
					fill.bgColor = {};
				if (y.indexed)
					fill.bgColor.indexed = parseInt(y.indexed, 10);
				if (y.theme)
					fill.bgColor.theme = parseInt(y.theme, 10);
				if (y.tint)
					fill.bgColor.tint = parseFloat(y.tint);
				if (y.rgb)
					fill.bgColor.rgb = y.rgb.substring(y.rgb.length - 6);
				break;
			case "<bgColor/>":
			case "</bgColor>":
				break;
			case "<fgColor":
				if (!fill.fgColor)
					fill.fgColor = {};
				if (y.theme)
					fill.fgColor.theme = parseInt(y.theme, 10);
				if (y.tint)
					fill.fgColor.tint = parseFloat(y.tint);
				if (y.rgb)
					fill.fgColor.rgb = y.rgb.substring(y.rgb.length - 6);
				break;
			case "<fgColor/>":
			case "</fgColor>":
				break;
			default:
				if (opts.WTF)
					throw "unrecognized " + y[0] + " in fills"
			}
		})
	}
	function parse_numFmts(t, opts) {
		styles.NumberFmt = [];
		var k = keys(SSF._table);
		for (var i = 0; i < k.length; ++i)
			styles.NumberFmt[k[i]] = SSF._table[k[i]];
		var m = t[0].match(tagregex);
		for (i = 0; i < m.length; ++i) {
			var y = parsexmltag(m[i]);
			switch (y[0]) {
			case "<numFmts":
			case "</numFmts>":
			case "<numFmts/>":
			case "<numFmts>":
				break;
			case "<numFmt": {
					var f = unescapexml(utf8read(y.formatCode)),
					j = parseInt(y.numFmtId, 10);
					styles.NumberFmt[j] = f;
					if (j > 0)
						SSF.load(f, j)
				}
				break;
			default:
				if (opts.WTF)
					throw "unrecognized " + y[0] + " in numFmts"
			}
		}
	}
	function write_numFmts(NF, opts) {
		var o = ["<numFmts>"];
		[[5, 8], [23, 26], [41, 44], [63, 66], [164, 392]].forEach(function (r) {
			for (var i = r[0]; i <= r[1]; ++i)
				if (NF[i] !== undefined)
					o[o.length] = writextag("numFmt", null, {
							numFmtId : i,
							formatCode : escapexml(NF[i])
						})
		});
		if (o.length === 1)
			return "";
		o[o.length] = "</numFmts>";
		o[0] = writextag("numFmts", null, {
				count : o.length - 2
			}).replace("/>", ">");
		return o.join("")
	}
	function parse_cellXfs(t, opts) {
		styles.CellXf = [];
		t[0].match(tagregex).forEach(function (x) {
			var y = parsexmltag(x);
			switch (y[0]) {
			case "<cellXfs":
			case "<cellXfs>":
			case "<cellXfs/>":
			case "</cellXfs>":
				break;
			case "<xf":
				delete y[0];
				if (y.numFmtId)
					y.numFmtId = parseInt(y.numFmtId, 10);
				if (y.fillId)
					y.fillId = parseInt(y.fillId, 10);
				styles.CellXf.push(y);
				break;
			case "</xf>":
				break;
			case "<alignment":
			case "<alignment/>":
				break;
			case "<protection":
			case "</protection>":
			case "<protection/>":
				break;
			case "<extLst":
			case "</extLst>":
				break;
			case "<ext":
				break;
			default:
				if (opts.WTF)
					throw "unrecognized " + y[0] + " in cellXfs"
			}
		})
	}
	function write_cellXfs(cellXfs) {
		var o = [];
		o[o.length] = writextag("cellXfs", null);
		cellXfs.forEach(function (c) {
			o[o.length] = writextag("xf", null, c)
		});
		o[o.length] = "</cellXfs>";
		if (o.length === 2)
			return "";
		o[0] = writextag("cellXfs", null, {
				count : o.length - 2
			}).replace("/>", ">");
		return o.join("")
	}
	var parse_sty_xml = function make_pstyx() {
		var numFmtRegex = /<numFmts([^>]*)>.*<\/numFmts>/;
		var cellXfRegex = /<cellXfs([^>]*)>.*<\/cellXfs>/;
		var fillsRegex = /<fills([^>]*)>.*<\/fills>/;
		return function parse_sty_xml(data, opts) {
			var t;
			if (t = data.match(numFmtRegex))
				parse_numFmts(t, opts);
			if (t = data.match(fillsRegex))
				parse_fills(t, opts);
			if (t = data.match(cellXfRegex))
				parse_cellXfs(t, opts);
			return styles
		}
	}();
	var STYLES_XML_ROOT = writextag("styleSheet", null, {
			xmlns : XMLNS.main[0],
			"xmlns:vt" : XMLNS.vt
		});
	RELS.STY = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles";
	function write_sty_xml(wb, opts) {
		var o = [XML_HEADER, STYLES_XML_ROOT],
		w;
		if ((w = write_numFmts(wb.SSF)) != null)
			o[o.length] = w;
		o[o.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
		o[o.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
		o[o.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
		o[o.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
		if (w = write_cellXfs(opts.cellXfs))
			o[o.length] = w;
		o[o.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
		o[o.length] = '<dxfs count="0"/>';
		o[o.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
		if (o.length > 2) {
			o[o.length] = "</styleSheet>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	function parse_BrtFmt(data, length) {
		var ifmt = data.read_shift(2);
		var stFmtCode = parse_XLWideString(data, length - 2);
		return [ifmt, stFmtCode]
	}
	function parse_BrtFont(data, length) {
		var out = {
			flags : {}

		};
		out.dyHeight = data.read_shift(2);
		out.grbit = parse_FontFlags(data, 2);
		out.bls = data.read_shift(2);
		out.sss = data.read_shift(2);
		out.uls = data.read_shift(1);
		out.bFamily = data.read_shift(1);
		out.bCharSet = data.read_shift(1);
		data.l++;
		out.brtColor = parse_BrtColor(data, 8);
		out.bFontScheme = data.read_shift(1);
		out.name = parse_XLWideString(data, length - 21);
		out.flags.Bold = out.bls === 700;
		out.flags.Italic = out.grbit.fItalic;
		out.flags.Strikeout = out.grbit.fStrikeout;
		out.flags.Outline = out.grbit.fOutline;
		out.flags.Shadow = out.grbit.fShadow;
		out.flags.Condense = out.grbit.fCondense;
		out.flags.Extend = out.grbit.fExtend;
		out.flags.Sub = out.sss & 2;
		out.flags.Sup = out.sss & 1;
		return out
	}
	function parse_BrtXF(data, length) {
		var ixfeParent = data.read_shift(2);
		var ifmt = data.read_shift(2);
		parsenoop(data, length - 4);
		return {
			ixfe : ixfeParent,
			ifmt : ifmt
		}
	}
	function parse_sty_bin(data, opts) {
		styles.NumberFmt = [];
		for (var y in SSF._table)
			styles.NumberFmt[y] = SSF._table[y];
		styles.CellXf = [];
		var state = "";
		var pass = false;
		recordhopper(data, function hopper_sty(val, R, RT) {
			switch (R.n) {
			case "BrtFmt":
				styles.NumberFmt[val[0]] = val[1];
				SSF.load(val[1], val[0]);
				break;
			case "BrtFont":
				break;
			case "BrtKnownFonts":
				break;
			case "BrtFill":
				break;
			case "BrtBorder":
				break;
			case "BrtXF":
				if (state === "CELLXFS") {
					styles.CellXf.push(val)
				}
				break;
			case "BrtStyle":
				break;
			case "BrtDXF":
				break;
			case "BrtMRUColor":
				break;
			case "BrtIndexedColor":
				break;
			case "BrtBeginStyleSheet":
				break;
			case "BrtEndStyleSheet":
				break;
			case "BrtBeginTableStyle":
				break;
			case "BrtTableStyleElement":
				break;
			case "BrtEndTableStyle":
				break;
			case "BrtBeginFmts":
				state = "FMTS";
				break;
			case "BrtEndFmts":
				state = "";
				break;
			case "BrtBeginFonts":
				state = "FONTS";
				break;
			case "BrtEndFonts":
				state = "";
				break;
			case "BrtACBegin":
				state = "ACFONTS";
				break;
			case "BrtACEnd":
				state = "";
				break;
			case "BrtBeginFills":
				state = "FILLS";
				break;
			case "BrtEndFills":
				state = "";
				break;
			case "BrtBeginBorders":
				state = "BORDERS";
				break;
			case "BrtEndBorders":
				state = "";
				break;
			case "BrtBeginCellStyleXFs":
				state = "CELLSTYLEXFS";
				break;
			case "BrtEndCellStyleXFs":
				state = "";
				break;
			case "BrtBeginCellXFs":
				state = "CELLXFS";
				break;
			case "BrtEndCellXFs":
				state = "";
				break;
			case "BrtBeginStyles":
				state = "STYLES";
				break;
			case "BrtEndStyles":
				state = "";
				break;
			case "BrtBeginDXFs":
				state = "DXFS";
				break;
			case "BrtEndDXFs":
				state = "";
				break;
			case "BrtBeginTableStyles":
				state = "TABLESTYLES";
				break;
			case "BrtEndTableStyles":
				state = "";
				break;
			case "BrtBeginColorPalette":
				state = "COLORPALETTE";
				break;
			case "BrtEndColorPalette":
				state = "";
				break;
			case "BrtBeginIndexedColors":
				state = "INDEXEDCOLORS";
				break;
			case "BrtEndIndexedColors":
				state = "";
				break;
			case "BrtBeginMRUColors":
				state = "MRUCOLORS";
				break;
			case "BrtEndMRUColors":
				state = "";
				break;
			case "BrtFRTBegin":
				pass = true;
				break;
			case "BrtFRTEnd":
				pass = false;
				break;
			case "BrtBeginStyleSheetExt14":
				break;
			case "BrtBeginSlicerStyles":
				break;
			case "BrtEndSlicerStyles":
				break;
			case "BrtBeginTimelineStylesheetExt15":
				break;
			case "BrtEndTimelineStylesheetExt15":
				break;
			case "BrtBeginTimelineStyles":
				break;
			case "BrtEndTimelineStyles":
				break;
			case "BrtEndStyleSheetExt14":
				break;
			default:
				if (!pass || opts.WTF)
					throw new Error("Unexpected record " + RT + " " + R.n)
			}
		});
		return styles
	}
	function write_sty_bin(data, opts) {
		var ba = buf_array();
		write_record(ba, "BrtBeginStyleSheet");
		write_record(ba, "BrtEndStyleSheet");
		return ba.end()
	}
	RELS.THEME = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme";
	function parse_clrScheme(t, opts) {
		themes.themeElements.clrScheme = [];
		var color = {};
		t[0].match(tagregex).forEach(function (x) {
			var y = parsexmltag(x);
			switch (y[0]) {
			case "<a:clrScheme":
			case "</a:clrScheme>":
				break;
			case "<a:srgbClr":
				color.rgb = y.val;
				break;
			case "<a:sysClr":
				color.rgb = y.lastClr;
				break;
			case "<a:dk1>":
			case "</a:dk1>":
			case "<a:dk2>":
			case "</a:dk2>":
			case "<a:lt1>":
			case "</a:lt1>":
			case "<a:lt2>":
			case "</a:lt2>":
			case "<a:accent1>":
			case "</a:accent1>":
			case "<a:accent2>":
			case "</a:accent2>":
			case "<a:accent3>":
			case "</a:accent3>":
			case "<a:accent4>":
			case "</a:accent4>":
			case "<a:accent5>":
			case "</a:accent5>":
			case "<a:accent6>":
			case "</a:accent6>":
			case "<a:hlink>":
			case "</a:hlink>":
			case "<a:folHlink>":
			case "</a:folHlink>":
				if (y[0][1] === "/") {
					themes.themeElements.clrScheme.push(color);
					color = {}

				} else {
					color.name = y[0].substring(3, y[0].length - 1)
				}
				break;
			default:
				if (opts.WTF)
					throw "unrecognized " + y[0] + " in clrScheme"
			}
		})
	}
	function parse_fontScheme(t, opts) {}

	function parse_fmtScheme(t, opts) {}

	var clrsregex = /<a:clrScheme([^>]*)>[^\u2603]*<\/a:clrScheme>/;
	var fntsregex = /<a:fontScheme([^>]*)>[^\u2603]*<\/a:fontScheme>/;
	var fmtsregex = /<a:fmtScheme([^>]*)>[^\u2603]*<\/a:fmtScheme>/;
	function parse_themeElements(data, opts) {
		themes.themeElements = {};
		var t;
		[["clrScheme", clrsregex, parse_clrScheme], ["fontScheme", fntsregex, parse_fontScheme], ["fmtScheme", fmtsregex, parse_fmtScheme]].forEach(function (m) {
			if (!(t = data.match(m[1])))
				throw m[0] + " not found in themeElements";
			m[2](t, opts)
		})
	}
	var themeltregex = /<a:themeElements([^>]*)>[^\u2603]*<\/a:themeElements>/;
	function parse_theme_xml(data, opts) {
		if (!data || data.length === 0)
			return themes;
		var t;
		if (!(t = data.match(themeltregex)))
			throw "themeElements not found in theme";
		parse_themeElements(t[0], opts);
		return themes
	}
	function write_theme() {
		return '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"><a:themeElements><a:clrScheme name="Office"><a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1><a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1><a:dk2><a:srgbClr val="1F497D"/></a:dk2><a:lt2><a:srgbClr val="EEECE1"/></a:lt2><a:accent1><a:srgbClr val="4F81BD"/></a:accent1><a:accent2><a:srgbClr val="C0504D"/></a:accent2><a:accent3><a:srgbClr val="9BBB59"/></a:accent3><a:accent4><a:srgbClr val="8064A2"/></a:accent4><a:accent5><a:srgbClr val="4BACC6"/></a:accent5><a:accent6><a:srgbClr val="F79646"/></a:accent6><a:hlink><a:srgbClr val="0000FF"/></a:hlink><a:folHlink><a:srgbClr val="800080"/></a:folHlink></a:clrScheme><a:fontScheme name="Office"><a:majorFont><a:latin typeface="Cambria"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="ï¼­ï¼³ ï¼°ã‚´ã‚·ãƒƒã‚¯"/><a:font script="Hang" typeface="ë§‘ì�€ ê³ ë”•"/><a:font script="Hans" typeface="å®‹ä½“"/><a:font script="Hant" typeface="æ–°ç´°æ˜Žé«”"/><a:font script="Arab" typeface="Times New Roman"/><a:font script="Hebr" typeface="Times New Roman"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="MoolBoran"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Times New Roman"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:majorFont><a:minorFont><a:latin typeface="Calibri"/><a:ea typeface=""/><a:cs typeface=""/><a:font script="Jpan" typeface="ï¼­ï¼³ ï¼°ã‚´ã‚·ãƒƒã‚¯"/><a:font script="Hang" typeface="ë§‘ì�€ ê³ ë”•"/><a:font script="Hans" typeface="å®‹ä½“"/><a:font script="Hant" typeface="æ–°ç´°æ˜Žé«”"/><a:font script="Arab" typeface="Arial"/><a:font script="Hebr" typeface="Arial"/><a:font script="Thai" typeface="Tahoma"/><a:font script="Ethi" typeface="Nyala"/><a:font script="Beng" typeface="Vrinda"/><a:font script="Gujr" typeface="Shruti"/><a:font script="Khmr" typeface="DaunPenh"/><a:font script="Knda" typeface="Tunga"/><a:font script="Guru" typeface="Raavi"/><a:font script="Cans" typeface="Euphemia"/><a:font script="Cher" typeface="Plantagenet Cherokee"/><a:font script="Yiii" typeface="Microsoft Yi Baiti"/><a:font script="Tibt" typeface="Microsoft Himalaya"/><a:font script="Thaa" typeface="MV Boli"/><a:font script="Deva" typeface="Mangal"/><a:font script="Telu" typeface="Gautami"/><a:font script="Taml" typeface="Latha"/><a:font script="Syrc" typeface="Estrangelo Edessa"/><a:font script="Orya" typeface="Kalinga"/><a:font script="Mlym" typeface="Kartika"/><a:font script="Laoo" typeface="DokChampa"/><a:font script="Sinh" typeface="Iskoola Pota"/><a:font script="Mong" typeface="Mongolian Baiti"/><a:font script="Viet" typeface="Arial"/><a:font script="Uigh" typeface="Microsoft Uighur"/><a:font script="Geor" typeface="Sylfaen"/></a:minorFont></a:fontScheme><a:fmtScheme name="Office"><a:fillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="1"/></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs></a:gsLst><a:lin ang="16200000" scaled="0"/></a:gradFill></a:fillStyleLst><a:lnStyleLst><a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln><a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln></a:lnStyleLst><a:effectStyleLst><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst></a:effectStyle><a:effectStyle><a:effectLst><a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw></a:effectLst><a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d><a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d></a:effectStyle></a:effectStyleLst><a:bgFillStyleLst><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path></a:gradFill><a:gradFill rotWithShape="1"><a:gsLst><a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs><a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs></a:gsLst><a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path></a:gradFill></a:bgFillStyleLst></a:fmtScheme></a:themeElements><a:objectDefaults><a:spDef><a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style></a:spDef><a:lnDef><a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style></a:lnDef></a:objectDefaults><a:extraClrSchemeLst/></a:theme>'
	}
	function parse_Theme(blob, length) {
		var dwThemeVersion = blob.read_shift(4);
		if (dwThemeVersion === 124226)
			return;
		blob.l += length - 4
	}
	function parse_ColorTheme(blob, length) {
		return blob.read_shift(4)
	}
	function parse_FullColorExt(blob, length) {
		var o = {};
		o.xclrType = blob.read_shift(2);
		o.nTintShade = blob.read_shift(2);
		switch (o.xclrType) {
		case 0:
			blob.l += 4;
			break;
		case 1:
			o.xclrValue = parse_IcvXF(blob, 4);
			break;
		case 2:
			o.xclrValue = parse_LongRGBA(blob, 4);
			break;
		case 3:
			o.xclrValue = parse_ColorTheme(blob, 4);
			break;
		case 4:
			blob.l += 4;
			break
		}
		blob.l += 8;
		return o
	}
	function parse_IcvXF(blob, length) {
		return parsenoop(blob, length)
	}
	function parse_XFExtGradient(blob, length) {
		return parsenoop(blob, length)
	}
	function parse_ExtProp(blob, length) {
		var extType = blob.read_shift(2);
		var cb = blob.read_shift(2);
		var o = [extType];
		switch (extType) {
		case 4:
		case 5:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
		case 13:
			o[1] = parse_FullColorExt(blob, cb);
			break;
		case 6:
			o[1] = parse_XFExtGradient(blob, cb);
			break;
		case 14:
		case 15:
			o[1] = blob.read_shift(cb === 5 ? 1 : 2);
			break;
		default:
			throw new Error("Unrecognized ExtProp type: " + extType + " " + cb)
		}
		return o
	}
	function parse_XFExt(blob, length) {
		var end = blob.l + length;
		blob.l += 2;
		var ixfe = blob.read_shift(2);
		blob.l += 2;
		var cexts = blob.read_shift(2);
		var ext = [];
		while (cexts-- > 0)
			ext.push(parse_ExtProp(blob, end - blob.l));
		return {
			ixfe : ixfe,
			ext : ext
		}
	}
	function update_xfext(xf, xfext) {
		xfext.forEach(function (xfe) {
			switch (xfe[0]) {
			case 4:
				break;
			case 5:
				break;
			case 7:
			case 8:
			case 9:
			case 10:
				break;
			case 13:
				break;
			case 14:
				break;
			default:
				throw "bafuq" + xfe[0].toString(16)
			}
		})
	}
	function parse_cc_xml(data, opts) {
		var d = [];
		var l = 0,
		i = 1;
		(data.match(tagregex) || []).forEach(function (x) {
			var y = parsexmltag(x);
			switch (y[0]) {
			case "<?xml":
				break;
			case "<calcChain":
			case "<calcChain>":
			case "</calcChain>":
				break;
			case "<c":
				delete y[0];
				if (y.i)
					i = y.i;
				else
					y.i = i;
				d.push(y);
				break
			}
		});
		return d
	}
	function write_cc_xml(data, opts) {}

	function parse_BrtCalcChainItem$(data, length) {
		var out = {};
		out.i = data.read_shift(4);
		var cell = {};
		cell.r = data.read_shift(4);
		cell.c = data.read_shift(4);
		out.r = encode_cell(cell);
		var flags = data.read_shift(1);
		if (flags & 2)
			out.l = "1";
		if (flags & 8)
			out.a = "1";
		return out
	}
	function parse_cc_bin(data, opts) {
		var out = [];
		var pass = false;
		recordhopper(data, function hopper_cc(val, R, RT) {
			switch (R.n) {
			case "BrtCalcChainItem$":
				out.push(val);
				break;
			case "BrtBeginCalcChain$":
				break;
			case "BrtEndCalcChain$":
				break;
			default:
				if (!pass || opts.WTF)
					throw new Error("Unexpected record " + RT + " " + R.n)
			}
		});
		return out
	}
	function write_cc_bin(data, opts) {}

	function parse_comments(zip, dirComments, sheets, sheetRels, opts) {
		for (var i = 0; i != dirComments.length; ++i) {
			var canonicalpath = dirComments[i];
			var comments = parse_cmnt(getzipdata(zip, canonicalpath.replace(/^\//, ""), true), canonicalpath, opts);
			if (!comments || !comments.length)
				continue;
			var sheetNames = keys(sheets);
			for (var j = 0; j != sheetNames.length; ++j) {
				var sheetName = sheetNames[j];
				var rels = sheetRels[sheetName];
				if (rels) {
					var rel = rels[canonicalpath];
					if (rel)
						insertCommentsIntoSheet(sheetName, sheets[sheetName], comments)
				}
			}
		}
	}
	function insertCommentsIntoSheet(sheetName, sheet, comments) {
		comments.forEach(function (comment) {
			var cell = sheet[comment.ref];
			if (!cell) {
				cell = {};
				sheet[comment.ref] = cell;
				var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
				var thisCell = decode_cell(comment.ref);
				if (range.s.r > thisCell.r)
					range.s.r = thisCell.r;
				if (range.e.r < thisCell.r)
					range.e.r = thisCell.r;
				if (range.s.c > thisCell.c)
					range.s.c = thisCell.c;
				if (range.e.c < thisCell.c)
					range.e.c = thisCell.c;
				var encoded = encode_range(range);
				if (encoded !== sheet["!ref"])
					sheet["!ref"] = encoded
			}
			if (!cell.c)
				cell.c = [];
			var o = {
				a : comment.author,
				t : comment.t,
				r : comment.r
			};
			if (comment.h)
				o.h = comment.h;
			cell.c.push(o)
		})
	}
	function parse_comments_xml(data, opts) {
		if (data.match(/<(?:\w+:)?comments *\/>/))
			return [];
		var authors = [];
		var commentList = [];
		data.match(/<(?:\w+:)?authors>([^\u2603]*)<\/(?:\w+:)?authors>/)[1].split(/<\/\w*:?author>/).forEach(function (x) {
			if (x === "" || x.trim() === "")
				return;
			authors.push(x.match(/<(?:\w+:)?author[^>]*>(.*)/)[1])
		});
		(data.match(/<(?:\w+:)?commentList>([^\u2603]*)<\/(?:\w+:)?commentList>/) || ["", ""])[1].split(/<\/\w*:?comment>/).forEach(function (x, index) {
			if (x === "" || x.trim() === "")
				return;
			var y = parsexmltag(x.match(/<(?:\w+:)?comment[^>]*>/)[0]);
			var comment = {
				author : y.authorId && authors[y.authorId] ? authors[y.authorId] : undefined,
				ref : y.ref,
				guid : y.guid
			};
			var cell = decode_cell(y.ref);
			if (opts.sheetRows && opts.sheetRows <= cell.r)
				return;
			var textMatch = x.match(/<text>([^\u2603]*)<\/text>/);
			if (!textMatch || !textMatch[1])
				return;
			var rt = parse_si(textMatch[1]);
			comment.r = rt.r;
			comment.t = rt.t;
			if (opts.cellHTML)
				comment.h = rt.h;
			commentList.push(comment)
		});
		return commentList
	}
	function write_comments_xml(data, opts) {}

	function parse_BrtBeginComment(data, length) {
		var out = {};
		out.iauthor = data.read_shift(4);
		var rfx = parse_UncheckedRfX(data, 16);
		out.rfx = rfx.s;
		out.ref = encode_cell(rfx.s);
		data.l += 16;
		return out
	}
	var parse_BrtCommentAuthor = parse_XLWideString;
	var parse_BrtCommentText = parse_RichStr;
	function parse_comments_bin(data, opts) {
		var out = [];
		var authors = [];
		var c = {};
		var pass = false;
		recordhopper(data, function hopper_cmnt(val, R, RT) {
			switch (R.n) {
			case "BrtCommentAuthor":
				authors.push(val);
				break;
			case "BrtBeginComment":
				c = val;
				break;
			case "BrtCommentText":
				c.t = val.t;
				c.h = val.h;
				c.r = val.r;
				break;
			case "BrtEndComment":
				c.author = authors[c.iauthor];
				delete c.iauthor;
				if (opts.sheetRows && opts.sheetRows <= c.rfx.r)
					break;
				delete c.rfx;
				out.push(c);
				break;
			case "BrtBeginComments":
				break;
			case "BrtEndComments":
				break;
			case "BrtBeginCommentAuthors":
				break;
			case "BrtEndCommentAuthors":
				break;
			case "BrtBeginCommentList":
				break;
			case "BrtEndCommentList":
				break;
			default:
				if (!pass || opts.WTF)
					throw new Error("Unexpected record " + RT + " " + R.n)
			}
		});
		return out
	}
	function write_comments_bin(data, opts) {}

	var rc_to_a1 = function () {
		var rcregex = /(^|[^A-Za-z])R(\[?)(-?\d+|)\]?C(\[?)(-?\d+|)\]?/g;
		var rcbase;
		function rcfunc($$, $1, $2, $3, $4, $5) {
			var R = $3.length > 0 ? parseInt($3, 10) | 0 : 0,
			C = $5.length > 0 ? parseInt($5, 10) | 0 : 0;
			if (C < 0 && $4.length === 0)
				C = 0;
			if ($4.length > 0)
				C += rcbase.c;
			if ($2.length > 0)
				R += rcbase.r;
			return $1 + encode_col(C) + encode_row(R)
		}
		return function rc_to_a1(fstr, base) {
			rcbase = base;
			return fstr.replace(rcregex, rcfunc)
		}
	}();
	function parseread(l) {
		return function (blob, length) {
			blob.l += l;
			return
		}
	}
	function parseread1(blob, length) {
		blob.l += 1;
		return
	}
	function parse_ColRelU(blob, length) {
		var c = blob.read_shift(2);
		return [c & 16383, c >> 14 & 1, c >> 15 & 1]
	}
	function parse_RgceArea(blob, length) {
		var r = blob.read_shift(2),
		R = blob.read_shift(2);
		var c = parse_ColRelU(blob, 2);
		var C = parse_ColRelU(blob, 2);
		return {
			s : {
				r : r,
				c : c[0],
				cRel : c[1],
				rRel : c[2]
			},
			e : {
				r : R,
				c : C[0],
				cRel : C[1],
				rRel : C[2]
			}
		}
	}
	function parse_RgceAreaRel(blob, length) {
		var r = blob.read_shift(2),
		R = blob.read_shift(2);
		var c = parse_ColRelU(blob, 2);
		var C = parse_ColRelU(blob, 2);
		return {
			s : {
				r : r,
				c : c[0],
				cRel : c[1],
				rRel : c[2]
			},
			e : {
				r : R,
				c : C[0],
				cRel : C[1],
				rRel : C[2]
			}
		}
	}
	function parse_RgceLoc(blob, length) {
		var r = blob.read_shift(2);
		var c = parse_ColRelU(blob, 2);
		return {
			r : r,
			c : c[0],
			cRel : c[1],
			rRel : c[2]
		}
	}
	function parse_RgceLocRel(blob, length) {
		var r = blob.read_shift(2);
		var cl = blob.read_shift(2);
		var cRel = (cl & 32768) >> 15,
		rRel = (cl & 16384) >> 14;
		cl &= 16383;
		if (cRel !== 0)
			while (cl >= 256)
				cl -= 256;
		return {
			r : r,
			c : cl,
			cRel : cRel,
			rRel : rRel
		}
	}
	function parse_PtgArea(blob, length) {
		var type = (blob[blob.l++] & 96) >> 5;
		var area = parse_RgceArea(blob, 8);
		return [type, area]
	}
	function parse_PtgArea3d(blob, length) {
		var type = (blob[blob.l++] & 96) >> 5;
		var ixti = blob.read_shift(2);
		var area = parse_RgceArea(blob, 8);
		return [type, ixti, area]
	}
	function parse_PtgAreaErr(blob, length) {
		var type = (blob[blob.l++] & 96) >> 5;
		blob.l += 8;
		return [type]
	}
	function parse_PtgAreaErr3d(blob, length) {
		var type = (blob[blob.l++] & 96) >> 5;
		var ixti = blob.read_shift(2);
		blob.l += 8;
		return [type, ixti]
	}
	function parse_PtgAreaN(blob, length) {
		var type = (blob[blob.l++] & 96) >> 5;
		var area = parse_RgceAreaRel(blob, 8);
		return [type, area]
	}
	function parse_PtgArray(blob, length) {
		var type = (blob[blob.l++] & 96) >> 5;
		blob.l += 7;
		return [type]
	}
	function parse_PtgAttrBaxcel(blob, length) {
		var bitSemi = blob[blob.l + 1] & 1;
		var bitBaxcel = 1;
		blob.l += 4;
		return [bitSemi, bitBaxcel]
	}
	function parse_PtgAttrChoose(blob, length) {
		blob.l += 2;
		var offset = blob.read_shift(2);
		var o = [];
		for (var i = 0; i <= offset; ++i)
			o.push(blob.read_shift(2));
		return o
	}
	function parse_PtgAttrGoto(blob, length) {
		var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
		blob.l += 2;
		return [bitGoto, blob.read_shift(2)]
	}
	function parse_PtgAttrIf(blob, length) {
		var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
		blob.l += 2;
		return [bitIf, blob.read_shift(2)]
	}
	function parse_PtgAttrSemi(blob, length) {
		var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
		blob.l += 4;
		return [bitSemi]
	}
	function parse_PtgAttrSpaceType(blob, length) {
		var type = blob.read_shift(1),
		cch = blob.read_shift(1);
		return [type, cch]
	}
	function parse_PtgAttrSpace(blob, length) {
		blob.read_shift(2);
		return parse_PtgAttrSpaceType(blob, 2)
	}
	function parse_PtgAttrSpaceSemi(blob, length) {
		blob.read_shift(2);
		return parse_PtgAttrSpaceType(blob, 2)
	}
	function parse_PtgRef(blob, length) {
		var ptg = blob[blob.l] & 31;
		var type = (blob[blob.l] & 96) >> 5;
		blob.l += 1;
		var loc = parse_RgceLoc(blob, 4);
		return [type, loc]
	}
	function parse_PtgRefN(blob, length) {
		var ptg = blob[blob.l] & 31;
		var type = (blob[blob.l] & 96) >> 5;
		blob.l += 1;
		var loc = parse_RgceLocRel(blob, 4);
		return [type, loc]
	}
	function parse_PtgRef3d(blob, length) {
		var ptg = blob[blob.l] & 31;
		var type = (blob[blob.l] & 96) >> 5;
		blob.l += 1;
		var ixti = blob.read_shift(2);
		var loc = parse_RgceLoc(blob, 4);
		return [type, ixti, loc]
	}
	function parse_PtgFunc(blob, length) {
		var ptg = blob[blob.l] & 31;
		var type = (blob[blob.l] & 96) >> 5;
		blob.l += 1;
		var iftab = blob.read_shift(2);
		return [FtabArgc[iftab], Ftab[iftab]]
	}
	function parse_PtgFuncVar(blob, length) {
		blob.l++;
		var cparams = blob.read_shift(1),
		tab = parsetab(blob);
		return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]]
	}
	function parsetab(blob, length) {
		return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767]
	}
	var parse_PtgAttrSum = parseread(4);
	var parse_PtgConcat = parseread1;
	function parse_PtgExp(blob, length) {
		blob.l++;
		var row = blob.read_shift(2);
		var col = blob.read_shift(2);
		return [row, col]
	}
	function parse_PtgErr(blob, length) {
		blob.l++;
		return BErr[blob.read_shift(1)]
	}
	function parse_PtgInt(blob, length) {
		blob.l++;
		return blob.read_shift(2)
	}
	function parse_PtgBool(blob, length) {
		blob.l++;
		return blob.read_shift(1) !== 0
	}
	function parse_PtgNum(blob, length) {
		blob.l++;
		return parse_Xnum(blob, 8)
	}
	function parse_PtgStr(blob, length) {
		blob.l++;
		return parse_ShortXLUnicodeString(blob)
	}
	function parse_SerAr(blob) {
		var val = [];
		switch (val[0] = blob.read_shift(1)) {
		case 4:
			val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
			blob.l += 7;
			break;
		case 16:
			val[1] = BErr[blob[blob.l]];
			blob.l += 8;
			break;
		case 0:
			blob.l += 8;
			break;
		case 1:
			val[1] = parse_Xnum(blob, 8);
			break;
		case 2:
			val[1] = parse_XLUnicodeString(blob);
			break
		}
		return val
	}
	function parse_PtgExtraMem(blob, cce) {
		var count = blob.read_shift(2);
		var out = [];
		for (var i = 0; i != count; ++i)
			out.push(parse_Ref8U(blob, 8));
		return out
	}
	function parse_PtgExtraArray(blob) {
		var cols = 1 + blob.read_shift(1);
		var rows = 1 + blob.read_shift(2);
		for (var i = 0, o = []; i != rows && (o[i] = []); ++i)
			for (var j = 0; j != cols; ++j)
				o[i][j] = parse_SerAr(blob);
		return o
	}
	function parse_PtgName(blob, length) {
		var type = blob.read_shift(1) >>> 5 & 3;
		var nameindex = blob.read_shift(4);
		return [type, 0, nameindex]
	}
	function parse_PtgNameX(blob, length) {
		var type = blob.read_shift(1) >>> 5 & 3;
		var ixti = blob.read_shift(2);
		var nameindex = blob.read_shift(4);
		return [type, ixti, nameindex]
	}
	function parse_PtgMemArea(blob, length) {
		var type = blob.read_shift(1) >>> 5 & 3;
		blob.l += 4;
		var cce = blob.read_shift(2);
		return [type, cce]
	}
	function parse_PtgMemFunc(blob, length) {
		var type = blob.read_shift(1) >>> 5 & 3;
		var cce = blob.read_shift(2);
		return [type, cce]
	}
	function parse_PtgRefErr(blob, length) {
		var type = blob.read_shift(1) >>> 5 & 3;
		blob.l += 4;
		return [type]
	}
	var parse_PtgAdd = parseread1;
	var parse_PtgDiv = parseread1;
	var parse_PtgEq = parseread1;
	var parse_PtgGe = parseread1;
	var parse_PtgGt = parseread1;
	var parse_PtgIsect = parseread1;
	var parse_PtgLe = parseread1;
	var parse_PtgLt = parseread1;
	var parse_PtgMissArg = parseread1;
	var parse_PtgMul = parseread1;
	var parse_PtgNe = parseread1;
	var parse_PtgParen = parseread1;
	var parse_PtgPercent = parseread1;
	var parse_PtgPower = parseread1;
	var parse_PtgRange = parseread1;
	var parse_PtgSub = parseread1;
	var parse_PtgUminus = parseread1;
	var parse_PtgUnion = parseread1;
	var parse_PtgUplus = parseread1;
	var parse_PtgMemErr = parsenoop;
	var parse_PtgMemNoMem = parsenoop;
	var parse_PtgRefErr3d = parsenoop;
	var parse_PtgTbl = parsenoop;
	var PtgTypes = {
		1 : {
			n : "PtgExp",
			f : parse_PtgExp
		},
		2 : {
			n : "PtgTbl",
			f : parse_PtgTbl
		},
		3 : {
			n : "PtgAdd",
			f : parse_PtgAdd
		},
		4 : {
			n : "PtgSub",
			f : parse_PtgSub
		},
		5 : {
			n : "PtgMul",
			f : parse_PtgMul
		},
		6 : {
			n : "PtgDiv",
			f : parse_PtgDiv
		},
		7 : {
			n : "PtgPower",
			f : parse_PtgPower
		},
		8 : {
			n : "PtgConcat",
			f : parse_PtgConcat
		},
		9 : {
			n : "PtgLt",
			f : parse_PtgLt
		},
		10 : {
			n : "PtgLe",
			f : parse_PtgLe
		},
		11 : {
			n : "PtgEq",
			f : parse_PtgEq
		},
		12 : {
			n : "PtgGe",
			f : parse_PtgGe
		},
		13 : {
			n : "PtgGt",
			f : parse_PtgGt
		},
		14 : {
			n : "PtgNe",
			f : parse_PtgNe
		},
		15 : {
			n : "PtgIsect",
			f : parse_PtgIsect
		},
		16 : {
			n : "PtgUnion",
			f : parse_PtgUnion
		},
		17 : {
			n : "PtgRange",
			f : parse_PtgRange
		},
		18 : {
			n : "PtgUplus",
			f : parse_PtgUplus
		},
		19 : {
			n : "PtgUminus",
			f : parse_PtgUminus
		},
		20 : {
			n : "PtgPercent",
			f : parse_PtgPercent
		},
		21 : {
			n : "PtgParen",
			f : parse_PtgParen
		},
		22 : {
			n : "PtgMissArg",
			f : parse_PtgMissArg
		},
		23 : {
			n : "PtgStr",
			f : parse_PtgStr
		},
		28 : {
			n : "PtgErr",
			f : parse_PtgErr
		},
		29 : {
			n : "PtgBool",
			f : parse_PtgBool
		},
		30 : {
			n : "PtgInt",
			f : parse_PtgInt
		},
		31 : {
			n : "PtgNum",
			f : parse_PtgNum
		},
		32 : {
			n : "PtgArray",
			f : parse_PtgArray
		},
		33 : {
			n : "PtgFunc",
			f : parse_PtgFunc
		},
		34 : {
			n : "PtgFuncVar",
			f : parse_PtgFuncVar
		},
		35 : {
			n : "PtgName",
			f : parse_PtgName
		},
		36 : {
			n : "PtgRef",
			f : parse_PtgRef
		},
		37 : {
			n : "PtgArea",
			f : parse_PtgArea
		},
		38 : {
			n : "PtgMemArea",
			f : parse_PtgMemArea
		},
		39 : {
			n : "PtgMemErr",
			f : parse_PtgMemErr
		},
		40 : {
			n : "PtgMemNoMem",
			f : parse_PtgMemNoMem
		},
		41 : {
			n : "PtgMemFunc",
			f : parse_PtgMemFunc
		},
		42 : {
			n : "PtgRefErr",
			f : parse_PtgRefErr
		},
		43 : {
			n : "PtgAreaErr",
			f : parse_PtgAreaErr
		},
		44 : {
			n : "PtgRefN",
			f : parse_PtgRefN
		},
		45 : {
			n : "PtgAreaN",
			f : parse_PtgAreaN
		},
		57 : {
			n : "PtgNameX",
			f : parse_PtgNameX
		},
		58 : {
			n : "PtgRef3d",
			f : parse_PtgRef3d
		},
		59 : {
			n : "PtgArea3d",
			f : parse_PtgArea3d
		},
		60 : {
			n : "PtgRefErr3d",
			f : parse_PtgRefErr3d
		},
		61 : {
			n : "PtgAreaErr3d",
			f : parse_PtgAreaErr3d
		},
		255 : {}

	};
	var PtgDupes = {
		64 : 32,
		96 : 32,
		65 : 33,
		97 : 33,
		66 : 34,
		98 : 34,
		67 : 35,
		99 : 35,
		68 : 36,
		100 : 36,
		69 : 37,
		101 : 37,
		70 : 38,
		102 : 38,
		71 : 39,
		103 : 39,
		72 : 40,
		104 : 40,
		73 : 41,
		105 : 41,
		74 : 42,
		106 : 42,
		75 : 43,
		107 : 43,
		76 : 44,
		108 : 44,
		77 : 45,
		109 : 45,
		89 : 57,
		121 : 57,
		90 : 58,
		122 : 58,
		91 : 59,
		123 : 59,
		92 : 60,
		124 : 60,
		93 : 61,
		125 : 61
	};
	(function () {
		for (var y in PtgDupes)
			PtgTypes[y] = PtgTypes[PtgDupes[y]]
	})();
	var Ptg18 = {};
	var Ptg19 = {
		1 : {
			n : "PtgAttrSemi",
			f : parse_PtgAttrSemi
		},
		2 : {
			n : "PtgAttrIf",
			f : parse_PtgAttrIf
		},
		4 : {
			n : "PtgAttrChoose",
			f : parse_PtgAttrChoose
		},
		8 : {
			n : "PtgAttrGoto",
			f : parse_PtgAttrGoto
		},
		16 : {
			n : "PtgAttrSum",
			f : parse_PtgAttrSum
		},
		32 : {
			n : "PtgAttrBaxcel",
			f : parse_PtgAttrBaxcel
		},
		64 : {
			n : "PtgAttrSpace",
			f : parse_PtgAttrSpace
		},
		65 : {
			n : "PtgAttrSpaceSemi",
			f : parse_PtgAttrSpaceSemi
		},
		255 : {}

	};
	function parse_Formula(blob, length, opts) {
		var cell = parse_XLSCell(blob, 6);
		var val = parse_FormulaValue(blob, 8);
		var flags = blob.read_shift(1);
		blob.read_shift(1);
		var chn = blob.read_shift(4);
		var cbf = "";
		if (opts.biff === 5)
			blob.l += length - 20;
		else
			cbf = parse_XLSCellParsedFormula(blob, length - 20, opts);
		return {
			cell : cell,
			val : val[0],
			formula : cbf,
			shared : flags >> 3 & 1,
			tt : val[1]
		}
	}
	function parse_FormulaValue(blob) {
		var b;
		if (__readUInt16LE(blob, blob.l + 6) !== 65535)
			return [parse_Xnum(blob), "n"];
		switch (blob[blob.l]) {
		case 0:
			blob.l += 8;
			return ["String", "s"];
		case 1:
			b = blob[blob.l + 2] === 1;
			blob.l += 8;
			return [b, "b"];
		case 2:
			b = blob[blob.l + 2];
			blob.l += 8;
			return [b, "e"];
		case 3:
			blob.l += 8;
			return ["", "s"]
		}
	}
	function parse_RgbExtra(blob, length, rgce, opts) {
		if (opts.biff < 8)
			return parsenoop(blob, length);
		var target = blob.l + length;
		var o = [];
		for (var i = 0; i !== rgce.length; ++i) {
			switch (rgce[i][0]) {
			case "PtgArray":
				rgce[i][1] = parse_PtgExtraArray(blob);
				o.push(rgce[i][1]);
				break;
			case "PtgMemArea":
				rgce[i][2] = parse_PtgExtraMem(blob, rgce[i][1]);
				o.push(rgce[i][2]);
				break;
			default:
				break
			}
		}
		length = target - blob.l;
		if (length !== 0)
			o.push(parsenoop(blob, length));
		return o
	}
	function parse_NameParsedFormula(blob, length, opts, cce) {
		var target = blob.l + length;
		var rgce = parse_Rgce(blob, cce);
		var rgcb;
		if (target !== blob.l)
			rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
		return [rgce, rgcb]
	}
	function parse_XLSCellParsedFormula(blob, length, opts) {
		var target = blob.l + length;
		var rgcb,
		cce = blob.read_shift(2);
		if (cce == 65535)
			return [[], parsenoop(blob, length - 2)];
		var rgce = parse_Rgce(blob, cce);
		if (length !== cce + 2)
			rgcb = parse_RgbExtra(blob, length - cce - 2, rgce, opts);
		return [rgce, rgcb]
	}
	function parse_SharedParsedFormula(blob, length, opts) {
		var target = blob.l + length;
		var rgcb,
		cce = blob.read_shift(2);
		var rgce = parse_Rgce(blob, cce);
		if (cce == 65535)
			return [[], parsenoop(blob, length - 2)];
		if (length !== cce + 2)
			rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
		return [rgce, rgcb]
	}
	function parse_ArrayParsedFormula(blob, length, opts, ref) {
		var target = blob.l + length;
		var rgcb,
		cce = blob.read_shift(2);
		if (cce == 65535)
			return [[], parsenoop(blob, length - 2)];
		var rgce = parse_Rgce(blob, cce);
		if (length !== cce + 2)
			rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
		return [rgce, rgcb]
	}
	function parse_Rgce(blob, length) {
		var target = blob.l + length;
		var R,
		id,
		ptgs = [];
		while (target != blob.l) {
			length = target - blob.l;
			id = blob[blob.l];
			R = PtgTypes[id];
			if (id === 24 || id === 25) {
				id = blob[blob.l + 1];
				R = (id === 24 ? Ptg18 : Ptg19)[id]
			}
			if (!R || !R.f) {
				ptgs.push(parsenoop(blob, length))
			} else {
				ptgs.push([R.n, R.f(blob, length)])
			}
		}
		return ptgs
	}
	function mapper(x) {
		return x.map(function f2(y) {
			return y[1]
		}).join(",")
	}
	function stringify_formula(formula, range, cell, supbooks, opts) {
		if (opts !== undefined && opts.biff === 5)
			return "BIFF5??";
		var _range = range !== undefined ? range : {
			s : {
				c : 0,
				r : 0
			}
		};
		var stack = [],
		e1,
		e2,
		type,
		c,
		ixti,
		nameidx,
		r;
		if (!formula[0] || !formula[0][0])
			return "";
		for (var ff = 0, fflen = formula[0].length; ff < fflen; ++ff) {
			var f = formula[0][ff];
			switch (f[0]) {
			case "PtgUminus":
				stack.push("-" + stack.pop());
				break;
			case "PtgUplus":
				stack.push("+" + stack.pop());
				break;
			case "PtgPercent":
				stack.push(stack.pop() + "%");
				break;
			case "PtgAdd":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "+" + e1);
				break;
			case "PtgSub":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "-" + e1);
				break;
			case "PtgMul":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "*" + e1);
				break;
			case "PtgDiv":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "/" + e1);
				break;
			case "PtgPower":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "^" + e1);
				break;
			case "PtgConcat":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "&" + e1);
				break;
			case "PtgLt":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "<" + e1);
				break;
			case "PtgLe":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "<=" + e1);
				break;
			case "PtgEq":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "=" + e1);
				break;
			case "PtgGe":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + ">=" + e1);
				break;
			case "PtgGt":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + ">" + e1);
				break;
			case "PtgNe":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "<>" + e1);
				break;
			case "PtgIsect":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + " " + e1);
				break;
			case "PtgUnion":
				e1 = stack.pop();
				e2 = stack.pop();
				stack.push(e2 + "," + e1);
				break;
			case "PtgRange":
				break;
			case "PtgAttrChoose":
				break;
			case "PtgAttrGoto":
				break;
			case "PtgAttrIf":
				break;
			case "PtgRef":
				type = f[1][0];
				c = shift_cell_xls(decode_cell(encode_cell(f[1][1])), _range);
				stack.push(encode_cell(c));
				break;
			case "PtgRefN":
				type = f[1][0];
				c = shift_cell_xls(decode_cell(encode_cell(f[1][1])), cell);
				stack.push(encode_cell(c));
				break;
			case "PtgRef3d":
				type = f[1][0];
				ixti = f[1][1];
				c = shift_cell_xls(f[1][2], _range);
				stack.push(supbooks[1][ixti + 1] + "!" + encode_cell(c));
				break;
			case "PtgFunc":
			case "PtgFuncVar":
				var argc = f[1][0],
				func = f[1][1];
				if (!argc)
					argc = 0;
				var args = stack.slice(-argc);
				stack.length -= argc;
				if (func === "User")
					func = args.shift();
				stack.push(func + "(" + args.join(",") + ")");
				break;
			case "PtgBool":
				stack.push(f[1] ? "TRUE" : "FALSE");
				break;
			case "PtgInt":
				stack.push(f[1]);
				break;
			case "PtgNum":
				stack.push(String(f[1]));
				break;
			case "PtgStr":
				stack.push('"' + f[1] + '"');
				break;
			case "PtgErr":
				stack.push(f[1]);
				break;
			case "PtgArea":
				type = f[1][0];
				r = shift_range_xls(f[1][1], _range);
				stack.push(encode_range(r));
				break;
			case "PtgArea3d":
				type = f[1][0];
				ixti = f[1][1];
				r = f[1][2];
				stack.push(supbooks[1][ixti + 1] + "!" + encode_range(r));
				break;
			case "PtgAttrSum":
				stack.push("SUM(" + stack.pop() + ")");
				break;
			case "PtgAttrSemi":
				break;
			case "PtgName":
				nameidx = f[1][2];
				var lbl = supbooks[0][nameidx];
				var name = lbl.Name;
				if (name in XLSXFutureFunctions)
					name = XLSXFutureFunctions[name];
				stack.push(name);
				break;
			case "PtgNameX":
				var bookidx = f[1][1];
				nameidx = f[1][2];
				var externbook;
				if (supbooks[bookidx + 1])
					externbook = supbooks[bookidx + 1][nameidx];
				else if (supbooks[bookidx - 1])
					externbook = supbooks[bookidx - 1][nameidx];
				if (!externbook)
					externbook = {
						body : "??NAMEX??"
					};
				stack.push(externbook.body);
				break;
			case "PtgParen":
				stack.push("(" + stack.pop() + ")");
				break;
			case "PtgRefErr":
				stack.push("#REF!");
				break;
			case "PtgExp":
				c = {
					c : f[1][1],
					r : f[1][0]
				};
				var q = {
					c : cell.c,
					r : cell.r
				};
				if (supbooks.sharedf[encode_cell(c)]) {
					var parsedf = supbooks.sharedf[encode_cell(c)];
					stack.push(stringify_formula(parsedf, _range, q, supbooks, opts))
				} else {
					var fnd = false;
					for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
						e2 = supbooks.arrayf[e1];
						if (c.c < e2[0].s.c || c.c > e2[0].e.c)
							continue;
						if (c.r < e2[0].s.r || c.r > e2[0].e.r)
							continue;
						stack.push(stringify_formula(e2[1], _range, q, supbooks, opts))
					}
					if (!fnd)
						stack.push(f[1])
				}
				break;
			case "PtgArray":
				stack.push("{" + f[1].map(mapper).join(";") + "}");
				break;
			case "PtgMemArea":
				break;
			case "PtgAttrSpace":
				break;
			case "PtgTbl":
				break;
			case "PtgMemErr":
				break;
			case "PtgMissArg":
				stack.push("");
				break;
			case "PtgAreaErr":
				break;
			case "PtgAreaN":
				stack.push("");
				break;
			case "PtgRefErr3d":
				break;
			case "PtgMemFunc":
				break;
			default:
				throw "Unrecognized Formula Token: " + f
			}
		}
		return stack[0]
	}
	function parse_XLSBCellParsedFormula(data, length) {
		var cce = data.read_shift(4);
		return parsenoop(data, length - 4)
	}
	var PtgDataType = {
		1 : "REFERENCE",
		2 : "VALUE",
		3 : "ARRAY"
	};
	var Cetab = {
		0 : "BEEP",
		1 : "OPEN",
		2 : "OPEN.LINKS",
		3 : "CLOSE.ALL",
		4 : "SAVE",
		5 : "SAVE.AS",
		6 : "FILE.DELETE",
		7 : "PAGE.SETUP",
		8 : "PRINT",
		9 : "PRINTER.SETUP",
		10 : "QUIT",
		11 : "NEW.WINDOW",
		12 : "ARRANGE.ALL",
		13 : "WINDOW.SIZE",
		14 : "WINDOW.MOVE",
		15 : "FULL",
		16 : "CLOSE",
		17 : "RUN",
		22 : "SET.PRINT.AREA",
		23 : "SET.PRINT.TITLES",
		24 : "SET.PAGE.BREAK",
		25 : "REMOVE.PAGE.BREAK",
		26 : "FONT",
		27 : "DISPLAY",
		28 : "PROTECT.DOCUMENT",
		29 : "PRECISION",
		30 : "A1.R1C1",
		31 : "CALCULATE.NOW",
		32 : "CALCULATION",
		34 : "DATA.FIND",
		35 : "EXTRACT",
		36 : "DATA.DELETE",
		37 : "SET.DATABASE",
		38 : "SET.CRITERIA",
		39 : "SORT",
		40 : "DATA.SERIES",
		41 : "TABLE",
		42 : "FORMAT.NUMBER",
		43 : "ALIGNMENT",
		44 : "STYLE",
		45 : "BORDER",
		46 : "CELL.PROTECTION",
		47 : "COLUMN.WIDTH",
		48 : "UNDO",
		49 : "CUT",
		50 : "COPY",
		51 : "PASTE",
		52 : "CLEAR",
		53 : "PASTE.SPECIAL",
		54 : "EDIT.DELETE",
		55 : "INSERT",
		56 : "FILL.RIGHT",
		57 : "FILL.DOWN",
		61 : "DEFINE.NAME",
		62 : "CREATE.NAMES",
		63 : "FORMULA.GOTO",
		64 : "FORMULA.FIND",
		65 : "SELECT.LAST.CELL",
		66 : "SHOW.ACTIVE.CELL",
		67 : "GALLERY.AREA",
		68 : "GALLERY.BAR",
		69 : "GALLERY.COLUMN",
		70 : "GALLERY.LINE",
		71 : "GALLERY.PIE",
		72 : "GALLERY.SCATTER",
		73 : "COMBINATION",
		74 : "PREFERRED",
		75 : "ADD.OVERLAY",
		76 : "GRIDLINES",
		77 : "SET.PREFERRED",
		78 : "AXES",
		79 : "LEGEND",
		80 : "ATTACH.TEXT",
		81 : "ADD.ARROW",
		82 : "SELECT.CHART",
		83 : "SELECT.PLOT.AREA",
		84 : "PATTERNS",
		85 : "MAIN.CHART",
		86 : "OVERLAY",
		87 : "SCALE",
		88 : "FORMAT.LEGEND",
		89 : "FORMAT.TEXT",
		90 : "EDIT.REPEAT",
		91 : "PARSE",
		92 : "JUSTIFY",
		93 : "HIDE",
		94 : "UNHIDE",
		95 : "WORKSPACE",
		96 : "FORMULA",
		97 : "FORMULA.FILL",
		98 : "FORMULA.ARRAY",
		99 : "DATA.FIND.NEXT",
		100 : "DATA.FIND.PREV",
		101 : "FORMULA.FIND.NEXT",
		102 : "FORMULA.FIND.PREV",
		103 : "ACTIVATE",
		104 : "ACTIVATE.NEXT",
		105 : "ACTIVATE.PREV",
		106 : "UNLOCKED.NEXT",
		107 : "UNLOCKED.PREV",
		108 : "COPY.PICTURE",
		109 : "SELECT",
		110 : "DELETE.NAME",
		111 : "DELETE.FORMAT",
		112 : "VLINE",
		113 : "HLINE",
		114 : "VPAGE",
		115 : "HPAGE",
		116 : "VSCROLL",
		117 : "HSCROLL",
		118 : "ALERT",
		119 : "NEW",
		120 : "CANCEL.COPY",
		121 : "SHOW.CLIPBOARD",
		122 : "MESSAGE",
		124 : "PASTE.LINK",
		125 : "APP.ACTIVATE",
		126 : "DELETE.ARROW",
		127 : "ROW.HEIGHT",
		128 : "FORMAT.MOVE",
		129 : "FORMAT.SIZE",
		130 : "FORMULA.REPLACE",
		131 : "SEND.KEYS",
		132 : "SELECT.SPECIAL",
		133 : "APPLY.NAMES",
		134 : "REPLACE.FONT",
		135 : "FREEZE.PANES",
		136 : "SHOW.INFO",
		137 : "SPLIT",
		138 : "ON.WINDOW",
		139 : "ON.DATA",
		140 : "DISABLE.INPUT",
		142 : "OUTLINE",
		143 : "LIST.NAMES",
		144 : "FILE.CLOSE",
		145 : "SAVE.WORKBOOK",
		146 : "DATA.FORM",
		147 : "COPY.CHART",
		148 : "ON.TIME",
		149 : "WAIT",
		150 : "FORMAT.FONT",
		151 : "FILL.UP",
		152 : "FILL.LEFT",
		153 : "DELETE.OVERLAY",
		155 : "SHORT.MENUS",
		159 : "SET.UPDATE.STATUS",
		161 : "COLOR.PALETTE",
		162 : "DELETE.STYLE",
		163 : "WINDOW.RESTORE",
		164 : "WINDOW.MAXIMIZE",
		166 : "CHANGE.LINK",
		167 : "CALCULATE.DOCUMENT",
		168 : "ON.KEY",
		169 : "APP.RESTORE",
		170 : "APP.MOVE",
		171 : "APP.SIZE",
		172 : "APP.MINIMIZE",
		173 : "APP.MAXIMIZE",
		174 : "BRING.TO.FRONT",
		175 : "SEND.TO.BACK",
		185 : "MAIN.CHART.TYPE",
		186 : "OVERLAY.CHART.TYPE",
		187 : "SELECT.END",
		188 : "OPEN.MAIL",
		189 : "SEND.MAIL",
		190 : "STANDARD.FONT",
		191 : "CONSOLIDATE",
		192 : "SORT.SPECIAL",
		193 : "GALLERY.3D.AREA",
		194 : "GALLERY.3D.COLUMN",
		195 : "GALLERY.3D.LINE",
		196 : "GALLERY.3D.PIE",
		197 : "VIEW.3D",
		198 : "GOAL.SEEK",
		199 : "WORKGROUP",
		200 : "FILL.GROUP",
		201 : "UPDATE.LINK",
		202 : "PROMOTE",
		203 : "DEMOTE",
		204 : "SHOW.DETAIL",
		206 : "UNGROUP",
		207 : "OBJECT.PROPERTIES",
		208 : "SAVE.NEW.OBJECT",
		209 : "SHARE",
		210 : "SHARE.NAME",
		211 : "DUPLICATE",
		212 : "APPLY.STYLE",
		213 : "ASSIGN.TO.OBJECT",
		214 : "OBJECT.PROTECTION",
		215 : "HIDE.OBJECT",
		216 : "SET.EXTRACT",
		217 : "CREATE.PUBLISHER",
		218 : "SUBSCRIBE.TO",
		219 : "ATTRIBUTES",
		220 : "SHOW.TOOLBAR",
		222 : "PRINT.PREVIEW",
		223 : "EDIT.COLOR",
		224 : "SHOW.LEVELS",
		225 : "FORMAT.MAIN",
		226 : "FORMAT.OVERLAY",
		227 : "ON.RECALC",
		228 : "EDIT.SERIES",
		229 : "DEFINE.STYLE",
		240 : "LINE.PRINT",
		243 : "ENTER.DATA",
		249 : "GALLERY.RADAR",
		250 : "MERGE.STYLES",
		251 : "EDITION.OPTIONS",
		252 : "PASTE.PICTURE",
		253 : "PASTE.PICTURE.LINK",
		254 : "SPELLING",
		256 : "ZOOM",
		259 : "INSERT.OBJECT",
		260 : "WINDOW.MINIMIZE",
		265 : "SOUND.NOTE",
		266 : "SOUND.PLAY",
		267 : "FORMAT.SHAPE",
		268 : "EXTEND.POLYGON",
		269 : "FORMAT.AUTO",
		272 : "GALLERY.3D.BAR",
		273 : "GALLERY.3D.SURFACE",
		274 : "FILL.AUTO",
		276 : "CUSTOMIZE.TOOLBAR",
		277 : "ADD.TOOL",
		278 : "EDIT.OBJECT",
		279 : "ON.DOUBLECLICK",
		280 : "ON.ENTRY",
		281 : "WORKBOOK.ADD",
		282 : "WORKBOOK.MOVE",
		283 : "WORKBOOK.COPY",
		284 : "WORKBOOK.OPTIONS",
		285 : "SAVE.WORKSPACE",
		288 : "CHART.WIZARD",
		289 : "DELETE.TOOL",
		290 : "MOVE.TOOL",
		291 : "WORKBOOK.SELECT",
		292 : "WORKBOOK.ACTIVATE",
		293 : "ASSIGN.TO.TOOL",
		295 : "COPY.TOOL",
		296 : "RESET.TOOL",
		297 : "CONSTRAIN.NUMERIC",
		298 : "PASTE.TOOL",
		302 : "WORKBOOK.NEW",
		305 : "SCENARIO.CELLS",
		306 : "SCENARIO.DELETE",
		307 : "SCENARIO.ADD",
		308 : "SCENARIO.EDIT",
		309 : "SCENARIO.SHOW",
		310 : "SCENARIO.SHOW.NEXT",
		311 : "SCENARIO.SUMMARY",
		312 : "PIVOT.TABLE.WIZARD",
		313 : "PIVOT.FIELD.PROPERTIES",
		314 : "PIVOT.FIELD",
		315 : "PIVOT.ITEM",
		316 : "PIVOT.ADD.FIELDS",
		318 : "OPTIONS.CALCULATION",
		319 : "OPTIONS.EDIT",
		320 : "OPTIONS.VIEW",
		321 : "ADDIN.MANAGER",
		322 : "MENU.EDITOR",
		323 : "ATTACH.TOOLBARS",
		324 : "VBAActivate",
		325 : "OPTIONS.CHART",
		328 : "VBA.INSERT.FILE",
		330 : "VBA.PROCEDURE.DEFINITION",
		336 : "ROUTING.SLIP",
		338 : "ROUTE.DOCUMENT",
		339 : "MAIL.LOGON",
		342 : "INSERT.PICTURE",
		343 : "EDIT.TOOL",
		344 : "GALLERY.DOUGHNUT",
		350 : "CHART.TREND",
		352 : "PIVOT.ITEM.PROPERTIES",
		354 : "WORKBOOK.INSERT",
		355 : "OPTIONS.TRANSITION",
		356 : "OPTIONS.GENERAL",
		370 : "FILTER.ADVANCED",
		373 : "MAIL.ADD.MAILER",
		374 : "MAIL.DELETE.MAILER",
		375 : "MAIL.REPLY",
		376 : "MAIL.REPLY.ALL",
		377 : "MAIL.FORWARD",
		378 : "MAIL.NEXT.LETTER",
		379 : "DATA.LABEL",
		380 : "INSERT.TITLE",
		381 : "FONT.PROPERTIES",
		382 : "MACRO.OPTIONS",
		383 : "WORKBOOK.HIDE",
		384 : "WORKBOOK.UNHIDE",
		385 : "WORKBOOK.DELETE",
		386 : "WORKBOOK.NAME",
		388 : "GALLERY.CUSTOM",
		390 : "ADD.CHART.AUTOFORMAT",
		391 : "DELETE.CHART.AUTOFORMAT",
		392 : "CHART.ADD.DATA",
		393 : "AUTO.OUTLINE",
		394 : "TAB.ORDER",
		395 : "SHOW.DIALOG",
		396 : "SELECT.ALL",
		397 : "UNGROUP.SHEETS",
		398 : "SUBTOTAL.CREATE",
		399 : "SUBTOTAL.REMOVE",
		400 : "RENAME.OBJECT",
		412 : "WORKBOOK.SCROLL",
		413 : "WORKBOOK.NEXT",
		414 : "WORKBOOK.PREV",
		415 : "WORKBOOK.TAB.SPLIT",
		416 : "FULL.SCREEN",
		417 : "WORKBOOK.PROTECT",
		420 : "SCROLLBAR.PROPERTIES",
		421 : "PIVOT.SHOW.PAGES",
		422 : "TEXT.TO.COLUMNS",
		423 : "FORMAT.CHARTTYPE",
		424 : "LINK.FORMAT",
		425 : "TRACER.DISPLAY",
		430 : "TRACER.NAVIGATE",
		431 : "TRACER.CLEAR",
		432 : "TRACER.ERROR",
		433 : "PIVOT.FIELD.GROUP",
		434 : "PIVOT.FIELD.UNGROUP",
		435 : "CHECKBOX.PROPERTIES",
		436 : "LABEL.PROPERTIES",
		437 : "LISTBOX.PROPERTIES",
		438 : "EDITBOX.PROPERTIES",
		439 : "PIVOT.REFRESH",
		440 : "LINK.COMBO",
		441 : "OPEN.TEXT",
		442 : "HIDE.DIALOG",
		443 : "SET.DIALOG.FOCUS",
		444 : "ENABLE.OBJECT",
		445 : "PUSHBUTTON.PROPERTIES",
		446 : "SET.DIALOG.DEFAULT",
		447 : "FILTER",
		448 : "FILTER.SHOW.ALL",
		449 : "CLEAR.OUTLINE",
		450 : "FUNCTION.WIZARD",
		451 : "ADD.LIST.ITEM",
		452 : "SET.LIST.ITEM",
		453 : "REMOVE.LIST.ITEM",
		454 : "SELECT.LIST.ITEM",
		455 : "SET.CONTROL.VALUE",
		456 : "SAVE.COPY.AS",
		458 : "OPTIONS.LISTS.ADD",
		459 : "OPTIONS.LISTS.DELETE",
		460 : "SERIES.AXES",
		461 : "SERIES.X",
		462 : "SERIES.Y",
		463 : "ERRORBAR.X",
		464 : "ERRORBAR.Y",
		465 : "FORMAT.CHART",
		466 : "SERIES.ORDER",
		467 : "MAIL.LOGOFF",
		468 : "CLEAR.ROUTING.SLIP",
		469 : "APP.ACTIVATE.MICROSOFT",
		470 : "MAIL.EDIT.MAILER",
		471 : "ON.SHEET",
		472 : "STANDARD.WIDTH",
		473 : "SCENARIO.MERGE",
		474 : "SUMMARY.INFO",
		475 : "FIND.FILE",
		476 : "ACTIVE.CELL.FONT",
		477 : "ENABLE.TIPWIZARD",
		478 : "VBA.MAKE.ADDIN",
		480 : "INSERTDATATABLE",
		481 : "WORKGROUP.OPTIONS",
		482 : "MAIL.SEND.MAILER",
		485 : "AUTOCORRECT",
		489 : "POST.DOCUMENT",
		491 : "PICKLIST",
		493 : "VIEW.SHOW",
		494 : "VIEW.DEFINE",
		495 : "VIEW.DELETE",
		509 : "SHEET.BACKGROUND",
		510 : "INSERT.MAP.OBJECT",
		511 : "OPTIONS.MENONO",
		517 : "MSOCHECKS",
		518 : "NORMAL",
		519 : "LAYOUT",
		520 : "RM.PRINT.AREA",
		521 : "CLEAR.PRINT.AREA",
		522 : "ADD.PRINT.AREA",
		523 : "MOVE.BRK",
		545 : "HIDECURR.NOTE",
		546 : "HIDEALL.NOTES",
		547 : "DELETE.NOTE",
		548 : "TRAVERSE.NOTES",
		549 : "ACTIVATE.NOTES",
		620 : "PROTECT.REVISIONS",
		621 : "UNPROTECT.REVISIONS",
		647 : "OPTIONS.ME",
		653 : "WEB.PUBLISH",
		667 : "NEWWEBQUERY",
		673 : "PIVOT.TABLE.CHART",
		753 : "OPTIONS.SAVE",
		755 : "OPTIONS.SPELL",
		808 : "HIDEALL.INKANNOTS"
	};
	var Ftab = {
		0 : "COUNT",
		1 : "IF",
		2 : "ISNA",
		3 : "ISERROR",
		4 : "SUM",
		5 : "AVERAGE",
		6 : "MIN",
		7 : "MAX",
		8 : "ROW",
		9 : "COLUMN",
		10 : "NA",
		11 : "NPV",
		12 : "STDEV",
		13 : "DOLLAR",
		14 : "FIXED",
		15 : "SIN",
		16 : "COS",
		17 : "TAN",
		18 : "ATAN",
		19 : "PI",
		20 : "SQRT",
		21 : "EXP",
		22 : "LN",
		23 : "LOG10",
		24 : "ABS",
		25 : "INT",
		26 : "SIGN",
		27 : "ROUND",
		28 : "LOOKUP",
		29 : "INDEX",
		30 : "REPT",
		31 : "MID",
		32 : "LEN",
		33 : "VALUE",
		34 : "TRUE",
		35 : "FALSE",
		36 : "AND",
		37 : "OR",
		38 : "NOT",
		39 : "MOD",
		40 : "DCOUNT",
		41 : "DSUM",
		42 : "DAVERAGE",
		43 : "DMIN",
		44 : "DMAX",
		45 : "DSTDEV",
		46 : "VAR",
		47 : "DVAR",
		48 : "TEXT",
		49 : "LINEST",
		50 : "TREND",
		51 : "LOGEST",
		52 : "GROWTH",
		53 : "GOTO",
		54 : "HALT",
		55 : "RETURN",
		56 : "PV",
		57 : "FV",
		58 : "NPER",
		59 : "PMT",
		60 : "RATE",
		61 : "MIRR",
		62 : "IRR",
		63 : "RAND",
		64 : "MATCH",
		65 : "DATE",
		66 : "TIME",
		67 : "DAY",
		68 : "MONTH",
		69 : "YEAR",
		70 : "WEEKDAY",
		71 : "HOUR",
		72 : "MINUTE",
		73 : "SECOND",
		74 : "NOW",
		75 : "AREAS",
		76 : "ROWS",
		77 : "COLUMNS",
		78 : "OFFSET",
		79 : "ABSREF",
		80 : "RELREF",
		81 : "ARGUMENT",
		82 : "SEARCH",
		83 : "TRANSPOSE",
		84 : "ERROR",
		85 : "STEP",
		86 : "TYPE",
		87 : "ECHO",
		88 : "SET.NAME",
		89 : "CALLER",
		90 : "DEREF",
		91 : "WINDOWS",
		92 : "SERIES",
		93 : "DOCUMENTS",
		94 : "ACTIVE.CELL",
		95 : "SELECTION",
		96 : "RESULT",
		97 : "ATAN2",
		98 : "ASIN",
		99 : "ACOS",
		100 : "CHOOSE",
		101 : "HLOOKUP",
		102 : "VLOOKUP",
		103 : "LINKS",
		104 : "INPUT",
		105 : "ISREF",
		106 : "GET.FORMULA",
		107 : "GET.NAME",
		108 : "SET.VALUE",
		109 : "LOG",
		110 : "EXEC",
		111 : "CHAR",
		112 : "LOWER",
		113 : "UPPER",
		114 : "PROPER",
		115 : "LEFT",
		116 : "RIGHT",
		117 : "EXACT",
		118 : "TRIM",
		119 : "REPLACE",
		120 : "SUBSTITUTE",
		121 : "CODE",
		122 : "NAMES",
		123 : "DIRECTORY",
		124 : "FIND",
		125 : "CELL",
		126 : "ISERR",
		127 : "ISTEXT",
		128 : "ISNUMBER",
		129 : "ISBLANK",
		130 : "T",
		131 : "N",
		132 : "FOPEN",
		133 : "FCLOSE",
		134 : "FSIZE",
		135 : "FREADLN",
		136 : "FREAD",
		137 : "FWRITELN",
		138 : "FWRITE",
		139 : "FPOS",
		140 : "DATEVALUE",
		141 : "TIMEVALUE",
		142 : "SLN",
		143 : "SYD",
		144 : "DDB",
		145 : "GET.DEF",
		146 : "REFTEXT",
		147 : "TEXTREF",
		148 : "INDIRECT",
		149 : "REGISTER",
		150 : "CALL",
		151 : "ADD.BAR",
		152 : "ADD.MENU",
		153 : "ADD.COMMAND",
		154 : "ENABLE.COMMAND",
		155 : "CHECK.COMMAND",
		156 : "RENAME.COMMAND",
		157 : "SHOW.BAR",
		158 : "DELETE.MENU",
		159 : "DELETE.COMMAND",
		160 : "GET.CHART.ITEM",
		161 : "DIALOG.BOX",
		162 : "CLEAN",
		163 : "MDETERM",
		164 : "MINVERSE",
		165 : "MMULT",
		166 : "FILES",
		167 : "IPMT",
		168 : "PPMT",
		169 : "COUNTA",
		170 : "CANCEL.KEY",
		171 : "FOR",
		172 : "WHILE",
		173 : "BREAK",
		174 : "NEXT",
		175 : "INITIATE",
		176 : "REQUEST",
		177 : "POKE",
		178 : "EXECUTE",
		179 : "TERMINATE",
		180 : "RESTART",
		181 : "HELP",
		182 : "GET.BAR",
		183 : "PRODUCT",
		184 : "FACT",
		185 : "GET.CELL",
		186 : "GET.WORKSPACE",
		187 : "GET.WINDOW",
		188 : "GET.DOCUMENT",
		189 : "DPRODUCT",
		190 : "ISNONTEXT",
		191 : "GET.NOTE",
		192 : "NOTE",
		193 : "STDEVP",
		194 : "VARP",
		195 : "DSTDEVP",
		196 : "DVARP",
		197 : "TRUNC",
		198 : "ISLOGICAL",
		199 : "DCOUNTA",
		200 : "DELETE.BAR",
		201 : "UNREGISTER",
		204 : "USDOLLAR",
		205 : "FINDB",
		206 : "SEARCHB",
		207 : "REPLACEB",
		208 : "LEFTB",
		209 : "RIGHTB",
		210 : "MIDB",
		211 : "LENB",
		212 : "ROUNDUP",
		213 : "ROUNDDOWN",
		214 : "ASC",
		215 : "DBCS",
		216 : "RANK",
		219 : "ADDRESS",
		220 : "DAYS360",
		221 : "TODAY",
		222 : "VDB",
		223 : "ELSE",
		224 : "ELSE.IF",
		225 : "END.IF",
		226 : "FOR.CELL",
		227 : "MEDIAN",
		228 : "SUMPRODUCT",
		229 : "SINH",
		230 : "COSH",
		231 : "TANH",
		232 : "ASINH",
		233 : "ACOSH",
		234 : "ATANH",
		235 : "DGET",
		236 : "CREATE.OBJECT",
		237 : "VOLATILE",
		238 : "LAST.ERROR",
		239 : "CUSTOM.UNDO",
		240 : "CUSTOM.REPEAT",
		241 : "FORMULA.CONVERT",
		242 : "GET.LINK.INFO",
		243 : "TEXT.BOX",
		244 : "INFO",
		245 : "GROUP",
		246 : "GET.OBJECT",
		247 : "DB",
		248 : "PAUSE",
		251 : "RESUME",
		252 : "FREQUENCY",
		253 : "ADD.TOOLBAR",
		254 : "DELETE.TOOLBAR",
		255 : "User",
		256 : "RESET.TOOLBAR",
		257 : "EVALUATE",
		258 : "GET.TOOLBAR",
		259 : "GET.TOOL",
		260 : "SPELLING.CHECK",
		261 : "ERROR.TYPE",
		262 : "APP.TITLE",
		263 : "WINDOW.TITLE",
		264 : "SAVE.TOOLBAR",
		265 : "ENABLE.TOOL",
		266 : "PRESS.TOOL",
		267 : "REGISTER.ID",
		268 : "GET.WORKBOOK",
		269 : "AVEDEV",
		270 : "BETADIST",
		271 : "GAMMALN",
		272 : "BETAINV",
		273 : "BINOMDIST",
		274 : "CHIDIST",
		275 : "CHIINV",
		276 : "COMBIN",
		277 : "CONFIDENCE",
		278 : "CRITBINOM",
		279 : "EVEN",
		280 : "EXPONDIST",
		281 : "FDIST",
		282 : "FINV",
		283 : "FISHER",
		284 : "FISHERINV",
		285 : "FLOOR",
		286 : "GAMMADIST",
		287 : "GAMMAINV",
		288 : "CEILING",
		289 : "HYPGEOMDIST",
		290 : "LOGNORMDIST",
		291 : "LOGINV",
		292 : "NEGBINOMDIST",
		293 : "NORMDIST",
		294 : "NORMSDIST",
		295 : "NORMINV",
		296 : "NORMSINV",
		297 : "STANDARDIZE",
		298 : "ODD",
		299 : "PERMUT",
		300 : "POISSON",
		301 : "TDIST",
		302 : "WEIBULL",
		303 : "SUMXMY2",
		304 : "SUMX2MY2",
		305 : "SUMX2PY2",
		306 : "CHITEST",
		307 : "CORREL",
		308 : "COVAR",
		309 : "FORECAST",
		310 : "FTEST",
		311 : "INTERCEPT",
		312 : "PEARSON",
		313 : "RSQ",
		314 : "STEYX",
		315 : "SLOPE",
		316 : "TTEST",
		317 : "PROB",
		318 : "DEVSQ",
		319 : "GEOMEAN",
		320 : "HARMEAN",
		321 : "SUMSQ",
		322 : "KURT",
		323 : "SKEW",
		324 : "ZTEST",
		325 : "LARGE",
		326 : "SMALL",
		327 : "QUARTILE",
		328 : "PERCENTILE",
		329 : "PERCENTRANK",
		330 : "MODE",
		331 : "TRIMMEAN",
		332 : "TINV",
		334 : "MOVIE.COMMAND",
		335 : "GET.MOVIE",
		336 : "CONCATENATE",
		337 : "POWER",
		338 : "PIVOT.ADD.DATA",
		339 : "GET.PIVOT.TABLE",
		340 : "GET.PIVOT.FIELD",
		341 : "GET.PIVOT.ITEM",
		342 : "RADIANS",
		343 : "DEGREES",
		344 : "SUBTOTAL",
		345 : "SUMIF",
		346 : "COUNTIF",
		347 : "COUNTBLANK",
		348 : "SCENARIO.GET",
		349 : "OPTIONS.LISTS.GET",
		350 : "ISPMT",
		351 : "DATEDIF",
		352 : "DATESTRING",
		353 : "NUMBERSTRING",
		354 : "ROMAN",
		355 : "OPEN.DIALOG",
		356 : "SAVE.DIALOG",
		357 : "VIEW.GET",
		358 : "GETPIVOTDATA",
		359 : "HYPERLINK",
		360 : "PHONETIC",
		361 : "AVERAGEA",
		362 : "MAXA",
		363 : "MINA",
		364 : "STDEVPA",
		365 : "VARPA",
		366 : "STDEVA",
		367 : "VARA",
		368 : "BAHTTEXT",
		369 : "THAIDAYOFWEEK",
		370 : "THAIDIGIT",
		371 : "THAIMONTHOFYEAR",
		372 : "THAINUMSOUND",
		373 : "THAINUMSTRING",
		374 : "THAISTRINGLENGTH",
		375 : "ISTHAIDIGIT",
		376 : "ROUNDBAHTDOWN",
		377 : "ROUNDBAHTUP",
		378 : "THAIYEAR",
		379 : "RTD"
	};
	var FtabArgc = {
		2 : 1,
		3 : 1,
		15 : 1,
		16 : 1,
		17 : 1,
		18 : 1,
		20 : 1,
		21 : 1,
		22 : 1,
		23 : 1,
		24 : 1,
		25 : 1,
		26 : 1,
		27 : 2,
		30 : 2,
		31 : 3,
		32 : 1,
		33 : 1,
		38 : 1,
		39 : 2,
		40 : 3,
		41 : 3,
		42 : 3,
		43 : 3,
		44 : 3,
		45 : 3,
		47 : 3,
		48 : 2,
		53 : 1,
		61 : 3,
		65 : 3,
		66 : 3,
		67 : 1,
		68 : 1,
		69 : 1,
		71 : 1,
		72 : 1,
		73 : 1,
		75 : 1,
		76 : 1,
		77 : 1,
		79 : 2,
		80 : 2,
		83 : 1,
		86 : 1,
		90 : 1,
		97 : 2,
		98 : 1,
		99 : 1,
		105 : 1,
		111 : 1,
		112 : 1,
		113 : 1,
		114 : 1,
		117 : 2,
		118 : 1,
		119 : 4,
		121 : 1,
		126 : 1,
		127 : 1,
		128 : 1,
		129 : 1,
		130 : 1,
		131 : 1,
		133 : 1,
		134 : 1,
		135 : 1,
		136 : 2,
		137 : 2,
		138 : 2,
		140 : 1,
		141 : 1,
		142 : 3,
		143 : 4,
		162 : 1,
		163 : 1,
		164 : 1,
		165 : 2,
		172 : 1,
		175 : 2,
		176 : 2,
		177 : 3,
		178 : 2,
		179 : 1,
		184 : 1,
		189 : 3,
		190 : 1,
		195 : 3,
		196 : 3,
		198 : 1,
		199 : 3,
		201 : 1,
		207 : 4,
		210 : 3,
		211 : 1,
		212 : 2,
		213 : 2,
		214 : 1,
		215 : 1,
		229 : 1,
		230 : 1,
		231 : 1,
		232 : 1,
		233 : 1,
		234 : 1,
		235 : 3,
		244 : 1,
		252 : 2,
		257 : 1,
		261 : 1,
		271 : 1,
		273 : 4,
		274 : 2,
		275 : 2,
		276 : 2,
		277 : 3,
		278 : 3,
		279 : 1,
		280 : 3,
		281 : 3,
		282 : 3,
		283 : 1,
		284 : 1,
		285 : 2,
		286 : 4,
		287 : 3,
		288 : 2,
		289 : 4,
		290 : 3,
		291 : 3,
		292 : 3,
		293 : 4,
		294 : 1,
		295 : 3,
		296 : 1,
		297 : 3,
		298 : 1,
		299 : 2,
		300 : 3,
		301 : 3,
		302 : 4,
		303 : 2,
		304 : 2,
		305 : 2,
		306 : 2,
		307 : 2,
		308 : 2,
		309 : 3,
		310 : 2,
		311 : 2,
		312 : 2,
		313 : 2,
		314 : 2,
		315 : 2,
		316 : 4,
		325 : 2,
		326 : 2,
		327 : 2,
		328 : 2,
		331 : 2,
		332 : 2,
		337 : 2,
		342 : 1,
		343 : 1,
		346 : 2,
		347 : 1,
		350 : 4,
		351 : 3,
		352 : 1,
		353 : 2,
		360 : 1,
		368 : 1,
		369 : 1,
		370 : 1,
		371 : 1,
		372 : 1,
		373 : 1,
		374 : 1,
		375 : 1,
		376 : 1,
		377 : 1,
		378 : 1,
		65535 : 0
	};
	var XLSXFutureFunctions = {
		"_xlfn.ACOT" : "ACOT",
		"_xlfn.ACOTH" : "ACOTH",
		"_xlfn.AGGREGATE" : "AGGREGATE",
		"_xlfn.ARABIC" : "ARABIC",
		"_xlfn.AVERAGEIF" : "AVERAGEIF",
		"_xlfn.AVERAGEIFS" : "AVERAGEIFS",
		"_xlfn.BASE" : "BASE",
		"_xlfn.BETA.DIST" : "BETA.DIST",
		"_xlfn.BETA.INV" : "BETA.INV",
		"_xlfn.BINOM.DIST" : "BINOM.DIST",
		"_xlfn.BINOM.DIST.RANGE" : "BINOM.DIST.RANGE",
		"_xlfn.BINOM.INV" : "BINOM.INV",
		"_xlfn.BITAND" : "BITAND",
		"_xlfn.BITLSHIFT" : "BITLSHIFT",
		"_xlfn.BITOR" : "BITOR",
		"_xlfn.BITRSHIFT" : "BITRSHIFT",
		"_xlfn.BITXOR" : "BITXOR",
		"_xlfn.CEILING.MATH" : "CEILING.MATH",
		"_xlfn.CEILING.PRECISE" : "CEILING.PRECISE",
		"_xlfn.CHISQ.DIST" : "CHISQ.DIST",
		"_xlfn.CHISQ.DIST.RT" : "CHISQ.DIST.RT",
		"_xlfn.CHISQ.INV" : "CHISQ.INV",
		"_xlfn.CHISQ.INV.RT" : "CHISQ.INV.RT",
		"_xlfn.CHISQ.TEST" : "CHISQ.TEST",
		"_xlfn.COMBINA" : "COMBINA",
		"_xlfn.CONFIDENCE.NORM" : "CONFIDENCE.NORM",
		"_xlfn.CONFIDENCE.T" : "CONFIDENCE.T",
		"_xlfn.COT" : "COT",
		"_xlfn.COTH" : "COTH",
		"_xlfn.COUNTIFS" : "COUNTIFS",
		"_xlfn.COVARIANCE.P" : "COVARIANCE.P",
		"_xlfn.COVARIANCE.S" : "COVARIANCE.S",
		"_xlfn.CSC" : "CSC",
		"_xlfn.CSCH" : "CSCH",
		"_xlfn.DAYS" : "DAYS",
		"_xlfn.DECIMAL" : "DECIMAL",
		"_xlfn.ECMA.CEILING" : "ECMA.CEILING",
		"_xlfn.ERF.PRECISE" : "ERF.PRECISE",
		"_xlfn.ERFC.PRECISE" : "ERFC.PRECISE",
		"_xlfn.EXPON.DIST" : "EXPON.DIST",
		"_xlfn.F.DIST" : "F.DIST",
		"_xlfn.F.DIST.RT" : "F.DIST.RT",
		"_xlfn.F.INV" : "F.INV",
		"_xlfn.F.INV.RT" : "F.INV.RT",
		"_xlfn.F.TEST" : "F.TEST",
		"_xlfn.FILTERXML" : "FILTERXML",
		"_xlfn.FLOOR.MATH" : "FLOOR.MATH",
		"_xlfn.FLOOR.PRECISE" : "FLOOR.PRECISE",
		"_xlfn.FORMULATEXT" : "FORMULATEXT",
		"_xlfn.GAMMA" : "GAMMA",
		"_xlfn.GAMMA.DIST" : "GAMMA.DIST",
		"_xlfn.GAMMA.INV" : "GAMMA.INV",
		"_xlfn.GAMMALN.PRECISE" : "GAMMALN.PRECISE",
		"_xlfn.GAUSS" : "GAUSS",
		"_xlfn.HYPGEOM.DIST" : "HYPGEOM.DIST",
		"_xlfn.IFNA" : "IFNA",
		"_xlfn.IFERROR" : "IFERROR",
		"_xlfn.IMCOSH" : "IMCOSH",
		"_xlfn.IMCOT" : "IMCOT",
		"_xlfn.IMCSC" : "IMCSC",
		"_xlfn.IMCSCH" : "IMCSCH",
		"_xlfn.IMSEC" : "IMSEC",
		"_xlfn.IMSECH" : "IMSECH",
		"_xlfn.IMSINH" : "IMSINH",
		"_xlfn.IMTAN" : "IMTAN",
		"_xlfn.ISFORMULA" : "ISFORMULA",
		"_xlfn.ISO.CEILING" : "ISO.CEILING",
		"_xlfn.ISOWEEKNUM" : "ISOWEEKNUM",
		"_xlfn.LOGNORM.DIST" : "LOGNORM.DIST",
		"_xlfn.LOGNORM.INV" : "LOGNORM.INV",
		"_xlfn.MODE.MULT" : "MODE.MULT",
		"_xlfn.MODE.SNGL" : "MODE.SNGL",
		"_xlfn.MUNIT" : "MUNIT",
		"_xlfn.NEGBINOM.DIST" : "NEGBINOM.DIST",
		"_xlfn.NETWORKDAYS.INTL" : "NETWORKDAYS.INTL",
		"_xlfn.NIGBINOM" : "NIGBINOM",
		"_xlfn.NORM.DIST" : "NORM.DIST",
		"_xlfn.NORM.INV" : "NORM.INV",
		"_xlfn.NORM.S.DIST" : "NORM.S.DIST",
		"_xlfn.NORM.S.INV" : "NORM.S.INV",
		"_xlfn.NUMBERVALUE" : "NUMBERVALUE",
		"_xlfn.PDURATION" : "PDURATION",
		"_xlfn.PERCENTILE.EXC" : "PERCENTILE.EXC",
		"_xlfn.PERCENTILE.INC" : "PERCENTILE.INC",
		"_xlfn.PERCENTRANK.EXC" : "PERCENTRANK.EXC",
		"_xlfn.PERCENTRANK.INC" : "PERCENTRANK.INC",
		"_xlfn.PERMUTATIONA" : "PERMUTATIONA",
		"_xlfn.PHI" : "PHI",
		"_xlfn.POISSON.DIST" : "POISSON.DIST",
		"_xlfn.QUARTILE.EXC" : "QUARTILE.EXC",
		"_xlfn.QUARTILE.INC" : "QUARTILE.INC",
		"_xlfn.QUERYSTRING" : "QUERYSTRING",
		"_xlfn.RANK.AVG" : "RANK.AVG",
		"_xlfn.RANK.EQ" : "RANK.EQ",
		"_xlfn.RRI" : "RRI",
		"_xlfn.SEC" : "SEC",
		"_xlfn.SECH" : "SECH",
		"_xlfn.SHEET" : "SHEET",
		"_xlfn.SHEETS" : "SHEETS",
		"_xlfn.SKEW.P" : "SKEW.P",
		"_xlfn.STDEV.P" : "STDEV.P",
		"_xlfn.STDEV.S" : "STDEV.S",
		"_xlfn.SUMIFS" : "SUMIFS",
		"_xlfn.T.DIST" : "T.DIST",
		"_xlfn.T.DIST.2T" : "T.DIST.2T",
		"_xlfn.T.DIST.RT" : "T.DIST.RT",
		"_xlfn.T.INV" : "T.INV",
		"_xlfn.T.INV.2T" : "T.INV.2T",
		"_xlfn.T.TEST" : "T.TEST",
		"_xlfn.UNICHAR" : "UNICHAR",
		"_xlfn.UNICODE" : "UNICODE",
		"_xlfn.VAR.P" : "VAR.P",
		"_xlfn.VAR.S" : "VAR.S",
		"_xlfn.WEBSERVICE" : "WEBSERVICE",
		"_xlfn.WEIBULL.DIST" : "WEIBULL.DIST",
		"_xlfn.WORKDAY.INTL" : "WORKDAY.INTL",
		"_xlfn.XOR" : "XOR",
		"_xlfn.Z.TEST" : "Z.TEST"
	};
	var strs = {};
	var _ssfopts = {};
	RELS.WS = "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet";
	function get_sst_id(sst, str) {
		for (var i = 0, len = sst.length; i < len; ++i)
			if (sst[i].t === str) {
				sst.Count++;
				return i
			}
		sst[len] = {
			t : str
		};
		sst.Count++;
		sst.Unique++;
		return len
	}
	function get_cell_style(styles, cell, opts) {
		var z = opts.revssf[cell.z != null ? cell.z : "General"];
		for (var i = 0, len = styles.length; i != len; ++i)
			if (styles[i].numFmtId === z)
				return i;
		styles[len] = {
			numFmtId : z,
			fontId : 0,
			fillId : 0,
			borderId : 0,
			xfId : 0,
			applyNumberFormat : 1
		};
		return len
	}
	function safe_format(p, fmtid, fillid, opts) {
		try {
			if (p.t === "e")
				p.w = p.w || BErr[p.v];
			else if (fmtid === 0) {
				if (p.t === "n") {
					if ((p.v | 0) === p.v)
						p.w = SSF._general_int(p.v, _ssfopts);
					else
						p.w = SSF._general_num(p.v, _ssfopts)
				} else if (p.t === "d") {
					var dd = datenum(p.v);
					if ((dd | 0) === dd)
						p.w = SSF._general_int(dd, _ssfopts);
					else
						p.w = SSF._general_num(dd, _ssfopts)
				} else if (p.v === undefined)
					return "";
				else
					p.w = SSF._general(p.v, _ssfopts)
			} else if (p.t === "d")
				p.w = SSF.format(fmtid, datenum(p.v), _ssfopts);
			else
				p.w = SSF.format(fmtid, p.v, _ssfopts);
			if (opts.cellNF)
				p.z = SSF._table[fmtid]
		} catch (e) {
			if (opts.WTF)
				throw e
		}
		if (fillid)
			try {
				p.s = styles.Fills[fillid];
				if (p.s.fgColor && p.s.fgColor.theme) {
					p.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.fgColor.theme].rgb, p.s.fgColor.tint || 0);
					if (opts.WTF)
						p.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p.s.fgColor.theme].rgb
				}
				if (p.s.bgColor && p.s.bgColor.theme) {
					p.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p.s.bgColor.theme].rgb, p.s.bgColor.tint || 0);
					if (opts.WTF)
						p.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p.s.bgColor.theme].rgb
				}
			} catch (e) {
				if (opts.WTF)
					throw e
			}
	}
	function parse_ws_xml_dim(ws, s) {
		var d = safe_decode_range(s);
		if (d.s.r <= d.e.r && d.s.c <= d.e.c && d.s.r >= 0 && d.s.c >= 0)
			ws["!ref"] = encode_range(d)
	}
	var mergecregex = /<mergeCell ref="[A-Z0-9:]+"\s*\/>/g;
	var sheetdataregex = /<(?:\w+:)?sheetData>([^\u2603]*)<\/(?:\w+:)?sheetData>/;
	var hlinkregex = /<hyperlink[^>]*\/>/g;
	var dimregex = /"(\w*:\w*)"/;
	var colregex = /<col[^>]*\/>/g;
	function parse_ws_xml(data, opts, rels) {
		if (!data)
			return data;
		var s = {};
		var ridx = data.indexOf("<dimension");
		if (ridx > 0) {
			var ref = data.substr(ridx, 50).match(dimregex);
			if (ref != null)
				parse_ws_xml_dim(s, ref[1])
		}
		var mergecells = [];
		if (data.indexOf("</mergeCells>") !== -1) {
			var merges = data.match(mergecregex);
			for (ridx = 0; ridx != merges.length; ++ridx)
				mergecells[ridx] = safe_decode_range(merges[ridx].substr(merges[ridx].indexOf('"') + 1))
		}
		var columns = [];
		if (opts.cellStyles && data.indexOf("</cols>") !== -1) {
			var cols = data.match(colregex);
			parse_ws_xml_cols(columns, cols)
		}
		var refguess = {
			s : {
				r : 1e6,
				c : 1e6
			},
			e : {
				r : 0,
				c : 0
			}
		};
		var mtch = data.match(sheetdataregex);
		if (mtch)
			parse_ws_xml_data(mtch[1], s, opts, refguess);
		if (data.indexOf("</hyperlinks>") !== -1)
			parse_ws_xml_hlinks(s, data.match(hlinkregex), rels);
		if (!s["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r)
			s["!ref"] = encode_range(refguess);
		if (opts.sheetRows > 0 && s["!ref"]) {
			var tmpref = safe_decode_range(s["!ref"]);
			if (opts.sheetRows < +tmpref.e.r) {
				tmpref.e.r = opts.sheetRows - 1;
				if (tmpref.e.r > refguess.e.r)
					tmpref.e.r = refguess.e.r;
				if (tmpref.e.r < tmpref.s.r)
					tmpref.s.r = tmpref.e.r;
				if (tmpref.e.c > refguess.e.c)
					tmpref.e.c = refguess.e.c;
				if (tmpref.e.c < tmpref.s.c)
					tmpref.s.c = tmpref.e.c;
				s["!fullref"] = s["!ref"];
				s["!ref"] = encode_range(tmpref)
			}
		}
		if (mergecells.length > 0)
			s["!merges"] = mergecells;
		if (columns.length > 0)
			s["!cols"] = columns;
		return s
	}
	function write_ws_xml_merges(merges) {
		if (merges.length == 0)
			return "";
		var o = '<mergeCells count="' + merges.length + '">';
		for (var i = 0; i != merges.length; ++i)
			o += '<mergeCell ref="' + encode_range(merges[i]) + '"/>';
		return o + "</mergeCells>"
	}
	function parse_ws_xml_hlinks(s, data, rels) {
		for (var i = 0; i != data.length; ++i) {
			var val = parsexmltag(data[i], true);
			if (!val.ref)
				return;
			var rel = rels ? rels["!id"][val.id] : null;
			if (rel) {
				val.Target = rel.Target;
				if (val.location)
					val.Target += "#" + val.location;
				val.Rel = rel
			} else {
				val.Target = val.location;
				rel = {
					Target : val.location,
					TargetMode : "Internal"
				};
				val.Rel = rel
			}
			var rng = safe_decode_range(val.ref);
			for (var R = rng.s.r; R <= rng.e.r; ++R)
				for (var C = rng.s.c; C <= rng.e.c; ++C) {
					var addr = encode_cell({
							c : C,
							r : R
						});
					if (!s[addr])
						s[addr] = {
							t : "stub",
							v : undefined
						};
					s[addr].l = val
				}
		}
	}
	function parse_ws_xml_cols(columns, cols) {
		var seencol = false;
		for (var coli = 0; coli != cols.length; ++coli) {
			var coll = parsexmltag(cols[coli], true);
			var colm = parseInt(coll.min, 10) - 1,
			colM = parseInt(coll.max, 10) - 1;
			delete coll.min;
			delete coll.max;
			if (!seencol && coll.width) {
				seencol = true;
				find_mdw(+coll.width, coll)
			}
			if (coll.width) {
				coll.wpx = width2px(+coll.width);
				coll.wch = px2char(coll.wpx);
				coll.MDW = MDW
			}
			while (colm <= colM)
				columns[colm++] = coll
		}
	}
	function write_ws_xml_cols(ws, cols) {
		var o = ["<cols>"],
		col,
		width;
		for (var i = 0; i != cols.length; ++i) {
			if (!(col = cols[i]))
				continue;
			var p = {
				min : i + 1,
				max : i + 1
			};
			width = -1;
			if (col.wpx)
				width = px2char(col.wpx);
			else if (col.wch)
				width = col.wch;
			if (width > -1) {
				p.width = char2width(width);
				p.customWidth = 1
			}
			o[o.length] = writextag("col", null, p)
		}
		o[o.length] = "</cols>";
		return o.join("")
	}
	function write_ws_xml_cell(cell, ref, ws, opts, idx, wb) {
		if (cell.v === undefined)
			return "";
		var vv = "";
		var oldt = cell.t,
		oldv = cell.v;
		switch (cell.t) {
		case "b":
			vv = cell.v ? "1" : "0";
			break;
		case "n":
			vv = "" + cell.v;
			break;
		case "e":
			vv = BErr[cell.v];
			break;
		case "d":
			if (opts.cellDates)
				vv = new Date(cell.v).toISOString();
			else {
				cell.t = "n";
				vv = "" + (cell.v = datenum(cell.v));
				if (typeof cell.z === "undefined")
					cell.z = SSF._table[14]
			}
			break;
		default:
			vv = cell.v;
			break
		}
		var v = writetag("v", escapexml(vv)),
		o = {
			r : ref
		};
		var os = get_cell_style(opts.cellXfs, cell, opts);
		if (os !== 0)
			o.s = os;
		switch (cell.t) {
		case "n":
			break;
		case "d":
			o.t = "d";
			break;
		case "b":
			o.t = "b";
			break;
		case "e":
			o.t = "e";
			break;
		default:
			if (opts.bookSST) {
				v = writetag("v", "" + get_sst_id(opts.Strings, cell.v));
				o.t = "s";
				break
			}
			o.t = "str";
			break
		}
		if (cell.t != oldt) {
			cell.t = oldt;
			cell.v = oldv
		}
		return writextag("c", v, o)
	}
	var parse_ws_xml_data = function parse_ws_xml_data_factory() {
		var cellregex = /<(?:\w+:)?c[ >]/,
		rowregex = /<\/(?:\w+:)?row>/;
		var rregex = /r=["']([^"']*)["']/,
		isregex = /<is>([\S\s]*?)<\/is>/;
		var match_v = matchtag("v"),
		match_f = matchtag("f");
		return function parse_ws_xml_data(sdata, s, opts, guess) {
			var ri = 0,
			x = "",
			cells = [],
			cref = [],
			idx = 0,
			i = 0,
			cc = 0,
			d = "",
			p;
			var tag,
			tagr = 0,
			tagc = 0;
			var sstr;
			var fmtid = 0,
			fillid = 0,
			do_format = Array.isArray(styles.CellXf),
			cf;
			for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
				x = marr[mt].trim();
				var xlen = x.length;
				if (xlen === 0)
					continue;
				for (ri = 0; ri < xlen; ++ri)
					if (x.charCodeAt(ri) === 62)
						break;
				++ri;
				tag = parsexmltag(x.substr(0, ri), true);
				tagr = typeof tag.r !== "undefined" ? parseInt(tag.r, 10) : tagr + 1;
				tagc = -1;
				if (opts.sheetRows && opts.sheetRows < tagr)
					continue;
				if (guess.s.r > tagr - 1)
					guess.s.r = tagr - 1;
				if (guess.e.r < tagr - 1)
					guess.e.r = tagr - 1;
				cells = x.substr(ri).split(cellregex);
				for (ri = typeof tag.r === "undefined" ? 0 : 1; ri != cells.length; ++ri) {
					x = cells[ri].trim();
					if (x.length === 0)
						continue;
					cref = x.match(rregex);
					idx = ri;
					i = 0;
					cc = 0;
					x = "<c " + (x.substr(0, 1) == "<" ? ">" : "") + x;
					if (cref !== null && cref.length === 2) {
						idx = 0;
						d = cref[1];
						for (i = 0; i != d.length; ++i) {
							if ((cc = d.charCodeAt(i) - 64) < 1 || cc > 26)
								break;
							idx = 26 * idx + cc
						}
						--idx;
						tagc = idx
					} else ++tagc;
					for (i = 0; i != x.length; ++i)
						if (x.charCodeAt(i) === 62)
							break;
					++i;
					tag = parsexmltag(x.substr(0, i), true);
					if (!tag.r)
						tag.r = utils.encode_cell({
								r : tagr - 1,
								c : tagc
							});
					d = x.substr(i);
					p = {
						t : ""
					};
					if ((cref = d.match(match_v)) !== null && cref[1] !== "")
						p.v = unescapexml(cref[1]);
					if (opts.cellFormula && (cref = d.match(match_f)) !== null)
						p.f = unescapexml(cref[1]);
					if (tag.t === undefined && p.v === undefined) {
						if (!opts.sheetStubs)
							continue;
						p.t = "stub"
					} else
						p.t = tag.t || "n";
					if (guess.s.c > idx)
						guess.s.c = idx;
					if (guess.e.c < idx)
						guess.e.c = idx;
					switch (p.t) {
					case "n":
						p.v = parseFloat(p.v);
						break;
					case "s":
						sstr = strs[parseInt(p.v, 10)];
						p.v = sstr.t;
						p.r = sstr.r;
						if (opts.cellHTML)
							p.h = sstr.h;
						break;
					case "str":
						p.t = "s";
						p.v = p.v != null ? utf8read(p.v) : "";
						if (opts.cellHTML)
							p.h = p.v;
						break;
					case "inlineStr":
						cref = d.match(isregex);
						p.t = "s";
						if (cref !== null) {
							sstr = parse_si(cref[1]);
							p.v = sstr.t
						} else
							p.v = "";
						break;
					case "b":
						p.v = parsexmlbool(p.v);
						break;
					case "d":
						if (!opts.cellDates) {
							p.v = datenum(p.v);
							p.t = "n"
						}
						break;
					case "e":
						p.w = p.v;
						p.v = RBErr[p.v];
						break
					}
					fmtid = fillid = 0;
					if (do_format && tag.s !== undefined) {
						cf = styles.CellXf[tag.s];
						if (cf != null) {
							if (cf.numFmtId != null)
								fmtid = cf.numFmtId;
							if (opts.cellStyles && cf.fillId != null)
								fillid = cf.fillId
						}
					}
					safe_format(p, fmtid, fillid, opts);
					s[tag.r] = p
				}
			}
		}
	}();
	function write_ws_xml_data(ws, opts, idx, wb) {
		var o = [],
		r = [],
		range = safe_decode_range(ws["!ref"]),
		cell,
		ref,
		rr = "",
		cols = [],
		R,
		C;
		for (C = range.s.c; C <= range.e.c; ++C)
			cols[C] = encode_col(C);
		for (R = range.s.r; R <= range.e.r; ++R) {
			r = [];
			rr = encode_row(R);
			for (C = range.s.c; C <= range.e.c; ++C) {
				ref = cols[C] + rr;
				if (ws[ref] === undefined)
					continue;
				if ((cell = write_ws_xml_cell(ws[ref], ref, ws, opts, idx, wb)) != null)
					r.push(cell)
			}
			if (r.length > 0)
				o[o.length] = writextag("row", r.join(""), {
						r : rr
					})
		}
		return o.join("")
	}
	var WS_XML_ROOT = writextag("worksheet", null, {
			xmlns : XMLNS.main[0],
			"xmlns:r" : XMLNS.r
		});
	function write_ws_xml(idx, opts, wb) {
		var o = [XML_HEADER, WS_XML_ROOT];
		var s = wb.SheetNames[idx],
		sidx = 0,
		rdata = "";
		var ws = wb.Sheets[s];
		if (ws === undefined)
			ws = {};
		var ref = ws["!ref"];
		if (ref === undefined)
			ref = "A1";
		o[o.length] = writextag("dimension", null, {
				ref : ref
			});
		if (ws["!cols"] !== undefined && ws["!cols"].length > 0)
			o[o.length] = write_ws_xml_cols(ws, ws["!cols"]);
		o[sidx = o.length] = "<sheetData/>";
		if (ws["!ref"] !== undefined) {
			rdata = write_ws_xml_data(ws, opts, idx, wb);
			if (rdata.length > 0)
				o[o.length] = rdata
		}
		if (o.length > sidx + 1) {
			o[o.length] = "</sheetData>";
			o[sidx] = o[sidx].replace("/>", ">")
		}
		if (ws["!merges"] !== undefined && ws["!merges"].length > 0)
			o[o.length] = write_ws_xml_merges(ws["!merges"]);
		if (o.length > 2) {
			o[o.length] = "</worksheet>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	function parse_BrtRowHdr(data, length) {
		var z = [];
		z.r = data.read_shift(4);
		data.l += length - 4;
		return z
	}
	var parse_BrtWsDim = parse_UncheckedRfX;
	var write_BrtWsDim = write_UncheckedRfX;
	function parse_BrtWsProp(data, length) {
		var z = {};
		data.l += 19;
		z.name = parse_XLSBCodeName(data, length - 19);
		return z
	}
	function parse_BrtCellBlank(data, length) {
		var cell = parse_XLSBCell(data);
		return [cell]
	}
	function write_BrtCellBlank(cell, val, o) {
		if (o == null)
			o = new_buf(8);
		return write_XLSBCell(val, o)
	}
	function parse_BrtCellBool(data, length) {
		var cell = parse_XLSBCell(data);
		var fBool = data.read_shift(1);
		return [cell, fBool, "b"]
	}
	function parse_BrtCellError(data, length) {
		var cell = parse_XLSBCell(data);
		var fBool = data.read_shift(1);
		return [cell, fBool, "e"]
	}
	function parse_BrtCellIsst(data, length) {
		var cell = parse_XLSBCell(data);
		var isst = data.read_shift(4);
		return [cell, isst, "s"]
	}
	function parse_BrtCellReal(data, length) {
		var cell = parse_XLSBCell(data);
		var value = parse_Xnum(data);
		return [cell, value, "n"]
	}
	function parse_BrtCellRk(data, length) {
		var cell = parse_XLSBCell(data);
		var value = parse_RkNumber(data);
		return [cell, value, "n"]
	}
	function parse_BrtCellSt(data, length) {
		var cell = parse_XLSBCell(data);
		var value = parse_XLWideString(data);
		return [cell, value, "str"]
	}
	function parse_BrtFmlaBool(data, length, opts) {
		var cell = parse_XLSBCell(data);
		var value = data.read_shift(1);
		var o = [cell, value, "b"];
		if (opts.cellFormula) {
			var formula = parse_XLSBCellParsedFormula(data, length - 9);
			o[3] = ""
		} else
			data.l += length - 9;
		return o
	}
	function parse_BrtFmlaError(data, length, opts) {
		var cell = parse_XLSBCell(data);
		var value = data.read_shift(1);
		var o = [cell, value, "e"];
		if (opts.cellFormula) {
			var formula = parse_XLSBCellParsedFormula(data, length - 9);
			o[3] = ""
		} else
			data.l += length - 9;
		return o
	}
	function parse_BrtFmlaNum(data, length, opts) {
		var cell = parse_XLSBCell(data);
		var value = parse_Xnum(data);
		var o = [cell, value, "n"];
		if (opts.cellFormula) {
			var formula = parse_XLSBCellParsedFormula(data, length - 16);
			o[3] = ""
		} else
			data.l += length - 16;
		return o
	}
	function parse_BrtFmlaString(data, length, opts) {
		var start = data.l;
		var cell = parse_XLSBCell(data);
		var value = parse_XLWideString(data);
		var o = [cell, value, "str"];
		if (opts.cellFormula) {
			var formula = parse_XLSBCellParsedFormula(data, start + length - data.l)
		} else
			data.l = start + length;
		return o
	}
	var parse_BrtMergeCell = parse_UncheckedRfX;
	function parse_BrtHLink(data, length, opts) {
		var end = data.l + length;
		var rfx = parse_UncheckedRfX(data, 16);
		var relId = parse_XLNullableWideString(data);
		var loc = parse_XLWideString(data);
		var tooltip = parse_XLWideString(data);
		var display = parse_XLWideString(data);
		data.l = end;
		return {
			rfx : rfx,
			relId : relId,
			loc : loc,
			tooltip : tooltip,
			display : display
		}
	}
	function parse_ws_bin(data, opts, rels) {
		if (!data)
			return data;
		if (!rels)
			rels = {
				"!id" : {}

			};
		var s = {};
		var ref;
		var refguess = {
			s : {
				r : 1e6,
				c : 1e6
			},
			e : {
				r : 0,
				c : 0
			}
		};
		var pass = false,
		end = false;
		var row,
		p,
		cf,
		R,
		C,
		addr,
		sstr,
		rr;
		var mergecells = [];
		recordhopper(data, function ws_parse(val, R) {
			if (end)
				return;
			switch (R.n) {
			case "BrtWsDim":
				ref = val;
				break;
			case "BrtRowHdr":
				row = val;
				if (opts.sheetRows && opts.sheetRows <= row.r)
					end = true;
				rr = encode_row(row.r);
				break;
			case "BrtFmlaBool":
			case "BrtFmlaError":
			case "BrtFmlaNum":
			case "BrtFmlaString":
			case "BrtCellBool":
			case "BrtCellError":
			case "BrtCellIsst":
			case "BrtCellReal":
			case "BrtCellRk":
			case "BrtCellSt":
				p = {
					t : val[2]
				};
				switch (val[2]) {
				case "n":
					p.v = val[1];
					break;
				case "s":
					sstr = strs[val[1]];
					p.v = sstr.t;
					p.r = sstr.r;
					break;
				case "b":
					p.v = val[1] ? true : false;
					break;
				case "e":
					p.v = val[1];
					p.w = BErr[p.v];
					break;
				case "str":
					p.t = "s";
					p.v = utf8read(val[1]);
					break
				}
				if (opts.cellFormula && val.length > 3)
					p.f = val[3];
				if (cf = styles.CellXf[val[0].iStyleRef])
					safe_format(p, cf.ifmt, null, opts);
				s[encode_col(C = val[0].c) + rr] = p;
				if (refguess.s.r > row.r)
					refguess.s.r = row.r;
				if (refguess.s.c > C)
					refguess.s.c = C;
				if (refguess.e.r < row.r)
					refguess.e.r = row.r;
				if (refguess.e.c < C)
					refguess.e.c = C;
				break;
			case "BrtCellBlank":
				if (!opts.sheetStubs)
					break;
				p = {
					t : "s",
					v : undefined
				};
				s[encode_col(C = val[0].c) + rr] = p;
				if (refguess.s.r > row.r)
					refguess.s.r = row.r;
				if (refguess.s.c > C)
					refguess.s.c = C;
				if (refguess.e.r < row.r)
					refguess.e.r = row.r;
				if (refguess.e.c < C)
					refguess.e.c = C;
				break;
			case "BrtBeginMergeCells":
				break;
			case "BrtEndMergeCells":
				break;
			case "BrtMergeCell":
				mergecells.push(val);
				break;
			case "BrtHLink":
				var rel = rels["!id"][val.relId];
				if (rel) {
					val.Target = rel.Target;
					if (val.loc)
						val.Target += "#" + val.loc;
					val.Rel = rel
				}
				for (R = val.rfx.s.r; R <= val.rfx.e.r; ++R)
					for (C = val.rfx.s.c; C <= val.rfx.e.c; ++C) {
						addr = encode_cell({
								c : C,
								r : R
							});
						if (!s[addr])
							s[addr] = {
								t : "s",
								v : undefined
							};
						s[addr].l = val
					}
				break;
			case "BrtArrFmla":
				break;
			case "BrtShrFmla":
				break;
			case "BrtBeginSheet":
				break;
			case "BrtWsProp":
				break;
			case "BrtSheetCalcProp":
				break;
			case "BrtBeginWsViews":
				break;
			case "BrtBeginWsView":
				break;
			case "BrtPane":
				break;
			case "BrtSel":
				break;
			case "BrtEndWsView":
				break;
			case "BrtEndWsViews":
				break;
			case "BrtACBegin":
				break;
			case "BrtRwDescent":
				break;
			case "BrtACEnd":
				break;
			case "BrtWsFmtInfoEx14":
				break;
			case "BrtWsFmtInfo":
				break;
			case "BrtBeginColInfos":
				break;
			case "BrtColInfo":
				break;
			case "BrtEndColInfos":
				break;
			case "BrtBeginSheetData":
				break;
			case "BrtEndSheetData":
				break;
			case "BrtSheetProtection":
				break;
			case "BrtPrintOptions":
				break;
			case "BrtMargins":
				break;
			case "BrtPageSetup":
				break;
			case "BrtFRTBegin":
				pass = true;
				break;
			case "BrtFRTEnd":
				pass = false;
				break;
			case "BrtEndSheet":
				break;
			case "BrtDrawing":
				break;
			case "BrtLegacyDrawing":
				break;
			case "BrtLegacyDrawingHF":
				break;
			case "BrtPhoneticInfo":
				break;
			case "BrtBeginHeaderFooter":
				break;
			case "BrtEndHeaderFooter":
				break;
			case "BrtBrk":
				break;
			case "BrtBeginRwBrk":
				break;
			case "BrtEndRwBrk":
				break;
			case "BrtBeginColBrk":
				break;
			case "BrtEndColBrk":
				break;
			case "BrtBeginUserShViews":
				break;
			case "BrtBeginUserShView":
				break;
			case "BrtEndUserShView":
				break;
			case "BrtEndUserShViews":
				break;
			case "BrtBkHim":
				break;
			case "BrtBeginOleObjects":
				break;
			case "BrtOleObject":
				break;
			case "BrtEndOleObjects":
				break;
			case "BrtBeginListParts":
				break;
			case "BrtListPart":
				break;
			case "BrtEndListParts":
				break;
			case "BrtBeginSortState":
				break;
			case "BrtBeginSortCond":
				break;
			case "BrtEndSortCond":
				break;
			case "BrtEndSortState":
				break;
			case "BrtBeginConditionalFormatting":
				break;
			case "BrtEndConditionalFormatting":
				break;
			case "BrtBeginCFRule":
				break;
			case "BrtEndCFRule":
				break;
			case "BrtBeginDVals":
				break;
			case "BrtDVal":
				break;
			case "BrtEndDVals":
				break;
			case "BrtRangeProtection":
				break;
			case "BrtBeginDCon":
				break;
			case "BrtEndDCon":
				break;
			case "BrtBeginDRefs":
				break;
			case "BrtDRef":
				break;
			case "BrtEndDRefs":
				break;
			case "BrtBeginActiveXControls":
				break;
			case "BrtActiveX":
				break;
			case "BrtEndActiveXControls":
				break;
			case "BrtBeginAFilter":
				break;
			case "BrtEndAFilter":
				break;
			case "BrtBeginFilterColumn":
				break;
			case "BrtBeginFilters":
				break;
			case "BrtFilter":
				break;
			case "BrtEndFilters":
				break;
			case "BrtEndFilterColumn":
				break;
			case "BrtDynamicFilter":
				break;
			case "BrtTop10Filter":
				break;
			case "BrtBeginCustomFilters":
				break;
			case "BrtCustomFilter":
				break;
			case "BrtEndCustomFilters":
				break;
			case "BrtBeginSmartTags":
				break;
			case "BrtBeginCellSmartTags":
				break;
			case "BrtBeginCellSmartTag":
				break;
			case "BrtCellSmartTagProperty":
				break;
			case "BrtEndCellSmartTag":
				break;
			case "BrtEndCellSmartTags":
				break;
			case "BrtEndSmartTags":
				break;
			case "BrtBeginCellWatches":
				break;
			case "BrtCellWatch":
				break;
			case "BrtEndCellWatches":
				break;
			case "BrtTable":
				break;
			case "BrtBeginCellIgnoreECs":
				break;
			case "BrtCellIgnoreEC":
				break;
			case "BrtEndCellIgnoreECs":
				break;
			default:
				if (!pass || opts.WTF)
					throw new Error("Unexpected record " + R.n)
			}
		}, opts);
		if (!s["!ref"] && (refguess.s.r < 1e6 || ref.e.r > 0 || ref.e.c > 0 || ref.s.r > 0 || ref.s.c > 0))
			s["!ref"] = encode_range(ref);
		if (opts.sheetRows && s["!ref"]) {
			var tmpref = safe_decode_range(s["!ref"]);
			if (opts.sheetRows < +tmpref.e.r) {
				tmpref.e.r = opts.sheetRows - 1;
				if (tmpref.e.r > refguess.e.r)
					tmpref.e.r = refguess.e.r;
				if (tmpref.e.r < tmpref.s.r)
					tmpref.s.r = tmpref.e.r;
				if (tmpref.e.c > refguess.e.c)
					tmpref.e.c = refguess.e.c;
				if (tmpref.e.c < tmpref.s.c)
					tmpref.s.c = tmpref.e.c;
				s["!fullref"] = s["!ref"];
				s["!ref"] = encode_range(tmpref)
			}
		}
		if (mergecells.length > 0)
			s["!merges"] = mergecells;
		return s
	}
	function write_ws_bin_cell(ba, cell, R, C, opts) {
		if (cell.v === undefined)
			return "";
		var vv = "";
		switch (cell.t) {
		case "b":
			vv = cell.v ? "1" : "0";
			break;
		case "n":
		case "e":
			vv = "" + cell.v;
			break;
		default:
			vv = cell.v;
			break
		}
		var o = {
			r : R,
			c : C
		};
		o.s = get_cell_style(opts.cellXfs, cell, opts);
		switch (cell.t) {
		case "s":
		case "str":
			if (opts.bookSST) {
				vv = get_sst_id(opts.Strings, cell.v);
				o.t = "s";
				break
			}
			o.t = "str";
			break;
		case "n":
			break;
		case "b":
			o.t = "b";
			break;
		case "e":
			o.t = "e";
			break
		}
		write_record(ba, "BrtCellBlank", write_BrtCellBlank(cell, o))
	}
	function write_CELLTABLE(ba, ws, idx, opts, wb) {
		var range = safe_decode_range(ws["!ref"] || "A1"),
		ref,
		rr = "",
		cols = [];
		write_record(ba, "BrtBeginSheetData");
		for (var R = range.s.r; R <= range.e.r; ++R) {
			rr = encode_row(R);
			for (var C = range.s.c; C <= range.e.c; ++C) {
				if (R === range.s.r)
					cols[C] = encode_col(C);
				ref = cols[C] + rr;
				if (!ws[ref])
					continue;
				write_ws_bin_cell(ba, ws[ref], R, C, opts)
			}
		}
		write_record(ba, "BrtEndSheetData")
	}
	function write_ws_bin(idx, opts, wb) {
		var ba = buf_array();
		var s = wb.SheetNames[idx],
		ws = wb.Sheets[s] || {};
		var r = safe_decode_range(ws["!ref"] || "A1");
		write_record(ba, "BrtBeginSheet");
		write_record(ba, "BrtWsDim", write_BrtWsDim(r));
		write_CELLTABLE(ba, ws, idx, opts, wb);
		write_record(ba, "BrtEndSheet");
		return ba.end()
	}
	var WBPropsDef = [["allowRefreshQuery", "0"], ["autoCompressPictures", "1"], ["backupFile", "0"], ["checkCompatibility", "0"], ["codeName", ""], ["date1904", "0"], ["dateCompatibility", "1"], ["filterPrivacy", "0"], ["hidePivotFieldList", "0"], ["promptedSolutions", "0"], ["publishItems", "0"], ["refreshAllConnections", false], ["saveExternalLinkValues", "1"], ["showBorderUnselectedTables", "1"], ["showInkAnnotation", "1"], ["showObjects", "all"], ["showPivotChartFilter", "0"]];
	var WBViewDef = [["activeTab", "0"], ["autoFilterDateGrouping", "1"], ["firstSheet", "0"], ["minimized", "0"], ["showHorizontalScroll", "1"], ["showSheetTabs", "1"], ["showVerticalScroll", "1"], ["tabRatio", "600"], ["visibility", "visible"]];
	var SheetDef = [["state", "visible"]];
	var CalcPrDef = [["calcCompleted", "true"], ["calcMode", "auto"], ["calcOnSave", "true"], ["concurrentCalc", "true"], ["fullCalcOnLoad", "false"], ["fullPrecision", "true"], ["iterate", "false"], ["iterateCount", "100"], ["iterateDelta", "0.001"], ["refMode", "A1"]];
	var CustomWBViewDef = [["autoUpdate", "false"], ["changesSavedWin", "false"], ["includeHiddenRowCol", "true"], ["includePrintSettings", "true"], ["maximized", "false"], ["minimized", "false"], ["onlySync", "false"], ["personalView", "false"], ["showComments", "commIndicator"], ["showFormulaBar", "true"], ["showHorizontalScroll", "true"], ["showObjects", "all"], ["showSheetTabs", "true"], ["showStatusbar", "true"], ["showVerticalScroll", "true"], ["tabRatio", "600"], ["xWindow", "0"], ["yWindow", "0"]];
	function push_defaults_array(target, defaults) {
		for (var j = 0; j != target.length; ++j) {
			var w = target[j];
			for (var i = 0; i != defaults.length; ++i) {
				var z = defaults[i];
				if (w[z[0]] == null)
					w[z[0]] = z[1]
			}
		}
	}
	function push_defaults(target, defaults) {
		for (var i = 0; i != defaults.length; ++i) {
			var z = defaults[i];
			if (target[z[0]] == null)
				target[z[0]] = z[1]
		}
	}
	function parse_wb_defaults(wb) {
		push_defaults(wb.WBProps, WBPropsDef);
		push_defaults(wb.CalcPr, CalcPrDef);
		push_defaults_array(wb.WBView, WBViewDef);
		push_defaults_array(wb.Sheets, SheetDef);
		_ssfopts.date1904 = parsexmlbool(wb.WBProps.date1904, "date1904")
	}
	var wbnsregex = /<\w+:workbook/;
	function parse_wb_xml(data, opts) {
		var wb = {
			AppVersion : {},
			WBProps : {},
			WBView : [],
			Sheets : [],
			CalcPr : {},
			xmlns : ""
		};
		var pass = false,
		xmlns = "xmlns";
		data.match(tagregex).forEach(function xml_wb(x) {
			var y = parsexmltag(x);
			switch (strip_ns(y[0])) {
			case "<?xml":
				break;
			case "<workbook":
				if (x.match(wbnsregex))
					xmlns = "xmlns" + x.match(/<(\w+):/)[1];
				wb.xmlns = y[xmlns];
				break;
			case "</workbook>":
				break;
			case "<fileVersion":
				delete y[0];
				wb.AppVersion = y;
				break;
			case "<fileVersion/>":
				break;
			case "<fileSharing":
			case "<fileSharing/>":
				break;
			case "<workbookPr":
				delete y[0];
				wb.WBProps = y;
				break;
			case "<workbookPr/>":
				delete y[0];
				wb.WBProps = y;
				break;
			case "<workbookProtection":
				break;
			case "<workbookProtection/>":
				break;
			case "<bookViews>":
			case "</bookViews>":
				break;
			case "<workbookView":
				delete y[0];
				wb.WBView.push(y);
				break;
			case "<sheets>":
			case "</sheets>":
				break;
			case "<sheet":
				delete y[0];
				y.name = utf8read(y.name);
				wb.Sheets.push(y);
				break;
			case "<functionGroups":
			case "<functionGroups/>":
				break;
			case "<functionGroup":
				break;
			case "<externalReferences":
			case "</externalReferences>":
			case "<externalReferences>":
				break;
			case "<externalReference":
				break;
			case "<definedNames/>":
				break;
			case "<definedNames>":
			case "<definedNames":
				pass = true;
				break;
			case "</definedNames>":
				pass = false;
				break;
			case "<definedName":
			case "<definedName/>":
			case "</definedName>":
				break;
			case "<calcPr":
				delete y[0];
				wb.CalcPr = y;
				break;
			case "<calcPr/>":
				delete y[0];
				wb.CalcPr = y;
				break;
			case "<oleSize":
				break;
			case "<customWorkbookViews>":
			case "</customWorkbookViews>":
			case "<customWorkbookViews":
				break;
			case "<customWorkbookView":
			case "</customWorkbookView>":
				break;
			case "<pivotCaches>":
			case "</pivotCaches>":
			case "<pivotCaches":
				break;
			case "<pivotCache":
				break;
			case "<smartTagPr":
			case "<smartTagPr/>":
				break;
			case "<smartTagTypes":
			case "<smartTagTypes>":
			case "</smartTagTypes>":
				break;
			case "<smartTagType":
				break;
			case "<webPublishing":
			case "<webPublishing/>":
				break;
			case "<fileRecoveryPr":
			case "<fileRecoveryPr/>":
				break;
			case "<webPublishObjects>":
			case "<webPublishObjects":
			case "</webPublishObjects>":
				break;
			case "<webPublishObject":
				break;
			case "<extLst>":
			case "</extLst>":
			case "<extLst/>":
				break;
			case "<ext":
				pass = true;
				break;
			case "</ext>":
				pass = false;
				break;
			case "<ArchID":
				break;
			case "<AlternateContent":
				pass = true;
				break;
			case "</AlternateContent>":
				pass = false;
				break;
			default:
				if (!pass && opts.WTF)
					throw "unrecognized " + y[0] + " in workbook"
			}
		});
		if (XMLNS.main.indexOf(wb.xmlns) === -1)
			throw new Error("Unknown Namespace: " + wb.xmlns);
		parse_wb_defaults(wb);
		return wb
	}
	var WB_XML_ROOT = writextag("workbook", null, {
			xmlns : XMLNS.main[0],
			"xmlns:r" : XMLNS.r
		});
	function safe1904(wb) {
		try {
			return parsexmlbool(wb.Workbook.WBProps.date1904) ? "true" : "false"
		} catch (e) {
			return "false"
		}
	}
	function write_wb_xml(wb, opts) {
		var o = [XML_HEADER];
		o[o.length] = WB_XML_ROOT;
		o[o.length] = writextag("workbookPr", null, {
				date1904 : safe1904(wb)
			});
		o[o.length] = "<sheets>";
		for (var i = 0; i != wb.SheetNames.length; ++i)
			o[o.length] = writextag("sheet", null, {
					name : wb.SheetNames[i].substr(0, 31),
					sheetId : "" + (i + 1),
					"r:id" : "rId" + (i + 1)
				});
		o[o.length] = "</sheets>";
		if (o.length > 2) {
			o[o.length] = "</workbook>";
			o[1] = o[1].replace("/>", ">")
		}
		return o.join("")
	}
	function parse_BrtBundleSh(data, length) {
		var z = {};
		z.hsState = data.read_shift(4);
		z.iTabID = data.read_shift(4);
		z.strRelID = parse_RelID(data, length - 8);
		z.name = parse_XLWideString(data);
		return z
	}
	function write_BrtBundleSh(data, o) {
		if (!o)
			o = new_buf(127);
		o.write_shift(4, data.hsState);
		o.write_shift(4, data.iTabID);
		write_RelID(data.strRelID, o);
		write_XLWideString(data.name.substr(0, 31), o);
		return o
	}
	function parse_BrtWbProp(data, length) {
		data.read_shift(4);
		var dwThemeVersion = data.read_shift(4);
		var strName = length > 8 ? parse_XLWideString(data) : "";
		return [dwThemeVersion, strName]
	}
	function write_BrtWbProp(data, o) {
		if (!o)
			o = new_buf(8);
		o.write_shift(4, 0);
		o.write_shift(4, 0);
		return o
	}
	function parse_BrtFRTArchID$(data, length) {
		var o = {};
		data.read_shift(4);
		o.ArchID = data.read_shift(4);
		data.l += length - 8;
		return o
	}
	function parse_wb_bin(data, opts) {
		var wb = {
			AppVersion : {},
			WBProps : {},
			WBView : [],
			Sheets : [],
			CalcPr : {},
			xmlns : ""
		};
		var pass = false,
		z;
		recordhopper(data, function hopper_wb(val, R) {
			switch (R.n) {
			case "BrtBundleSh":
				wb.Sheets.push(val);
				break;
			case "BrtBeginBook":
				break;
			case "BrtFileVersion":
				break;
			case "BrtWbProp":
				break;
			case "BrtACBegin":
				break;
			case "BrtAbsPath15":
				break;
			case "BrtACEnd":
				break;
			case "BrtWbFactoid":
				break;
			case "BrtBookProtection":
				break;
			case "BrtBeginBookViews":
				break;
			case "BrtBookView":
				break;
			case "BrtEndBookViews":
				break;
			case "BrtBeginBundleShs":
				break;
			case "BrtEndBundleShs":
				break;
			case "BrtBeginFnGroup":
				break;
			case "BrtEndFnGroup":
				break;
			case "BrtBeginExternals":
				break;
			case "BrtSupSelf":
				break;
			case "BrtSupBookSrc":
				break;
			case "BrtExternSheet":
				break;
			case "BrtEndExternals":
				break;
			case "BrtName":
				break;
			case "BrtCalcProp":
				break;
			case "BrtUserBookView":
				break;
			case "BrtBeginPivotCacheIDs":
				break;
			case "BrtBeginPivotCacheID":
				break;
			case "BrtEndPivotCacheID":
				break;
			case "BrtEndPivotCacheIDs":
				break;
			case "BrtWebOpt":
				break;
			case "BrtFileRecover":
				break;
			case "BrtFileSharing":
				break;
			case "BrtBeginSmartTagTypes":
				break;
			case "BrtSmartTagType":
				break;
			case "BrtEndSmartTagTypes":
				break;
			case "BrtFRTBegin":
				pass = true;
				break;
			case "BrtFRTArchID$":
				break;
			case "BrtWorkBookPr15":
				break;
			case "BrtFRTEnd":
				pass = false;
				break;
			case "BrtEndBook":
				break;
			default:
				if (!pass || opts.WTF)
					throw new Error("Unexpected record " + R.n)
			}
		});
		parse_wb_defaults(wb);
		return wb
	}
	function write_BUNDLESHS(ba, wb, opts) {
		write_record(ba, "BrtBeginBundleShs");
		for (var idx = 0; idx != wb.SheetNames.length; ++idx) {
			var d = {
				hsState : 0,
				iTabID : idx + 1,
				strRelID : "rId" + (idx + 1),
				name : wb.SheetNames[idx]
			};
			write_record(ba, "BrtBundleSh", write_BrtBundleSh(d))
		}
		write_record(ba, "BrtEndBundleShs")
	}
	function write_BrtFileVersion(data, o) {
		if (!o)
			o = new_buf(127);
		for (var i = 0; i != 4; ++i)
			o.write_shift(4, 0);
		write_XLWideString("SheetJS", o);
		write_XLWideString(XLSX.version, o);
		write_XLWideString(XLSX.version, o);
		write_XLWideString("7262", o);
		o.length = o.l;
		return o
	}
	function write_BOOKVIEWS(ba, wb, opts) {
		write_record(ba, "BrtBeginBookViews");
		write_record(ba, "BrtEndBookViews")
	}
	function write_BrtCalcProp(data, o) {
		if (!o)
			o = new_buf(26);
		o.write_shift(4, 0);
		o.write_shift(4, 1);
		o.write_shift(4, 0);
		write_Xnum(0, o);
		o.write_shift(-4, 1023);
		o.write_shift(1, 51);
		o.write_shift(1, 0);
		return o
	}
	function write_BrtFileRecover(data, o) {
		if (!o)
			o = new_buf(1);
		o.write_shift(1, 0);
		return o
	}
	function write_wb_bin(wb, opts) {
		var ba = buf_array();
		write_record(ba, "BrtBeginBook");
		write_record(ba, "BrtFileVersion", write_BrtFileVersion());
		write_record(ba, "BrtWbProp", write_BrtWbProp());
		write_BOOKVIEWS(ba, wb, opts);
		write_BUNDLESHS(ba, wb, opts);
		write_record(ba, "BrtCalcProp", write_BrtCalcProp());
		write_record(ba, "BrtFileRecover", write_BrtFileRecover());
		write_record(ba, "BrtEndBook");
		return ba.end()
	}
	function parse_wb(data, name, opts) {
		return (name.substr(-4) === ".bin" ? parse_wb_bin : parse_wb_xml)(data, opts)
	}
	function parse_ws(data, name, opts, rels) {
		return (name.substr(-4) === ".bin" ? parse_ws_bin : parse_ws_xml)(data, opts, rels)
	}
	function parse_sty(data, name, opts) {
		return (name.substr(-4) === ".bin" ? parse_sty_bin : parse_sty_xml)(data, opts)
	}
	function parse_theme(data, name, opts) {
		return parse_theme_xml(data, opts)
	}
	function parse_sst(data, name, opts) {
		return (name.substr(-4) === ".bin" ? parse_sst_bin : parse_sst_xml)(data, opts)
	}
	function parse_cmnt(data, name, opts) {
		return (name.substr(-4) === ".bin" ? parse_comments_bin : parse_comments_xml)(data, opts)
	}
	function parse_cc(data, name, opts) {
		return (name.substr(-4) === ".bin" ? parse_cc_bin : parse_cc_xml)(data, opts)
	}
	function write_wb(wb, name, opts) {
		return (name.substr(-4) === ".bin" ? write_wb_bin : write_wb_xml)(wb, opts)
	}
	function write_ws(data, name, opts, wb) {
		return (name.substr(-4) === ".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb)
	}
	function write_sty(data, name, opts) {
		return (name.substr(-4) === ".bin" ? write_sty_bin : write_sty_xml)(data, opts)
	}
	function write_sst(data, name, opts) {
		return (name.substr(-4) === ".bin" ? write_sst_bin : write_sst_xml)(data, opts)
	}
	var attregexg2 = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
	var attregex2 = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
	var _chr = function (c) {
		return String.fromCharCode(c)
	};
	function xlml_parsexmltag(tag, skip_root) {
		var words = tag.split(/\s+/);
		var z = [];
		if (!skip_root)
			z[0] = words[0];
		if (words.length === 1)
			return z;
		var m = tag.match(attregexg2),
		y,
		j,
		w,
		i;
		if (m)
			for (i = 0; i != m.length; ++i) {
				y = m[i].match(attregex2);
				if ((j = y[1].indexOf(":")) === -1)
					z[y[1]] = y[2].substr(1, y[2].length - 2);
				else {
					if (y[1].substr(0, 6) === "xmlns:")
						w = "xmlns" + y[1].substr(6);
					else
						w = y[1].substr(j + 1);
					z[w] = y[2].substr(1, y[2].length - 2)
				}
			}
		return z
	}
	function xlml_parsexmltagobj(tag) {
		var words = tag.split(/\s+/);
		var z = {};
		if (words.length === 1)
			return z;
		var m = tag.match(attregexg2),
		y,
		j,
		w,
		i;
		if (m)
			for (i = 0; i != m.length; ++i) {
				y = m[i].match(attregex2);
				if ((j = y[1].indexOf(":")) === -1)
					z[y[1]] = y[2].substr(1, y[2].length - 2);
				else {
					if (y[1].substr(0, 6) === "xmlns:")
						w = "xmlns" + y[1].substr(6);
					else
						w = y[1].substr(j + 1);
					z[w] = y[2].substr(1, y[2].length - 2)
				}
			}
		return z
	}
	function xlml_format(format, value) {
		var fmt = XLMLFormatMap[format] || unescapexml(format);
		if (fmt === "General")
			return SSF._general(value);
		return SSF.format(fmt, value)
	}
	function xlml_set_custprop(Custprops, Rn, cp, val) {
		switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
		case "boolean":
			val = parsexmlbool(val);
			break;
		case "i2":
		case "int":
			val = parseInt(val, 10);
			break;
		case "r4":
		case "float":
			val = parseFloat(val);
			break;
		case "date":
		case "dateTime.tz":
			val = new Date(val);
			break;
		case "i8":
		case "string":
		case "fixed":
		case "uuid":
		case "bin.base64":
			break;
		default:
			throw "bad custprop:" + cp[0]
		}
		Custprops[unescapexml(Rn[3])] = val
	}
	function safe_format_xlml(cell, nf, o) {
		try {
			if (cell.t === "e") {
				cell.w = cell.w || BErr[cell.v]
			} else if (nf === "General") {
				if (cell.t === "n") {
					if ((cell.v | 0) === cell.v)
						cell.w = SSF._general_int(cell.v);
					else
						cell.w = SSF._general_num(cell.v)
				} else
					cell.w = SSF._general(cell.v)
			} else
				cell.w = xlml_format(nf || "General", cell.v);
			if (o.cellNF)
				cell.z = XLMLFormatMap[nf] || nf || "General"
		} catch (e) {
			if (o.WTF)
				throw e
		}
	}
	function process_style_xlml(styles, stag, opts) {
		if (opts.cellStyles) {
			if (stag.Interior) {
				var I = stag.Interior;
				if (I.Pattern)
					I.patternType = XLMLPatternTypeMap[I.Pattern] || I.Pattern
			}
		}
		styles[stag.ID] = stag
	}
	function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, o) {
		var nf = "General",
		sid = cell.StyleID,
		S = {};
		o = o || {};
		var interiors = [];
		if (sid === undefined && row)
			sid = row.StyleID;
		if (sid === undefined && csty)
			sid = csty.StyleID;
		while (styles[sid] !== undefined) {
			if (styles[sid].nf)
				nf = styles[sid].nf;
			if (styles[sid].Interior)
				interiors.push(styles[sid].Interior);
			if (!styles[sid].Parent)
				break;
			sid = styles[sid].Parent
		}
		switch (data.Type) {
		case "Boolean":
			cell.t = "b";
			cell.v = parsexmlbool(xml);
			break;
		case "String":
			cell.t = "s";
			cell.r = xlml_fixstr(unescapexml(xml));
			cell.v = xml.indexOf("<") > -1 ? ss : cell.r;
			break;
		case "DateTime":
			cell.v = (Date.parse(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3);
			if (cell.v !== cell.v)
				cell.v = unescapexml(xml);
			else if (cell.v >= 1 && cell.v < 60)
				cell.v = cell.v - 1;
			if (!nf || nf == "General")
				nf = "yyyy-mm-dd";
		case "Number":
			if (cell.v === undefined)
				cell.v = +xml;
			if (!cell.t)
				cell.t = "n";
			break;
		case "Error":
			cell.t = "e";
			cell.v = RBErr[xml];
			cell.w = xml;
			break;
		default:
			cell.t = "s";
			cell.v = xlml_fixstr(ss);
			break
		}
		safe_format_xlml(cell, nf, o);
		if (o.cellFormula != null && cell.Formula) {
			cell.f = rc_to_a1(unescapexml(cell.Formula), base);
			cell.Formula = undefined
		}
		if (o.cellStyles) {
			interiors.forEach(function (x) {
				if (!S.patternType && x.patternType)
					S.patternType = x.patternType
			});
			cell.s = S
		}
		cell.ixfe = cell.StyleID !== undefined ? cell.StyleID : "Default"
	}
	function xlml_clean_comment(comment) {
		comment.t = comment.v;
		comment.v = comment.w = comment.ixfe = undefined
	}
	function xlml_normalize(d) {
		if (has_buf && Buffer.isBuffer(d))
			return d.toString("utf8");
		if (typeof d === "string")
			return d;
		throw "badf"
	}
	var xlmlregex = /<(\/?)([a-z0-9]*:|)(\w+)[^>]*>/gm;
	function parse_xlml_xml(d, opts) {
		var str = xlml_normalize(d);
		var Rn;
		var state = [],
		tmp;
		var sheets = {},
		sheetnames = [],
		cursheet = {},
		sheetname = "";
		var table = {},
		cell = {},
		row = {},
		dtag,
		didx;
		var c = 0,
		r = 0;
		var refguess = {
			s : {
				r : 1e6,
				c : 1e6
			},
			e : {
				r : 0,
				c : 0
			}
		};
		var styles = {},
		stag = {};
		var ss = "",
		fidx = 0;
		var mergecells = [];
		var Props = {},
		Custprops = {},
		pidx = 0,
		cp = {};
		var comments = [],
		comment = {};
		var cstys = [],
		csty;
		xlmlregex.lastIndex = 0;
		while (Rn = xlmlregex.exec(str))
			switch (Rn[3]) {
			case "Data":
				if (state[state.length - 1][1])
					break;
				if (Rn[1] === "/")
					parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == "Comment" ? comment : cell, {
						c : c,
						r : r
					}, styles, cstys[c], row, opts);
				else {
					ss = "";
					dtag = xlml_parsexmltag(Rn[0]);
					didx = Rn.index + Rn[0].length
				}
				break;
			case "Cell":
				if (Rn[1] === "/") {
					if (comments.length > 0)
						cell.c = comments;
					if ((!opts.sheetRows || opts.sheetRows > r) && cell.v !== undefined)
						cursheet[encode_col(c) + encode_row(r)] = cell;
					if (cell.HRef) {
						cell.l = {
							Target : cell.HRef,
							tooltip : cell.HRefScreenTip
						};
						cell.HRef = cell.HRefScreenTip = undefined
					}
					if (cell.MergeAcross || cell.MergeDown) {
						var cc = c + (parseInt(cell.MergeAcross, 10) | 0);
						var rr = r + (parseInt(cell.MergeDown, 10) | 0);
						mergecells.push({
							s : {
								c : c,
								r : r
							},
							e : {
								c : cc,
								r : rr
							}
						})
					}
					++c;
					if (cell.MergeAcross)
						c += +cell.MergeAcross
				} else {
					cell = xlml_parsexmltagobj(Rn[0]);
					if (cell.Index)
						c = +cell.Index - 1;
					if (c < refguess.s.c)
						refguess.s.c = c;
					if (c > refguess.e.c)
						refguess.e.c = c;
					if (Rn[0].substr(-2) === "/>")
						++c;
					comments = []
				}
				break;
			case "Row":
				if (Rn[1] === "/" || Rn[0].substr(-2) === "/>") {
					if (r < refguess.s.r)
						refguess.s.r = r;
					if (r > refguess.e.r)
						refguess.e.r = r;
					if (Rn[0].substr(-2) === "/>") {
						row = xlml_parsexmltag(Rn[0]);
						if (row.Index)
							r = +row.Index - 1
					}
					c = 0;
					++r
				} else {
					row = xlml_parsexmltag(Rn[0]);
					if (row.Index)
						r = +row.Index - 1
				}
				break;
			case "Worksheet":
				if (Rn[1] === "/") {
					if ((tmp = state.pop())[0] !== Rn[3])
						throw "Bad state: " + tmp;
					sheetnames.push(sheetname);
					if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c)
						cursheet["!ref"] = encode_range(refguess);
					if (mergecells.length)
						cursheet["!merges"] = mergecells;
					sheets[sheetname] = cursheet
				} else {
					refguess = {
						s : {
							r : 1e6,
							c : 1e6
						},
						e : {
							r : 0,
							c : 0
						}
					};
					r = c = 0;
					state.push([Rn[3], false]);
					tmp = xlml_parsexmltag(Rn[0]);
					sheetname = tmp.Name;
					cursheet = {};
					mergecells = []
				}
				break;
			case "Table":
				if (Rn[1] === "/") {
					if ((tmp = state.pop())[0] !== Rn[3])
						throw "Bad state: " + tmp
				} else if (Rn[0].slice(-2) == "/>")
					break;
				else {
					table = xlml_parsexmltag(Rn[0]);
					state.push([Rn[3], false]);
					cstys = []
				}
				break;
			case "Style":
				if (Rn[1] === "/")
					process_style_xlml(styles, stag, opts);
				else
					stag = xlml_parsexmltag(Rn[0]);
				break;
			case "NumberFormat":
				stag.nf = xlml_parsexmltag(Rn[0]).Format || "General";
				break;
			case "Column":
				if (state[state.length - 1][0] !== "Table")
					break;
				csty = xlml_parsexmltag(Rn[0]);
				cstys[csty.Index - 1 || cstys.length] = csty;
				for (var i = 0; i < +csty.Span; ++i)
					cstys[cstys.length] = csty;
				break;
			case "NamedRange":
				break;
			case "NamedCell":
				break;
			case "B":
				break;
			case "I":
				break;
			case "U":
				break;
			case "S":
				break;
			case "Sub":
				break;
			case "Sup":
				break;
			case "Span":
				break;
			case "Border":
				break;
			case "Alignment":
				break;
			case "Borders":
				break;
			case "Font":
				if (Rn[0].substr(-2) === "/>")
					break;
				else if (Rn[1] === "/")
					ss += str.slice(fidx, Rn.index);
				else
					fidx = Rn.index + Rn[0].length;
				break;
			case "Interior":
				if (!opts.cellStyles)
					break;
				stag.Interior = xlml_parsexmltag(Rn[0]);
				break;
			case "Protection":
				break;
			case "Author":
			case "Title":
			case "Description":
			case "Created":
			case "Keywords":
			case "Subject":
			case "Category":
			case "Company":
			case "LastAuthor":
			case "LastSaved":
			case "LastPrinted":
			case "Version":
			case "Revision":
			case "TotalTime":
			case "HyperlinkBase":
			case "Manager":
				if (Rn[0].substr(-2) === "/>")
					break;
				else if (Rn[1] === "/")
					xlml_set_prop(Props, Rn[3], str.slice(pidx, Rn.index));
				else
					pidx = Rn.index + Rn[0].length;
				break;
			case "Paragraphs":
				break;
			case "Styles":
			case "Workbook":
				if (Rn[1] === "/") {
					if ((tmp = state.pop())[0] !== Rn[3])
						throw "Bad state: " + tmp
				} else
					state.push([Rn[3], false]);
				break;
			case "Comment":
				if (Rn[1] === "/") {
					if ((tmp = state.pop())[0] !== Rn[3])
						throw "Bad state: " + tmp;
					xlml_clean_comment(comment);
					comments.push(comment)
				} else {
					state.push([Rn[3], false]);
					tmp = xlml_parsexmltag(Rn[0]);
					comment = {
						a : tmp.Author
					}
				}
				break;
			case "Name":
				break;
			case "ComponentOptions":
			case "DocumentProperties":
			case "CustomDocumentProperties":
			case "OfficeDocumentSettings":
			case "PivotTable":
			case "PivotCache":
			case "Names":
			case "MapInfo":
			case "PageBreaks":
			case "QueryTable":
			case "DataValidation":
			case "AutoFilter":
			case "Sorting":
			case "Schema":
			case "data":
			case "ConditionalFormatting":
			case "SmartTagType":
			case "SmartTags":
			case "ExcelWorkbook":
			case "WorkbookOptions":
			case "WorksheetOptions":
				if (Rn[1] === "/") {
					if ((tmp = state.pop())[0] !== Rn[3])
						throw "Bad state: " + tmp
				} else if (Rn[0].charAt(Rn[0].length - 2) !== "/")
					state.push([Rn[3], true]);
				break;
			default:
				var seen = true;
				switch (state[state.length - 1][0]) {
				case "OfficeDocumentSettings":
					switch (Rn[3]) {
					case "AllowPNG":
						break;
					case "RemovePersonalInformation":
						break;
					case "DownloadComponents":
						break;
					case "LocationOfComponents":
						break;
					case "Colors":
						break;
					case "Color":
						break;
					case "Index":
						break;
					case "RGB":
						break;
					case "PixelsPerInch":
						break;
					case "TargetScreenSize":
						break;
					case "ReadOnlyRecommended":
						break;
					default:
						seen = false
					}
					break;
				case "ComponentOptions":
					switch (Rn[3]) {
					case "Toolbar":
						break;
					case "HideOfficeLogo":
						break;
					case "SpreadsheetAutoFit":
						break;
					case "Label":
						break;
					case "Caption":
						break;
					case "MaxHeight":
						break;
					case "MaxWidth":
						break;
					case "NextSheetNumber":
						break;
					default:
						seen = false
					}
					break;
				case "ExcelWorkbook":
					switch (Rn[3]) {
					case "WindowHeight":
						break;
					case "WindowWidth":
						break;
					case "WindowTopX":
						break;
					case "WindowTopY":
						break;
					case "TabRatio":
						break;
					case "ProtectStructure":
						break;
					case "ProtectWindows":
						break;
					case "ActiveSheet":
						break;
					case "DisplayInkNotes":
						break;
					case "FirstVisibleSheet":
						break;
					case "SupBook":
						break;
					case "SheetName":
						break;
					case "SheetIndex":
						break;
					case "SheetIndexFirst":
						break;
					case "SheetIndexLast":
						break;
					case "Dll":
						break;
					case "AcceptLabelsInFormulas":
						break;
					case "DoNotSaveLinkValues":
						break;
					case "Date1904":
						break;
					case "Iteration":
						break;
					case "MaxIterations":
						break;
					case "MaxChange":
						break;
					case "Path":
						break;
					case "Xct":
						break;
					case "Count":
						break;
					case "SelectedSheets":
						break;
					case "Calculation":
						break;
					case "Uncalced":
						break;
					case "StartupPrompt":
						break;
					case "Crn":
						break;
					case "ExternName":
						break;
					case "Formula":
						break;
					case "ColFirst":
						break;
					case "ColLast":
						break;
					case "WantAdvise":
						break;
					case "Boolean":
						break;
					case "Error":
						break;
					case "Text":
						break;
					case "OLE":
						break;
					case "NoAutoRecover":
						break;
					case "PublishObjects":
						break;
					case "DoNotCalculateBeforeSave":
						break;
					case "Number":
						break;
					case "RefModeR1C1":
						break;
					case "EmbedSaveSmartTags":
						break;
					default:
						seen = false
					}
					break;
				case "WorkbookOptions":
					switch (Rn[3]) {
					case "OWCVersion":
						break;
					case "Height":
						break;
					case "Width":
						break;
					default:
						seen = false
					}
					break;
				case "WorksheetOptions":
					switch (Rn[3]) {
					case "Unsynced":
						break;
					case "Visible":
						break;
					case "Print":
						break;
					case "Panes":
						break;
					case "Scale":
						break;
					case "Pane":
						break;
					case "Number":
						break;
					case "Layout":
						break;
					case "Header":
						break;
					case "Footer":
						break;
					case "PageSetup":
						break;
					case "PageMargins":
						break;
					case "Selected":
						break;
					case "ProtectObjects":
						break;
					case "EnableSelection":
						break;
					case "ProtectScenarios":
						break;
					case "ValidPrinterInfo":
						break;
					case "HorizontalResolution":
						break;
					case "VerticalResolution":
						break;
					case "NumberofCopies":
						break;
					case "ActiveRow":
						break;
					case "ActiveCol":
						break;
					case "ActivePane":
						break;
					case "TopRowVisible":
						break;
					case "TopRowBottomPane":
						break;
					case "LeftColumnVisible":
						break;
					case "LeftColumnRightPane":
						break;
					case "FitToPage":
						break;
					case "RangeSelection":
						break;
					case "PaperSizeIndex":
						break;
					case "PageLayoutZoom":
						break;
					case "PageBreakZoom":
						break;
					case "FilterOn":
						break;
					case "DoNotDisplayGridlines":
						break;
					case "SplitHorizontal":
						break;
					case "SplitVertical":
						break;
					case "FreezePanes":
						break;
					case "FrozenNoSplit":
						break;
					case "FitWidth":
						break;
					case "FitHeight":
						break;
					case "CommentsLayout":
						break;
					case "Zoom":
						break;
					case "LeftToRight":
						break;
					case "Gridlines":
						break;
					case "AllowSort":
						break;
					case "AllowFilter":
						break;
					case "AllowInsertRows":
						break;
					case "AllowDeleteRows":
						break;
					case "AllowInsertCols":
						break;
					case "AllowDeleteCols":
						break;
					case "AllowInsertHyperlinks":
						break;
					case "AllowFormatCells":
						break;
					case "AllowSizeCols":
						break;
					case "AllowSizeRows":
						break;
					case "NoSummaryRowsBelowDetail":
						break;
					case "TabColorIndex":
						break;
					case "DoNotDisplayHeadings":
						break;
					case "ShowPageLayoutZoom":
						break;
					case "NoSummaryColumnsRightDetail":
						break;
					case "BlackAndWhite":
						break;
					case "DoNotDisplayZeros":
						break;
					case "DisplayPageBreak":
						break;
					case "RowColHeadings":
						break;
					case "DoNotDisplayOutline":
						break;
					case "NoOrientation":
						break;
					case "AllowUsePivotTables":
						break;
					case "ZeroHeight":
						break;
					case "ViewableRange":
						break;
					case "Selection":
						break;
					case "ProtectContents":
						break;
					default:
						seen = false
					}
					break;
				case "PivotTable":
				case "PivotCache":
					switch (Rn[3]) {
					case "ImmediateItemsOnDrop":
						break;
					case "ShowPageMultipleItemLabel":
						break;
					case "CompactRowIndent":
						break;
					case "Location":
						break;
					case "PivotField":
						break;
					case "Orientation":
						break;
					case "LayoutForm":
						break;
					case "LayoutSubtotalLocation":
						break;
					case "LayoutCompactRow":
						break;
					case "Position":
						break;
					case "PivotItem":
						break;
					case "DataType":
						break;
					case "DataField":
						break;
					case "SourceName":
						break;
					case "ParentField":
						break;
					case "PTLineItems":
						break;
					case "PTLineItem":
						break;
					case "CountOfSameItems":
						break;
					case "Item":
						break;
					case "ItemType":
						break;
					case "PTSource":
						break;
					case "CacheIndex":
						break;
					case "ConsolidationReference":
						break;
					case "FileName":
						break;
					case "Reference":
						break;
					case "NoColumnGrand":
						break;
					case "NoRowGrand":
						break;
					case "BlankLineAfterItems":
						break;
					case "Hidden":
						break;
					case "Subtotal":
						break;
					case "BaseField":
						break;
					case "MapChildItems":
						break;
					case "Function":
						break;
					case "RefreshOnFileOpen":
						break;
					case "PrintSetTitles":
						break;
					case "MergeLabels":
						break;
					case "DefaultVersion":
						break;
					case "RefreshName":
						break;
					case "RefreshDate":
						break;
					case "RefreshDateCopy":
						break;
					case "VersionLastRefresh":
						break;
					case "VersionLastUpdate":
						break;
					case "VersionUpdateableMin":
						break;
					case "VersionRefreshableMin":
						break;
					case "Calculation":
						break;
					default:
						seen = false
					}
					break;
				case "PageBreaks":
					switch (Rn[3]) {
					case "ColBreaks":
						break;
					case "ColBreak":
						break;
					case "RowBreaks":
						break;
					case "RowBreak":
						break;
					case "ColStart":
						break;
					case "ColEnd":
						break;
					case "RowEnd":
						break;
					default:
						seen = false
					}
					break;
				case "AutoFilter":
					switch (Rn[3]) {
					case "AutoFilterColumn":
						break;
					case "AutoFilterCondition":
						break;
					case "AutoFilterAnd":
						break;
					case "AutoFilterOr":
						break;
					default:
						seen = false
					}
					break;
				case "QueryTable":
					switch (Rn[3]) {
					case "Id":
						break;
					case "AutoFormatFont":
						break;
					case "AutoFormatPattern":
						break;
					case "QuerySource":
						break;
					case "QueryType":
						break;
					case "EnableRedirections":
						break;
					case "RefreshedInXl9":
						break;
					case "URLString":
						break;
					case "HTMLTables":
						break;
					case "Connection":
						break;
					case "CommandText":
						break;
					case "RefreshInfo":
						break;
					case "NoTitles":
						break;
					case "NextId":
						break;
					case "ColumnInfo":
						break;
					case "OverwriteCells":
						break;
					case "DoNotPromptForFile":
						break;
					case "TextWizardSettings":
						break;
					case "Source":
						break;
					case "Number":
						break;
					case "Decimal":
						break;
					case "ThousandSeparator":
						break;
					case "TrailingMinusNumbers":
						break;
					case "FormatSettings":
						break;
					case "FieldType":
						break;
					case "Delimiters":
						break;
					case "Tab":
						break;
					case "Comma":
						break;
					case "AutoFormatName":
						break;
					case "VersionLastEdit":
						break;
					case "VersionLastRefresh":
						break;
					default:
						seen = false
					}
					break;
				case "Sorting":
				case "ConditionalFormatting":
				case "DataValidation":
					switch (Rn[3]) {
					case "Range":
						break;
					case "Type":
						break;
					case "Min":
						break;
					case "Max":
						break;
					case "Sort":
						break;
					case "Descending":
						break;
					case "Order":
						break;
					case "CaseSensitive":
						break;
					case "Value":
						break;
					case "ErrorStyle":
						break;
					case "ErrorMessage":
						break;
					case "ErrorTitle":
						break;
					case "CellRangeList":
						break;
					case "InputMessage":
						break;
					case "InputTitle":
						break;
					case "ComboHide":
						break;
					case "InputHide":
						break;
					case "Condition":
						break;
					case "Qualifier":
						break;
					case "UseBlank":
						break;
					case "Value1":
						break;
					case "Value2":
						break;
					case "Format":
						break;
					default:
						seen = false
					}
					break;
				case "MapInfo":
				case "Schema":
				case "data":
					switch (Rn[3]) {
					case "Map":
						break;
					case "Entry":
						break;
					case "Range":
						break;
					case "XPath":
						break;
					case "Field":
						break;
					case "XSDType":
						break;
					case "FilterOn":
						break;
					case "Aggregate":
						break;
					case "ElementType":
						break;
					case "AttributeType":
						break;
					case "schema":
					case "element":
					case "complexType":
					case "datatype":
					case "all":
					case "attribute":
					case "extends":
						break;
					case "row":
						break;
					default:
						seen = false
					}
					break;
				case "SmartTags":
					break;
				default:
					seen = false;
					break
				}
				if (seen)
					break;
				if (!state[state.length - 1][1])
					throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
				if (state[state.length - 1][0] === "CustomDocumentProperties") {
					if (Rn[0].substr(-2) === "/>")
						break;
					else if (Rn[1] === "/")
						xlml_set_custprop(Custprops, Rn, cp, str.slice(pidx, Rn.index));
					else {
						cp = Rn;
						pidx = Rn.index + Rn[0].length
					}
					break
				}
				if (opts.WTF)
					throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|")
			}
		var out = {};
		if (!opts.bookSheets && !opts.bookProps)
			out.Sheets = sheets;
		out.SheetNames = sheetnames;
		out.SSF = SSF.get_table();
		out.Props = Props;
		out.Custprops = Custprops;
		return out
	}
	function parse_xlml(data, opts) {
		fix_read_opts(opts = opts || {});
		switch (opts.type || "base64") {
		case "base64":
			return parse_xlml_xml(Base64.decode(data), opts);
		case "binary":
		case "buffer":
		case "file":
			return parse_xlml_xml(data, opts);
		case "array":
			return parse_xlml_xml(data.map(_chr).join(""), opts)
		}
	}
	function write_xlml(wb, opts) {}

	function parse_compobj(obj) {
		var v = {};
		var o = obj.content;
		var l = 28,
		m;
		m = __lpstr(o, l);
		l += 4 + __readUInt32LE(o, l);
		v.UserType = m;
		m = __readUInt32LE(o, l);
		l += 4;
		switch (m) {
		case 0:
			break;
		case 4294967295:
		case 4294967294:
			l += 4;
			break;
		default:
			if (m > 400)
				throw new Error("Unsupported Clipboard: " + m.toString(16));
			l += m
		}
		m = __lpstr(o, l);
		l += m.length === 0 ? 0 : 5 + m.length;
		v.Reserved1 = m;
		if ((m = __readUInt32LE(o, l)) !== 1907550708)
			return v;
		throw "Unsupported Unicode Extension"
	}
	function slurp(R, blob, length, opts) {
		var l = length;
		var bufs = [];
		var d = blob.slice(blob.l, blob.l + l);
		if (opts && opts.enc && opts.enc.insitu_decrypt)
			switch (R.n) {
			case "BOF":
			case "FilePass":
			case "FileLock":
			case "InterfaceHdr":
			case "RRDInfo":
			case "RRDHead":
			case "UsrExcl":
				break;
			default:
				if (d.length === 0)
					break;
				opts.enc.insitu_decrypt(d)
			}
		bufs.push(d);
		blob.l += l;
		var next = XLSRecordEnum[__readUInt16LE(blob, blob.l)];
		while (next != null && next.n === "Continue") {
			l = __readUInt16LE(blob, blob.l + 2);
			bufs.push(blob.slice(blob.l + 4, blob.l + 4 + l));
			blob.l += 4 + l;
			next = XLSRecordEnum[__readUInt16LE(blob, blob.l)]
		}
		var b = bconcat(bufs);
		prep_blob(b, 0);
		var ll = 0;
		b.lens = [];
		for (var j = 0; j < bufs.length; ++j) {
			b.lens.push(ll);
			ll += bufs[j].length
		}
		return R.f(b, b.length, opts)
	}
	function safe_format_xf(p, opts, date1904) {
		if (!p.XF)
			return;
		try {
			var fmtid = p.XF.ifmt || 0;
			if (p.t === "e") {
				p.w = p.w || BErr[p.v]
			} else if (fmtid === 0) {
				if (p.t === "n") {
					if ((p.v | 0) === p.v)
						p.w = SSF._general_int(p.v);
					else
						p.w = SSF._general_num(p.v)
				} else
					p.w = SSF._general(p.v)
			} else
				p.w = SSF.format(fmtid, p.v, {
						date1904 : date1904 || false
					});
			if (opts.cellNF)
				p.z = SSF._table[fmtid]
		} catch (e) {
			if (opts.WTF)
				throw e
		}
	}
	function make_cell(val, ixfe, t) {
		return {
			v : val,
			ixfe : ixfe,
			t : t
		}
	}
	function parse_workbook(blob, options) {
		var wb = {
			opts : {}

		};
		var Sheets = {};
		var out = {};
		var Directory = {};
		var found_sheet = false;
		var range = {};
		var last_formula = null;
		var sst = [];
		var cur_sheet = "";
		var Preamble = {};
		var lastcell,
		last_cell,
		cc,
		cmnt,
		rng,
		rngC,
		rngR;
		var shared_formulae = {};
		var array_formulae = [];
		var temp_val;
		var country;
		var cell_valid = true;
		var XFs = [];
		var palette = [];
		var get_rgb = function getrgb(icv) {
			if (icv < 8)
				return XLSIcv[icv];
			if (icv < 64)
				return palette[icv - 8] || XLSIcv[icv];
			return XLSIcv[icv]
		};
		var process_cell_style = function pcs(cell, line) {
			var xfd = line.XF.data;
			if (!xfd || !xfd.patternType)
				return;
			line.s = {};
			line.s.patternType = xfd.patternType;
			var t;
			if (t = rgb2Hex(get_rgb(xfd.icvFore))) {
				line.s.fgColor = {
					rgb : t
				}
			}
			if (t = rgb2Hex(get_rgb(xfd.icvBack))) {
				line.s.bgColor = {
					rgb : t
				}
			}
		};
		var addcell = function addcell(cell, line, options) {
			if (!cell_valid)
				return;
			if (options.cellStyles && line.XF && line.XF.data)
				process_cell_style(cell, line);
			lastcell = cell;
			last_cell = encode_cell(cell);
			if (range.s) {
				if (cell.r < range.s.r)
					range.s.r = cell.r;
				if (cell.c < range.s.c)
					range.s.c = cell.c
			}
			if (range.e) {
				if (cell.r + 1 > range.e.r)
					range.e.r = cell.r + 1;
				if (cell.c + 1 > range.e.c)
					range.e.c = cell.c + 1
			}
			if (options.sheetRows && lastcell.r >= options.sheetRows)
				cell_valid = false;
			else
				out[last_cell] = line
		};
		var opts = {
			enc : false,
			sbcch : 0,
			snames : [],
			sharedf : shared_formulae,
			arrayf : array_formulae,
			rrtabid : [],
			lastuser : "",
			biff : 8,
			codepage : 0,
			winlocked : 0,
			wtf : false
		};
		if (options.password)
			opts.password = options.password;
		var mergecells = [];
		var objects = [];
		var supbooks = [[]];
		var sbc = 0,
		sbci = 0,
		sbcli = 0;
		supbooks.SheetNames = opts.snames;
		supbooks.sharedf = opts.sharedf;
		supbooks.arrayf = opts.arrayf;
		var last_Rn = "";
		var file_depth = 0;
		opts.codepage = 1200;
		set_cp(1200);
		while (blob.l < blob.length - 1) {
			var s = blob.l;
			var RecordType = blob.read_shift(2);
			if (RecordType === 0 && last_Rn === "EOF")
				break;
			var length = blob.l === blob.length ? 0 : blob.read_shift(2),
			y;
			var R = XLSRecordEnum[RecordType];
			if (R && R.f) {
				if (options.bookSheets) {
					if (last_Rn === "BoundSheet8" && R.n !== "BoundSheet8")
						break
				}
				last_Rn = R.n;
				if (R.r === 2 || R.r == 12) {
					var rt = blob.read_shift(2);
					length -= 2;
					if (!opts.enc && rt !== RecordType)
						throw "rt mismatch";
					if (R.r == 12) {
						blob.l += 10;
						length -= 10
					}
				}
				var val;
				if (R.n === "EOF")
					val = R.f(blob, length, opts);
				else
					val = slurp(R, blob, length, opts);
				var Rn = R.n;
				if (opts.biff === 5 || opts.biff === 2)
					switch (Rn) {
					case "Lbl":
						Rn = "Label";
						break
					}
				switch (Rn) {
				case "Date1904":
					wb.opts.Date1904 = val;
					break;
				case "WriteProtect":
					wb.opts.WriteProtect = true;
					break;
				case "FilePass":
					if (!opts.enc)
						blob.l = 0;
					opts.enc = val;
					if (opts.WTF)
						console.error(val);
					if (!options.password)
						throw new Error("File is password-protected");
					if (val.Type !== 0)
						throw new Error("Encryption scheme unsupported");
					if (!val.valid)
						throw new Error("Password is incorrect");
					break;
				case "WriteAccess":
					opts.lastuser = val;
					break;
				case "FileSharing":
					break;
				case "CodePage":
					if (val === 21010)
						val = 1200;
					else if (val === 32769)
						val = 1252;
					opts.codepage = val;
					set_cp(val);
					break;
				case "RRTabId":
					opts.rrtabid = val;
					break;
				case "WinProtect":
					opts.winlocked = val;
					break;
				case "Template":
					break;
				case "RefreshAll":
					wb.opts.RefreshAll = val;
					break;
				case "BookBool":
					break;
				case "UsesELFs":
					break;
				case "MTRSettings": {
						if (val[0] && val[1])
							throw "Unsupported threads: " + val
					}
					break;
				case "CalcCount":
					wb.opts.CalcCount = val;
					break;
				case "CalcDelta":
					wb.opts.CalcDelta = val;
					break;
				case "CalcIter":
					wb.opts.CalcIter = val;
					break;
				case "CalcMode":
					wb.opts.CalcMode = val;
					break;
				case "CalcPrecision":
					wb.opts.CalcPrecision = val;
					break;
				case "CalcSaveRecalc":
					wb.opts.CalcSaveRecalc = val;
					break;
				case "CalcRefMode":
					opts.CalcRefMode = val;
					break;
				case "Uncalced":
					break;
				case "ForceFullCalculation":
					wb.opts.FullCalc = val;
					break;
				case "WsBool":
					break;
				case "XF":
					XFs.push(val);
					break;
				case "ExtSST":
					break;
				case "BookExt":
					break;
				case "RichTextStream":
					break;
				case "BkHim":
					break;
				case "SupBook":
					supbooks[++sbc] = [val];
					sbci = 0;
					break;
				case "ExternName":
					supbooks[sbc][++sbci] = val;
					break;
				case "Index":
					break;
				case "Lbl":
					supbooks[0][++sbcli] = val;
					break;
				case "ExternSheet":
					supbooks[sbc] = supbooks[sbc].concat(val);
					sbci += val.length;
					break;
				case "Protect":
					out["!protect"] = val;
					break;
				case "Password":
					if (val !== 0 && opts.WTF)
						console.error("Password verifier: " + val);
					break;
				case "Prot4Rev":
				case "Prot4RevPass":
					break;
				case "BoundSheet8": {
						Directory[val.pos] = val;
						opts.snames.push(val.name)
					}
					break;
				case "EOF": {
						if (--file_depth)
							break;
						if (range.e) {
							out["!range"] = range;
							if (range.e.r > 0 && range.e.c > 0) {
								range.e.r--;
								range.e.c--;
								out["!ref"] = encode_range(range);
								range.e.r++;
								range.e.c++
							}
							if (mergecells.length > 0)
								out["!merges"] = mergecells;
							if (objects.length > 0)
								out["!objects"] = objects
						}
						if (cur_sheet === "")
							Preamble = out;
						else
							Sheets[cur_sheet] = out;
						out = {}

					}
					break;
				case "BOF": {
						if (opts.biff !== 8);
						else if (val.BIFFVer === 1280)
							opts.biff = 5;
						else if (val.BIFFVer === 2)
							opts.biff = 2;
						else if (val.BIFFVer === 7)
							opts.biff = 2;
						if (file_depth++)
							break;
						cell_valid = true;
						out = {};
						if (opts.biff === 2) {
							if (cur_sheet === "")
								cur_sheet = "Sheet1";
							range = {
								s : {
									r : 0,
									c : 0
								},
								e : {
									r : 0,
									c : 0
								}
							}
						} else
							cur_sheet = (Directory[s] || {
								name : ""
							}).name;
						mergecells = [];
						objects = []
					}
					break;
				case "Number":
				case "BIFF2NUM": {
						temp_val = {
							ixfe : val.ixfe,
							XF : XFs[val.ixfe],
							v : val.val,
							t : "n"
						};
						if (temp_val.XF)
							safe_format_xf(temp_val, options, wb.opts.Date1904);
						addcell({
							c : val.c,
							r : val.r
						}, temp_val, options)
					}
					break;
				case "BoolErr": {
						temp_val = {
							ixfe : val.ixfe,
							XF : XFs[val.ixfe],
							v : val.val,
							t : val.t
						};
						if (temp_val.XF)
							safe_format_xf(temp_val, options, wb.opts.Date1904);
						addcell({
							c : val.c,
							r : val.r
						}, temp_val, options)
					}
					break;
				case "RK": {
						temp_val = {
							ixfe : val.ixfe,
							XF : XFs[val.ixfe],
							v : val.rknum,
							t : "n"
						};
						if (temp_val.XF)
							safe_format_xf(temp_val, options, wb.opts.Date1904);
						addcell({
							c : val.c,
							r : val.r
						}, temp_val, options)
					}
					break;
				case "MulRk": {
						for (var j = val.c; j <= val.C; ++j) {
							var ixfe = val.rkrec[j - val.c][0];
							temp_val = {
								ixfe : ixfe,
								XF : XFs[ixfe],
								v : val.rkrec[j - val.c][1],
								t : "n"
							};
							if (temp_val.XF)
								safe_format_xf(temp_val, options, wb.opts.Date1904);
							addcell({
								c : j,
								r : val.r
							}, temp_val, options)
						}
					}
					break;
				case "Formula": {
						switch (val.val) {
						case "String":
							last_formula = val;
							break;
						case "Array Formula":
							throw "Array Formula unsupported";
						default:
							temp_val = {
								v : val.val,
								ixfe : val.cell.ixfe,
								t : val.tt
							};
							temp_val.XF = XFs[temp_val.ixfe];
							if (options.cellFormula)
								temp_val.f = "=" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
							if (temp_val.XF)
								safe_format_xf(temp_val, options, wb.opts.Date1904);
							addcell(val.cell, temp_val, options);
							last_formula = val
						}
					}
					break;
				case "String": {
						if (last_formula) {
							last_formula.val = val;
							temp_val = {
								v : last_formula.val,
								ixfe : last_formula.cell.ixfe,
								t : "s"
							};
							temp_val.XF = XFs[temp_val.ixfe];
							if (options.cellFormula)
								temp_val.f = "=" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
							if (temp_val.XF)
								safe_format_xf(temp_val, options, wb.opts.Date1904);
							addcell(last_formula.cell, temp_val, options);
							last_formula = null
						}
					}
					break;
				case "Array": {
						array_formulae.push(val)
					}
					break;
				case "ShrFmla": {
						if (!cell_valid)
							break;
						shared_formulae[encode_cell(last_formula.cell)] = val[0]
					}
					break;
				case "LabelSst":
					temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
					temp_val.XF = XFs[temp_val.ixfe];
					if (temp_val.XF)
						safe_format_xf(temp_val, options, wb.opts.Date1904);
					addcell({
						c : val.c,
						r : val.r
					}, temp_val, options);
					break;
				case "Label":
				case "BIFF2STR":
					temp_val = make_cell(val.val, val.ixfe, "s");
					temp_val.XF = XFs[temp_val.ixfe];
					if (temp_val.XF)
						safe_format_xf(temp_val, options, wb.opts.Date1904);
					addcell({
						c : val.c,
						r : val.r
					}, temp_val, options);
					break;
				case "Dimensions": {
						if (file_depth === 1)
							range = val
					}
					break;
				case "SST": {
						sst = val
					}
					break;
				case "Format": {
						SSF.load(val[1], val[0])
					}
					break;
				case "MergeCells":
					mergecells = mergecells.concat(val);
					break;
				case "Obj":
					objects[val.cmo[0]] = opts.lastobj = val;
					break;
				case "TxO":
					opts.lastobj.TxO = val;
					break;
				case "HLink": {
						for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
							for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC)
								if (out[encode_cell({
											c : rngC,
											r : rngR
										})])
									out[encode_cell({
											c : rngC,
											r : rngR
										})].l = val[1]
					}
					break;
				case "HLinkTooltip": {
						for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
							for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC)
								if (out[encode_cell({
											c : rngC,
											r : rngR
										})])
									out[encode_cell({
											c : rngC,
											r : rngR
										})].l.tooltip = val[1]
					}
					break;
				case "Note": {
						if (opts.biff <= 5 && opts.biff >= 2)
							break;
						cc = out[encode_cell(val[0])];
						var noteobj = objects[val[2]];
						if (!cc)
							break;
						if (!cc.c)
							cc.c = [];
						cmnt = {
							a : val[1],
							t : noteobj.TxO.t
						};
						cc.c.push(cmnt)
					}
					break;
				default:
					switch (R.n) {
					case "ClrtClient":
						break;
					case "XFExt":
						update_xfext(XFs[val.ixfe], val.ext);
						break;
					case "NameCmt":
						break;
					case "Header":
						break;
					case "Footer":
						break;
					case "HCenter":
						break;
					case "VCenter":
						break;
					case "Pls":
						break;
					case "Setup":
						break;
					case "DefColWidth":
						break;
					case "GCW":
						break;
					case "LHRecord":
						break;
					case "ColInfo":
						break;
					case "Row":
						break;
					case "DBCell":
						break;
					case "MulBlank":
						break;
					case "EntExU2":
						break;
					case "SxView":
						break;
					case "Sxvd":
						break;
					case "SXVI":
						break;
					case "SXVDEx":
						break;
					case "SxIvd":
						break;
					case "SXDI":
						break;
					case "SXLI":
						break;
					case "SXEx":
						break;
					case "QsiSXTag":
						break;
					case "Selection":
						break;
					case "Feat":
						break;
					case "FeatHdr":
					case "FeatHdr11":
						break;
					case "Feature11":
					case "Feature12":
					case "List12":
						break;
					case "Blank":
						break;
					case "Country":
						country = val;
						break;
					case "RecalcId":
						break;
					case "DefaultRowHeight":
					case "DxGCol":
						break;
					case "Fbi":
					case "Fbi2":
					case "GelFrame":
						break;
					case "Font":
						break;
					case "XFCRC":
						break;
					case "Style":
						break;
					case "StyleExt":
						break;
					case "Palette":
						palette = val;
						break;
					case "Theme":
						break;
					case "ScenarioProtect":
						break;
					case "ObjProtect":
						break;
					case "CondFmt12":
						break;
					case "Table":
						break;
					case "TableStyles":
						break;
					case "TableStyle":
						break;
					case "TableStyleElement":
						break;
					case "SXStreamID":
						break;
					case "SXVS":
						break;
					case "DConRef":
						break;
					case "SXAddl":
						break;
					case "DConBin":
						break;
					case "DConName":
						break;
					case "SXPI":
						break;
					case "SxFormat":
						break;
					case "SxSelect":
						break;
					case "SxRule":
						break;
					case "SxFilt":
						break;
					case "SxItm":
						break;
					case "SxDXF":
						break;
					case "ScenMan":
						break;
					case "DCon":
						break;
					case "CellWatch":
						break;
					case "PrintRowCol":
						break;
					case "PrintGrid":
						break;
					case "PrintSize":
						break;
					case "XCT":
						break;
					case "CRN":
						break;
					case "Scl": {}

						break;
					case "SheetExt": {}

						break;
					case "SheetExtOptional": {}

						break;
					case "ObNoMacros": {}

						break;
					case "ObProj": {}

						break;
					case "CodeName": {}

						break;
					case "GUIDTypeLib": {}

						break;
					case "WOpt":
						break;
					case "PhoneticInfo":
						break;
					case "OleObjectSize":
						break;
					case "DXF":
					case "DXFN":
					case "DXFN12":
					case "DXFN12List":
					case "DXFN12NoCB":
						break;
					case "Dv":
					case "DVal":
						break;
					case "BRAI":
					case "Series":
					case "SeriesText":
						break;
					case "DConn":
						break;
					case "DbOrParamQry":
						break;
					case "DBQueryExt":
						break;
					case "IFmtRecord":
						break;
					case "CondFmt":
					case "CF":
					case "CF12":
					case "CFEx":
						break;
					case "Excel9File":
						break;
					case "Units":
						break;
					case "InterfaceHdr":
					case "Mms":
					case "InterfaceEnd":
					case "DSF":
					case "BuiltInFnGroupCount":
					case "Window1":
					case "Window2":
					case "HideObj":
					case "GridSet":
					case "Guts":
					case "UserBView":
					case "UserSViewBegin":
					case "UserSViewEnd":
					case "Pane":
						break;
					default:
						switch (R.n) {
						case "Dat":
						case "Begin":
						case "End":
						case "StartBlock":
						case "EndBlock":
						case "Frame":
						case "Area":
						case "Axis":
						case "AxisLine":
						case "Tick":
							break;
						case "AxesUsed":
						case "CrtLayout12":
						case "CrtLayout12A":
						case "CrtLink":
						case "CrtLine":
						case "CrtMlFrt":
						case "CrtMlFrtContinue":
							break;
						case "LineFormat":
						case "AreaFormat":
						case "Chart":
						case "Chart3d":
						case "Chart3DBarShape":
						case "ChartFormat":
						case "ChartFrtInfo":
							break;
						case "PlotArea":
						case "PlotGrowth":
							break;
						case "SeriesList":
						case "SerParent":
						case "SerAuxTrend":
							break;
						case "DataFormat":
						case "SerToCrt":
						case "FontX":
							break;
						case "CatSerRange":
						case "AxcExt":
						case "SerFmt":
							break;
						case "ShtProps":
							break;
						case "DefaultText":
						case "Text":
						case "CatLab":
							break;
						case "DataLabExtContents":
							break;
						case "Legend":
						case "LegendException":
							break;
						case "Pie":
						case "Scatter":
							break;
						case "PieFormat":
						case "MarkerFormat":
							break;
						case "StartObject":
						case "EndObject":
							break;
						case "AlRuns":
						case "ObjectLink":
							break;
						case "SIIndex":
							break;
						case "AttachedLabel":
						case "YMult":
							break;
						case "Line":
						case "Bar":
							break;
						case "Surf":
							break;
						case "AxisParent":
							break;
						case "Pos":
							break;
						case "ValueRange":
							break;
						case "SXViewEx9":
							break;
						case "SXViewLink":
							break;
						case "PivotChartBits":
							break;
						case "SBaseRef":
							break;
						case "TextPropsStream":
							break;
						case "LnExt":
							break;
						case "MkrExt":
							break;
						case "CrtCoopt":
							break;
						case "Qsi":
						case "Qsif":
						case "Qsir":
						case "QsiSXTag":
							break;
						case "TxtQry":
							break;
						case "FilterMode":
							break;
						case "AutoFilter":
						case "AutoFilterInfo":
							break;
						case "AutoFilter12":
							break;
						case "DropDownObjIds":
							break;
						case "Sort":
							break;
						case "SortData":
							break;
						case "ShapePropsStream":
							break;
						case "MsoDrawing":
						case "MsoDrawingGroup":
						case "MsoDrawingSelection":
							break;
						case "ImData":
							break;
						case "WebPub":
						case "AutoWebPub":
						case "RightMargin":
						case "LeftMargin":
						case "TopMargin":
						case "BottomMargin":
						case "HeaderFooter":
						case "HFPicture":
						case "PLV":
						case "HorizontalPageBreaks":
						case "VerticalPageBreaks":
						case "Backup":
						case "CompressPictures":
						case "Compat12":
							break;
						case "Continue":
						case "ContinueFrt12":
							break;
						case "FrtFontList":
						case "FrtWrapper":
							break;
						case "ExternCount":
							break;
						case "RString":
							break;
						case "TabIdConf":
						case "Radar":
						case "RadarArea":
						case "DropBar":
						case "Intl":
						case "CoordList":
						case "SerAuxErrBar":
							break;
						default:
							switch (R.n) {
							case "SCENARIO":
							case "DConBin":
							case "PicF":
							case "DataLabExt":
							case "Lel":
							case "BopPop":
							case "BopPopCustom":
							case "RealTimeData":
							case "Name":
								break;
							default:
								if (options.WTF)
									throw "Unrecognized Record " + R.n
							}
						}
					}
				}
			} else
				blob.l += length
		}
		var sheetnamesraw = opts.biff === 2 ? ["Sheet1"] : Object.keys(Directory).sort(function (a, b) {
				return Number(a) - Number(b)
			}).map(function (x) {
				return Directory[x].name
			});
		var sheetnames = sheetnamesraw.slice();
		wb.Directory = sheetnamesraw;
		wb.SheetNames = sheetnamesraw;
		if (!options.bookSheets)
			wb.Sheets = Sheets;
		wb.Preamble = Preamble;
		wb.Strings = sst;
		wb.SSF = SSF.get_table();
		if (opts.enc)
			wb.Encryption = opts.enc;
		wb.Metadata = {};
		if (country !== undefined)
			wb.Metadata.Country = country;
		return wb
	}
	function parse_xlscfb(cfb, options) {
		if (!options)
			options = {};
		fix_read_opts(options);
		reset_cp();
		var CompObj,
		Summary,
		Workbook;
		if (cfb.find) {
			CompObj = cfb.find("!CompObj");
			Summary = cfb.find("!SummaryInformation");
			Workbook = cfb.find("/Workbook")
		} else {
			prep_blob(cfb, 0);
			Workbook = {
				content : cfb
			}
		}
		if (!Workbook)
			Workbook = cfb.find("/Book");
		var CompObjP,
		SummaryP,
		WorkbookP;
		if (CompObj)
			CompObjP = parse_compobj(CompObj);
		if (options.bookProps && !options.bookSheets)
			WorkbookP = {};
		else {
			if (Workbook)
				WorkbookP = parse_workbook(Workbook.content, options, !!Workbook.find);
			else
				throw new Error("Cannot find Workbook stream")
		}
		if (cfb.find)
			parse_props(cfb);
		var props = {};
		for (var y in cfb.Summary)
			props[y] = cfb.Summary[y];
		for (y in cfb.DocSummary)
			props[y] = cfb.DocSummary[y];
		WorkbookP.Props = WorkbookP.Custprops = props;
		if (options.bookFiles)
			WorkbookP.cfb = cfb;
		WorkbookP.CompObjP = CompObjP;
		return WorkbookP
	}
	function parse_props(cfb) {
		var DSI = cfb.find("!DocumentSummaryInformation");
		if (DSI)
			try {
				cfb.DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI)
			} catch (e) {}

		var SI = cfb.find("!SummaryInformation");
		if (SI)
			try {
				cfb.Summary = parse_PropertySetStream(SI, SummaryPIDSI)
			} catch (e) {}

	}
	var XLSBRecordEnum = {
		0 : {
			n : "BrtRowHdr",
			f : parse_BrtRowHdr
		},
		1 : {
			n : "BrtCellBlank",
			f : parse_BrtCellBlank
		},
		2 : {
			n : "BrtCellRk",
			f : parse_BrtCellRk
		},
		3 : {
			n : "BrtCellError",
			f : parse_BrtCellError
		},
		4 : {
			n : "BrtCellBool",
			f : parse_BrtCellBool
		},
		5 : {
			n : "BrtCellReal",
			f : parse_BrtCellReal
		},
		6 : {
			n : "BrtCellSt",
			f : parse_BrtCellSt
		},
		7 : {
			n : "BrtCellIsst",
			f : parse_BrtCellIsst
		},
		8 : {
			n : "BrtFmlaString",
			f : parse_BrtFmlaString
		},
		9 : {
			n : "BrtFmlaNum",
			f : parse_BrtFmlaNum
		},
		10 : {
			n : "BrtFmlaBool",
			f : parse_BrtFmlaBool
		},
		11 : {
			n : "BrtFmlaError",
			f : parse_BrtFmlaError
		},
		16 : {
			n : "BrtFRTArchID$",
			f : parse_BrtFRTArchID$
		},
		19 : {
			n : "BrtSSTItem",
			f : parse_RichStr
		},
		20 : {
			n : "BrtPCDIMissing",
			f : parsenoop
		},
		21 : {
			n : "BrtPCDINumber",
			f : parsenoop
		},
		22 : {
			n : "BrtPCDIBoolean",
			f : parsenoop
		},
		23 : {
			n : "BrtPCDIError",
			f : parsenoop
		},
		24 : {
			n : "BrtPCDIString",
			f : parsenoop
		},
		25 : {
			n : "BrtPCDIDatetime",
			f : parsenoop
		},
		26 : {
			n : "BrtPCDIIndex",
			f : parsenoop
		},
		27 : {
			n : "BrtPCDIAMissing",
			f : parsenoop
		},
		28 : {
			n : "BrtPCDIANumber",
			f : parsenoop
		},
		29 : {
			n : "BrtPCDIABoolean",
			f : parsenoop
		},
		30 : {
			n : "BrtPCDIAError",
			f : parsenoop
		},
		31 : {
			n : "BrtPCDIAString",
			f : parsenoop
		},
		32 : {
			n : "BrtPCDIADatetime",
			f : parsenoop
		},
		33 : {
			n : "BrtPCRRecord",
			f : parsenoop
		},
		34 : {
			n : "BrtPCRRecordDt",
			f : parsenoop
		},
		35 : {
			n : "BrtFRTBegin",
			f : parsenoop
		},
		36 : {
			n : "BrtFRTEnd",
			f : parsenoop
		},
		37 : {
			n : "BrtACBegin",
			f : parsenoop
		},
		38 : {
			n : "BrtACEnd",
			f : parsenoop
		},
		39 : {
			n : "BrtName",
			f : parsenoop
		},
		40 : {
			n : "BrtIndexRowBlock",
			f : parsenoop
		},
		42 : {
			n : "BrtIndexBlock",
			f : parsenoop
		},
		43 : {
			n : "BrtFont",
			f : parse_BrtFont
		},
		44 : {
			n : "BrtFmt",
			f : parse_BrtFmt
		},
		45 : {
			n : "BrtFill",
			f : parsenoop
		},
		46 : {
			n : "BrtBorder",
			f : parsenoop
		},
		47 : {
			n : "BrtXF",
			f : parse_BrtXF
		},
		48 : {
			n : "BrtStyle",
			f : parsenoop
		},
		49 : {
			n : "BrtCellMeta",
			f : parsenoop
		},
		50 : {
			n : "BrtValueMeta",
			f : parsenoop
		},
		51 : {
			n : "BrtMdb",
			f : parsenoop
		},
		52 : {
			n : "BrtBeginFmd",
			f : parsenoop
		},
		53 : {
			n : "BrtEndFmd",
			f : parsenoop
		},
		54 : {
			n : "BrtBeginMdx",
			f : parsenoop
		},
		55 : {
			n : "BrtEndMdx",
			f : parsenoop
		},
		56 : {
			n : "BrtBeginMdxTuple",
			f : parsenoop
		},
		57 : {
			n : "BrtEndMdxTuple",
			f : parsenoop
		},
		58 : {
			n : "BrtMdxMbrIstr",
			f : parsenoop
		},
		59 : {
			n : "BrtStr",
			f : parsenoop
		},
		60 : {
			n : "BrtColInfo",
			f : parsenoop
		},
		62 : {
			n : "BrtCellRString",
			f : parsenoop
		},
		63 : {
			n : "BrtCalcChainItem$",
			f : parse_BrtCalcChainItem$
		},
		64 : {
			n : "BrtDVal",
			f : parsenoop
		},
		65 : {
			n : "BrtSxvcellNum",
			f : parsenoop
		},
		66 : {
			n : "BrtSxvcellStr",
			f : parsenoop
		},
		67 : {
			n : "BrtSxvcellBool",
			f : parsenoop
		},
		68 : {
			n : "BrtSxvcellErr",
			f : parsenoop
		},
		69 : {
			n : "BrtSxvcellDate",
			f : parsenoop
		},
		70 : {
			n : "BrtSxvcellNil",
			f : parsenoop
		},
		128 : {
			n : "BrtFileVersion",
			f : parsenoop
		},
		129 : {
			n : "BrtBeginSheet",
			f : parsenoop
		},
		130 : {
			n : "BrtEndSheet",
			f : parsenoop
		},
		131 : {
			n : "BrtBeginBook",
			f : parsenoop,
			p : 0
		},
		132 : {
			n : "BrtEndBook",
			f : parsenoop
		},
		133 : {
			n : "BrtBeginWsViews",
			f : parsenoop
		},
		134 : {
			n : "BrtEndWsViews",
			f : parsenoop
		},
		135 : {
			n : "BrtBeginBookViews",
			f : parsenoop
		},
		136 : {
			n : "BrtEndBookViews",
			f : parsenoop
		},
		137 : {
			n : "BrtBeginWsView",
			f : parsenoop
		},
		138 : {
			n : "BrtEndWsView",
			f : parsenoop
		},
		139 : {
			n : "BrtBeginCsViews",
			f : parsenoop
		},
		140 : {
			n : "BrtEndCsViews",
			f : parsenoop
		},
		141 : {
			n : "BrtBeginCsView",
			f : parsenoop
		},
		142 : {
			n : "BrtEndCsView",
			f : parsenoop
		},
		143 : {
			n : "BrtBeginBundleShs",
			f : parsenoop
		},
		144 : {
			n : "BrtEndBundleShs",
			f : parsenoop
		},
		145 : {
			n : "BrtBeginSheetData",
			f : parsenoop
		},
		146 : {
			n : "BrtEndSheetData",
			f : parsenoop
		},
		147 : {
			n : "BrtWsProp",
			f : parse_BrtWsProp
		},
		148 : {
			n : "BrtWsDim",
			f : parse_BrtWsDim,
			p : 16
		},
		151 : {
			n : "BrtPane",
			f : parsenoop
		},
		152 : {
			n : "BrtSel",
			f : parsenoop
		},
		153 : {
			n : "BrtWbProp",
			f : parse_BrtWbProp
		},
		154 : {
			n : "BrtWbFactoid",
			f : parsenoop
		},
		155 : {
			n : "BrtFileRecover",
			f : parsenoop
		},
		156 : {
			n : "BrtBundleSh",
			f : parse_BrtBundleSh
		},
		157 : {
			n : "BrtCalcProp",
			f : parsenoop
		},
		158 : {
			n : "BrtBookView",
			f : parsenoop
		},
		159 : {
			n : "BrtBeginSst",
			f : parse_BrtBeginSst
		},
		160 : {
			n : "BrtEndSst",
			f : parsenoop
		},
		161 : {
			n : "BrtBeginAFilter",
			f : parsenoop
		},
		162 : {
			n : "BrtEndAFilter",
			f : parsenoop
		},
		163 : {
			n : "BrtBeginFilterColumn",
			f : parsenoop
		},
		164 : {
			n : "BrtEndFilterColumn",
			f : parsenoop
		},
		165 : {
			n : "BrtBeginFilters",
			f : parsenoop
		},
		166 : {
			n : "BrtEndFilters",
			f : parsenoop
		},
		167 : {
			n : "BrtFilter",
			f : parsenoop
		},
		168 : {
			n : "BrtColorFilter",
			f : parsenoop
		},
		169 : {
			n : "BrtIconFilter",
			f : parsenoop
		},
		170 : {
			n : "BrtTop10Filter",
			f : parsenoop
		},
		171 : {
			n : "BrtDynamicFilter",
			f : parsenoop
		},
		172 : {
			n : "BrtBeginCustomFilters",
			f : parsenoop
		},
		173 : {
			n : "BrtEndCustomFilters",
			f : parsenoop
		},
		174 : {
			n : "BrtCustomFilter",
			f : parsenoop
		},
		175 : {
			n : "BrtAFilterDateGroupItem",
			f : parsenoop
		},
		176 : {
			n : "BrtMergeCell",
			f : parse_BrtMergeCell
		},
		177 : {
			n : "BrtBeginMergeCells",
			f : parsenoop
		},
		178 : {
			n : "BrtEndMergeCells",
			f : parsenoop
		},
		179 : {
			n : "BrtBeginPivotCacheDef",
			f : parsenoop
		},
		180 : {
			n : "BrtEndPivotCacheDef",
			f : parsenoop
		},
		181 : {
			n : "BrtBeginPCDFields",
			f : parsenoop
		},
		182 : {
			n : "BrtEndPCDFields",
			f : parsenoop
		},
		183 : {
			n : "BrtBeginPCDField",
			f : parsenoop
		},
		184 : {
			n : "BrtEndPCDField",
			f : parsenoop
		},
		185 : {
			n : "BrtBeginPCDSource",
			f : parsenoop
		},
		186 : {
			n : "BrtEndPCDSource",
			f : parsenoop
		},
		187 : {
			n : "BrtBeginPCDSRange",
			f : parsenoop
		},
		188 : {
			n : "BrtEndPCDSRange",
			f : parsenoop
		},
		189 : {
			n : "BrtBeginPCDFAtbl",
			f : parsenoop
		},
		190 : {
			n : "BrtEndPCDFAtbl",
			f : parsenoop
		},
		191 : {
			n : "BrtBeginPCDIRun",
			f : parsenoop
		},
		192 : {
			n : "BrtEndPCDIRun",
			f : parsenoop
		},
		193 : {
			n : "BrtBeginPivotCacheRecords",
			f : parsenoop
		},
		194 : {
			n : "BrtEndPivotCacheRecords",
			f : parsenoop
		},
		195 : {
			n : "BrtBeginPCDHierarchies",
			f : parsenoop
		},
		196 : {
			n : "BrtEndPCDHierarchies",
			f : parsenoop
		},
		197 : {
			n : "BrtBeginPCDHierarchy",
			f : parsenoop
		},
		198 : {
			n : "BrtEndPCDHierarchy",
			f : parsenoop
		},
		199 : {
			n : "BrtBeginPCDHFieldsUsage",
			f : parsenoop
		},
		200 : {
			n : "BrtEndPCDHFieldsUsage",
			f : parsenoop
		},
		201 : {
			n : "BrtBeginExtConnection",
			f : parsenoop
		},
		202 : {
			n : "BrtEndExtConnection",
			f : parsenoop
		},
		203 : {
			n : "BrtBeginECDbProps",
			f : parsenoop
		},
		204 : {
			n : "BrtEndECDbProps",
			f : parsenoop
		},
		205 : {
			n : "BrtBeginECOlapProps",
			f : parsenoop
		},
		206 : {
			n : "BrtEndECOlapProps",
			f : parsenoop
		},
		207 : {
			n : "BrtBeginPCDSConsol",
			f : parsenoop
		},
		208 : {
			n : "BrtEndPCDSConsol",
			f : parsenoop
		},
		209 : {
			n : "BrtBeginPCDSCPages",
			f : parsenoop
		},
		210 : {
			n : "BrtEndPCDSCPages",
			f : parsenoop
		},
		211 : {
			n : "BrtBeginPCDSCPage",
			f : parsenoop
		},
		212 : {
			n : "BrtEndPCDSCPage",
			f : parsenoop
		},
		213 : {
			n : "BrtBeginPCDSCPItem",
			f : parsenoop
		},
		214 : {
			n : "BrtEndPCDSCPItem",
			f : parsenoop
		},
		215 : {
			n : "BrtBeginPCDSCSets",
			f : parsenoop
		},
		216 : {
			n : "BrtEndPCDSCSets",
			f : parsenoop
		},
		217 : {
			n : "BrtBeginPCDSCSet",
			f : parsenoop
		},
		218 : {
			n : "BrtEndPCDSCSet",
			f : parsenoop
		},
		219 : {
			n : "BrtBeginPCDFGroup",
			f : parsenoop
		},
		220 : {
			n : "BrtEndPCDFGroup",
			f : parsenoop
		},
		221 : {
			n : "BrtBeginPCDFGItems",
			f : parsenoop
		},
		222 : {
			n : "BrtEndPCDFGItems",
			f : parsenoop
		},
		223 : {
			n : "BrtBeginPCDFGRange",
			f : parsenoop
		},
		224 : {
			n : "BrtEndPCDFGRange",
			f : parsenoop
		},
		225 : {
			n : "BrtBeginPCDFGDiscrete",
			f : parsenoop
		},
		226 : {
			n : "BrtEndPCDFGDiscrete",
			f : parsenoop
		},
		227 : {
			n : "BrtBeginPCDSDTupleCache",
			f : parsenoop
		},
		228 : {
			n : "BrtEndPCDSDTupleCache",
			f : parsenoop
		},
		229 : {
			n : "BrtBeginPCDSDTCEntries",
			f : parsenoop
		},
		230 : {
			n : "BrtEndPCDSDTCEntries",
			f : parsenoop
		},
		231 : {
			n : "BrtBeginPCDSDTCEMembers",
			f : parsenoop
		},
		232 : {
			n : "BrtEndPCDSDTCEMembers",
			f : parsenoop
		},
		233 : {
			n : "BrtBeginPCDSDTCEMember",
			f : parsenoop
		},
		234 : {
			n : "BrtEndPCDSDTCEMember",
			f : parsenoop
		},
		235 : {
			n : "BrtBeginPCDSDTCQueries",
			f : parsenoop
		},
		236 : {
			n : "BrtEndPCDSDTCQueries",
			f : parsenoop
		},
		237 : {
			n : "BrtBeginPCDSDTCQuery",
			f : parsenoop
		},
		238 : {
			n : "BrtEndPCDSDTCQuery",
			f : parsenoop
		},
		239 : {
			n : "BrtBeginPCDSDTCSets",
			f : parsenoop
		},
		240 : {
			n : "BrtEndPCDSDTCSets",
			f : parsenoop
		},
		241 : {
			n : "BrtBeginPCDSDTCSet",
			f : parsenoop
		},
		242 : {
			n : "BrtEndPCDSDTCSet",
			f : parsenoop
		},
		243 : {
			n : "BrtBeginPCDCalcItems",
			f : parsenoop
		},
		244 : {
			n : "BrtEndPCDCalcItems",
			f : parsenoop
		},
		245 : {
			n : "BrtBeginPCDCalcItem",
			f : parsenoop
		},
		246 : {
			n : "BrtEndPCDCalcItem",
			f : parsenoop
		},
		247 : {
			n : "BrtBeginPRule",
			f : parsenoop
		},
		248 : {
			n : "BrtEndPRule",
			f : parsenoop
		},
		249 : {
			n : "BrtBeginPRFilters",
			f : parsenoop
		},
		250 : {
			n : "BrtEndPRFilters",
			f : parsenoop
		},
		251 : {
			n : "BrtBeginPRFilter",
			f : parsenoop
		},
		252 : {
			n : "BrtEndPRFilter",
			f : parsenoop
		},
		253 : {
			n : "BrtBeginPNames",
			f : parsenoop
		},
		254 : {
			n : "BrtEndPNames",
			f : parsenoop
		},
		255 : {
			n : "BrtBeginPName",
			f : parsenoop
		},
		256 : {
			n : "BrtEndPName",
			f : parsenoop
		},
		257 : {
			n : "BrtBeginPNPairs",
			f : parsenoop
		},
		258 : {
			n : "BrtEndPNPairs",
			f : parsenoop
		},
		259 : {
			n : "BrtBeginPNPair",
			f : parsenoop
		},
		260 : {
			n : "BrtEndPNPair",
			f : parsenoop
		},
		261 : {
			n : "BrtBeginECWebProps",
			f : parsenoop
		},
		262 : {
			n : "BrtEndECWebProps",
			f : parsenoop
		},
		263 : {
			n : "BrtBeginEcWpTables",
			f : parsenoop
		},
		264 : {
			n : "BrtEndECWPTables",
			f : parsenoop
		},
		265 : {
			n : "BrtBeginECParams",
			f : parsenoop
		},
		266 : {
			n : "BrtEndECParams",
			f : parsenoop
		},
		267 : {
			n : "BrtBeginECParam",
			f : parsenoop
		},
		268 : {
			n : "BrtEndECParam",
			f : parsenoop
		},
		269 : {
			n : "BrtBeginPCDKPIs",
			f : parsenoop
		},
		270 : {
			n : "BrtEndPCDKPIs",
			f : parsenoop
		},
		271 : {
			n : "BrtBeginPCDKPI",
			f : parsenoop
		},
		272 : {
			n : "BrtEndPCDKPI",
			f : parsenoop
		},
		273 : {
			n : "BrtBeginDims",
			f : parsenoop
		},
		274 : {
			n : "BrtEndDims",
			f : parsenoop
		},
		275 : {
			n : "BrtBeginDim",
			f : parsenoop
		},
		276 : {
			n : "BrtEndDim",
			f : parsenoop
		},
		277 : {
			n : "BrtIndexPartEnd",
			f : parsenoop
		},
		278 : {
			n : "BrtBeginStyleSheet",
			f : parsenoop
		},
		279 : {
			n : "BrtEndStyleSheet",
			f : parsenoop
		},
		280 : {
			n : "BrtBeginSXView",
			f : parsenoop
		},
		281 : {
			n : "BrtEndSXVI",
			f : parsenoop
		},
		282 : {
			n : "BrtBeginSXVI",
			f : parsenoop
		},
		283 : {
			n : "BrtBeginSXVIs",
			f : parsenoop
		},
		284 : {
			n : "BrtEndSXVIs",
			f : parsenoop
		},
		285 : {
			n : "BrtBeginSXVD",
			f : parsenoop
		},
		286 : {
			n : "BrtEndSXVD",
			f : parsenoop
		},
		287 : {
			n : "BrtBeginSXVDs",
			f : parsenoop
		},
		288 : {
			n : "BrtEndSXVDs",
			f : parsenoop
		},
		289 : {
			n : "BrtBeginSXPI",
			f : parsenoop
		},
		290 : {
			n : "BrtEndSXPI",
			f : parsenoop
		},
		291 : {
			n : "BrtBeginSXPIs",
			f : parsenoop
		},
		292 : {
			n : "BrtEndSXPIs",
			f : parsenoop
		},
		293 : {
			n : "BrtBeginSXDI",
			f : parsenoop
		},
		294 : {
			n : "BrtEndSXDI",
			f : parsenoop
		},
		295 : {
			n : "BrtBeginSXDIs",
			f : parsenoop
		},
		296 : {
			n : "BrtEndSXDIs",
			f : parsenoop
		},
		297 : {
			n : "BrtBeginSXLI",
			f : parsenoop
		},
		298 : {
			n : "BrtEndSXLI",
			f : parsenoop
		},
		299 : {
			n : "BrtBeginSXLIRws",
			f : parsenoop
		},
		300 : {
			n : "BrtEndSXLIRws",
			f : parsenoop
		},
		301 : {
			n : "BrtBeginSXLICols",
			f : parsenoop
		},
		302 : {
			n : "BrtEndSXLICols",
			f : parsenoop
		},
		303 : {
			n : "BrtBeginSXFormat",
			f : parsenoop
		},
		304 : {
			n : "BrtEndSXFormat",
			f : parsenoop
		},
		305 : {
			n : "BrtBeginSXFormats",
			f : parsenoop
		},
		306 : {
			n : "BrtEndSxFormats",
			f : parsenoop
		},
		307 : {
			n : "BrtBeginSxSelect",
			f : parsenoop
		},
		308 : {
			n : "BrtEndSxSelect",
			f : parsenoop
		},
		309 : {
			n : "BrtBeginISXVDRws",
			f : parsenoop
		},
		310 : {
			n : "BrtEndISXVDRws",
			f : parsenoop
		},
		311 : {
			n : "BrtBeginISXVDCols",
			f : parsenoop
		},
		312 : {
			n : "BrtEndISXVDCols",
			f : parsenoop
		},
		313 : {
			n : "BrtEndSXLocation",
			f : parsenoop
		},
		314 : {
			n : "BrtBeginSXLocation",
			f : parsenoop
		},
		315 : {
			n : "BrtEndSXView",
			f : parsenoop
		},
		316 : {
			n : "BrtBeginSXTHs",
			f : parsenoop
		},
		317 : {
			n : "BrtEndSXTHs",
			f : parsenoop
		},
		318 : {
			n : "BrtBeginSXTH",
			f : parsenoop
		},
		319 : {
			n : "BrtEndSXTH",
			f : parsenoop
		},
		320 : {
			n : "BrtBeginISXTHRws",
			f : parsenoop
		},
		321 : {
			n : "BrtEndISXTHRws",
			f : parsenoop
		},
		322 : {
			n : "BrtBeginISXTHCols",
			f : parsenoop
		},
		323 : {
			n : "BrtEndISXTHCols",
			f : parsenoop
		},
		324 : {
			n : "BrtBeginSXTDMPS",
			f : parsenoop
		},
		325 : {
			n : "BrtEndSXTDMPs",
			f : parsenoop
		},
		326 : {
			n : "BrtBeginSXTDMP",
			f : parsenoop
		},
		327 : {
			n : "BrtEndSXTDMP",
			f : parsenoop
		},
		328 : {
			n : "BrtBeginSXTHItems",
			f : parsenoop
		},
		329 : {
			n : "BrtEndSXTHItems",
			f : parsenoop
		},
		330 : {
			n : "BrtBeginSXTHItem",
			f : parsenoop
		},
		331 : {
			n : "BrtEndSXTHItem",
			f : parsenoop
		},
		332 : {
			n : "BrtBeginMetadata",
			f : parsenoop
		},
		333 : {
			n : "BrtEndMetadata",
			f : parsenoop
		},
		334 : {
			n : "BrtBeginEsmdtinfo",
			f : parsenoop
		},
		335 : {
			n : "BrtMdtinfo",
			f : parsenoop
		},
		336 : {
			n : "BrtEndEsmdtinfo",
			f : parsenoop
		},
		337 : {
			n : "BrtBeginEsmdb",
			f : parsenoop
		},
		338 : {
			n : "BrtEndEsmdb",
			f : parsenoop
		},
		339 : {
			n : "BrtBeginEsfmd",
			f : parsenoop
		},
		340 : {
			n : "BrtEndEsfmd",
			f : parsenoop
		},
		341 : {
			n : "BrtBeginSingleCells",
			f : parsenoop
		},
		342 : {
			n : "BrtEndSingleCells",
			f : parsenoop
		},
		343 : {
			n : "BrtBeginList",
			f : parsenoop
		},
		344 : {
			n : "BrtEndList",
			f : parsenoop
		},
		345 : {
			n : "BrtBeginListCols",
			f : parsenoop
		},
		346 : {
			n : "BrtEndListCols",
			f : parsenoop
		},
		347 : {
			n : "BrtBeginListCol",
			f : parsenoop
		},
		348 : {
			n : "BrtEndListCol",
			f : parsenoop
		},
		349 : {
			n : "BrtBeginListXmlCPr",
			f : parsenoop
		},
		350 : {
			n : "BrtEndListXmlCPr",
			f : parsenoop
		},
		351 : {
			n : "BrtListCCFmla",
			f : parsenoop
		},
		352 : {
			n : "BrtListTrFmla",
			f : parsenoop
		},
		353 : {
			n : "BrtBeginExternals",
			f : parsenoop
		},
		354 : {
			n : "BrtEndExternals",
			f : parsenoop
		},
		355 : {
			n : "BrtSupBookSrc",
			f : parsenoop
		},
		357 : {
			n : "BrtSupSelf",
			f : parsenoop
		},
		358 : {
			n : "BrtSupSame",
			f : parsenoop
		},
		359 : {
			n : "BrtSupTabs",
			f : parsenoop
		},
		360 : {
			n : "BrtBeginSupBook",
			f : parsenoop
		},
		361 : {
			n : "BrtPlaceholderName",
			f : parsenoop
		},
		362 : {
			n : "BrtExternSheet",
			f : parsenoop
		},
		363 : {
			n : "BrtExternTableStart",
			f : parsenoop
		},
		364 : {
			n : "BrtExternTableEnd",
			f : parsenoop
		},
		366 : {
			n : "BrtExternRowHdr",
			f : parsenoop
		},
		367 : {
			n : "BrtExternCellBlank",
			f : parsenoop
		},
		368 : {
			n : "BrtExternCellReal",
			f : parsenoop
		},
		369 : {
			n : "BrtExternCellBool",
			f : parsenoop
		},
		370 : {
			n : "BrtExternCellError",
			f : parsenoop
		},
		371 : {
			n : "BrtExternCellString",
			f : parsenoop
		},
		372 : {
			n : "BrtBeginEsmdx",
			f : parsenoop
		},
		373 : {
			n : "BrtEndEsmdx",
			f : parsenoop
		},
		374 : {
			n : "BrtBeginMdxSet",
			f : parsenoop
		},
		375 : {
			n : "BrtEndMdxSet",
			f : parsenoop
		},
		376 : {
			n : "BrtBeginMdxMbrProp",
			f : parsenoop
		},
		377 : {
			n : "BrtEndMdxMbrProp",
			f : parsenoop
		},
		378 : {
			n : "BrtBeginMdxKPI",
			f : parsenoop
		},
		379 : {
			n : "BrtEndMdxKPI",
			f : parsenoop
		},
		380 : {
			n : "BrtBeginEsstr",
			f : parsenoop
		},
		381 : {
			n : "BrtEndEsstr",
			f : parsenoop
		},
		382 : {
			n : "BrtBeginPRFItem",
			f : parsenoop
		},
		383 : {
			n : "BrtEndPRFItem",
			f : parsenoop
		},
		384 : {
			n : "BrtBeginPivotCacheIDs",
			f : parsenoop
		},
		385 : {
			n : "BrtEndPivotCacheIDs",
			f : parsenoop
		},
		386 : {
			n : "BrtBeginPivotCacheID",
			f : parsenoop
		},
		387 : {
			n : "BrtEndPivotCacheID",
			f : parsenoop
		},
		388 : {
			n : "BrtBeginISXVIs",
			f : parsenoop
		},
		389 : {
			n : "BrtEndISXVIs",
			f : parsenoop
		},
		390 : {
			n : "BrtBeginColInfos",
			f : parsenoop
		},
		391 : {
			n : "BrtEndColInfos",
			f : parsenoop
		},
		392 : {
			n : "BrtBeginRwBrk",
			f : parsenoop
		},
		393 : {
			n : "BrtEndRwBrk",
			f : parsenoop
		},
		394 : {
			n : "BrtBeginColBrk",
			f : parsenoop
		},
		395 : {
			n : "BrtEndColBrk",
			f : parsenoop
		},
		396 : {
			n : "BrtBrk",
			f : parsenoop
		},
		397 : {
			n : "BrtUserBookView",
			f : parsenoop
		},
		398 : {
			n : "BrtInfo",
			f : parsenoop
		},
		399 : {
			n : "BrtCUsr",
			f : parsenoop
		},
		400 : {
			n : "BrtUsr",
			f : parsenoop
		},
		401 : {
			n : "BrtBeginUsers",
			f : parsenoop
		},
		403 : {
			n : "BrtEOF",
			f : parsenoop
		},
		404 : {
			n : "BrtUCR",
			f : parsenoop
		},
		405 : {
			n : "BrtRRInsDel",
			f : parsenoop
		},
		406 : {
			n : "BrtRREndInsDel",
			f : parsenoop
		},
		407 : {
			n : "BrtRRMove",
			f : parsenoop
		},
		408 : {
			n : "BrtRREndMove",
			f : parsenoop
		},
		409 : {
			n : "BrtRRChgCell",
			f : parsenoop
		},
		410 : {
			n : "BrtRREndChgCell",
			f : parsenoop
		},
		411 : {
			n : "BrtRRHeader",
			f : parsenoop
		},
		412 : {
			n : "BrtRRUserView",
			f : parsenoop
		},
		413 : {
			n : "BrtRRRenSheet",
			f : parsenoop
		},
		414 : {
			n : "BrtRRInsertSh",
			f : parsenoop
		},
		415 : {
			n : "BrtRRDefName",
			f : parsenoop
		},
		416 : {
			n : "BrtRRNote",
			f : parsenoop
		},
		417 : {
			n : "BrtRRConflict",
			f : parsenoop
		},
		418 : {
			n : "BrtRRTQSIF",
			f : parsenoop
		},
		419 : {
			n : "BrtRRFormat",
			f : parsenoop
		},
		420 : {
			n : "BrtRREndFormat",
			f : parsenoop
		},
		421 : {
			n : "BrtRRAutoFmt",
			f : parsenoop
		},
		422 : {
			n : "BrtBeginUserShViews",
			f : parsenoop
		},
		423 : {
			n : "BrtBeginUserShView",
			f : parsenoop
		},
		424 : {
			n : "BrtEndUserShView",
			f : parsenoop
		},
		425 : {
			n : "BrtEndUserShViews",
			f : parsenoop
		},
		426 : {
			n : "BrtArrFmla",
			f : parsenoop
		},
		427 : {
			n : "BrtShrFmla",
			f : parsenoop
		},
		428 : {
			n : "BrtTable",
			f : parsenoop
		},
		429 : {
			n : "BrtBeginExtConnections",
			f : parsenoop
		},
		430 : {
			n : "BrtEndExtConnections",
			f : parsenoop
		},
		431 : {
			n : "BrtBeginPCDCalcMems",
			f : parsenoop
		},
		432 : {
			n : "BrtEndPCDCalcMems",
			f : parsenoop
		},
		433 : {
			n : "BrtBeginPCDCalcMem",
			f : parsenoop
		},
		434 : {
			n : "BrtEndPCDCalcMem",
			f : parsenoop
		},
		435 : {
			n : "BrtBeginPCDHGLevels",
			f : parsenoop
		},
		436 : {
			n : "BrtEndPCDHGLevels",
			f : parsenoop
		},
		437 : {
			n : "BrtBeginPCDHGLevel",
			f : parsenoop
		},
		438 : {
			n : "BrtEndPCDHGLevel",
			f : parsenoop
		},
		439 : {
			n : "BrtBeginPCDHGLGroups",
			f : parsenoop
		},
		440 : {
			n : "BrtEndPCDHGLGroups",
			f : parsenoop
		},
		441 : {
			n : "BrtBeginPCDHGLGroup",
			f : parsenoop
		},
		442 : {
			n : "BrtEndPCDHGLGroup",
			f : parsenoop
		},
		443 : {
			n : "BrtBeginPCDHGLGMembers",
			f : parsenoop
		},
		444 : {
			n : "BrtEndPCDHGLGMembers",
			f : parsenoop
		},
		445 : {
			n : "BrtBeginPCDHGLGMember",
			f : parsenoop
		},
		446 : {
			n : "BrtEndPCDHGLGMember",
			f : parsenoop
		},
		447 : {
			n : "BrtBeginQSI",
			f : parsenoop
		},
		448 : {
			n : "BrtEndQSI",
			f : parsenoop
		},
		449 : {
			n : "BrtBeginQSIR",
			f : parsenoop
		},
		450 : {
			n : "BrtEndQSIR",
			f : parsenoop
		},
		451 : {
			n : "BrtBeginDeletedNames",
			f : parsenoop
		},
		452 : {
			n : "BrtEndDeletedNames",
			f : parsenoop
		},
		453 : {
			n : "BrtBeginDeletedName",
			f : parsenoop
		},
		454 : {
			n : "BrtEndDeletedName",
			f : parsenoop
		},
		455 : {
			n : "BrtBeginQSIFs",
			f : parsenoop
		},
		456 : {
			n : "BrtEndQSIFs",
			f : parsenoop
		},
		457 : {
			n : "BrtBeginQSIF",
			f : parsenoop
		},
		458 : {
			n : "BrtEndQSIF",
			f : parsenoop
		},
		459 : {
			n : "BrtBeginAutoSortScope",
			f : parsenoop
		},
		460 : {
			n : "BrtEndAutoSortScope",
			f : parsenoop
		},
		461 : {
			n : "BrtBeginConditionalFormatting",
			f : parsenoop
		},
		462 : {
			n : "BrtEndConditionalFormatting",
			f : parsenoop
		},
		463 : {
			n : "BrtBeginCFRule",
			f : parsenoop
		},
		464 : {
			n : "BrtEndCFRule",
			f : parsenoop
		},
		465 : {
			n : "BrtBeginIconSet",
			f : parsenoop
		},
		466 : {
			n : "BrtEndIconSet",
			f : parsenoop
		},
		467 : {
			n : "BrtBeginDatabar",
			f : parsenoop
		},
		468 : {
			n : "BrtEndDatabar",
			f : parsenoop
		},
		469 : {
			n : "BrtBeginColorScale",
			f : parsenoop
		},
		470 : {
			n : "BrtEndColorScale",
			f : parsenoop
		},
		471 : {
			n : "BrtCFVO",
			f : parsenoop
		},
		472 : {
			n : "BrtExternValueMeta",
			f : parsenoop
		},
		473 : {
			n : "BrtBeginColorPalette",
			f : parsenoop
		},
		474 : {
			n : "BrtEndColorPalette",
			f : parsenoop
		},
		475 : {
			n : "BrtIndexedColor",
			f : parsenoop
		},
		476 : {
			n : "BrtMargins",
			f : parsenoop
		},
		477 : {
			n : "BrtPrintOptions",
			f : parsenoop
		},
		478 : {
			n : "BrtPageSetup",
			f : parsenoop
		},
		479 : {
			n : "BrtBeginHeaderFooter",
			f : parsenoop
		},
		480 : {
			n : "BrtEndHeaderFooter",
			f : parsenoop
		},
		481 : {
			n : "BrtBeginSXCrtFormat",
			f : parsenoop
		},
		482 : {
			n : "BrtEndSXCrtFormat",
			f : parsenoop
		},
		483 : {
			n : "BrtBeginSXCrtFormats",
			f : parsenoop
		},
		484 : {
			n : "BrtEndSXCrtFormats",
			f : parsenoop
		},
		485 : {
			n : "BrtWsFmtInfo",
			f : parsenoop
		},
		486 : {
			n : "BrtBeginMgs",
			f : parsenoop
		},
		487 : {
			n : "BrtEndMGs",
			f : parsenoop
		},
		488 : {
			n : "BrtBeginMGMaps",
			f : parsenoop
		},
		489 : {
			n : "BrtEndMGMaps",
			f : parsenoop
		},
		490 : {
			n : "BrtBeginMG",
			f : parsenoop
		},
		491 : {
			n : "BrtEndMG",
			f : parsenoop
		},
		492 : {
			n : "BrtBeginMap",
			f : parsenoop
		},
		493 : {
			n : "BrtEndMap",
			f : parsenoop
		},
		494 : {
			n : "BrtHLink",
			f : parse_BrtHLink
		},
		495 : {
			n : "BrtBeginDCon",
			f : parsenoop
		},
		496 : {
			n : "BrtEndDCon",
			f : parsenoop
		},
		497 : {
			n : "BrtBeginDRefs",
			f : parsenoop
		},
		498 : {
			n : "BrtEndDRefs",
			f : parsenoop
		},
		499 : {
			n : "BrtDRef",
			f : parsenoop
		},
		500 : {
			n : "BrtBeginScenMan",
			f : parsenoop
		},
		501 : {
			n : "BrtEndScenMan",
			f : parsenoop
		},
		502 : {
			n : "BrtBeginSct",
			f : parsenoop
		},
		503 : {
			n : "BrtEndSct",
			f : parsenoop
		},
		504 : {
			n : "BrtSlc",
			f : parsenoop
		},
		505 : {
			n : "BrtBeginDXFs",
			f : parsenoop
		},
		506 : {
			n : "BrtEndDXFs",
			f : parsenoop
		},
		507 : {
			n : "BrtDXF",
			f : parsenoop
		},
		508 : {
			n : "BrtBeginTableStyles",
			f : parsenoop
		},
		509 : {
			n : "BrtEndTableStyles",
			f : parsenoop
		},
		510 : {
			n : "BrtBeginTableStyle",
			f : parsenoop
		},
		511 : {
			n : "BrtEndTableStyle",
			f : parsenoop
		},
		512 : {
			n : "BrtTableStyleElement",
			f : parsenoop
		},
		513 : {
			n : "BrtTableStyleClient",
			f : parsenoop
		},
		514 : {
			n : "BrtBeginVolDeps",
			f : parsenoop
		},
		515 : {
			n : "BrtEndVolDeps",
			f : parsenoop
		},
		516 : {
			n : "BrtBeginVolType",
			f : parsenoop
		},
		517 : {
			n : "BrtEndVolType",
			f : parsenoop
		},
		518 : {
			n : "BrtBeginVolMain",
			f : parsenoop
		},
		519 : {
			n : "BrtEndVolMain",
			f : parsenoop
		},
		520 : {
			n : "BrtBeginVolTopic",
			f : parsenoop
		},
		521 : {
			n : "BrtEndVolTopic",
			f : parsenoop
		},
		522 : {
			n : "BrtVolSubtopic",
			f : parsenoop
		},
		523 : {
			n : "BrtVolRef",
			f : parsenoop
		},
		524 : {
			n : "BrtVolNum",
			f : parsenoop
		},
		525 : {
			n : "BrtVolErr",
			f : parsenoop
		},
		526 : {
			n : "BrtVolStr",
			f : parsenoop
		},
		527 : {
			n : "BrtVolBool",
			f : parsenoop
		},
		528 : {
			n : "BrtBeginCalcChain$",
			f : parsenoop
		},
		529 : {
			n : "BrtEndCalcChain$",
			f : parsenoop
		},
		530 : {
			n : "BrtBeginSortState",
			f : parsenoop
		},
		531 : {
			n : "BrtEndSortState",
			f : parsenoop
		},
		532 : {
			n : "BrtBeginSortCond",
			f : parsenoop
		},
		533 : {
			n : "BrtEndSortCond",
			f : parsenoop
		},
		534 : {
			n : "BrtBookProtection",
			f : parsenoop
		},
		535 : {
			n : "BrtSheetProtection",
			f : parsenoop
		},
		536 : {
			n : "BrtRangeProtection",
			f : parsenoop
		},
		537 : {
			n : "BrtPhoneticInfo",
			f : parsenoop
		},
		538 : {
			n : "BrtBeginECTxtWiz",
			f : parsenoop
		},
		539 : {
			n : "BrtEndECTxtWiz",
			f : parsenoop
		},
		540 : {
			n : "BrtBeginECTWFldInfoLst",
			f : parsenoop
		},
		541 : {
			n : "BrtEndECTWFldInfoLst",
			f : parsenoop
		},
		542 : {
			n : "BrtBeginECTwFldInfo",
			f : parsenoop
		},
		548 : {
			n : "BrtFileSharing",
			f : parsenoop
		},
		549 : {
			n : "BrtOleSize",
			f : parsenoop
		},
		550 : {
			n : "BrtDrawing",
			f : parsenoop
		},
		551 : {
			n : "BrtLegacyDrawing",
			f : parsenoop
		},
		552 : {
			n : "BrtLegacyDrawingHF",
			f : parsenoop
		},
		553 : {
			n : "BrtWebOpt",
			f : parsenoop
		},
		554 : {
			n : "BrtBeginWebPubItems",
			f : parsenoop
		},
		555 : {
			n : "BrtEndWebPubItems",
			f : parsenoop
		},
		556 : {
			n : "BrtBeginWebPubItem",
			f : parsenoop
		},
		557 : {
			n : "BrtEndWebPubItem",
			f : parsenoop
		},
		558 : {
			n : "BrtBeginSXCondFmt",
			f : parsenoop
		},
		559 : {
			n : "BrtEndSXCondFmt",
			f : parsenoop
		},
		560 : {
			n : "BrtBeginSXCondFmts",
			f : parsenoop
		},
		561 : {
			n : "BrtEndSXCondFmts",
			f : parsenoop
		},
		562 : {
			n : "BrtBkHim",
			f : parsenoop
		},
		564 : {
			n : "BrtColor",
			f : parsenoop
		},
		565 : {
			n : "BrtBeginIndexedColors",
			f : parsenoop
		},
		566 : {
			n : "BrtEndIndexedColors",
			f : parsenoop
		},
		569 : {
			n : "BrtBeginMRUColors",
			f : parsenoop
		},
		570 : {
			n : "BrtEndMRUColors",
			f : parsenoop
		},
		572 : {
			n : "BrtMRUColor",
			f : parsenoop
		},
		573 : {
			n : "BrtBeginDVals",
			f : parsenoop
		},
		574 : {
			n : "BrtEndDVals",
			f : parsenoop
		},
		577 : {
			n : "BrtSupNameStart",
			f : parsenoop
		},
		578 : {
			n : "BrtSupNameValueStart",
			f : parsenoop
		},
		579 : {
			n : "BrtSupNameValueEnd",
			f : parsenoop
		},
		580 : {
			n : "BrtSupNameNum",
			f : parsenoop
		},
		581 : {
			n : "BrtSupNameErr",
			f : parsenoop
		},
		582 : {
			n : "BrtSupNameSt",
			f : parsenoop
		},
		583 : {
			n : "BrtSupNameNil",
			f : parsenoop
		},
		584 : {
			n : "BrtSupNameBool",
			f : parsenoop
		},
		585 : {
			n : "BrtSupNameFmla",
			f : parsenoop
		},
		586 : {
			n : "BrtSupNameBits",
			f : parsenoop
		},
		587 : {
			n : "BrtSupNameEnd",
			f : parsenoop
		},
		588 : {
			n : "BrtEndSupBook",
			f : parsenoop
		},
		589 : {
			n : "BrtCellSmartTagProperty",
			f : parsenoop
		},
		590 : {
			n : "BrtBeginCellSmartTag",
			f : parsenoop
		},
		591 : {
			n : "BrtEndCellSmartTag",
			f : parsenoop
		},
		592 : {
			n : "BrtBeginCellSmartTags",
			f : parsenoop
		},
		593 : {
			n : "BrtEndCellSmartTags",
			f : parsenoop
		},
		594 : {
			n : "BrtBeginSmartTags",
			f : parsenoop
		},
		595 : {
			n : "BrtEndSmartTags",
			f : parsenoop
		},
		596 : {
			n : "BrtSmartTagType",
			f : parsenoop
		},
		597 : {
			n : "BrtBeginSmartTagTypes",
			f : parsenoop
		},
		598 : {
			n : "BrtEndSmartTagTypes",
			f : parsenoop
		},
		599 : {
			n : "BrtBeginSXFilters",
			f : parsenoop
		},
		600 : {
			n : "BrtEndSXFilters",
			f : parsenoop
		},
		601 : {
			n : "BrtBeginSXFILTER",
			f : parsenoop
		},
		602 : {
			n : "BrtEndSXFilter",
			f : parsenoop
		},
		603 : {
			n : "BrtBeginFills",
			f : parsenoop
		},
		604 : {
			n : "BrtEndFills",
			f : parsenoop
		},
		605 : {
			n : "BrtBeginCellWatches",
			f : parsenoop
		},
		606 : {
			n : "BrtEndCellWatches",
			f : parsenoop
		},
		607 : {
			n : "BrtCellWatch",
			f : parsenoop
		},
		608 : {
			n : "BrtBeginCRErrs",
			f : parsenoop
		},
		609 : {
			n : "BrtEndCRErrs",
			f : parsenoop
		},
		610 : {
			n : "BrtCrashRecErr",
			f : parsenoop
		},
		611 : {
			n : "BrtBeginFonts",
			f : parsenoop
		},
		612 : {
			n : "BrtEndFonts",
			f : parsenoop
		},
		613 : {
			n : "BrtBeginBorders",
			f : parsenoop
		},
		614 : {
			n : "BrtEndBorders",
			f : parsenoop
		},
		615 : {
			n : "BrtBeginFmts",
			f : parsenoop
		},
		616 : {
			n : "BrtEndFmts",
			f : parsenoop
		},
		617 : {
			n : "BrtBeginCellXFs",
			f : parsenoop
		},
		618 : {
			n : "BrtEndCellXFs",
			f : parsenoop
		},
		619 : {
			n : "BrtBeginStyles",
			f : parsenoop
		},
		620 : {
			n : "BrtEndStyles",
			f : parsenoop
		},
		625 : {
			n : "BrtBigName",
			f : parsenoop
		},
		626 : {
			n : "BrtBeginCellStyleXFs",
			f : parsenoop
		},
		627 : {
			n : "BrtEndCellStyleXFs",
			f : parsenoop
		},
		628 : {
			n : "BrtBeginComments",
			f : parsenoop
		},
		629 : {
			n : "BrtEndComments",
			f : parsenoop
		},
		630 : {
			n : "BrtBeginCommentAuthors",
			f : parsenoop
		},
		631 : {
			n : "BrtEndCommentAuthors",
			f : parsenoop
		},
		632 : {
			n : "BrtCommentAuthor",
			f : parse_BrtCommentAuthor
		},
		633 : {
			n : "BrtBeginCommentList",
			f : parsenoop
		},
		634 : {
			n : "BrtEndCommentList",
			f : parsenoop
		},
		635 : {
			n : "BrtBeginComment",
			f : parse_BrtBeginComment
		},
		636 : {
			n : "BrtEndComment",
			f : parsenoop
		},
		637 : {
			n : "BrtCommentText",
			f : parse_BrtCommentText
		},
		638 : {
			n : "BrtBeginOleObjects",
			f : parsenoop
		},
		639 : {
			n : "BrtOleObject",
			f : parsenoop
		},
		640 : {
			n : "BrtEndOleObjects",
			f : parsenoop
		},
		641 : {
			n : "BrtBeginSxrules",
			f : parsenoop
		},
		642 : {
			n : "BrtEndSxRules",
			f : parsenoop
		},
		643 : {
			n : "BrtBeginActiveXControls",
			f : parsenoop
		},
		644 : {
			n : "BrtActiveX",
			f : parsenoop
		},
		645 : {
			n : "BrtEndActiveXControls",
			f : parsenoop
		},
		646 : {
			n : "BrtBeginPCDSDTCEMembersSortBy",
			f : parsenoop
		},
		648 : {
			n : "BrtBeginCellIgnoreECs",
			f : parsenoop
		},
		649 : {
			n : "BrtCellIgnoreEC",
			f : parsenoop
		},
		650 : {
			n : "BrtEndCellIgnoreECs",
			f : parsenoop
		},
		651 : {
			n : "BrtCsProp",
			f : parsenoop
		},
		652 : {
			n : "BrtCsPageSetup",
			f : parsenoop
		},
		653 : {
			n : "BrtBeginUserCsViews",
			f : parsenoop
		},
		654 : {
			n : "BrtEndUserCsViews",
			f : parsenoop
		},
		655 : {
			n : "BrtBeginUserCsView",
			f : parsenoop
		},
		656 : {
			n : "BrtEndUserCsView",
			f : parsenoop
		},
		657 : {
			n : "BrtBeginPcdSFCIEntries",
			f : parsenoop
		},
		658 : {
			n : "BrtEndPCDSFCIEntries",
			f : parsenoop
		},
		659 : {
			n : "BrtPCDSFCIEntry",
			f : parsenoop
		},
		660 : {
			n : "BrtBeginListParts",
			f : parsenoop
		},
		661 : {
			n : "BrtListPart",
			f : parsenoop
		},
		662 : {
			n : "BrtEndListParts",
			f : parsenoop
		},
		663 : {
			n : "BrtSheetCalcProp",
			f : parsenoop
		},
		664 : {
			n : "BrtBeginFnGroup",
			f : parsenoop
		},
		665 : {
			n : "BrtFnGroup",
			f : parsenoop
		},
		666 : {
			n : "BrtEndFnGroup",
			f : parsenoop
		},
		667 : {
			n : "BrtSupAddin",
			f : parsenoop
		},
		668 : {
			n : "BrtSXTDMPOrder",
			f : parsenoop
		},
		669 : {
			n : "BrtCsProtection",
			f : parsenoop
		},
		671 : {
			n : "BrtBeginWsSortMap",
			f : parsenoop
		},
		672 : {
			n : "BrtEndWsSortMap",
			f : parsenoop
		},
		673 : {
			n : "BrtBeginRRSort",
			f : parsenoop
		},
		674 : {
			n : "BrtEndRRSort",
			f : parsenoop
		},
		675 : {
			n : "BrtRRSortItem",
			f : parsenoop
		},
		676 : {
			n : "BrtFileSharingIso",
			f : parsenoop
		},
		677 : {
			n : "BrtBookProtectionIso",
			f : parsenoop
		},
		678 : {
			n : "BrtSheetProtectionIso",
			f : parsenoop
		},
		679 : {
			n : "BrtCsProtectionIso",
			f : parsenoop
		},
		680 : {
			n : "BrtRangeProtectionIso",
			f : parsenoop
		},
		1024 : {
			n : "BrtRwDescent",
			f : parsenoop
		},
		1025 : {
			n : "BrtKnownFonts",
			f : parsenoop
		},
		1026 : {
			n : "BrtBeginSXTupleSet",
			f : parsenoop
		},
		1027 : {
			n : "BrtEndSXTupleSet",
			f : parsenoop
		},
		1028 : {
			n : "BrtBeginSXTupleSetHeader",
			f : parsenoop
		},
		1029 : {
			n : "BrtEndSXTupleSetHeader",
			f : parsenoop
		},
		1030 : {
			n : "BrtSXTupleSetHeaderItem",
			f : parsenoop
		},
		1031 : {
			n : "BrtBeginSXTupleSetData",
			f : parsenoop
		},
		1032 : {
			n : "BrtEndSXTupleSetData",
			f : parsenoop
		},
		1033 : {
			n : "BrtBeginSXTupleSetRow",
			f : parsenoop
		},
		1034 : {
			n : "BrtEndSXTupleSetRow",
			f : parsenoop
		},
		1035 : {
			n : "BrtSXTupleSetRowItem",
			f : parsenoop
		},
		1036 : {
			n : "BrtNameExt",
			f : parsenoop
		},
		1037 : {
			n : "BrtPCDH14",
			f : parsenoop
		},
		1038 : {
			n : "BrtBeginPCDCalcMem14",
			f : parsenoop
		},
		1039 : {
			n : "BrtEndPCDCalcMem14",
			f : parsenoop
		},
		1040 : {
			n : "BrtSXTH14",
			f : parsenoop
		},
		1041 : {
			n : "BrtBeginSparklineGroup",
			f : parsenoop
		},
		1042 : {
			n : "BrtEndSparklineGroup",
			f : parsenoop
		},
		1043 : {
			n : "BrtSparkline",
			f : parsenoop
		},
		1044 : {
			n : "BrtSXDI14",
			f : parsenoop
		},
		1045 : {
			n : "BrtWsFmtInfoEx14",
			f : parsenoop
		},
		1046 : {
			n : "BrtBeginConditionalFormatting14",
			f : parsenoop
		},
		1047 : {
			n : "BrtEndConditionalFormatting14",
			f : parsenoop
		},
		1048 : {
			n : "BrtBeginCFRule14",
			f : parsenoop
		},
		1049 : {
			n : "BrtEndCFRule14",
			f : parsenoop
		},
		1050 : {
			n : "BrtCFVO14",
			f : parsenoop
		},
		1051 : {
			n : "BrtBeginDatabar14",
			f : parsenoop
		},
		1052 : {
			n : "BrtBeginIconSet14",
			f : parsenoop
		},
		1053 : {
			n : "BrtDVal14",
			f : parsenoop
		},
		1054 : {
			n : "BrtBeginDVals14",
			f : parsenoop
		},
		1055 : {
			n : "BrtColor14",
			f : parsenoop
		},
		1056 : {
			n : "BrtBeginSparklines",
			f : parsenoop
		},
		1057 : {
			n : "BrtEndSparklines",
			f : parsenoop
		},
		1058 : {
			n : "BrtBeginSparklineGroups",
			f : parsenoop
		},
		1059 : {
			n : "BrtEndSparklineGroups",
			f : parsenoop
		},
		1061 : {
			n : "BrtSXVD14",
			f : parsenoop
		},
		1062 : {
			n : "BrtBeginSxview14",
			f : parsenoop
		},
		1063 : {
			n : "BrtEndSxview14",
			f : parsenoop
		},
		1066 : {
			n : "BrtBeginPCD14",
			f : parsenoop
		},
		1067 : {
			n : "BrtEndPCD14",
			f : parsenoop
		},
		1068 : {
			n : "BrtBeginExtConn14",
			f : parsenoop
		},
		1069 : {
			n : "BrtEndExtConn14",
			f : parsenoop
		},
		1070 : {
			n : "BrtBeginSlicerCacheIDs",
			f : parsenoop
		},
		1071 : {
			n : "BrtEndSlicerCacheIDs",
			f : parsenoop
		},
		1072 : {
			n : "BrtBeginSlicerCacheID",
			f : parsenoop
		},
		1073 : {
			n : "BrtEndSlicerCacheID",
			f : parsenoop
		},
		1075 : {
			n : "BrtBeginSlicerCache",
			f : parsenoop
		},
		1076 : {
			n : "BrtEndSlicerCache",
			f : parsenoop
		},
		1077 : {
			n : "BrtBeginSlicerCacheDef",
			f : parsenoop
		},
		1078 : {
			n : "BrtEndSlicerCacheDef",
			f : parsenoop
		},
		1079 : {
			n : "BrtBeginSlicersEx",
			f : parsenoop
		},
		1080 : {
			n : "BrtEndSlicersEx",
			f : parsenoop
		},
		1081 : {
			n : "BrtBeginSlicerEx",
			f : parsenoop
		},
		1082 : {
			n : "BrtEndSlicerEx",
			f : parsenoop
		},
		1083 : {
			n : "BrtBeginSlicer",
			f : parsenoop
		},
		1084 : {
			n : "BrtEndSlicer",
			f : parsenoop
		},
		1085 : {
			n : "BrtSlicerCachePivotTables",
			f : parsenoop
		},
		1086 : {
			n : "BrtBeginSlicerCacheOlapImpl",
			f : parsenoop
		},
		1087 : {
			n : "BrtEndSlicerCacheOlapImpl",
			f : parsenoop
		},
		1088 : {
			n : "BrtBeginSlicerCacheLevelsData",
			f : parsenoop
		},
		1089 : {
			n : "BrtEndSlicerCacheLevelsData",
			f : parsenoop
		},
		1090 : {
			n : "BrtBeginSlicerCacheLevelData",
			f : parsenoop
		},
		1091 : {
			n : "BrtEndSlicerCacheLevelData",
			f : parsenoop
		},
		1092 : {
			n : "BrtBeginSlicerCacheSiRanges",
			f : parsenoop
		},
		1093 : {
			n : "BrtEndSlicerCacheSiRanges",
			f : parsenoop
		},
		1094 : {
			n : "BrtBeginSlicerCacheSiRange",
			f : parsenoop
		},
		1095 : {
			n : "BrtEndSlicerCacheSiRange",
			f : parsenoop
		},
		1096 : {
			n : "BrtSlicerCacheOlapItem",
			f : parsenoop
		},
		1097 : {
			n : "BrtBeginSlicerCacheSelections",
			f : parsenoop
		},
		1098 : {
			n : "BrtSlicerCacheSelection",
			f : parsenoop
		},
		1099 : {
			n : "BrtEndSlicerCacheSelections",
			f : parsenoop
		},
		1100 : {
			n : "BrtBeginSlicerCacheNative",
			f : parsenoop
		},
		1101 : {
			n : "BrtEndSlicerCacheNative",
			f : parsenoop
		},
		1102 : {
			n : "BrtSlicerCacheNativeItem",
			f : parsenoop
		},
		1103 : {
			n : "BrtRangeProtection14",
			f : parsenoop
		},
		1104 : {
			n : "BrtRangeProtectionIso14",
			f : parsenoop
		},
		1105 : {
			n : "BrtCellIgnoreEC14",
			f : parsenoop
		},
		1111 : {
			n : "BrtList14",
			f : parsenoop
		},
		1112 : {
			n : "BrtCFIcon",
			f : parsenoop
		},
		1113 : {
			n : "BrtBeginSlicerCachesPivotCacheIDs",
			f : parsenoop
		},
		1114 : {
			n : "BrtEndSlicerCachesPivotCacheIDs",
			f : parsenoop
		},
		1115 : {
			n : "BrtBeginSlicers",
			f : parsenoop
		},
		1116 : {
			n : "BrtEndSlicers",
			f : parsenoop
		},
		1117 : {
			n : "BrtWbProp14",
			f : parsenoop
		},
		1118 : {
			n : "BrtBeginSXEdit",
			f : parsenoop
		},
		1119 : {
			n : "BrtEndSXEdit",
			f : parsenoop
		},
		1120 : {
			n : "BrtBeginSXEdits",
			f : parsenoop
		},
		1121 : {
			n : "BrtEndSXEdits",
			f : parsenoop
		},
		1122 : {
			n : "BrtBeginSXChange",
			f : parsenoop
		},
		1123 : {
			n : "BrtEndSXChange",
			f : parsenoop
		},
		1124 : {
			n : "BrtBeginSXChanges",
			f : parsenoop
		},
		1125 : {
			n : "BrtEndSXChanges",
			f : parsenoop
		},
		1126 : {
			n : "BrtSXTupleItems",
			f : parsenoop
		},
		1128 : {
			n : "BrtBeginSlicerStyle",
			f : parsenoop
		},
		1129 : {
			n : "BrtEndSlicerStyle",
			f : parsenoop
		},
		1130 : {
			n : "BrtSlicerStyleElement",
			f : parsenoop
		},
		1131 : {
			n : "BrtBeginStyleSheetExt14",
			f : parsenoop
		},
		1132 : {
			n : "BrtEndStyleSheetExt14",
			f : parsenoop
		},
		1133 : {
			n : "BrtBeginSlicerCachesPivotCacheID",
			f : parsenoop
		},
		1134 : {
			n : "BrtEndSlicerCachesPivotCacheID",
			f : parsenoop
		},
		1135 : {
			n : "BrtBeginConditionalFormattings",
			f : parsenoop
		},
		1136 : {
			n : "BrtEndConditionalFormattings",
			f : parsenoop
		},
		1137 : {
			n : "BrtBeginPCDCalcMemExt",
			f : parsenoop
		},
		1138 : {
			n : "BrtEndPCDCalcMemExt",
			f : parsenoop
		},
		1139 : {
			n : "BrtBeginPCDCalcMemsExt",
			f : parsenoop
		},
		1140 : {
			n : "BrtEndPCDCalcMemsExt",
			f : parsenoop
		},
		1141 : {
			n : "BrtPCDField14",
			f : parsenoop
		},
		1142 : {
			n : "BrtBeginSlicerStyles",
			f : parsenoop
		},
		1143 : {
			n : "BrtEndSlicerStyles",
			f : parsenoop
		},
		1144 : {
			n : "BrtBeginSlicerStyleElements",
			f : parsenoop
		},
		1145 : {
			n : "BrtEndSlicerStyleElements",
			f : parsenoop
		},
		1146 : {
			n : "BrtCFRuleExt",
			f : parsenoop
		},
		1147 : {
			n : "BrtBeginSXCondFmt14",
			f : parsenoop
		},
		1148 : {
			n : "BrtEndSXCondFmt14",
			f : parsenoop
		},
		1149 : {
			n : "BrtBeginSXCondFmts14",
			f : parsenoop
		},
		1150 : {
			n : "BrtEndSXCondFmts14",
			f : parsenoop
		},
		1152 : {
			n : "BrtBeginSortCond14",
			f : parsenoop
		},
		1153 : {
			n : "BrtEndSortCond14",
			f : parsenoop
		},
		1154 : {
			n : "BrtEndDVals14",
			f : parsenoop
		},
		1155 : {
			n : "BrtEndIconSet14",
			f : parsenoop
		},
		1156 : {
			n : "BrtEndDatabar14",
			f : parsenoop
		},
		1157 : {
			n : "BrtBeginColorScale14",
			f : parsenoop
		},
		1158 : {
			n : "BrtEndColorScale14",
			f : parsenoop
		},
		1159 : {
			n : "BrtBeginSxrules14",
			f : parsenoop
		},
		1160 : {
			n : "BrtEndSxrules14",
			f : parsenoop
		},
		1161 : {
			n : "BrtBeginPRule14",
			f : parsenoop
		},
		1162 : {
			n : "BrtEndPRule14",
			f : parsenoop
		},
		1163 : {
			n : "BrtBeginPRFilters14",
			f : parsenoop
		},
		1164 : {
			n : "BrtEndPRFilters14",
			f : parsenoop
		},
		1165 : {
			n : "BrtBeginPRFilter14",
			f : parsenoop
		},
		1166 : {
			n : "BrtEndPRFilter14",
			f : parsenoop
		},
		1167 : {
			n : "BrtBeginPRFItem14",
			f : parsenoop
		},
		1168 : {
			n : "BrtEndPRFItem14",
			f : parsenoop
		},
		1169 : {
			n : "BrtBeginCellIgnoreECs14",
			f : parsenoop
		},
		1170 : {
			n : "BrtEndCellIgnoreECs14",
			f : parsenoop
		},
		1171 : {
			n : "BrtDxf14",
			f : parsenoop
		},
		1172 : {
			n : "BrtBeginDxF14s",
			f : parsenoop
		},
		1173 : {
			n : "BrtEndDxf14s",
			f : parsenoop
		},
		1177 : {
			n : "BrtFilter14",
			f : parsenoop
		},
		1178 : {
			n : "BrtBeginCustomFilters14",
			f : parsenoop
		},
		1180 : {
			n : "BrtCustomFilter14",
			f : parsenoop
		},
		1181 : {
			n : "BrtIconFilter14",
			f : parsenoop
		},
		1182 : {
			n : "BrtPivotCacheConnectionName",
			f : parsenoop
		},
		2048 : {
			n : "BrtBeginDecoupledPivotCacheIDs",
			f : parsenoop
		},
		2049 : {
			n : "BrtEndDecoupledPivotCacheIDs",
			f : parsenoop
		},
		2050 : {
			n : "BrtDecoupledPivotCacheID",
			f : parsenoop
		},
		2051 : {
			n : "BrtBeginPivotTableRefs",
			f : parsenoop
		},
		2052 : {
			n : "BrtEndPivotTableRefs",
			f : parsenoop
		},
		2053 : {
			n : "BrtPivotTableRef",
			f : parsenoop
		},
		2054 : {
			n : "BrtSlicerCacheBookPivotTables",
			f : parsenoop
		},
		2055 : {
			n : "BrtBeginSxvcells",
			f : parsenoop
		},
		2056 : {
			n : "BrtEndSxvcells",
			f : parsenoop
		},
		2057 : {
			n : "BrtBeginSxRow",
			f : parsenoop
		},
		2058 : {
			n : "BrtEndSxRow",
			f : parsenoop
		},
		2060 : {
			n : "BrtPcdCalcMem15",
			f : parsenoop
		},
		2067 : {
			n : "BrtQsi15",
			f : parsenoop
		},
		2068 : {
			n : "BrtBeginWebExtensions",
			f : parsenoop
		},
		2069 : {
			n : "BrtEndWebExtensions",
			f : parsenoop
		},
		2070 : {
			n : "BrtWebExtension",
			f : parsenoop
		},
		2071 : {
			n : "BrtAbsPath15",
			f : parsenoop
		},
		2072 : {
			n : "BrtBeginPivotTableUISettings",
			f : parsenoop
		},
		2073 : {
			n : "BrtEndPivotTableUISettings",
			f : parsenoop
		},
		2075 : {
			n : "BrtTableSlicerCacheIDs",
			f : parsenoop
		},
		2076 : {
			n : "BrtTableSlicerCacheID",
			f : parsenoop
		},
		2077 : {
			n : "BrtBeginTableSlicerCache",
			f : parsenoop
		},
		2078 : {
			n : "BrtEndTableSlicerCache",
			f : parsenoop
		},
		2079 : {
			n : "BrtSxFilter15",
			f : parsenoop
		},
		2080 : {
			n : "BrtBeginTimelineCachePivotCacheIDs",
			f : parsenoop
		},
		2081 : {
			n : "BrtEndTimelineCachePivotCacheIDs",
			f : parsenoop
		},
		2082 : {
			n : "BrtTimelineCachePivotCacheID",
			f : parsenoop
		},
		2083 : {
			n : "BrtBeginTimelineCacheIDs",
			f : parsenoop
		},
		2084 : {
			n : "BrtEndTimelineCacheIDs",
			f : parsenoop
		},
		2085 : {
			n : "BrtBeginTimelineCacheID",
			f : parsenoop
		},
		2086 : {
			n : "BrtEndTimelineCacheID",
			f : parsenoop
		},
		2087 : {
			n : "BrtBeginTimelinesEx",
			f : parsenoop
		},
		2088 : {
			n : "BrtEndTimelinesEx",
			f : parsenoop
		},
		2089 : {
			n : "BrtBeginTimelineEx",
			f : parsenoop
		},
		2090 : {
			n : "BrtEndTimelineEx",
			f : parsenoop
		},
		2091 : {
			n : "BrtWorkBookPr15",
			f : parsenoop
		},
		2092 : {
			n : "BrtPCDH15",
			f : parsenoop
		},
		2093 : {
			n : "BrtBeginTimelineStyle",
			f : parsenoop
		},
		2094 : {
			n : "BrtEndTimelineStyle",
			f : parsenoop
		},
		2095 : {
			n : "BrtTimelineStyleElement",
			f : parsenoop
		},
		2096 : {
			n : "BrtBeginTimelineStylesheetExt15",
			f : parsenoop
		},
		2097 : {
			n : "BrtEndTimelineStylesheetExt15",
			f : parsenoop
		},
		2098 : {
			n : "BrtBeginTimelineStyles",
			f : parsenoop
		},
		2099 : {
			n : "BrtEndTimelineStyles",
			f : parsenoop
		},
		2100 : {
			n : "BrtBeginTimelineStyleElements",
			f : parsenoop
		},
		2101 : {
			n : "BrtEndTimelineStyleElements",
			f : parsenoop
		},
		2102 : {
			n : "BrtDxf15",
			f : parsenoop
		},
		2103 : {
			n : "BrtBeginDxfs15",
			f : parsenoop
		},
		2104 : {
			n : "brtEndDxfs15",
			f : parsenoop
		},
		2105 : {
			n : "BrtSlicerCacheHideItemsWithNoData",
			f : parsenoop
		},
		2106 : {
			n : "BrtBeginItemUniqueNames",
			f : parsenoop
		},
		2107 : {
			n : "BrtEndItemUniqueNames",
			f : parsenoop
		},
		2108 : {
			n : "BrtItemUniqueName",
			f : parsenoop
		},
		2109 : {
			n : "BrtBeginExtConn15",
			f : parsenoop
		},
		2110 : {
			n : "BrtEndExtConn15",
			f : parsenoop
		},
		2111 : {
			n : "BrtBeginOledbPr15",
			f : parsenoop
		},
		2112 : {
			n : "BrtEndOledbPr15",
			f : parsenoop
		},
		2113 : {
			n : "BrtBeginDataFeedPr15",
			f : parsenoop
		},
		2114 : {
			n : "BrtEndDataFeedPr15",
			f : parsenoop
		},
		2115 : {
			n : "BrtTextPr15",
			f : parsenoop
		},
		2116 : {
			n : "BrtRangePr15",
			f : parsenoop
		},
		2117 : {
			n : "BrtDbCommand15",
			f : parsenoop
		},
		2118 : {
			n : "BrtBeginDbTables15",
			f : parsenoop
		},
		2119 : {
			n : "BrtEndDbTables15",
			f : parsenoop
		},
		2120 : {
			n : "BrtDbTable15",
			f : parsenoop
		},
		2121 : {
			n : "BrtBeginDataModel",
			f : parsenoop
		},
		2122 : {
			n : "BrtEndDataModel",
			f : parsenoop
		},
		2123 : {
			n : "BrtBeginModelTables",
			f : parsenoop
		},
		2124 : {
			n : "BrtEndModelTables",
			f : parsenoop
		},
		2125 : {
			n : "BrtModelTable",
			f : parsenoop
		},
		2126 : {
			n : "BrtBeginModelRelationships",
			f : parsenoop
		},
		2127 : {
			n : "BrtEndModelRelationships",
			f : parsenoop
		},
		2128 : {
			n : "BrtModelRelationship",
			f : parsenoop
		},
		2129 : {
			n : "BrtBeginECTxtWiz15",
			f : parsenoop
		},
		2130 : {
			n : "BrtEndECTxtWiz15",
			f : parsenoop
		},
		2131 : {
			n : "BrtBeginECTWFldInfoLst15",
			f : parsenoop
		},
		2132 : {
			n : "BrtEndECTWFldInfoLst15",
			f : parsenoop
		},
		2133 : {
			n : "BrtBeginECTWFldInfo15",
			f : parsenoop
		},
		2134 : {
			n : "BrtFieldListActiveItem",
			f : parsenoop
		},
		2135 : {
			n : "BrtPivotCacheIdVersion",
			f : parsenoop
		},
		2136 : {
			n : "BrtSXDI15",
			f : parsenoop
		},
		65535 : {
			n : "",
			f : parsenoop
		}
	};
	var evert_RE = evert_key(XLSBRecordEnum, "n");
	var XLSRecordEnum = {
		3 : {
			n : "BIFF2NUM",
			f : parse_BIFF2NUM
		},
		4 : {
			n : "BIFF2STR",
			f : parse_BIFF2STR
		},
		6 : {
			n : "Formula",
			f : parse_Formula
		},
		9 : {
			n : "BOF",
			f : parse_BOF
		},
		10 : {
			n : "EOF",
			f : parse_EOF
		},
		12 : {
			n : "CalcCount",
			f : parse_CalcCount
		},
		13 : {
			n : "CalcMode",
			f : parse_CalcMode
		},
		14 : {
			n : "CalcPrecision",
			f : parse_CalcPrecision
		},
		15 : {
			n : "CalcRefMode",
			f : parse_CalcRefMode
		},
		16 : {
			n : "CalcDelta",
			f : parse_CalcDelta
		},
		17 : {
			n : "CalcIter",
			f : parse_CalcIter
		},
		18 : {
			n : "Protect",
			f : parse_Protect
		},
		19 : {
			n : "Password",
			f : parse_Password
		},
		20 : {
			n : "Header",
			f : parse_Header
		},
		21 : {
			n : "Footer",
			f : parse_Footer
		},
		23 : {
			n : "ExternSheet",
			f : parse_ExternSheet
		},
		24 : {
			n : "Lbl",
			f : parse_Lbl
		},
		25 : {
			n : "WinProtect",
			f : parse_WinProtect
		},
		26 : {
			n : "VerticalPageBreaks",
			f : parse_VerticalPageBreaks
		},
		27 : {
			n : "HorizontalPageBreaks",
			f : parse_HorizontalPageBreaks
		},
		28 : {
			n : "Note",
			f : parse_Note
		},
		29 : {
			n : "Selection",
			f : parse_Selection
		},
		34 : {
			n : "Date1904",
			f : parse_Date1904
		},
		35 : {
			n : "ExternName",
			f : parse_ExternName
		},
		38 : {
			n : "LeftMargin",
			f : parse_LeftMargin
		},
		39 : {
			n : "RightMargin",
			f : parse_RightMargin
		},
		40 : {
			n : "TopMargin",
			f : parse_TopMargin
		},
		41 : {
			n : "BottomMargin",
			f : parse_BottomMargin
		},
		42 : {
			n : "PrintRowCol",
			f : parse_PrintRowCol
		},
		43 : {
			n : "PrintGrid",
			f : parse_PrintGrid
		},
		47 : {
			n : "FilePass",
			f : parse_FilePass
		},
		49 : {
			n : "Font",
			f : parse_Font
		},
		51 : {
			n : "PrintSize",
			f : parse_PrintSize
		},
		60 : {
			n : "Continue",
			f : parse_Continue
		},
		61 : {
			n : "Window1",
			f : parse_Window1
		},
		64 : {
			n : "Backup",
			f : parse_Backup
		},
		65 : {
			n : "Pane",
			f : parse_Pane
		},
		66 : {
			n : "CodePage",
			f : parse_CodePage
		},
		77 : {
			n : "Pls",
			f : parse_Pls
		},
		80 : {
			n : "DCon",
			f : parse_DCon
		},
		81 : {
			n : "DConRef",
			f : parse_DConRef
		},
		82 : {
			n : "DConName",
			f : parse_DConName
		},
		85 : {
			n : "DefColWidth",
			f : parse_DefColWidth
		},
		89 : {
			n : "XCT",
			f : parse_XCT
		},
		90 : {
			n : "CRN",
			f : parse_CRN
		},
		91 : {
			n : "FileSharing",
			f : parse_FileSharing
		},
		92 : {
			n : "WriteAccess",
			f : parse_WriteAccess
		},
		93 : {
			n : "Obj",
			f : parse_Obj
		},
		94 : {
			n : "Uncalced",
			f : parse_Uncalced
		},
		95 : {
			n : "CalcSaveRecalc",
			f : parse_CalcSaveRecalc
		},
		96 : {
			n : "Template",
			f : parse_Template
		},
		97 : {
			n : "Intl",
			f : parse_Intl
		},
		99 : {
			n : "ObjProtect",
			f : parse_ObjProtect
		},
		125 : {
			n : "ColInfo",
			f : parse_ColInfo
		},
		128 : {
			n : "Guts",
			f : parse_Guts
		},
		129 : {
			n : "WsBool",
			f : parse_WsBool
		},
		130 : {
			n : "GridSet",
			f : parse_GridSet
		},
		131 : {
			n : "HCenter",
			f : parse_HCenter
		},
		132 : {
			n : "VCenter",
			f : parse_VCenter
		},
		133 : {
			n : "BoundSheet8",
			f : parse_BoundSheet8
		},
		134 : {
			n : "WriteProtect",
			f : parse_WriteProtect
		},
		140 : {
			n : "Country",
			f : parse_Country
		},
		141 : {
			n : "HideObj",
			f : parse_HideObj
		},
		144 : {
			n : "Sort",
			f : parse_Sort
		},
		146 : {
			n : "Palette",
			f : parse_Palette
		},
		151 : {
			n : "Sync",
			f : parse_Sync
		},
		152 : {
			n : "LPr",
			f : parse_LPr
		},
		153 : {
			n : "DxGCol",
			f : parse_DxGCol
		},
		154 : {
			n : "FnGroupName",
			f : parse_FnGroupName
		},
		155 : {
			n : "FilterMode",
			f : parse_FilterMode
		},
		156 : {
			n : "BuiltInFnGroupCount",
			f : parse_BuiltInFnGroupCount
		},
		157 : {
			n : "AutoFilterInfo",
			f : parse_AutoFilterInfo
		},
		158 : {
			n : "AutoFilter",
			f : parse_AutoFilter
		},
		160 : {
			n : "Scl",
			f : parse_Scl
		},
		161 : {
			n : "Setup",
			f : parse_Setup
		},
		174 : {
			n : "ScenMan",
			f : parse_ScenMan
		},
		175 : {
			n : "SCENARIO",
			f : parse_SCENARIO
		},
		176 : {
			n : "SxView",
			f : parse_SxView
		},
		177 : {
			n : "Sxvd",
			f : parse_Sxvd
		},
		178 : {
			n : "SXVI",
			f : parse_SXVI
		},
		180 : {
			n : "SxIvd",
			f : parse_SxIvd
		},
		181 : {
			n : "SXLI",
			f : parse_SXLI
		},
		182 : {
			n : "SXPI",
			f : parse_SXPI
		},
		184 : {
			n : "DocRoute",
			f : parse_DocRoute
		},
		185 : {
			n : "RecipName",
			f : parse_RecipName
		},
		189 : {
			n : "MulRk",
			f : parse_MulRk
		},
		190 : {
			n : "MulBlank",
			f : parse_MulBlank
		},
		193 : {
			n : "Mms",
			f : parse_Mms
		},
		197 : {
			n : "SXDI",
			f : parse_SXDI
		},
		198 : {
			n : "SXDB",
			f : parse_SXDB
		},
		199 : {
			n : "SXFDB",
			f : parse_SXFDB
		},
		200 : {
			n : "SXDBB",
			f : parse_SXDBB
		},
		201 : {
			n : "SXNum",
			f : parse_SXNum
		},
		202 : {
			n : "SxBool",
			f : parse_SxBool
		},
		203 : {
			n : "SxErr",
			f : parse_SxErr
		},
		204 : {
			n : "SXInt",
			f : parse_SXInt
		},
		205 : {
			n : "SXString",
			f : parse_SXString
		},
		206 : {
			n : "SXDtr",
			f : parse_SXDtr
		},
		207 : {
			n : "SxNil",
			f : parse_SxNil
		},
		208 : {
			n : "SXTbl",
			f : parse_SXTbl
		},
		209 : {
			n : "SXTBRGIITM",
			f : parse_SXTBRGIITM
		},
		210 : {
			n : "SxTbpg",
			f : parse_SxTbpg
		},
		211 : {
			n : "ObProj",
			f : parse_ObProj
		},
		213 : {
			n : "SXStreamID",
			f : parse_SXStreamID
		},
		215 : {
			n : "DBCell",
			f : parse_DBCell
		},
		216 : {
			n : "SXRng",
			f : parse_SXRng
		},
		217 : {
			n : "SxIsxoper",
			f : parse_SxIsxoper
		},
		218 : {
			n : "BookBool",
			f : parse_BookBool
		},
		220 : {
			n : "DbOrParamQry",
			f : parse_DbOrParamQry
		},
		221 : {
			n : "ScenarioProtect",
			f : parse_ScenarioProtect
		},
		222 : {
			n : "OleObjectSize",
			f : parse_OleObjectSize
		},
		224 : {
			n : "XF",
			f : parse_XF
		},
		225 : {
			n : "InterfaceHdr",
			f : parse_InterfaceHdr
		},
		226 : {
			n : "InterfaceEnd",
			f : parse_InterfaceEnd
		},
		227 : {
			n : "SXVS",
			f : parse_SXVS
		},
		229 : {
			n : "MergeCells",
			f : parse_MergeCells
		},
		233 : {
			n : "BkHim",
			f : parse_BkHim
		},
		235 : {
			n : "MsoDrawingGroup",
			f : parse_MsoDrawingGroup
		},
		236 : {
			n : "MsoDrawing",
			f : parse_MsoDrawing
		},
		237 : {
			n : "MsoDrawingSelection",
			f : parse_MsoDrawingSelection
		},
		239 : {
			n : "PhoneticInfo",
			f : parse_PhoneticInfo
		},
		240 : {
			n : "SxRule",
			f : parse_SxRule
		},
		241 : {
			n : "SXEx",
			f : parse_SXEx
		},
		242 : {
			n : "SxFilt",
			f : parse_SxFilt
		},
		244 : {
			n : "SxDXF",
			f : parse_SxDXF
		},
		245 : {
			n : "SxItm",
			f : parse_SxItm
		},
		246 : {
			n : "SxName",
			f : parse_SxName
		},
		247 : {
			n : "SxSelect",
			f : parse_SxSelect
		},
		248 : {
			n : "SXPair",
			f : parse_SXPair
		},
		249 : {
			n : "SxFmla",
			f : parse_SxFmla
		},
		251 : {
			n : "SxFormat",
			f : parse_SxFormat
		},
		252 : {
			n : "SST",
			f : parse_SST
		},
		253 : {
			n : "LabelSst",
			f : parse_LabelSst
		},
		255 : {
			n : "ExtSST",
			f : parse_ExtSST
		},
		256 : {
			n : "SXVDEx",
			f : parse_SXVDEx
		},
		259 : {
			n : "SXFormula",
			f : parse_SXFormula
		},
		290 : {
			n : "SXDBEx",
			f : parse_SXDBEx
		},
		311 : {
			n : "RRDInsDel",
			f : parse_RRDInsDel
		},
		312 : {
			n : "RRDHead",
			f : parse_RRDHead
		},
		315 : {
			n : "RRDChgCell",
			f : parse_RRDChgCell
		},
		317 : {
			n : "RRTabId",
			f : parse_RRTabId
		},
		318 : {
			n : "RRDRenSheet",
			f : parse_RRDRenSheet
		},
		319 : {
			n : "RRSort",
			f : parse_RRSort
		},
		320 : {
			n : "RRDMove",
			f : parse_RRDMove
		},
		330 : {
			n : "RRFormat",
			f : parse_RRFormat
		},
		331 : {
			n : "RRAutoFmt",
			f : parse_RRAutoFmt
		},
		333 : {
			n : "RRInsertSh",
			f : parse_RRInsertSh
		},
		334 : {
			n : "RRDMoveBegin",
			f : parse_RRDMoveBegin
		},
		335 : {
			n : "RRDMoveEnd",
			f : parse_RRDMoveEnd
		},
		336 : {
			n : "RRDInsDelBegin",
			f : parse_RRDInsDelBegin
		},
		337 : {
			n : "RRDInsDelEnd",
			f : parse_RRDInsDelEnd
		},
		338 : {
			n : "RRDConflict",
			f : parse_RRDConflict
		},
		339 : {
			n : "RRDDefName",
			f : parse_RRDDefName
		},
		340 : {
			n : "RRDRstEtxp",
			f : parse_RRDRstEtxp
		},
		351 : {
			n : "LRng",
			f : parse_LRng
		},
		352 : {
			n : "UsesELFs",
			f : parse_UsesELFs
		},
		353 : {
			n : "DSF",
			f : parse_DSF
		},
		401 : {
			n : "CUsr",
			f : parse_CUsr
		},
		402 : {
			n : "CbUsr",
			f : parse_CbUsr
		},
		403 : {
			n : "UsrInfo",
			f : parse_UsrInfo
		},
		404 : {
			n : "UsrExcl",
			f : parse_UsrExcl
		},
		405 : {
			n : "FileLock",
			f : parse_FileLock
		},
		406 : {
			n : "RRDInfo",
			f : parse_RRDInfo
		},
		407 : {
			n : "BCUsrs",
			f : parse_BCUsrs
		},
		408 : {
			n : "UsrChk",
			f : parse_UsrChk
		},
		425 : {
			n : "UserBView",
			f : parse_UserBView
		},
		426 : {
			n : "UserSViewBegin",
			f : parse_UserSViewBegin
		},
		427 : {
			n : "UserSViewEnd",
			f : parse_UserSViewEnd
		},
		428 : {
			n : "RRDUserView",
			f : parse_RRDUserView
		},
		429 : {
			n : "Qsi",
			f : parse_Qsi
		},
		430 : {
			n : "SupBook",
			f : parse_SupBook
		},
		431 : {
			n : "Prot4Rev",
			f : parse_Prot4Rev
		},
		432 : {
			n : "CondFmt",
			f : parse_CondFmt
		},
		433 : {
			n : "CF",
			f : parse_CF
		},
		434 : {
			n : "DVal",
			f : parse_DVal
		},
		437 : {
			n : "DConBin",
			f : parse_DConBin
		},
		438 : {
			n : "TxO",
			f : parse_TxO
		},
		439 : {
			n : "RefreshAll",
			f : parse_RefreshAll
		},
		440 : {
			n : "HLink",
			f : parse_HLink
		},
		441 : {
			n : "Lel",
			f : parse_Lel
		},
		442 : {
			n : "CodeName",
			f : parse_XLSCodeName
		},
		443 : {
			n : "SXFDBType",
			f : parse_SXFDBType
		},
		444 : {
			n : "Prot4RevPass",
			f : parse_Prot4RevPass
		},
		445 : {
			n : "ObNoMacros",
			f : parse_ObNoMacros
		},
		446 : {
			n : "Dv",
			f : parse_Dv
		},
		448 : {
			n : "Excel9File",
			f : parse_Excel9File
		},
		449 : {
			n : "RecalcId",
			f : parse_RecalcId,
			r : 2
		},
		450 : {
			n : "EntExU2",
			f : parse_EntExU2
		},
		512 : {
			n : "Dimensions",
			f : parse_Dimensions
		},
		513 : {
			n : "Blank",
			f : parse_Blank
		},
		515 : {
			n : "Number",
			f : parse_Number
		},
		516 : {
			n : "Label",
			f : parse_Label
		},
		517 : {
			n : "BoolErr",
			f : parse_BoolErr
		},
		519 : {
			n : "String",
			f : parse_String
		},
		520 : {
			n : "Row",
			f : parse_Row
		},
		523 : {
			n : "Index",
			f : parse_Index
		},
		545 : {
			n : "Array",
			f : parse_Array
		},
		549 : {
			n : "DefaultRowHeight",
			f : parse_DefaultRowHeight
		},
		566 : {
			n : "Table",
			f : parse_Table
		},
		574 : {
			n : "Window2",
			f : parse_Window2
		},
		638 : {
			n : "RK",
			f : parse_RK
		},
		659 : {
			n : "Style",
			f : parse_Style
		},
		1048 : {
			n : "BigName",
			f : parse_BigName
		},
		1054 : {
			n : "Format",
			f : parse_Format
		},
		1084 : {
			n : "ContinueBigName",
			f : parse_ContinueBigName
		},
		1212 : {
			n : "ShrFmla",
			f : parse_ShrFmla
		},
		2048 : {
			n : "HLinkTooltip",
			f : parse_HLinkTooltip
		},
		2049 : {
			n : "WebPub",
			f : parse_WebPub
		},
		2050 : {
			n : "QsiSXTag",
			f : parse_QsiSXTag
		},
		2051 : {
			n : "DBQueryExt",
			f : parse_DBQueryExt
		},
		2052 : {
			n : "ExtString",
			f : parse_ExtString
		},
		2053 : {
			n : "TxtQry",
			f : parse_TxtQry
		},
		2054 : {
			n : "Qsir",
			f : parse_Qsir
		},
		2055 : {
			n : "Qsif",
			f : parse_Qsif
		},
		2056 : {
			n : "RRDTQSIF",
			f : parse_RRDTQSIF
		},
		2057 : {
			n : "BOF",
			f : parse_BOF
		},
		2058 : {
			n : "OleDbConn",
			f : parse_OleDbConn
		},
		2059 : {
			n : "WOpt",
			f : parse_WOpt
		},
		2060 : {
			n : "SXViewEx",
			f : parse_SXViewEx
		},
		2061 : {
			n : "SXTH",
			f : parse_SXTH
		},
		2062 : {
			n : "SXPIEx",
			f : parse_SXPIEx
		},
		2063 : {
			n : "SXVDTEx",
			f : parse_SXVDTEx
		},
		2064 : {
			n : "SXViewEx9",
			f : parse_SXViewEx9
		},
		2066 : {
			n : "ContinueFrt",
			f : parse_ContinueFrt
		},
		2067 : {
			n : "RealTimeData",
			f : parse_RealTimeData
		},
		2128 : {
			n : "ChartFrtInfo",
			f : parse_ChartFrtInfo
		},
		2129 : {
			n : "FrtWrapper",
			f : parse_FrtWrapper
		},
		2130 : {
			n : "StartBlock",
			f : parse_StartBlock
		},
		2131 : {
			n : "EndBlock",
			f : parse_EndBlock
		},
		2132 : {
			n : "StartObject",
			f : parse_StartObject
		},
		2133 : {
			n : "EndObject",
			f : parse_EndObject
		},
		2134 : {
			n : "CatLab",
			f : parse_CatLab
		},
		2135 : {
			n : "YMult",
			f : parse_YMult
		},
		2136 : {
			n : "SXViewLink",
			f : parse_SXViewLink
		},
		2137 : {
			n : "PivotChartBits",
			f : parse_PivotChartBits
		},
		2138 : {
			n : "FrtFontList",
			f : parse_FrtFontList
		},
		2146 : {
			n : "SheetExt",
			f : parse_SheetExt
		},
		2147 : {
			n : "BookExt",
			f : parse_BookExt,
			r : 12
		},
		2148 : {
			n : "SXAddl",
			f : parse_SXAddl
		},
		2149 : {
			n : "CrErr",
			f : parse_CrErr
		},
		2150 : {
			n : "HFPicture",
			f : parse_HFPicture
		},
		2151 : {
			n : "FeatHdr",
			f : parse_FeatHdr
		},
		2152 : {
			n : "Feat",
			f : parse_Feat
		},
		2154 : {
			n : "DataLabExt",
			f : parse_DataLabExt
		},
		2155 : {
			n : "DataLabExtContents",
			f : parse_DataLabExtContents
		},
		2156 : {
			n : "CellWatch",
			f : parse_CellWatch
		},
		2161 : {
			n : "FeatHdr11",
			f : parse_FeatHdr11
		},
		2162 : {
			n : "Feature11",
			f : parse_Feature11
		},
		2164 : {
			n : "DropDownObjIds",
			f : parse_DropDownObjIds
		},
		2165 : {
			n : "ContinueFrt11",
			f : parse_ContinueFrt11
		},
		2166 : {
			n : "DConn",
			f : parse_DConn
		},
		2167 : {
			n : "List12",
			f : parse_List12
		},
		2168 : {
			n : "Feature12",
			f : parse_Feature12
		},
		2169 : {
			n : "CondFmt12",
			f : parse_CondFmt12
		},
		2170 : {
			n : "CF12",
			f : parse_CF12
		},
		2171 : {
			n : "CFEx",
			f : parse_CFEx
		},
		2172 : {
			n : "XFCRC",
			f : parse_XFCRC,
			r : 12
		},
		2173 : {
			n : "XFExt",
			f : parse_XFExt,
			r : 12
		},
		2174 : {
			n : "AutoFilter12",
			f : parse_AutoFilter12
		},
		2175 : {
			n : "ContinueFrt12",
			f : parse_ContinueFrt12
		},
		2180 : {
			n : "MDTInfo",
			f : parse_MDTInfo
		},
		2181 : {
			n : "MDXStr",
			f : parse_MDXStr
		},
		2182 : {
			n : "MDXTuple",
			f : parse_MDXTuple
		},
		2183 : {
			n : "MDXSet",
			f : parse_MDXSet
		},
		2184 : {
			n : "MDXProp",
			f : parse_MDXProp
		},
		2185 : {
			n : "MDXKPI",
			f : parse_MDXKPI
		},
		2186 : {
			n : "MDB",
			f : parse_MDB
		},
		2187 : {
			n : "PLV",
			f : parse_PLV
		},
		2188 : {
			n : "Compat12",
			f : parse_Compat12,
			r : 12
		},
		2189 : {
			n : "DXF",
			f : parse_DXF
		},
		2190 : {
			n : "TableStyles",
			f : parse_TableStyles,
			r : 12
		},
		2191 : {
			n : "TableStyle",
			f : parse_TableStyle
		},
		2192 : {
			n : "TableStyleElement",
			f : parse_TableStyleElement
		},
		2194 : {
			n : "StyleExt",
			f : parse_StyleExt
		},
		2195 : {
			n : "NamePublish",
			f : parse_NamePublish
		},
		2196 : {
			n : "NameCmt",
			f : parse_NameCmt
		},
		2197 : {
			n : "SortData",
			f : parse_SortData
		},
		2198 : {
			n : "Theme",
			f : parse_Theme,
			r : 12
		},
		2199 : {
			n : "GUIDTypeLib",
			f : parse_GUIDTypeLib
		},
		2200 : {
			n : "FnGrp12",
			f : parse_FnGrp12
		},
		2201 : {
			n : "NameFnGrp12",
			f : parse_NameFnGrp12
		},
		2202 : {
			n : "MTRSettings",
			f : parse_MTRSettings,
			r : 12
		},
		2203 : {
			n : "CompressPictures",
			f : parse_CompressPictures
		},
		2204 : {
			n : "HeaderFooter",
			f : parse_HeaderFooter
		},
		2205 : {
			n : "CrtLayout12",
			f : parse_CrtLayout12
		},
		2206 : {
			n : "CrtMlFrt",
			f : parse_CrtMlFrt
		},
		2207 : {
			n : "CrtMlFrtContinue",
			f : parse_CrtMlFrtContinue
		},
		2211 : {
			n : "ForceFullCalculation",
			f : parse_ForceFullCalculation
		},
		2212 : {
			n : "ShapePropsStream",
			f : parse_ShapePropsStream
		},
		2213 : {
			n : "TextPropsStream",
			f : parse_TextPropsStream
		},
		2214 : {
			n : "RichTextStream",
			f : parse_RichTextStream
		},
		2215 : {
			n : "CrtLayout12A",
			f : parse_CrtLayout12A
		},
		4097 : {
			n : "Units",
			f : parse_Units
		},
		4098 : {
			n : "Chart",
			f : parse_Chart
		},
		4099 : {
			n : "Series",
			f : parse_Series
		},
		4102 : {
			n : "DataFormat",
			f : parse_DataFormat
		},
		4103 : {
			n : "LineFormat",
			f : parse_LineFormat
		},
		4105 : {
			n : "MarkerFormat",
			f : parse_MarkerFormat
		},
		4106 : {
			n : "AreaFormat",
			f : parse_AreaFormat
		},
		4107 : {
			n : "PieFormat",
			f : parse_PieFormat
		},
		4108 : {
			n : "AttachedLabel",
			f : parse_AttachedLabel
		},
		4109 : {
			n : "SeriesText",
			f : parse_SeriesText
		},
		4116 : {
			n : "ChartFormat",
			f : parse_ChartFormat
		},
		4117 : {
			n : "Legend",
			f : parse_Legend
		},
		4118 : {
			n : "SeriesList",
			f : parse_SeriesList
		},
		4119 : {
			n : "Bar",
			f : parse_Bar
		},
		4120 : {
			n : "Line",
			f : parse_Line
		},
		4121 : {
			n : "Pie",
			f : parse_Pie
		},
		4122 : {
			n : "Area",
			f : parse_Area
		},
		4123 : {
			n : "Scatter",
			f : parse_Scatter
		},
		4124 : {
			n : "CrtLine",
			f : parse_CrtLine
		},
		4125 : {
			n : "Axis",
			f : parse_Axis
		},
		4126 : {
			n : "Tick",
			f : parse_Tick
		},
		4127 : {
			n : "ValueRange",
			f : parse_ValueRange
		},
		4128 : {
			n : "CatSerRange",
			f : parse_CatSerRange
		},
		4129 : {
			n : "AxisLine",
			f : parse_AxisLine
		},
		4130 : {
			n : "CrtLink",
			f : parse_CrtLink
		},
		4132 : {
			n : "DefaultText",
			f : parse_DefaultText
		},
		4133 : {
			n : "Text",
			f : parse_Text
		},
		4134 : {
			n : "FontX",
			f : parse_FontX
		},
		4135 : {
			n : "ObjectLink",
			f : parse_ObjectLink
		},
		4146 : {
			n : "Frame",
			f : parse_Frame
		},
		4147 : {
			n : "Begin",
			f : parse_Begin
		},
		4148 : {
			n : "End",
			f : parse_End
		},
		4149 : {
			n : "PlotArea",
			f : parse_PlotArea
		},
		4154 : {
			n : "Chart3d",
			f : parse_Chart3d
		},
		4156 : {
			n : "PicF",
			f : parse_PicF
		},
		4157 : {
			n : "DropBar",
			f : parse_DropBar
		},
		4158 : {
			n : "Radar",
			f : parse_Radar
		},
		4159 : {
			n : "Surf",
			f : parse_Surf
		},
		4160 : {
			n : "RadarArea",
			f : parse_RadarArea
		},
		4161 : {
			n : "AxisParent",
			f : parse_AxisParent
		},
		4163 : {
			n : "LegendException",
			f : parse_LegendException
		},
		4164 : {
			n : "ShtProps",
			f : parse_ShtProps
		},
		4165 : {
			n : "SerToCrt",
			f : parse_SerToCrt
		},
		4166 : {
			n : "AxesUsed",
			f : parse_AxesUsed
		},
		4168 : {
			n : "SBaseRef",
			f : parse_SBaseRef
		},
		4170 : {
			n : "SerParent",
			f : parse_SerParent
		},
		4171 : {
			n : "SerAuxTrend",
			f : parse_SerAuxTrend
		},
		4174 : {
			n : "IFmtRecord",
			f : parse_IFmtRecord
		},
		4175 : {
			n : "Pos",
			f : parse_Pos
		},
		4176 : {
			n : "AlRuns",
			f : parse_AlRuns
		},
		4177 : {
			n : "BRAI",
			f : parse_BRAI
		},
		4187 : {
			n : "SerAuxErrBar",
			f : parse_SerAuxErrBar
		},
		4188 : {
			n : "ClrtClient",
			f : parse_ClrtClient
		},
		4189 : {
			n : "SerFmt",
			f : parse_SerFmt
		},
		4191 : {
			n : "Chart3DBarShape",
			f : parse_Chart3DBarShape
		},
		4192 : {
			n : "Fbi",
			f : parse_Fbi
		},
		4193 : {
			n : "BopPop",
			f : parse_BopPop
		},
		4194 : {
			n : "AxcExt",
			f : parse_AxcExt
		},
		4195 : {
			n : "Dat",
			f : parse_Dat
		},
		4196 : {
			n : "PlotGrowth",
			f : parse_PlotGrowth
		},
		4197 : {
			n : "SIIndex",
			f : parse_SIIndex
		},
		4198 : {
			n : "GelFrame",
			f : parse_GelFrame
		},
		4199 : {
			n : "BopPopCustom",
			f : parse_BopPopCustom
		},
		4200 : {
			n : "Fbi2",
			f : parse_Fbi2
		},
		22 : {
			n : "ExternCount",
			f : parsenoop
		},
		126 : {
			n : "RK",
			f : parsenoop
		},
		127 : {
			n : "ImData",
			f : parsenoop
		},
		135 : {
			n : "Addin",
			f : parsenoop
		},
		136 : {
			n : "Edg",
			f : parsenoop
		},
		137 : {
			n : "Pub",
			f : parsenoop
		},
		145 : {
			n : "Sub",
			f : parsenoop
		},
		148 : {
			n : "LHRecord",
			f : parsenoop
		},
		149 : {
			n : "LHNGraph",
			f : parsenoop
		},
		150 : {
			n : "Sound",
			f : parsenoop
		},
		169 : {
			n : "CoordList",
			f : parsenoop
		},
		171 : {
			n : "GCW",
			f : parsenoop
		},
		188 : {
			n : "ShrFmla",
			f : parsenoop
		},
		194 : {
			n : "AddMenu",
			f : parsenoop
		},
		195 : {
			n : "DelMenu",
			f : parsenoop
		},
		214 : {
			n : "RString",
			f : parsenoop
		},
		223 : {
			n : "UDDesc",
			f : parsenoop
		},
		234 : {
			n : "TabIdConf",
			f : parsenoop
		},
		354 : {
			n : "XL5Modify",
			f : parsenoop
		},
		421 : {
			n : "FileSharing2",
			f : parsenoop
		},
		536 : {
			n : "Name",
			f : parsenoop
		},
		547 : {
			n : "ExternName",
			f : parse_ExternName
		},
		561 : {
			n : "Font",
			f : parsenoop
		},
		1030 : {
			n : "Formula",
			f : parse_Formula
		},
		2157 : {
			n : "FeatInfo",
			f : parsenoop
		},
		2163 : {
			n : "FeatInfo11",
			f : parsenoop
		},
		2177 : {
			n : "SXAddl12",
			f : parsenoop
		},
		2240 : {
			n : "AutoWebPub",
			f : parsenoop
		},
		2241 : {
			n : "ListObj",
			f : parsenoop
		},
		2242 : {
			n : "ListField",
			f : parsenoop
		},
		2243 : {
			n : "ListDV",
			f : parsenoop
		},
		2244 : {
			n : "ListCondFmt",
			f : parsenoop
		},
		2245 : {
			n : "ListCF",
			f : parsenoop
		},
		2246 : {
			n : "FMQry",
			f : parsenoop
		},
		2247 : {
			n : "FMSQry",
			f : parsenoop
		},
		2248 : {
			n : "PLV",
			f : parsenoop
		},
		2249 : {
			n : "LnExt",
			f : parsenoop
		},
		2250 : {
			n : "MkrExt",
			f : parsenoop
		},
		2251 : {
			n : "CrtCoopt",
			f : parsenoop
		},
		0 : {}

	};
	function parse_ods(zip, opts) {
		if (typeof module !== "undefined" && typeof require !== "undefined" && typeof ODS === "undefined")
			ODS = require("./od" + "s");
		if (typeof ODS === "undefined" || !ODS.parse_ods)
			throw new Error("Unsupported ODS");
		return ODS.parse_ods(zip, opts)
	}
	function fix_opts_func(defaults) {
		return function fix_opts(opts) {
			for (var i = 0; i != defaults.length; ++i) {
				var d = defaults[i];
				if (opts[d[0]] === undefined)
					opts[d[0]] = d[1];
				if (d[2] === "n")
					opts[d[0]] = Number(opts[d[0]])
			}
		}
	}
	var fix_read_opts = fix_opts_func([["cellNF", false], ["cellHTML", true], ["cellFormula", true], ["cellStyles", false], ["cellDates", false], ["sheetStubs", false], ["sheetRows", 0, "n"], ["bookDeps", false], ["bookSheets", false], ["bookProps", false], ["bookFiles", false], ["bookVBA", false], ["password", ""], ["WTF", false]]);
	var fix_write_opts = fix_opts_func([["cellDates", false], ["bookSST", false], ["bookType", "xlsx"], ["WTF", false]]);
	function safe_parse_wbrels(wbrels, sheets) {
		if (!wbrels)
			return 0;
		try {
			wbrels = sheets.map(function pwbr(w) {
					return [w.name, wbrels["!id"][w.id].Target]
				})
		} catch (e) {
			return null
		}
		return !wbrels || wbrels.length === 0 ? null : wbrels
	}
	function safe_parse_ws(zip, path, relsPath, sheet, sheetRels, sheets, opts) {
		try {
			sheetRels[sheet] = parse_rels(getzipdata(zip, relsPath, true), path);
			sheets[sheet] = parse_ws(getzipdata(zip, path), path, opts, sheetRels[sheet])
		} catch (e) {
			if (opts.WTF)
				throw e
		}
	}
	var nodirs = function nodirs(x) {
		return x.substr(-1) != "/"
	};
	function parse_zip(zip, opts) {
		make_ssf(SSF);
		opts = opts || {};
		fix_read_opts(opts);
		reset_cp();
		if (safegetzipfile(zip, "META-INF/manifest.xml"))
			return parse_ods(zip, opts);
		var entries = keys(zip.files).filter(nodirs).sort();
		var dir = parse_ct(getzipdata(zip, "[Content_Types].xml"), opts);
		var xlsb = false;
		var sheets,
		binname;
		if (dir.workbooks.length === 0) {
			binname = "xl/workbook.xml";
			if (getzipdata(zip, binname, true))
				dir.workbooks.push(binname)
		}
		if (dir.workbooks.length === 0) {
			binname = "xl/workbook.bin";
			if (!getzipfile(zip, binname, true))
				throw new Error("Could not find workbook");
			dir.workbooks.push(binname);
			xlsb = true
		}
		if (dir.workbooks[0].substr(-3) == "bin")
			xlsb = true;
		if (xlsb)
			set_cp(1200);
		if (!opts.bookSheets && !opts.bookProps) {
			strs = [];
			if (dir.sst)
				strs = parse_sst(getzipdata(zip, dir.sst.replace(/^\//, "")), dir.sst, opts);
			styles = {};
			if (dir.style)
				styles = parse_sty(getzipdata(zip, dir.style.replace(/^\//, "")), dir.style, opts);
			themes = {};
			if (opts.cellStyles && dir.themes.length)
				themes = parse_theme(getzipdata(zip, dir.themes[0].replace(/^\//, ""), true), dir.themes[0], opts)
		}
		var wb = parse_wb(getzipdata(zip, dir.workbooks[0].replace(/^\//, "")), dir.workbooks[0], opts);
		var props = {},
		propdata = "";
		if (dir.coreprops.length !== 0) {
			propdata = getzipdata(zip, dir.coreprops[0].replace(/^\//, ""), true);
			if (propdata)
				props = parse_core_props(propdata);
			if (dir.extprops.length !== 0) {
				propdata = getzipdata(zip, dir.extprops[0].replace(/^\//, ""), true);
				if (propdata)
					parse_ext_props(propdata, props)
			}
		}
		var custprops = {};
		if (!opts.bookSheets || opts.bookProps) {
			if (dir.custprops.length !== 0) {
				propdata = getzipdata(zip, dir.custprops[0].replace(/^\//, ""), true);
				if (propdata)
					custprops = parse_cust_props(propdata, opts)
			}
		}
		var out = {};
		if (opts.bookSheets || opts.bookProps) {
			if (props.Worksheets && props.SheetNames.length > 0)
				sheets = props.SheetNames;
			else if (wb.Sheets)
				sheets = wb.Sheets.map(function pluck(x) {
						return x.name
					});
			if (opts.bookProps) {
				out.Props = props;
				out.Custprops = custprops
			}
			if (typeof sheets !== "undefined")
				out.SheetNames = sheets;
			if (opts.bookSheets ? out.SheetNames : opts.bookProps)
				return out
		}
		sheets = {};
		var deps = {};
		if (opts.bookDeps && dir.calcchain)
			deps = parse_cc(getzipdata(zip, dir.calcchain.replace(/^\//, "")), dir.calcchain, opts);
		var i = 0;
		var sheetRels = {};
		var path,
		relsPath;
		if (!props.Worksheets) {
			var wbsheets = wb.Sheets;
			props.Worksheets = wbsheets.length;
			props.SheetNames = [];
			for (var j = 0; j != wbsheets.length; ++j) {
				props.SheetNames[j] = wbsheets[j].name
			}
		}
		var wbext = xlsb ? "bin" : "xml";
		var wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
		var wbrels = parse_rels(getzipdata(zip, wbrelsfile, true), wbrelsfile);
		if (wbrels)
			wbrels = safe_parse_wbrels(wbrels, wb.Sheets);
		var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
		for (i = 0; i != props.Worksheets; ++i) {
			if (wbrels)
				path = "xl/" + wbrels[i][1].replace(/[\/]?xl\//, "");
			else {
				path = "xl/worksheets/sheet" + (i + 1 - nmode) + "." + wbext;
				path = path.replace(/sheet0\./, "sheet.")
			}
			relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
			safe_parse_ws(zip, path, relsPath, props.SheetNames[i], sheetRels, sheets, opts)
		}
		if (dir.comments)
			parse_comments(zip, dir.comments, sheets, sheetRels, opts);
		out = {
			Directory : dir,
			Workbook : wb,
			Props : props,
			Custprops : custprops,
			Deps : deps,
			Sheets : sheets,
			SheetNames : props.SheetNames,
			Strings : strs,
			Styles : styles,
			Themes : themes,
			SSF : SSF.get_table()
		};
		if (opts.bookFiles) {
			out.keys = entries;
			out.files = zip.files
		}
		if (opts.bookVBA) {
			if (dir.vba.length > 0)
				out.vbaraw = getzipdata(zip, dir.vba[0], true);
			else if (dir.defaults.bin === "application/vnd.ms-office.vbaProject")
				out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true)
		}
		return out
	}
	function add_rels(rels, rId, f, type, relobj) {
		if (!relobj)
			relobj = {};
		if (!rels["!id"])
			rels["!id"] = {};
		relobj.Id = "rId" + rId;
		relobj.Type = type;
		relobj.Target = f;
		if (rels["!id"][relobj.Id])
			throw new Error("Cannot rewrite rId " + rId);
		rels["!id"][relobj.Id] = relobj;
		rels[("/" + relobj.Target).replace("//", "/")] = relobj
	}
	function write_zip(wb, opts) {
		if (wb && !wb.SSF) {
			wb.SSF = SSF.get_table()
		}
		if (wb && wb.SSF) {
			make_ssf(SSF);
			SSF.load_table(wb.SSF);
			opts.revssf = evert_num(wb.SSF);
			opts.revssf[wb.SSF[65535]] = 0
		}
		opts.rels = {};
		opts.wbrels = {};
		opts.Strings = [];
		opts.Strings.Count = 0;
		opts.Strings.Unique = 0;
		var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
		var ct = {
			workbooks : [],
			sheets : [],
			calcchains : [],
			themes : [],
			styles : [],
			coreprops : [],
			extprops : [],
			custprops : [],
			strs : [],
			comments : [],
			vba : [],
			TODO : [],
			rels : [],
			xmlns : ""
		};
		fix_write_opts(opts = opts || {});
		var zip = new jszip;
		var f = "",
		rId = 0;
		opts.cellXfs = [];
		get_cell_style(opts.cellXfs, {}, {
			revssf : {
				General : 0
			}
		});
		f = "docProps/core.xml";
		zip.file(f, write_core_props(wb.Props, opts));
		ct.coreprops.push(f);
		add_rels(opts.rels, 2, f, RELS.CORE_PROPS);
		f = "docProps/app.xml";
		if (!wb.Props)
			wb.Props = {};
		wb.Props.SheetNames = wb.SheetNames;
		wb.Props.Worksheets = wb.SheetNames.length;
		zip.file(f, write_ext_props(wb.Props, opts));
		ct.extprops.push(f);
		add_rels(opts.rels, 3, f, RELS.EXT_PROPS);
		if (wb.Custprops !== wb.Props && keys(wb.Custprops || {}).length > 0) {
			f = "docProps/custom.xml";
			zip.file(f, write_cust_props(wb.Custprops, opts));
			ct.custprops.push(f);
			add_rels(opts.rels, 4, f, RELS.CUST_PROPS)
		}
		f = "xl/workbook." + wbext;
		zip.file(f, write_wb(wb, f, opts));
		ct.workbooks.push(f);
		add_rels(opts.rels, 1, f, RELS.WB);
		for (rId = 1; rId <= wb.SheetNames.length; ++rId) {
			f = "xl/worksheets/sheet" + rId + "." + wbext;
			zip.file(f, write_ws(rId - 1, f, opts, wb));
			ct.sheets.push(f);
			add_rels(opts.wbrels, rId, "worksheets/sheet" + rId + "." + wbext, RELS.WS)
		}
		if (opts.Strings != null && opts.Strings.length > 0) {
			f = "xl/sharedStrings." + wbext;
			zip.file(f, write_sst(opts.Strings, f, opts));
			ct.strs.push(f);
			add_rels(opts.wbrels, ++rId, "sharedStrings." + wbext, RELS.SST)
		}
		f = "xl/theme/theme1.xml";
		zip.file(f, write_theme());
		ct.themes.push(f);
		add_rels(opts.wbrels, ++rId, "theme/theme1.xml", RELS.THEME);
		f = "xl/styles." + wbext;
		zip.file(f, write_sty(wb, f, opts));
		ct.styles.push(f);
		add_rels(opts.wbrels, ++rId, "styles." + wbext, RELS.STY);
		zip.file("[Content_Types].xml", write_ct(ct, opts));
		zip.file("_rels/.rels", write_rels(opts.rels));
		zip.file("xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
		return zip
	}
	function firstbyte(f, o) {
		switch ((o || {}).type || "base64") {
		case "buffer":
			return f[0];
		case "base64":
			return Base64.decode(f.substr(0, 12)).charCodeAt(0);
		case "binary":
			return f.charCodeAt(0);
		case "array":
			return f[0];
		default:
			throw new Error("Unrecognized type " + o.type)
		}
	}
	function read_zip(data, opts) {
		var zip,
		d = data;
		var o = opts || {};
		if (!o.type)
			o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
		switch (o.type) {
		case "base64":
			zip = new jszip(d, {
					base64 : true
				});
			break;
		case "binary":
		case "array":
			zip = new jszip(d, {
					base64 : false
				});
			break;
		case "buffer":
			zip = new jszip(d);
			break;
		case "file":
			zip = new jszip(d = _fs.readFileSync(data));
			break;
		default:
			throw new Error("Unrecognized type " + o.type)
		}
		return parse_zip(zip, o)
	}
	function readSync(data, opts) {
		var zip,
		d = data,
		isfile = false,
		n;
		var o = opts || {};
		if (!o.type)
			o.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
		if (o.type == "file") {
			isfile = true;
			o.type = "buffer";
			d = _fs.readFileSync(data)
		}
		switch (n = firstbyte(d, o)) {
		case 208:
			if (isfile)
				o.type = "file";
			return parse_xlscfb(CFB.read(data, o), o);
		case 9:
			return parse_xlscfb(s2a(o.type === "base64" ? Base64.decode(data) : data), o);
		case 60:
			return parse_xlml(d, o);
		case 80:
			if (isfile)
				o.type = "file";
			return read_zip(data, opts);
		default:
			throw new Error("Unsupported file " + n)
		}
	}
	function readFileSync(data, opts) {
		var o = opts || {};
		o.type = "file";
		return readSync(data, o)
	}
	function write_zip_type(wb, opts) {
		var o = opts || {};
		var z = write_zip(wb, o);
		switch (o.type) {
		case "base64":
			return z.generate({
				type : "base64"
			});
		case "binary":
			return z.generate({
				type : "string"
			});
		case "buffer":
			return z.generate({
				type : "nodebuffer"
			});
		case "file":
			return _fs.writeFileSync(o.file, z.generate({
					type : "nodebuffer"
				}));
		default:
			throw new Error("Unrecognized type " + o.type)
		}
	}
	function writeSync(wb, opts) {
		var o = opts || {};
		switch (o.bookType) {
		case "xml":
			return write_xlml(wb, o);
		default:
			return write_zip_type(wb, o)
		}
	}
	function writeFileSync(wb, filename, opts) {
		var o = opts || {};
		o.type = "file";
		o.file = filename;
		switch (o.file.substr(-5).toLowerCase()) {
		case ".xlsx":
			o.bookType = "xlsx";
			break;
		case ".xlsm":
			o.bookType = "xlsm";
			break;
		case ".xlsb":
			o.bookType = "xlsb";
			break;
		default:
			switch (o.file.substr(-4).toLowerCase()) {
			case ".xls":
				o.bookType = "xls";
				break;
			case ".xml":
				o.bookType = "xml";
				break
			}
		}
		return writeSync(wb, o)
	}
	function decode_row(rowstr) {
		return parseInt(unfix_row(rowstr), 10) - 1
	}
	function encode_row(row) {
		return "" + (row + 1)
	}
	function fix_row(cstr) {
		return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2")
	}
	function unfix_row(cstr) {
		return cstr.replace(/\$(\d+)$/, "$1")
	}
	function decode_col(colstr) {
		var c = unfix_col(colstr),
		d = 0,
		i = 0;
		for (; i !== c.length; ++i)
			d = 26 * d + c.charCodeAt(i) - 64;
		return d - 1
	}
	function encode_col(col) {
		var s = "";
		for (++col; col; col = Math.floor((col - 1) / 26))
			s = String.fromCharCode((col - 1) % 26 + 65) + s;
		return s
	}
	function fix_col(cstr) {
		return cstr.replace(/^([A-Z])/, "$$$1")
	}
	function unfix_col(cstr) {
		return cstr.replace(/^\$([A-Z])/, "$1")
	}
	function split_cell(cstr) {
		return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",")
	}
	function decode_cell(cstr) {
		var splt = split_cell(cstr);
		return {
			c : decode_col(splt[0]),
			r : decode_row(splt[1])
		}
	}
	function encode_cell(cell) {
		return encode_col(cell.c) + encode_row(cell.r)
	}
	function fix_cell(cstr) {
		return fix_col(fix_row(cstr))
	}
	function unfix_cell(cstr) {
		return unfix_col(unfix_row(cstr))
	}
	function decode_range(range) {
		var x = range.split(":").map(decode_cell);
		return {
			s : x[0],
			e : x[x.length - 1]
		}
	}
	function encode_range(cs, ce) {
		if (ce === undefined || typeof ce === "number")
			return encode_range(cs.s, cs.e);
		if (typeof cs !== "string")
			cs = encode_cell(cs);
		if (typeof ce !== "string")
			ce = encode_cell(ce);
		return cs == ce ? cs : cs + ":" + ce
	}
	function safe_decode_range(range) {
		var o = {
			s : {
				c : 0,
				r : 0
			},
			e : {
				c : 0,
				r : 0
			}
		};
		var idx = 0,
		i = 0,
		cc = 0;
		var len = range.length;
		for (idx = 0; i < len; ++i) {
			if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
				break;
			idx = 26 * idx + cc
		}
		o.s.c = --idx;
		for (idx = 0; i < len; ++i) {
			if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
				break;
			idx = 10 * idx + cc
		}
		o.s.r = --idx;
		if (i === len || range.charCodeAt(++i) === 58) {
			o.e.c = o.s.c;
			o.e.r = o.s.r;
			return o
		}
		for (idx = 0; i != len; ++i) {
			if ((cc = range.charCodeAt(i) - 64) < 1 || cc > 26)
				break;
			idx = 26 * idx + cc
		}
		o.e.c = --idx;
		for (idx = 0; i != len; ++i) {
			if ((cc = range.charCodeAt(i) - 48) < 0 || cc > 9)
				break;
			idx = 10 * idx + cc
		}
		o.e.r = --idx;
		return o
	}
	function safe_format_cell(cell, v) {
		if (cell.z !== undefined)
			try {
				return cell.w = SSF.format(cell.z, v)
			} catch (e) {}

		if (!cell.XF)
			return v;
		try {
			return cell.w = SSF.format(cell.XF.ifmt || 0, v)
		} catch (e) {
			return "" + v
		}
	}
	function format_cell(cell, v) {
		if (cell == null || cell.t == null)
			return "";
		if (cell.w !== undefined)
			return cell.w;
		if (v === undefined)
			return safe_format_cell(cell, cell.v);
		return safe_format_cell(cell, v)
	}
	function sheet_to_json(sheet, opts) {
		var val,
		row,
		range,
		header = 0,
		offset = 1,
		r,
		hdr = [],
		isempty,
		R,
		C,
		v;
		var o = opts != null ? opts : {};
		var raw = o.raw;
		if (sheet == null || sheet["!ref"] == null)
			return [];
		range = o.range !== undefined ? o.range : sheet["!ref"];
		if (o.header === 1)
			header = 1;
		else if (o.header === "A")
			header = 2;
		else if (Array.isArray(o.header))
			header = 3;
		switch (typeof range) {
		case "string":
			r = safe_decode_range(range);
			break;
		case "number":
			r = safe_decode_range(sheet["!ref"]);
			r.s.r = range;
			break;
		default:
			r = range
		}
		if (header > 0)
			offset = 0;
		var rr = encode_row(r.s.r);
		var cols = new Array(r.e.c - r.s.c + 1);
		var out = new Array(r.e.r - r.s.r - offset + 1);
		var outi = 0;
		for (C = r.s.c; C <= r.e.c; ++C) {
			cols[C] = encode_col(C);
			val = sheet[cols[C] + rr];
			switch (header) {
			case 1:
				hdr[C] = C;
				break;
			case 2:
				hdr[C] = cols[C];
				break;
			case 3:
				hdr[C] = o.header[C - r.s.c];
				break;
			default:
				if (val === undefined)
					continue;
				hdr[C] = format_cell(val)
			}
		}
		for (R = r.s.r + offset; R <= r.e.r; ++R) {
			rr = encode_row(R);
			isempty = true;
			if (header === 1)
				row = [];
			else {
				row = {};
				if (Object.defineProperty)
					Object.defineProperty(row, "__rowNum__", {
						value : R,
						enumerable : false
					});
				else
					row.__rowNum__ = R
			}
			for (C = r.s.c; C <= r.e.c; ++C) {
				val = sheet[cols[C] + rr];
				if (val === undefined || val.t === undefined)
					continue;
				v = val.v;
				switch (val.t) {
				case "e":
					continue;
				case "s":
					break;
				case "b":
				case "n":
					break;
				default:
					throw "unrecognized type " + val.t
				}
				if (v !== undefined) {
					row[hdr[C]] = raw ? v : format_cell(val, v);
					isempty = false
				}
			}
			if (isempty === false || header === 1)
				out[outi++] = row
		}
		out.length = outi;
		return out
	}
	function sheet_to_row_object_array(sheet, opts) {
		return sheet_to_json(sheet, opts != null ? opts : {})
	}
	function sheet_to_csv(sheet, opts) {
		var out = "",
		txt = "",
		qreg = /"/g;
		var o = opts == null ? {}

		 : opts;
		if (sheet == null || sheet["!ref"] == null)
			return "";
		var r = safe_decode_range(sheet["!ref"]);
		var FS = o.FS !== undefined ? o.FS : ",",
		fs = FS.charCodeAt(0);
		var RS = o.RS !== undefined ? o.RS : "\n",
		rs = RS.charCodeAt(0);
		var row = "",
		rr = "",
		cols = [];
		var i = 0,
		cc = 0,
		val;
		var R = 0,
		C = 0;
		for (C = r.s.c; C <= r.e.c; ++C)
			cols[C] = encode_col(C);
		for (R = r.s.r; R <= r.e.r; ++R) {
			row = "";
			rr = encode_row(R);
			for (C = r.s.c; C <= r.e.c; ++C) {
				val = sheet[cols[C] + rr];
				txt = val !== undefined ? "" + format_cell(val) : "";
				for (i = 0, cc = 0; i !== txt.length; ++i)
					if ((cc = txt.charCodeAt(i)) === fs || cc === rs || cc === 34) {
						txt = '"' + txt.replace(qreg, '""') + '"';
						break
					}
				row += (C === r.s.c ? "" : FS) + txt
			}
			out += row + RS
		}
		return out
	}
	var make_csv = sheet_to_csv;
	function sheet_to_formulae(sheet) {
		var cmds,
		y = "",
		x,
		val = "";
		if (sheet == null || sheet["!ref"] == null)
			return "";
		var r = safe_decode_range(sheet["!ref"]),
		rr = "",
		cols = [],
		C;
		cmds = new Array((r.e.r - r.s.r + 1) * (r.e.c - r.s.c + 1));
		var i = 0;
		for (C = r.s.c; C <= r.e.c; ++C)
			cols[C] = encode_col(C);
		for (var R = r.s.r; R <= r.e.r; ++R) {
			rr = encode_row(R);
			for (C = r.s.c; C <= r.e.c; ++C) {
				y = cols[C] + rr;
				x = sheet[y];
				val = "";
				if (x === undefined)
					continue;
				if (x.f != null)
					val = x.f;
				else if (x.w !== undefined)
					val = "'" + x.w;
				else if (x.v === undefined)
					continue;
				else
					val = "" + x.v;
				cmds[i++] = y + "=" + val
			}
		}
		cmds.length = i;
		return cmds
	}
	var utils = {
		encode_col : encode_col,
		encode_row : encode_row,
		encode_cell : encode_cell,
		encode_range : encode_range,
		decode_col : decode_col,
		decode_row : decode_row,
		split_cell : split_cell,
		decode_cell : decode_cell,
		decode_range : decode_range,
		format_cell : format_cell,
		get_formulae : sheet_to_formulae,
		make_csv : sheet_to_csv,
		make_json : sheet_to_json,
		make_formulae : sheet_to_formulae,
		sheet_to_csv : sheet_to_csv,
		sheet_to_json : sheet_to_json,
		sheet_to_formulae : sheet_to_formulae,
		sheet_to_row_object_array : sheet_to_row_object_array
	};
	XLSX.parse_xlscfb = parse_xlscfb;
	XLSX.parse_zip = parse_zip;
	XLSX.read = readSync;
	XLSX.readFile = readFileSync;
	XLSX.readFileSync = readFileSync;
	XLSX.write = writeSync;
	XLSX.writeFile = writeFileSync;
	XLSX.writeFileSync = writeFileSync;
	XLSX.utils = utils;
	XLSX.CFB = CFB;
	XLSX.SSF = SSF
})(typeof exports !== "undefined" ? exports : XLSX);
var XLS = XLSX;

function datenum(v, date1904) {
	if (date1904)
		v += 1462;
	var epoch = Date.parse(v);
	return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);
};

function sheet_from_array_of_arrays(data, opts) {
	var ws = {};
	var range = {
		s : {
			c : 10000000,
			r : 10000000
		},
		e : {
			c : 0,
			r : 0
		}
	};
	for (var R = 0; R != data.length; ++R) {
		for (var C = 0; C != data[R].length; ++C) {
			if (range.s.r > R)
				range.s.r = R;
			if (range.s.c > C)
				range.s.c = C;
			if (range.e.r < R)
				range.e.r = R;
			if (range.e.c < C)
				range.e.c = C;
			var cell = {
				v : data[R][C]
			};
			if (cell.v == null)
				continue;
			var cell_ref = XLSX.utils.encode_cell({
					c : C,
					r : R
				});

			if (typeof cell.v === 'number')
				cell.t = 'n';
			else if (typeof cell.v === 'boolean')
				cell.t = 'b';
			else if (cell.v instanceof Date) {
				cell.t = 'n';
				cell.z = XLSX.SSF._table[14];
				cell.v = datenum(cell.v);
			} else
				cell.t = 's';

			ws[cell_ref] = cell;
		}
	}
	if (range.s.c < 10000000)
		ws['!ref'] = XLSX.utils.encode_range(range);
	return ws;
};
function s2ab(s) {
	var buf = new ArrayBuffer(s.length);
	var view = new Uint8Array(buf);
	for (var i = 0; i != s.length; ++i)
		view[i] = s.charCodeAt(i) & 0xFF;
	return buf;
};
function Workbook() {
	if (!(this instanceof Workbook))
		return new Workbook();
	this.SheetNames = [];
	this.Sheets = {};
};
function exportToExcelXLSX(data, ws_name, file_name, wb) {
	wb.SheetNames.push(ws_name);
	wb.Sheets[ws_name] = sheet_from_array_of_arrays(data);
};
function downloadXLSX(wb, file_name) {
	var wbout = XLSX.write(wb, {
			bookType : 'xlsx',
			bookSST : true,
			type : 'binary'
		});
	saveAs(new Blob([s2ab(wbout)], {
			type : "application/octet-stream"
		}), file_name + ".xlsx");
};
function testExportToXlsx() {
	var data = [['Emp', 'PermanentStatus', 'DOB', 'Salary', 'PerformanceRating'], ['RDX', true, new Date("1992-02-13"), 55000, 4.2], ['Lakhan', true, new Date("1988-01-01"), 50000, 4], ['Surendra', true, new Date("1990-02-02"), 48000, 3.8], ['Rajnish', true, new Date("1990-03-03"), 45000, 3.6], ['Rahul g', false, new Date("1990-04-04"), null, 0], ['Ankit', true, new Date("1990-04-04"), 45000, 4.0], ['Brajraj', true, new Date("1990-04-04"), 44000, 3.5], ['Rohit', false, new Date("1990-04-04"), null, 0], ['Lalit', false, new Date("1990-04-04"), null, 0], ['Vinod', true, new Date("1990-09-01"), 32500, 3.9], ['Suraj', true, new Date("1990-04-04"), 30000, 3.9]]
	var ws_name = ("Sheet") ? this.m_excelsheetname : "Sheet";
	var file_name = ("TestXLSX") ? this.exportFileName : "Dashboard";
	var wb = new Workbook();
	exportToExcelXLSX(data, ws_name, file_name, wb);
	downloadXLSX(wb, file_name);
};
/************************************* Start of  Underscore.js file           ******************************************/
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define('underscore', factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, (function () {
    var current = global._;
    var exports = global._ = factory();
    exports.noConflict = function () { global._ = current; return exports; };
  }()));
}(this, (function () {
  //     Underscore.js 1.13.6
  //     https://underscorejs.org
  //     (c) 2009-2022 Jeremy Ashkenas, Julian Gonggrijp, and DocumentCloud and Investigative Reporters & Editors
  //     Underscore may be freely distributed under the MIT license.

  // Current version.
  var VERSION = '1.13.6';

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = (typeof self == 'object' && self.self === self && self) ||
            (typeof global == 'object' && global.global === global && global) ||
            Function('return this')() ||
            {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // Modern feature detection.
  var supportsArrayBuffer = typeof ArrayBuffer !== 'undefined',
      supportsDataView = typeof DataView !== 'undefined';

  // All **ECMAScript 5+** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create,
      nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;

  // Create references to these builtin functions because we override them.
  var _isNaN = isNaN,
      _isFinite = isFinite;

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  // The largest integer that can be represented exactly.
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  function restArguments(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  }

  // Is a given variable an object?
  function isObject(obj) {
    var type = typeof obj;
    return type === 'function' || (type === 'object' && !!obj);
  }

  // Is a given value equal to null?
  function isNull(obj) {
    return obj === null;
  }

  // Is a given variable undefined?
  function isUndefined(obj) {
    return obj === void 0;
  }

  // Is a given value a boolean?
  function isBoolean(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  }

  // Is a given value a DOM element?
  function isElement(obj) {
    return !!(obj && obj.nodeType === 1);
  }

  // Internal function for creating a `toString`-based type tester.
  function tagTester(name) {
    var tag = '[object ' + name + ']';
    return function(obj) {
      return toString.call(obj) === tag;
    };
  }

  var isString = tagTester('String');

  var isNumber = tagTester('Number');

  var isDate = tagTester('Date');

  var isRegExp = tagTester('RegExp');

  var isError = tagTester('Error');

  var isSymbol = tagTester('Symbol');

  var isArrayBuffer = tagTester('ArrayBuffer');

  var isFunction = tagTester('Function');

  // Optimize `isFunction` if appropriate. Work around some `typeof` bugs in old
  // v8, IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  var isFunction$1 = isFunction;

  var hasObjectTag = tagTester('Object');

  // In IE 10 - Edge 13, `DataView` has string tag `'[object Object]'`.
  // In IE 11, the most common among them, this problem also applies to
  // `Map`, `WeakMap` and `Set`.
  // Also, there are cases where an application can override the native
  // `DataView` object, in cases like that we can't use the constructor
  // safely and should just rely on alternate `DataView` checks
  var hasDataViewBug = (
        supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag(new DataView(new ArrayBuffer(8))))
      ),
      isIE11 = (typeof Map !== 'undefined' && hasObjectTag(new Map));

  var isDataView = tagTester('DataView');

  // In IE 10 - Edge 13, we need a different heuristic
  // to determine whether an object is a `DataView`.
  // Also, in cases where the native `DataView` is
  // overridden we can't rely on the tag itself.
  function alternateIsDataView(obj) {
    return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
  }

  var isDataView$1 = (hasDataViewBug ? alternateIsDataView : isDataView);

  // Is a given value an array?
  // Delegates to ECMA5's native `Array.isArray`.
  var isArray = nativeIsArray || tagTester('Array');

  // Internal function to check whether `key` is an own property name of `obj`.
  function has$1(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  }

  var isArguments = tagTester('Arguments');

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  (function() {
    if (!isArguments(arguments)) {
      isArguments = function(obj) {
        return has$1(obj, 'callee');
      };
    }
  }());

  var isArguments$1 = isArguments;

  // Is a given object a finite number?
  function isFinite$1(obj) {
    return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
  }

  // Is the given value `NaN`?
  function isNaN$1(obj) {
    return isNumber(obj) && _isNaN(obj);
  }

  // Predicate-generating function. Often useful outside of Underscore.
  function constant(value) {
    return function() {
      return value;
    };
  }

  // Common internal logic for `isArrayLike` and `isBufferLike`.
  function createSizePropertyCheck(getSizeProperty) {
    return function(collection) {
      var sizeProperty = getSizeProperty(collection);
      return typeof sizeProperty == 'number' && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
    }
  }

  // Internal helper to generate a function to obtain property `key` from `obj`.
  function shallowProperty(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  }

  // Internal helper to obtain the `byteLength` property of an object.
  var getByteLength = shallowProperty('byteLength');

  // Internal helper to determine whether we should spend extensive checks against
  // `ArrayBuffer` et al.
  var isBufferLike = createSizePropertyCheck(getByteLength);

  // Is a given value a typed array?
  var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
  function isTypedArray(obj) {
    // `ArrayBuffer.isView` is the most future-proof, so use it when available.
    // Otherwise, fall back on the above regular expression.
    return nativeIsView ? (nativeIsView(obj) && !isDataView$1(obj)) :
                  isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
  }

  var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);

  // Internal helper to obtain the `length` property of an object.
  var getLength = shallowProperty('length');

  // Internal helper to create a simple lookup structure.
  // `collectNonEnumProps` used to depend on `_.contains`, but this led to
  // circular imports. `emulatedSet` is a one-off solution that only works for
  // arrays of strings.
  function emulatedSet(keys) {
    var hash = {};
    for (var l = keys.length, i = 0; i < l; ++i) hash[keys[i]] = true;
    return {
      contains: function(key) { return hash[key] === true; },
      push: function(key) {
        hash[key] = true;
        return keys.push(key);
      }
    };
  }

  // Internal helper. Checks `keys` for the presence of keys in IE < 9 that won't
  // be iterated by `for key in ...` and thus missed. Extends `keys` in place if
  // needed.
  function collectNonEnumProps(obj, keys) {
    keys = emulatedSet(keys);
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (isFunction$1(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has$1(obj, prop) && !keys.contains(prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !keys.contains(prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  function keys(obj) {
    if (!isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has$1(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  function isEmpty(obj) {
    if (obj == null) return true;
    // Skip the more expensive `toString`-based type checks if `obj` has no
    // `.length`.
    var length = getLength(obj);
    if (typeof length == 'number' && (
      isArray(obj) || isString(obj) || isArguments$1(obj)
    )) return length === 0;
    return getLength(keys(obj)) === 0;
  }

  // Returns whether an object has a given set of `key:value` pairs.
  function isMatch(object, attrs) {
    var _keys = keys(attrs), length = _keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = _keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  }

  // If Underscore is called as a function, it returns a wrapped object that can
  // be used OO-style. This wrapper holds altered versions of all functions added
  // through `_.mixin`. Wrapped objects may be chained.
  function _$1(obj) {
    if (obj instanceof _$1) return obj;
    if (!(this instanceof _$1)) return new _$1(obj);
    this._wrapped = obj;
  }

  _$1.VERSION = VERSION;

  // Extracts the result from a wrapped and chained object.
  _$1.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxies for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;

  _$1.prototype.toString = function() {
    return String(this._wrapped);
  };

  // Internal function to wrap or shallow-copy an ArrayBuffer,
  // typed array or DataView to a new view, reusing the buffer.
  function toBufferView(bufferSource) {
    return new Uint8Array(
      bufferSource.buffer || bufferSource,
      bufferSource.byteOffset || 0,
      getByteLength(bufferSource)
    );
  }

  // We use this string twice, so give it a name for minification.
  var tagDataView = '[object DataView]';

  // Internal recursive comparison function for `_.isEqual`.
  function eq(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](https://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  }

  // Internal recursive comparison function for `_.isEqual`.
  function deepEq(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _$1) a = a._wrapped;
    if (b instanceof _$1) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    // Work around a bug in IE 10 - Edge 13.
    if (hasDataViewBug && className == '[object Object]' && isDataView$1(a)) {
      if (!isDataView$1(b)) return false;
      className = tagDataView;
    }
    switch (className) {
      // These types are compared by value.
      case '[object RegExp]':
        // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
      case '[object ArrayBuffer]':
      case tagDataView:
        // Coerce to typed array so we can fall through.
        return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays && isTypedArray$1(a)) {
        var byteLength = getByteLength(a);
        if (byteLength !== getByteLength(b)) return false;
        if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
        areArrays = true;
    }
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor &&
                               isFunction$1(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var _keys = keys(a), key;
      length = _keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = _keys[length];
        if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  }

  // Perform a deep comparison to check if two objects are equal.
  function isEqual(a, b) {
    return eq(a, b);
  }

  // Retrieve all the enumerable property names of an object.
  function allKeys(obj) {
    if (!isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  }

  // Since the regular `Object.prototype.toString` type tests don't work for
  // some types in IE 11, we use a fingerprinting heuristic instead, based
  // on the methods. It's not great, but it's the best we got.
  // The fingerprint method lists are defined below.
  function ie11fingerprint(methods) {
    var length = getLength(methods);
    return function(obj) {
      if (obj == null) return false;
      // `Map`, `WeakMap` and `Set` have no enumerable keys.
      var keys = allKeys(obj);
      if (getLength(keys)) return false;
      for (var i = 0; i < length; i++) {
        if (!isFunction$1(obj[methods[i]])) return false;
      }
      // If we are testing against `WeakMap`, we need to ensure that
      // `obj` doesn't have a `forEach` method in order to distinguish
      // it from a regular `Map`.
      return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
    };
  }

  // In the interest of compact minification, we write
  // each string in the fingerprints only once.
  var forEachName = 'forEach',
      hasName = 'has',
      commonInit = ['clear', 'delete'],
      mapTail = ['get', hasName, 'set'];

  // `Map`, `WeakMap` and `Set` each have slightly different
  // combinations of the above sublists.
  var mapMethods = commonInit.concat(forEachName, mapTail),
      weakMapMethods = commonInit.concat(mapTail),
      setMethods = ['add'].concat(commonInit, forEachName, hasName);

  var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester('Map');

  var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester('WeakMap');

  var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester('Set');

  var isWeakSet = tagTester('WeakSet');

  // Retrieve the values of an object's properties.
  function values(obj) {
    var _keys = keys(obj);
    var length = _keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[_keys[i]];
    }
    return values;
  }

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of `_.object` with one argument.
  function pairs(obj) {
    var _keys = keys(obj);
    var length = _keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [_keys[i], obj[_keys[i]]];
    }
    return pairs;
  }

  // Invert the keys and values of an object. The values must be serializable.
  function invert(obj) {
    var result = {};
    var _keys = keys(obj);
    for (var i = 0, length = _keys.length; i < length; i++) {
      result[obj[_keys[i]]] = _keys[i];
    }
    return result;
  }

  // Return a sorted list of the function names available on the object.
  function functions(obj) {
    var names = [];
    for (var key in obj) {
      if (isFunction$1(obj[key])) names.push(key);
    }
    return names.sort();
  }

  // An internal function for creating assigner functions.
  function createAssigner(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  }

  // Extend a given object with all the properties in passed-in object(s).
  var extend = createAssigner(allKeys);

  // Assigns a given object with all the own properties in the passed-in
  // object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  var extendOwn = createAssigner(keys);

  // Fill in a given object with default properties.
  var defaults = createAssigner(allKeys, true);

  // Create a naked function reference for surrogate-prototype-swapping.
  function ctor() {
    return function(){};
  }

  // An internal function for creating a new object that inherits from another.
  function baseCreate(prototype) {
    if (!isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    var Ctor = ctor();
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  }

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  function create(prototype, props) {
    var result = baseCreate(prototype);
    if (props) extendOwn(result, props);
    return result;
  }

  // Create a (shallow-cloned) duplicate of an object.
  function clone(obj) {
    if (!isObject(obj)) return obj;
    return isArray(obj) ? obj.slice() : extend({}, obj);
  }

  // Invokes `interceptor` with the `obj` and then returns `obj`.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  function tap(obj, interceptor) {
    interceptor(obj);
    return obj;
  }

  // Normalize a (deep) property `path` to array.
  // Like `_.iteratee`, this function can be customized.
  function toPath$1(path) {
    return isArray(path) ? path : [path];
  }
  _$1.toPath = toPath$1;

  // Internal wrapper for `_.toPath` to enable minification.
  // Similar to `cb` for `_.iteratee`.
  function toPath(path) {
    return _$1.toPath(path);
  }

  // Internal function to obtain a nested property in `obj` along `path`.
  function deepGet(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  }

  // Get the value of the (deep) property on `path` from `object`.
  // If any property in `path` does not exist or if the value is
  // `undefined`, return `defaultValue` instead.
  // The `path` is normalized through `_.toPath`.
  function get(object, path, defaultValue) {
    var value = deepGet(object, toPath(path));
    return isUndefined(value) ? defaultValue : value;
  }

  // Shortcut function for checking if an object has a given property directly on
  // itself (in other words, not on a prototype). Unlike the internal `has`
  // function, this public version can also traverse nested properties.
  function has(obj, path) {
    path = toPath(path);
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (!has$1(obj, key)) return false;
      obj = obj[key];
    }
    return !!length;
  }

  // Keep the identity function around for default iteratees.
  function identity(value) {
    return value;
  }

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  function matcher(attrs) {
    attrs = extendOwn({}, attrs);
    return function(obj) {
      return isMatch(obj, attrs);
    };
  }

  // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indices.
  function property(path) {
    path = toPath(path);
    return function(obj) {
      return deepGet(obj, path);
    };
  }

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  function optimizeCb(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because we’re not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  }

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `_.identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  function baseIteratee(value, context, argCount) {
    if (value == null) return identity;
    if (isFunction$1(value)) return optimizeCb(value, context, argCount);
    if (isObject(value) && !isArray(value)) return matcher(value);
    return property(value);
  }

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only `argCount` argument.
  function iteratee(value, context) {
    return baseIteratee(value, context, Infinity);
  }
  _$1.iteratee = iteratee;

  // The function we call internally to generate a callback. It invokes
  // `_.iteratee` if overridden, otherwise `baseIteratee`.
  function cb(value, context, argCount) {
    if (_$1.iteratee !== iteratee) return _$1.iteratee(value, context);
    return baseIteratee(value, context, argCount);
  }

  // Returns the results of applying the `iteratee` to each element of `obj`.
  // In contrast to `_.map` it returns an object.
  function mapObject(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var _keys = keys(obj),
        length = _keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = _keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  }

  // Predicate-generating function. Often useful outside of Underscore.
  function noop(){}

  // Generates a function for a given object that returns a given property.
  function propertyOf(obj) {
    if (obj == null) return noop;
    return function(path) {
      return get(obj, path);
    };
  }

  // Run a function **n** times.
  function times(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  }

  // Return a random integer between `min` and `max` (inclusive).
  function random(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  }

  // A (possibly faster) way to get the current timestamp as an integer.
  var now = Date.now || function() {
    return new Date().getTime();
  };

  // Internal helper to generate functions for escaping and unescaping strings
  // to/from HTML interpolation.
  function createEscaper(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  }

  // Internal list of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };

  // Function for escaping strings to HTML interpolation.
  var _escape = createEscaper(escapeMap);

  // Internal list of HTML entities for unescaping.
  var unescapeMap = invert(escapeMap);

  // Function for unescaping strings from HTML interpolation.
  var _unescape = createEscaper(unescapeMap);

  // By default, Underscore uses ERB-style template delimiters. Change the
  // following template settings to use alternative delimiters.
  var templateSettings = _$1.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `_.templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  function escapeChar(match) {
    return '\\' + escapes[match];
  }

  // In order to prevent third-party code injection through
  // `_.templateSettings.variable`, we test it against the following regular
  // expression. It is intentionally a bit more liberal than just matching valid
  // identifiers, but still prevents possible loopholes through defaults or
  // destructuring assignment.
  var bareIdentifier = /^\s*(\w|\$)+\s*$/;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  function template(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = defaults({}, settings, _$1.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    var argument = settings.variable;
    if (argument) {
      // Insure against third-party code injection. (CVE-2021-23358)
      if (!bareIdentifier.test(argument)) throw new Error(
        'variable is not a bare identifier: ' + argument
      );
    } else {
      // If a variable is not specified, place data values in local scope.
      source = 'with(obj||{}){\n' + source + '}\n';
      argument = 'obj';
    }

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(argument, '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _$1);
    };

    // Provide the compiled source as a convenience for precompilation.
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  }

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  function result(obj, path, fallback) {
    path = toPath(path);
    var length = path.length;
    if (!length) {
      return isFunction$1(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = isFunction$1(prop) ? prop.call(obj) : prop;
    }
    return obj;
  }

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  function uniqueId(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  }

  // Start chaining a wrapped Underscore object.
  function chain(obj) {
    var instance = _$1(obj);
    instance._chain = true;
    return instance;
  }

  // Internal function to execute `sourceFunc` bound to `context` with optional
  // `args`. Determines whether to execute a function as a constructor or as a
  // normal function.
  function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (isObject(result)) return result;
    return self;
  }

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. `_` acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  var partial = restArguments(function(func, boundArgs) {
    var placeholder = partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  partial.placeholder = _$1;

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally).
  var bind = restArguments(function(func, context, args) {
    if (!isFunction$1(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Internal helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var isArrayLike = createSizePropertyCheck(getLength);

  // Internal implementation of a recursive `flatten` function.
  function flatten$1(input, depth, strict, output) {
    output = output || [];
    if (!depth && depth !== 0) {
      depth = Infinity;
    } else if (depth <= 0) {
      return output.concat(input);
    }
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
        // Flatten current level of array or arguments object.
        if (depth > 1) {
          flatten$1(value, depth - 1, strict, output);
          idx = output.length;
        } else {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  }

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  var bindAll = restArguments(function(obj, keys) {
    keys = flatten$1(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = bind(obj[key], obj);
    }
    return obj;
  });

  // Memoize an expensive function by storing its results.
  function memoize(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has$1(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  }

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  var delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  var defer = partial(delay, _$1, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  function throttle(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var _now = now();
      if (!previous && options.leading === false) previous = _now;
      var remaining = wait - (_now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = _now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  }

  // When a sequence of calls of the returned function ends, the argument
  // function is triggered. The end of a sequence is defined by the `wait`
  // parameter. If `immediate` is passed, the argument function will be
  // triggered at the beginning of the sequence instead of at the end.
  function debounce(func, wait, immediate) {
    var timeout, previous, args, result, context;

    var later = function() {
      var passed = now() - previous;
      if (wait > passed) {
        timeout = setTimeout(later, wait - passed);
      } else {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
        // This check is needed because `func` can recursively invoke `debounced`.
        if (!timeout) args = context = null;
      }
    };

    var debounced = restArguments(function(_args) {
      context = this;
      args = _args;
      previous = now();
      if (!timeout) {
        timeout = setTimeout(later, wait);
        if (immediate) result = func.apply(context, args);
      }
      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = args = context = null;
    };

    return debounced;
  }

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  function wrap(func, wrapper) {
    return partial(wrapper, func);
  }

  // Returns a negated version of the passed-in predicate.
  function negate(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  }

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  function compose() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  }

  // Returns a function that will only be executed on and after the Nth call.
  function after(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  }

  // Returns a function that will only be executed up to (but not including) the
  // Nth call.
  function before(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  }

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  var once = partial(before, 2);

  // Returns the first key on an object that passes a truth test.
  function findKey(obj, predicate, context) {
    predicate = cb(predicate, context);
    var _keys = keys(obj), key;
    for (var i = 0, length = _keys.length; i < length; i++) {
      key = _keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  }

  // Internal function to generate `_.findIndex` and `_.findLastIndex`.
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a truth test.
  var findIndex = createPredicateIndexFinder(1);

  // Returns the last index on an array-like that passes a truth test.
  var findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  function sortedIndex(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  }

  // Internal function to generate the `_.indexOf` and `_.lastIndexOf` functions.
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), isNaN$1);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  var indexOf = createIndexFinder(1, findIndex, sortedIndex);

  // Return the position of the last occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  var lastIndexOf = createIndexFinder(-1, findLastIndex);

  // Return the first value which passes a truth test.
  function find(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? findIndex : findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  }

  // Convenience version of a common use case of `_.find`: getting the first
  // object containing specific `key:value` pairs.
  function findWhere(obj, attrs) {
    return find(obj, matcher(attrs));
  }

  // The cornerstone for collection functions, an `each`
  // implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  function each(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var _keys = keys(obj);
      for (i = 0, length = _keys.length; i < length; i++) {
        iteratee(obj[_keys[i]], _keys[i], obj);
      }
    }
    return obj;
  }

  // Return the results of applying the iteratee to each element.
  function map(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var _keys = !isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  }

  // Internal helper to create a reducing function, iterating left or right.
  function createReduce(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var _keys = !isArrayLike(obj) && keys(obj),
          length = (_keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[_keys ? _keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = _keys ? _keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  var reduce = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  var reduceRight = createReduce(-1);

  // Return all the elements that pass a truth test.
  function filter(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  }

  // Return all the elements for which a truth test fails.
  function reject(obj, predicate, context) {
    return filter(obj, negate(cb(predicate)), context);
  }

  // Determine whether all of the elements pass a truth test.
  function every(obj, predicate, context) {
    predicate = cb(predicate, context);
    var _keys = !isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  }

  // Determine if at least one element in the object passes a truth test.
  function some(obj, predicate, context) {
    predicate = cb(predicate, context);
    var _keys = !isArrayLike(obj) && keys(obj),
        length = (_keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = _keys ? _keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  }

  // Determine if the array or object contains a given item (using `===`).
  function contains(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return indexOf(obj, item, fromIndex) >= 0;
  }

  // Invoke a method (with arguments) on every item in a collection.
  var invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (isFunction$1(path)) {
      func = path;
    } else {
      path = toPath(path);
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `_.map`: fetching a property.
  function pluck(obj, key) {
    return map(obj, property(key));
  }

  // Convenience version of a common use case of `_.filter`: selecting only
  // objects containing specific `key:value` pairs.
  function where(obj, attrs) {
    return filter(obj, matcher(attrs));
  }

  // Return the maximum element (or element-based computation).
  function max(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
      obj = isArrayLike(obj) ? obj : values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || (computed === -Infinity && result === -Infinity)) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  }

  // Return the minimum element (or element-based computation).
  function min(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || (typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null)) {
      obj = isArrayLike(obj) ? obj : values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || (computed === Infinity && result === Infinity)) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  }

  // Safely create a real, live array from anything iterable.
  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  function toArray(obj) {
    if (!obj) return [];
    if (isArray(obj)) return slice.call(obj);
    if (isString(obj)) {
      // Keep surrogate pair characters together.
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return map(obj, identity);
    return values(obj);
  }

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `_.map`.
  function sample(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = values(obj);
      return obj[random(obj.length - 1)];
    }
    var sample = toArray(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  }

  // Shuffle a collection.
  function shuffle(obj) {
    return sample(obj, Infinity);
  }

  // Sort the object's values by a criterion produced by an iteratee.
  function sortBy(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return pluck(map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  }

  // An internal function used for aggregate "group by" operations.
  function group(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  }

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  var groupBy = group(function(result, value, key) {
    if (has$1(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `_.groupBy`, but for
  // when you know that your index values will be unique.
  var indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  var countBy = group(function(result, value, key) {
    if (has$1(result, key)) result[key]++; else result[key] = 1;
  });

  // Split a collection into two arrays: one whose elements all pass the given
  // truth test, and one whose elements all do not pass the truth test.
  var partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Return the number of elements in a collection.
  function size(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : keys(obj).length;
  }

  // Internal `_.pick` helper function to determine whether `key` is an enumerable
  // property name of `obj`.
  function keyInObj(value, key, obj) {
    return key in obj;
  }

  // Return a copy of the object only containing the allowed properties.
  var pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (isFunction$1(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten$1(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the disallowed properties.
  var omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (isFunction$1(iteratee)) {
      iteratee = negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = map(flatten$1(keys, false, false), String);
      iteratee = function(value, key) {
        return !contains(keys, key);
      };
    }
    return pick(obj, iteratee, context);
  });

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  function initial(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  }

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. The **guard** check allows it to work with `_.map`.
  function first(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[0];
    return initial(array, array.length - n);
  }

  // Returns everything but the first entry of the `array`. Especially useful on
  // the `arguments` object. Passing an **n** will return the rest N values in the
  // `array`.
  function rest(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  }

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  function last(array, n, guard) {
    if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return rest(array, Math.max(0, array.length - n));
  }

  // Trim out all falsy values from an array.
  function compact(array) {
    return filter(array, Boolean);
  }

  // Flatten out an array, either recursively (by default), or up to `depth`.
  // Passing `true` or `false` as `depth` means `1` or `Infinity`, respectively.
  function flatten(array, depth) {
    return flatten$1(array, depth, false);
  }

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  var difference = restArguments(function(array, rest) {
    rest = flatten$1(rest, true, true);
    return filter(array, function(value){
      return !contains(rest, value);
    });
  });

  // Return a version of the array that does not contain the specified value(s).
  var without = restArguments(function(array, otherArrays) {
    return difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  function uniq(array, isSorted, iteratee, context) {
    if (!isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  }

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  var union = restArguments(function(arrays) {
    return uniq(flatten$1(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  function intersection(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  }

  // Complement of zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  function unzip(array) {
    var length = (array && max(array, getLength).length) || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = pluck(array, index);
    }
    return result;
  }

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  var zip = restArguments(unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of `_.pairs`.
  function object(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  }

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](https://docs.python.org/library/functions.html#range).
  function range(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  }

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  function chunk(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  }

  // Helper function to continue chaining intermediate results.
  function chainResult(instance, obj) {
    return instance._chain ? _$1(obj).chain() : obj;
  }

  // Add your own custom functions to the Underscore object.
  function mixin(obj) {
    each(functions(obj), function(name) {
      var func = _$1[name] = obj[name];
      _$1.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_$1, args));
      };
    });
    return _$1;
  }

  // Add all mutator `Array` functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _$1.prototype[name] = function() {
      var obj = this._wrapped;
      if (obj != null) {
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0) {
          delete obj[0];
        }
      }
      return chainResult(this, obj);
    };
  });

  // Add all accessor `Array` functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _$1.prototype[name] = function() {
      var obj = this._wrapped;
      if (obj != null) obj = method.apply(obj, arguments);
      return chainResult(this, obj);
    };
  });

  // Named Exports

  var allExports = {
    __proto__: null,
    VERSION: VERSION,
    restArguments: restArguments,
    isObject: isObject,
    isNull: isNull,
    isUndefined: isUndefined,
    isBoolean: isBoolean,
    isElement: isElement,
    isString: isString,
    isNumber: isNumber,
    isDate: isDate,
    isRegExp: isRegExp,
    isError: isError,
    isSymbol: isSymbol,
    isArrayBuffer: isArrayBuffer,
    isDataView: isDataView$1,
    isArray: isArray,
    isFunction: isFunction$1,
    isArguments: isArguments$1,
    isFinite: isFinite$1,
    isNaN: isNaN$1,
    isTypedArray: isTypedArray$1,
    isEmpty: isEmpty,
    isMatch: isMatch,
    isEqual: isEqual,
    isMap: isMap,
    isWeakMap: isWeakMap,
    isSet: isSet,
    isWeakSet: isWeakSet,
    keys: keys,
    allKeys: allKeys,
    values: values,
    pairs: pairs,
    invert: invert,
    functions: functions,
    methods: functions,
    extend: extend,
    extendOwn: extendOwn,
    assign: extendOwn,
    defaults: defaults,
    create: create,
    clone: clone,
    tap: tap,
    get: get,
    has: has,
    mapObject: mapObject,
    identity: identity,
    constant: constant,
    noop: noop,
    toPath: toPath$1,
    property: property,
    propertyOf: propertyOf,
    matcher: matcher,
    matches: matcher,
    times: times,
    random: random,
    now: now,
    escape: _escape,
    unescape: _unescape,
    templateSettings: templateSettings,
    template: template,
    result: result,
    uniqueId: uniqueId,
    chain: chain,
    iteratee: iteratee,
    partial: partial,
    bind: bind,
    bindAll: bindAll,
    memoize: memoize,
    delay: delay,
    defer: defer,
    throttle: throttle,
    debounce: debounce,
    wrap: wrap,
    negate: negate,
    compose: compose,
    after: after,
    before: before,
    once: once,
    findKey: findKey,
    findIndex: findIndex,
    findLastIndex: findLastIndex,
    sortedIndex: sortedIndex,
    indexOf: indexOf,
    lastIndexOf: lastIndexOf,
    find: find,
    detect: find,
    findWhere: findWhere,
    each: each,
    forEach: each,
    map: map,
    collect: map,
    reduce: reduce,
    foldl: reduce,
    inject: reduce,
    reduceRight: reduceRight,
    foldr: reduceRight,
    filter: filter,
    select: filter,
    reject: reject,
    every: every,
    all: every,
    some: some,
    any: some,
    contains: contains,
    includes: contains,
    include: contains,
    invoke: invoke,
    pluck: pluck,
    where: where,
    max: max,
    min: min,
    shuffle: shuffle,
    sample: sample,
    sortBy: sortBy,
    groupBy: groupBy,
    indexBy: indexBy,
    countBy: countBy,
    partition: partition,
    toArray: toArray,
    size: size,
    pick: pick,
    omit: omit,
    first: first,
    head: first,
    take: first,
    initial: initial,
    last: last,
    rest: rest,
    tail: rest,
    drop: rest,
    compact: compact,
    flatten: flatten,
    without: without,
    uniq: uniq,
    unique: uniq,
    union: union,
    intersection: intersection,
    difference: difference,
    unzip: unzip,
    transpose: unzip,
    zip: zip,
    object: object,
    range: range,
    chunk: chunk,
    mixin: mixin,
    'default': _$1
  };

  // Default Export

  // Add all of the Underscore functions to the wrapper object.
  var _ = mixin(allExports);
  // Legacy Node.js API.
  _._ = _;

  return _;

})));
/*************************************   End of Underscore.js file       ******************************************/



/* Start of canvg.js library includes,
 *  http://canvg.github.io/canvg/rgbcolor.js
 *  http://canvg.github.io/canvg/StackBlur.js
 *  http://canvg.github.io/canvg/canvg.js
 * source : https://github.com/canvg/canvg */
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    this.ok = false;

    // strip any leading #
    if (color_string.charAt(0) == '#') { // remove # if any
        color_string = color_string.substr(1,6);
    }

    color_string = color_string.replace(/ /g,'');
    color_string = color_string.toLowerCase();

    // before getting into regexps, try simple matches
    // and overwrite the input
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred : 'cd5c5c',
        indigo : '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };
    for (var key in simple_colors) {
        if (color_string == key) {
            color_string = simple_colors[key];
        }
    }
    // emd of simple type-in colors

    // array of color definition objects
    var color_defs = [
        {
            re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
            example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'],
            process: function (bits){
                return [
                    parseInt(bits[1]),
                    parseInt(bits[2]),
                    parseInt(bits[3])
                ];
            }
        },
        {
            re: /^(\w{2})(\w{2})(\w{2})$/,
            example: ['#00ff00', '336699'],
            process: function (bits){
                return [
                    parseInt(bits[1], 16),
                    parseInt(bits[2], 16),
                    parseInt(bits[3], 16)
                ];
            }
        },
        {
            re: /^(\w{1})(\w{1})(\w{1})$/,
            example: ['#fb0', 'f0f'],
            process: function (bits){
                return [
                    parseInt(bits[1] + bits[1], 16),
                    parseInt(bits[2] + bits[2], 16),
                    parseInt(bits[3] + bits[3], 16)
                ];
            }
        }
    ];

    // search through the definitions to find a match
    for (var i = 0; i < color_defs.length; i++) {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits) {
            channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true;
        }

    }

    // validate/cleanup values
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);

    // some getters
    this.toRGB = function () {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')';
    }
    this.toHex = function () {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length == 1) r = '0' + r;
        if (g.length == 1) g = '0' + g;
        if (b.length == 1) b = '0' + b;
        return '#' + r + g + b;
    }

    // help
    this.getHelpXML = function () {

        var examples = new Array();
        // add regexps
        for (var i = 0; i < color_defs.length; i++) {
            var example = color_defs[i].example;
            for (var j = 0; j < example.length; j++) {
                examples[examples.length] = example[j];
            }
        }
        // add type-in colors
        for (var sc in simple_colors) {
            examples[examples.length] = sc;
        }

        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (var i = 0; i < examples.length; i++) {
            try {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText =
                        'margin: 3px; '
                        + 'border: 1px solid black; '
                        + 'background:' + list_color.toHex() + '; '
                        + 'color:' + list_color.toHex()
                ;
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(
                    ' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex()
                );
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item);

            } catch(e){}
        }
        return xml;

    }

}
/*

StackBlur - a fast almost Gaussian Blur For Canvas

Version: 	0.5
Author:		Mario Klingemann
Contact: 	mario@quasimondo.com
Website:	http://www.quasimondo.com/StackBlurForCanvas
Twitter:	@quasimondo

In case you find this class useful - especially in commercial projects -
I am not totally unhappy for a small donation to my PayPal account
mario@quasimondo.de

Or support me on flattr: 
https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript

Copyright (c) 2010 Mario Klingemann

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
*/

var mul_table = [
        512,512,456,512,328,456,335,512,405,328,271,456,388,335,292,512,
        454,405,364,328,298,271,496,456,420,388,360,335,312,292,273,512,
        482,454,428,405,383,364,345,328,312,298,284,271,259,496,475,456,
        437,420,404,388,374,360,347,335,323,312,302,292,282,273,265,512,
        497,482,468,454,441,428,417,405,394,383,373,364,354,345,337,328,
        320,312,305,298,291,284,278,271,265,259,507,496,485,475,465,456,
        446,437,428,420,412,404,396,388,381,374,367,360,354,347,341,335,
        329,323,318,312,307,302,297,292,287,282,278,273,269,265,261,512,
        505,497,489,482,475,468,461,454,447,441,435,428,422,417,411,405,
        399,394,389,383,378,373,368,364,359,354,350,345,341,337,332,328,
        324,320,316,312,309,305,301,298,294,291,287,284,281,278,274,271,
        268,265,262,259,257,507,501,496,491,485,480,475,470,465,460,456,
        451,446,442,437,433,428,424,420,416,412,408,404,400,396,392,388,
        385,381,377,374,370,367,363,360,357,354,350,347,344,341,338,335,
        332,329,326,323,320,318,315,312,310,307,304,302,299,297,294,292,
        289,287,285,282,280,278,275,273,271,269,267,265,263,261,259];
        
   
var shg_table = [
	     9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 
		17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 
		19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20,
		20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21,
		21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
		22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23,
		23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
		23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
		24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 ];

function premultiplyAlpha(imageData)
{
	var pixels = imageData.data;
	var size = imageData.width * imageData.height * 4;
	
	for (var i=0; i<size; i+=4)
	{
		var a = pixels[i+3] / 255;
		pixels[i  ] *= a;
		pixels[i+1] *= a;
		pixels[i+2] *= a;
	}
}

function unpremultiplyAlpha(imageData)
{
	var pixels = imageData.data;
	var size = imageData.width * imageData.height * 4;
	
	for (var i=0; i<size; i+=4)
	{
		var a = pixels[i+3];
		if (a != 0)
		{
			a = 255 / a;
			pixels[i  ] *= a;
			pixels[i+1] *= a;
			pixels[i+2] *= a;
		}
	}
}

function stackBlurImage( imageID, canvasID, radius, blurAlphaChannel )
{
			
 	var img = document.getElementById( imageID );
	var w = img.naturalWidth;
    var h = img.naturalHeight;
       
	var canvas = document.getElementById( canvasID );
      
    canvas.style.width  = w + "px";
    canvas.style.height = h + "px";
    canvas.width = w;
    canvas.height = h;
    
    var context = canvas.getContext("2d");
    context.clearRect( 0, 0, w, h );
    context.drawImage( img, 0, 0 );

	if ( isNaN(radius) || radius < 1 ) return;
	
	if ( blurAlphaChannel )
		stackBlurCanvasRGBA( canvasID, 0, 0, w, h, radius );
	else 
		stackBlurCanvasRGB( canvasID, 0, 0, w, h, radius );
}


function stackBlurCanvasRGBA( id, top_x, top_y, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;
	
	var canvas  = document.getElementById( id );
	var context = canvas.getContext("2d");
	var imageData;
	
	try {
	  try {
		imageData = context.getImageData( top_x, top_y, width, height );
	  } catch(e) {
	  
		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
		try {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
			imageData = context.getImageData( top_x, top_y, width, height );
		} catch(e) {
			alert("Cannot access local image");
			throw new Error("unable to access local image data: " + e);
			return;
		}
	  }
	} catch(e) {
	  alert("Cannot access image");
	  throw new Error("unable to access image data: " + e);
	}
	
	premultiplyAlpha(imageData);
	
	var pixels = imageData.data;
			
	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, 
	r_out_sum, g_out_sum, b_out_sum, a_out_sum,
	r_in_sum, g_in_sum, b_in_sum, a_in_sum, 
	pr, pg, pb, pa, rbs;
			
	var div = 1 + 1 + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = 1 + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[1];
	var shg_sum = shg_table[1];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[p+3])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		}
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
			pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
			pixels[yi+3] = (a_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p =  ( yw + ( ( p = x + 1 + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			a_in_sum += ( stackIn.a = pixels[p+3]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			a_sum += a_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;

			yi += 4;
		}
		yw += width;
	}

	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		a_out_sum = radiusPlus1 * ( pa = pixels[yi+3]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		a_sum += sumFactor * pa;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack.a = pa;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= 1; i++ )
		{
			yi = ( yp + x ) << 2;
			
			r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			a_sum += ( stack.a = ( pa = pixels[yi+3])) * rbs;
		   
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			a_in_sum += pa;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p]   = (r_sum * mul_sum) >> shg_sum;
			pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
			pixels[p+3] = (a_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			a_sum -= a_out_sum;
		   
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			a_out_sum -= stackIn.a;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			a_sum += ( a_in_sum += ( stackIn.a = pixels[p+3]));
		   
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			a_out_sum += ( pa = stackOut.a );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			a_in_sum -= pa;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
	
	unpremultiplyAlpha(imageData);
	
	context.putImageData( imageData, top_x, top_y );
}


function stackBlurCanvasRGB( id, top_x, top_y, width, height, radius )
{
	if ( isNaN(radius) || radius < 1 ) return;
	radius |= 0;
	
	var canvas  = document.getElementById( id );
	var context = canvas.getContext("2d");
	var imageData;
	
	try {
	  try {
		imageData = context.getImageData( top_x, top_y, width, height );
	  } catch(e) {
	  
		// NOTE: this part is supposedly only needed if you want to work with local files
		// so it might be okay to remove the whole try/catch block and just use
		// imageData = context.getImageData( top_x, top_y, width, height );
		try {
			netscape.security.PrivilegeManager.enablePrivilege("UniversalBrowserRead");
			imageData = context.getImageData( top_x, top_y, width, height );
		} catch(e) {
			alert("Cannot access local image");
			throw new Error("unable to access local image data: " + e);
			return;
		}
	  }
	} catch(e) {
	  alert("Cannot access image");
	  throw new Error("unable to access image data: " + e);
	}
			
	var pixels = imageData.data;
			
	var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum,
	r_out_sum, g_out_sum, b_out_sum,
	r_in_sum, g_in_sum, b_in_sum,
	pr, pg, pb, rbs;
			
	var div = radius + radius + 1;
	var w4 = width << 2;
	var widthMinus1  = width - 1;
	var heightMinus1 = height - 1;
	var radiusPlus1  = radius + 1;
	var sumFactor = radiusPlus1 * ( radiusPlus1 + 1 ) / 2;
	
	var stackStart = new BlurStack();
	var stack = stackStart;
	for ( i = 1; i < div; i++ )
	{
		stack = stack.next = new BlurStack();
		if ( i == radiusPlus1 ) var stackEnd = stack;
	}
	stack.next = stackStart;
	var stackIn = null;
	var stackOut = null;
	
	yw = yi = 0;
	
	var mul_sum = mul_table[radius];
	var shg_sum = shg_table[radius];
	
	for ( y = 0; y < height; y++ )
	{
		r_in_sum = g_in_sum = b_in_sum = r_sum = g_sum = b_sum = 0;
		
		r_out_sum = radiusPlus1 * ( pr = pixels[yi] );
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1] );
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2] );
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack = stack.next;
		}
		
		for( i = 1; i < radiusPlus1; i++ )
		{
			p = yi + (( widthMinus1 < i ? widthMinus1 : i ) << 2 );
			r_sum += ( stack.r = ( pr = pixels[p])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[p+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[p+2])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			
			stack = stack.next;
		}
		
		
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( x = 0; x < width; x++ )
		{
			pixels[yi]   = (r_sum * mul_sum) >> shg_sum;
			pixels[yi+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[yi+2] = (b_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			
			p =  ( yw + ( ( p = x + radius + 1 ) < widthMinus1 ? p : widthMinus1 ) ) << 2;
			
			r_in_sum += ( stackIn.r = pixels[p]);
			g_in_sum += ( stackIn.g = pixels[p+1]);
			b_in_sum += ( stackIn.b = pixels[p+2]);
			
			r_sum += r_in_sum;
			g_sum += g_in_sum;
			b_sum += b_in_sum;
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			
			stackOut = stackOut.next;

			yi += 4;
		}
		yw += width;
	}

	
	for ( x = 0; x < width; x++ )
	{
		g_in_sum = b_in_sum = r_in_sum = g_sum = b_sum = r_sum = 0;
		
		yi = x << 2;
		r_out_sum = radiusPlus1 * ( pr = pixels[yi]);
		g_out_sum = radiusPlus1 * ( pg = pixels[yi+1]);
		b_out_sum = radiusPlus1 * ( pb = pixels[yi+2]);
		
		r_sum += sumFactor * pr;
		g_sum += sumFactor * pg;
		b_sum += sumFactor * pb;
		
		stack = stackStart;
		
		for( i = 0; i < radiusPlus1; i++ )
		{
			stack.r = pr;
			stack.g = pg;
			stack.b = pb;
			stack = stack.next;
		}
		
		yp = width;
		
		for( i = 1; i <= radius; i++ )
		{
			yi = ( yp + x ) << 2;
			
			r_sum += ( stack.r = ( pr = pixels[yi])) * ( rbs = radiusPlus1 - i );
			g_sum += ( stack.g = ( pg = pixels[yi+1])) * rbs;
			b_sum += ( stack.b = ( pb = pixels[yi+2])) * rbs;
			
			r_in_sum += pr;
			g_in_sum += pg;
			b_in_sum += pb;
			
			stack = stack.next;
		
			if( i < heightMinus1 )
			{
				yp += width;
			}
		}
		
		yi = x;
		stackIn = stackStart;
		stackOut = stackEnd;
		for ( y = 0; y < height; y++ )
		{
			p = yi << 2;
			pixels[p]   = (r_sum * mul_sum) >> shg_sum;
			pixels[p+1] = (g_sum * mul_sum) >> shg_sum;
			pixels[p+2] = (b_sum * mul_sum) >> shg_sum;
			
			r_sum -= r_out_sum;
			g_sum -= g_out_sum;
			b_sum -= b_out_sum;
			
			r_out_sum -= stackIn.r;
			g_out_sum -= stackIn.g;
			b_out_sum -= stackIn.b;
			
			p = ( x + (( ( p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1 ) * width )) << 2;
			
			r_sum += ( r_in_sum += ( stackIn.r = pixels[p]));
			g_sum += ( g_in_sum += ( stackIn.g = pixels[p+1]));
			b_sum += ( b_in_sum += ( stackIn.b = pixels[p+2]));
			
			stackIn = stackIn.next;
			
			r_out_sum += ( pr = stackOut.r );
			g_out_sum += ( pg = stackOut.g );
			b_out_sum += ( pb = stackOut.b );
			
			r_in_sum -= pr;
			g_in_sum -= pg;
			b_in_sum -= pb;
			
			stackOut = stackOut.next;
			
			yi += width;
		}
	}
	
	context.putImageData( imageData, top_x, top_y );
	
}

function BlurStack()
{
	this.r = 0;
	this.g = 0;
	this.b = 0;
	this.a = 0;
	this.next = null;
}
/*
 * canvg.js - Javascript SVG parser and renderer on Canvas
 * MIT Licensed
 * Gabe Lerner (gabelerner@gmail.com)
 * http://code.google.com/p/canvg/
 *
 * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/
 */
(function(){
	// canvg(target, s)
	// empty parameters: replace all 'svg' elements on page with 'canvas' elements
	// target: canvas element or the id of a canvas element
	// s: svg string, url to svg file, or xml document
	// opts: optional hash of options
	//		 ignoreMouse: true => ignore mouse events
	//		 ignoreAnimation: true => ignore animations
	//		 ignoreDimensions: true => does not try to resize canvas
	//		 ignoreClear: true => does not clear canvas
	//		 offsetX: int => draws at a x offset
	//		 offsetY: int => draws at a y offset
	//		 scaleWidth: int => scales horizontally to width
	//		 scaleHeight: int => scales vertically to height
	//		 renderCallback: function => will call the function after the first render is completed
	//		 forceRedraw: function => will call the function on every frame, if it returns true, will redraw
	this.canvg = function (target, s, opts) {
		// no parameters
		if (target == null && s == null && opts == null) {
			var svgTags = document.querySelectorAll('svg');
			for (var i=0; i<svgTags.length; i++) {
				var svgTag = svgTags[i];
				var c = document.createElement('canvas');
				c.width = svgTag.clientWidth;
				c.height = svgTag.clientHeight;
				svgTag.parentNode.insertBefore(c, svgTag);
				svgTag.parentNode.removeChild(svgTag);
				var div = document.createElement('div');
				div.appendChild(svgTag);
				canvg(c, div.innerHTML);
			}
			return;
		}

		if (typeof target == 'string') {
			target = document.getElementById(target);
		}

		// store class on canvas
		if (target.svg != null) target.svg.stop();
		var svg = build(opts || {});
		// on i.e. 8 for flash canvas, we can't assign the property so check for it
		if (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;

		var ctx = target.getContext('2d');
		if (typeof(s.documentElement) != 'undefined') {
			// load from xml doc
			svg.loadXmlDoc(ctx, s);
		}
		else if (s.substr(0,1) == '<') {
			// load from xml string
			svg.loadXml(ctx, s);
		}
		else {
			// load from url
			svg.load(ctx, s);
		}
	}

	// see https://developer.mozilla.org/en-US/docs/Web/API/Element.matches
	var matchesSelector;
	if (typeof(Element.prototype.matches) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.matches(selector);
		};
	} else if (typeof(Element.prototype.webkitMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.webkitMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.mozMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.mozMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.msMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.msMatchesSelector(selector);
		};
	} else if (typeof(Element.prototype.oMatchesSelector) != 'undefined') {
		matchesSelector = function(node, selector) {
			return node.oMatchesSelector(selector);
		};
	} else {
		// requires Sizzle: https://github.com/jquery/sizzle/wiki/Sizzle-Documentation
		// or jQuery: http://jquery.com/download/
		// or Zepto: http://zeptojs.com/#
		// without it, this is a ReferenceError

		if (typeof jQuery === 'function' || typeof Zepto === 'function') {
			matchesSelector = function (node, selector) {
				return $(node).is(selector);
			};
		}

		if (typeof matchesSelector === 'undefined') {
			matchesSelector = Sizzle.matchesSelector;
		}
	}

	// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/gi;
	var pseudoClassWithBracketsRegex = /(:[\w-]+\([^\)]*\))/gi;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	function getSelectorSpecificity(selector) {
		var typeCount = [0, 0, 0];
		var findMatch = function(regex, type) {
			var matches = selector.match(regex);
			if (matches == null) {
				return;
			}
			typeCount[type] += matches.length;
			selector = selector.replace(regex, ' ');
		};

		selector = selector.replace(/:not\(([^\)]*)\)/g, '     $1 ');
		selector = selector.replace(/{[^]*/gm, ' ');
		findMatch(attributeRegex, 1);
		findMatch(idRegex, 0);
		findMatch(classRegex, 1);
		findMatch(pseudoElementRegex, 2);
		findMatch(pseudoClassWithBracketsRegex, 1);
		findMatch(pseudoClassRegex, 1);
		selector = selector.replace(/[\*\s\+>~]/g, ' ');
		selector = selector.replace(/[#\.]/g, ' ');
		findMatch(elementRegex, 2);
		return typeCount.join('');
	}

	function build(opts) {
		var svg = { opts: opts };

		svg.FRAMERATE = 30;
		svg.MAX_VIRTUAL_PIXELS = 30000;

		svg.log = function(msg) {};
		if (svg.opts['log'] == true && typeof(console) != 'undefined') {
			svg.log = function(msg) { console.log(msg); };
		};

		// globals
		svg.init = function(ctx) {
			var uniqueId = 0;
			svg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;	};
			svg.Definitions = {};
			svg.Styles = {};
			svg.StylesSpecificity = {};
			svg.Animations = [];
			svg.Images = [];
			svg.ctx = ctx;
			svg.ViewPort = new (function () {
				this.viewPorts = [];
				this.Clear = function() { this.viewPorts = []; }
				this.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }
				this.RemoveCurrent = function() { this.viewPorts.pop(); }
				this.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }
				this.width = function() { return this.Current().width; }
				this.height = function() { return this.Current().height; }
				this.ComputeSize = function(d) {
					if (d != null && typeof(d) == 'number') return d;
					if (d == 'x') return this.width();
					if (d == 'y') return this.height();
					return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);
				}
			});
		}
		svg.init();

		// images loaded
		svg.ImagesLoaded = function() {
			for (var i=0; i<svg.Images.length; i++) {
				if (!svg.Images[i].loaded) return false;
			}
			return true;
		}

		// trim
		svg.trim = function(s) { return s.replace(/^\s+|\s+$/g, ''); }

		// compress spaces
		svg.compressSpaces = function(s) { return s.replace(/[\s\r\t\n]+/gm,' '); }

		// ajax
		svg.ajax = function(url) {
			var AJAX;
			if(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}
			else{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}
			if(AJAX){
			   AJAX.open('GET',url,false);
			   AJAX.send(null);
			   return AJAX.responseText;
			}
			return null;
		}

		// parse xml
		svg.parseXml = function(xml) {
			if (typeof(Windows) != 'undefined' && typeof(Windows.Data) != 'undefined' && typeof(Windows.Data.Xml) != 'undefined') {
				var xmlDoc = new Windows.Data.Xml.Dom.XmlDocument();
				var settings = new Windows.Data.Xml.Dom.XmlLoadSettings();
				settings.prohibitDtd = false;
				xmlDoc.loadXml(xml, settings);
				return xmlDoc;
			}
			else if (window.DOMParser)
			{
				var parser = new DOMParser();
				return parser.parseFromString(xml, 'text/xml');
			}
			else
			{
				xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
				var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
				xmlDoc.async = 'false';
				xmlDoc.loadXML(xml);
				return xmlDoc;
			}
		}

		svg.Property = function(name, value) {
			this.name = name;
			this.value = value;
		}
			svg.Property.prototype.getValue = function() {
				return this.value;
			}

			svg.Property.prototype.hasValue = function() {
				return (this.value != null && this.value !== '');
			}

			// return the numerical value of the property
			svg.Property.prototype.numValue = function() {
				if (!this.hasValue()) return 0;

				var n = parseFloat(this.value);
				if ((this.value + '').match(/%$/)) {
					n = n / 100.0;
				}
				return n;
			}

			svg.Property.prototype.valueOrDefault = function(def) {
				if (this.hasValue()) return this.value;
				return def;
			}

			svg.Property.prototype.numValueOrDefault = function(def) {
				if (this.hasValue()) return this.numValue();
				return def;
			}

			// color extensions
				// augment the current color value with the opacity
				svg.Property.prototype.addOpacity = function(opacityProp) {
					var newValue = this.value;
					if (opacityProp.value != null && opacityProp.value != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns
						var color = new RGBColor(this.value);
						if (color.ok) {
							newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacityProp.numValue() + ')';
						}
					}
					return new svg.Property(this.name, newValue);
				}

			// definition extensions
				// get the definition from the definitions table
				svg.Property.prototype.getDefinition = function() {
					var name = this.value.match(/#([^\)'"]+)/);
					if (name) { name = name[1]; }
					if (!name) { name = this.value; }
					return svg.Definitions[name];
				}

				svg.Property.prototype.isUrlDefinition = function() {
					return this.value.indexOf('url(') == 0
				}

				svg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {
					var def = this.getDefinition();

					// gradient
					if (def != null && def.createGradient) {
						return def.createGradient(svg.ctx, e, opacityProp);
					}

					// pattern
					if (def != null && def.createPattern) {
						if (def.getHrefAttribute().hasValue()) {
							var pt = def.attribute('patternTransform');
							def = def.getHrefAttribute().getDefinition();
							if (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }
						}
						return def.createPattern(svg.ctx, e);
					}

					return null;
				}

			// length extensions
				svg.Property.prototype.getDPI = function(viewPort) {
					return 96.0; // TODO: compute?
				}

				svg.Property.prototype.getEM = function(viewPort) {
					var em = 12;

					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					if (fontSize.hasValue()) em = fontSize.toPixels(viewPort);

					return em;
				}

				svg.Property.prototype.getUnits = function() {
					var s = this.value+'';
					return s.replace(/[0-9\.\-]/g,'');
				}

				// get the length as pixels
				svg.Property.prototype.toPixels = function(viewPort, processPercent) {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);
					if (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;
					if (s.match(/px$/)) return this.numValue();
					if (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);
					if (s.match(/pc$/)) return this.numValue() * 15;
					if (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;
					if (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;
					if (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);
					if (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);
					var n = this.numValue();
					if (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);
					return n;
				}

			// time extensions
				// get the time as milliseconds
				svg.Property.prototype.toMilliseconds = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/s$/)) return this.numValue() * 1000;
					if (s.match(/ms$/)) return this.numValue();
					return this.numValue();
				}

			// angle extensions
				// get the angle as radians
				svg.Property.prototype.toRadians = function() {
					if (!this.hasValue()) return 0;
					var s = this.value+'';
					if (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);
					if (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);
					if (s.match(/rad$/)) return this.numValue();
					return this.numValue() * (Math.PI / 180.0);
				}

			// text extensions
				// get the text baseline
				var textBaselineMapping = {
					'baseline': 'alphabetic',
					'before-edge': 'top',
					'text-before-edge': 'top',
					'middle': 'middle',
					'central': 'middle',
					'after-edge': 'bottom',
					'text-after-edge': 'bottom',
					'ideographic': 'ideographic',
					'alphabetic': 'alphabetic',
					'hanging': 'hanging',
					'mathematical': 'alphabetic'
				};
				svg.Property.prototype.toTextBaseline = function () {
					if (!this.hasValue()) return null;
					return textBaselineMapping[this.value];
				}

		// fonts
		svg.Font = new (function() {
			this.Styles = 'normal|italic|oblique|inherit';
			this.Variants = 'normal|small-caps|inherit';
			this.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';

			this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {
				var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
				return {
					fontFamily: fontFamily || f.fontFamily,
					fontSize: fontSize || f.fontSize,
					fontStyle: fontStyle || f.fontStyle,
					fontWeight: fontWeight || f.fontWeight,
					fontVariant: fontVariant || f.fontVariant,
					toString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }
				}
			}

			var that = this;
			this.Parse = function(s) {
				var f = {};
				var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
				var set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }
				var ff = '';
				for (var i=0; i<d.length; i++) {
					if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }
					else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;	}
					else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {	if (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }
					else if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }
					else { if (d[i] != 'inherit') ff += d[i]; }
				} if (ff != '') f.fontFamily = ff;
				return f;
			}
		});

		// points and paths
		svg.ToNumberArray = function(s) {
			var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
			for (var i=0; i<a.length; i++) {
				a[i] = parseFloat(a[i]);
			}
			return a;
		}
		svg.Point = function(x, y) {
			this.x = x;
			this.y = y;
		}
			svg.Point.prototype.angleTo = function(p) {
				return Math.atan2(p.y - this.y, p.x - this.x);
			}

			svg.Point.prototype.applyTransform = function(v) {
				var xp = this.x * v[0] + this.y * v[2] + v[4];
				var yp = this.x * v[1] + this.y * v[3] + v[5];
				this.x = xp;
				this.y = yp;
			}

		svg.CreatePoint = function(s) {
			var a = svg.ToNumberArray(s);
			return new svg.Point(a[0], a[1]);
		}
		svg.CreatePath = function(s) {
			var a = svg.ToNumberArray(s);
			var path = [];
			for (var i=0; i<a.length; i+=2) {
				path.push(new svg.Point(a[i], a[i+1]));
			}
			return path;
		}

		// bounding box
		svg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want
			this.x1 = Number.NaN;
			this.y1 = Number.NaN;
			this.x2 = Number.NaN;
			this.y2 = Number.NaN;

			this.x = function() { return this.x1; }
			this.y = function() { return this.y1; }
			this.width = function() { return this.x2 - this.x1; }
			this.height = function() { return this.y2 - this.y1; }

			this.addPoint = function(x, y) {
				if (x != null) {
					if (isNaN(this.x1) || isNaN(this.x2)) {
						this.x1 = x;
						this.x2 = x;
					}
					if (x < this.x1) this.x1 = x;
					if (x > this.x2) this.x2 = x;
				}

				if (y != null) {
					if (isNaN(this.y1) || isNaN(this.y2)) {
						this.y1 = y;
						this.y2 = y;
					}
					if (y < this.y1) this.y1 = y;
					if (y > this.y2) this.y2 = y;
				}
			}
			this.addX = function(x) { this.addPoint(x, null); }
			this.addY = function(y) { this.addPoint(null, y); }

			this.addBoundingBox = function(bb) {
				this.addPoint(bb.x1, bb.y1);
				this.addPoint(bb.x2, bb.y2);
			}

			this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {
				var cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)
				var cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)
				var cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)
				this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,	cp2y, p2x, p2y);
			}

			this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
				// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
				var p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];
				this.addPoint(p0[0], p0[1]);
				this.addPoint(p3[0], p3[1]);

				for (i=0; i<=1; i++) {
					var f = function(t) {
						return Math.pow(1-t, 3) * p0[i]
						+ 3 * Math.pow(1-t, 2) * t * p1[i]
						+ 3 * (1-t) * Math.pow(t, 2) * p2[i]
						+ Math.pow(t, 3) * p3[i];
					}

					var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
					var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
					var c = 3 * p1[i] - 3 * p0[i];

					if (a == 0) {
						if (b == 0) continue;
						var t = -c / b;
						if (0 < t && t < 1) {
							if (i == 0) this.addX(f(t));
							if (i == 1) this.addY(f(t));
						}
						continue;
					}

					var b2ac = Math.pow(b, 2) - 4 * c * a;
					if (b2ac < 0) continue;
					var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
					if (0 < t1 && t1 < 1) {
						if (i == 0) this.addX(f(t1));
						if (i == 1) this.addY(f(t1));
					}
					var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
					if (0 < t2 && t2 < 1) {
						if (i == 0) this.addX(f(t2));
						if (i == 1) this.addY(f(t2));
					}
				}
			}

			this.isPointInBox = function(x, y) {
				return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);
			}

			this.addPoint(x1, y1);
			this.addPoint(x2, y2);
		}

		// transforms
		svg.Transform = function(v) {
			var that = this;
			this.Type = {}

			// translate
			this.Type.translate = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.translate(this.p.x || 0.0, this.p.y || 0.0);
				}
				this.unapply = function(ctx) {
					ctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
				}
			}

			// rotate
			this.Type.rotate = function(s) {
				var a = svg.ToNumberArray(s);
				this.angle = new svg.Property('angle', a[0]);
				this.cx = a[1] || 0;
				this.cy = a[2] || 0;
				this.apply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.unapply = function(ctx) {
					ctx.translate(this.cx, this.cy);
					ctx.rotate(-1.0 * this.angle.toRadians());
					ctx.translate(-this.cx, -this.cy);
				}
				this.applyToPoint = function(p) {
					var a = this.angle.toRadians();
					p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
					p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
					p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);
				}
			}

			this.Type.scale = function(s) {
				this.p = svg.CreatePoint(s);
				this.apply = function(ctx) {
					ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);
				}
				this.unapply = function(ctx) {
					ctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);
				}
				this.applyToPoint = function(p) {
					p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);
				}
			}

			this.Type.matrix = function(s) {
				this.m = svg.ToNumberArray(s);
				this.apply = function(ctx) {
					ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);
				}
				this.unapply = function(ctx) {
					var a = this.m[0];
					var b = this.m[2];
					var c = this.m[4];
					var d = this.m[1];
					var e = this.m[3];
					var f = this.m[5];
					var g = 0.0;
					var h = 0.0;
					var i = 1.0;
					var det = 1 / (a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g));
					ctx.transform(
						det*(e*i-f*h),
						det*(f*g-d*i),
						det*(c*h-b*i),
						det*(a*i-c*g),
						det*(b*f-c*e),
						det*(c*d-a*f)
					);
				}
				this.applyToPoint = function(p) {
					p.applyTransform(this.m);
				}
			}

			this.Type.SkewBase = function(s) {
				this.base = that.Type.matrix;
				this.base(s);
				this.angle = new svg.Property('angle', s);
			}
			this.Type.SkewBase.prototype = new this.Type.matrix;

			this.Type.skewX = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];
			}
			this.Type.skewX.prototype = new this.Type.SkewBase;

			this.Type.skewY = function(s) {
				this.base = that.Type.SkewBase;
				this.base(s);
				this.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];
			}
			this.Type.skewY.prototype = new this.Type.SkewBase;

			this.transforms = [];

			this.apply = function(ctx) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].apply(ctx);
				}
			}

			this.unapply = function(ctx) {
				for (var i=this.transforms.length-1; i>=0; i--) {
					this.transforms[i].unapply(ctx);
				}
			}

			this.applyToPoint = function(p) {
				for (var i=0; i<this.transforms.length; i++) {
					this.transforms[i].applyToPoint(p);
				}
			}

			var data = svg.trim(svg.compressSpaces(v)).replace(/\)([a-zA-Z])/g, ') $1').replace(/\)(\s?,\s?)/g,') ').split(/\s(?=[a-z])/);
			for (var i=0; i<data.length; i++) {
				var type = svg.trim(data[i].split('(')[0]);
				var s = data[i].split('(')[1].replace(')','');
				var transform = new this.Type[type](s);
				transform.type = type;
				this.transforms.push(transform);
			}
		}

		// aspect ratio
		svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {
			// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute
			aspectRatio = svg.compressSpaces(aspectRatio);
			aspectRatio = aspectRatio.replace(/^defer\s/,''); // ignore defer
			var align = aspectRatio.split(' ')[0] || 'xMidYMid';
			var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';

			// calculate scale
			var scaleX = width / desiredWidth;
			var scaleY = height / desiredHeight;
			var scaleMin = Math.min(scaleX, scaleY);
			var scaleMax = Math.max(scaleX, scaleY);
			if (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }
			if (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }

			refX = new svg.Property('refX', refX);
			refY = new svg.Property('refY', refY);
			if (refX.hasValue() && refY.hasValue()) {
				ctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));
			}
			else {
				// align
				if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
				if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
				if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);
				if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);
			}

			// scale
			if (align == 'none') ctx.scale(scaleX, scaleY);
			else if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);
			else if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);

			// translate
			ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);
		}

		// elements
		svg.Element = {}

		svg.EmptyProperty = new svg.Property('EMPTY', '');

		svg.Element.ElementBase = function(node) {
			this.attributes = {};
			this.styles = {};
			this.stylesSpecificity = {};
			this.children = [];

			// get or create attribute
			this.attribute = function(name, createIfNotExists) {
				var a = this.attributes[name];
				if (a != null) return a;

				if (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }
				return a || svg.EmptyProperty;
			}

			this.getHrefAttribute = function() {
				for (var a in this.attributes) {
					if (a == 'href' || a.match(/:href$/)) {
						return this.attributes[a];
					}
				}
				return svg.EmptyProperty;
			}

			// get or create style, crawls up node tree
			this.style = function(name, createIfNotExists, skipAncestors) {
				var s = this.styles[name];
				if (s != null) return s;

				var a = this.attribute(name);
				if (a != null && a.hasValue()) {
					this.styles[name] = a; // move up to me to cache
					return a;
				}

				if (skipAncestors != true) {
					var p = this.parent;
					if (p != null) {
						var ps = p.style(name);
						if (ps != null && ps.hasValue()) {
							return ps;
						}
					}
				}

				if (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }
				return s || svg.EmptyProperty;
			}

			// base render
			this.render = function(ctx) {
				// don't render display=none
				if (this.style('display').value == 'none') return;

				// don't render visibility=hidden
				if (this.style('visibility').value == 'hidden') return;

				ctx.save();
				if (this.attribute('mask').hasValue()) { // mask
					var mask = this.attribute('mask').getDefinition();
					if (mask != null) mask.apply(ctx, this);
				}
				else if (this.style('filter').hasValue()) { // filter
					var filter = this.style('filter').getDefinition();
					if (filter != null) filter.apply(ctx, this);
				}
				else {
					this.setContext(ctx);
					this.renderChildren(ctx);
					this.clearContext(ctx);
				}
				ctx.restore();
			}

			// base set context
			this.setContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base clear context
			this.clearContext = function(ctx) {
				// OVERRIDE ME!
			}

			// base render children
			this.renderChildren = function(ctx) {
				for (var i=0; i<this.children.length; i++) {
					this.children[i].render(ctx);
				}
			}

			this.addChild = function(childNode, create) {
				var child = childNode;
				if (create) child = svg.CreateElement(childNode);
				child.parent = this;
				if (child.type != 'title') { this.children.push(child);	}
			}
			
			this.addStylesFromStyleDefinition = function () {
				// add styles
				for (var selector in svg.Styles) {
					if (selector[0] != '@' && matchesSelector(node, selector)) {
						var styles = svg.Styles[selector];
						var specificity = svg.StylesSpecificity[selector];
						if (styles != null) {
							for (var name in styles) {
								var existingSpecificity = this.stylesSpecificity[name];
								if (typeof(existingSpecificity) == 'undefined') {
									existingSpecificity = '000';
								}
								if (specificity > existingSpecificity) {
									this.styles[name] = styles[name];
									this.stylesSpecificity[name] = specificity;
								}
							}
						}
					}
				}
			};

			if (node != null && node.nodeType == 1) { //ELEMENT_NODE
				// add attributes
				for (var i=0; i<node.attributes.length; i++) {
					var attribute = node.attributes[i];
					this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.value);
				}
				
				this.addStylesFromStyleDefinition();

				// add inline styles
				if (this.attribute('style').hasValue()) {
					var styles = this.attribute('style').value.split(';');
					for (var i=0; i<styles.length; i++) {
						if (svg.trim(styles[i]) != '') {
							var style = styles[i].split(':');
							var name = svg.trim(style[0]);
							var value = svg.trim(style[1]);
							this.styles[name] = new svg.Property(name, value);
						}
					}
				}

				// add id
				if (this.attribute('id').hasValue()) {
					if (svg.Definitions[this.attribute('id').value] == null) {
						svg.Definitions[this.attribute('id').value] = this;
					}
				}

				// add children
				for (var i=0; i<node.childNodes.length; i++) {
					var childNode = node.childNodes[i];
					if (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE
					if (this.captureTextNodes && (childNode.nodeType == 3 || childNode.nodeType == 4)) {
						var text = childNode.value || childNode.text || childNode.textContent || '';
						if (svg.compressSpaces(text) != '') {
							this.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE
						}
					}
				}
			}
		}

		svg.Element.RenderedElementBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.setContext = function(ctx) {
				// fill
				if (this.style('fill').isUrlDefinition()) {
					var fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));
					if (fs != null) ctx.fillStyle = fs;
				}
				else if (this.style('fill').hasValue()) {
					var fillStyle = this.style('fill');
					if (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;
					if (fillStyle.value != 'inherit') ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);
				}
				if (this.style('fill-opacity').hasValue()) {
					var fillStyle = new svg.Property('fill', ctx.fillStyle);
					fillStyle = fillStyle.addOpacity(this.style('fill-opacity'));
					ctx.fillStyle = fillStyle.value;
				}

				// stroke
				if (this.style('stroke').isUrlDefinition()) {
					var fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));
					if (fs != null) ctx.strokeStyle = fs;
				}
				else if (this.style('stroke').hasValue()) {
					var strokeStyle = this.style('stroke');
					if (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;
					if (strokeStyle.value != 'inherit') ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);
				}
				if (this.style('stroke-opacity').hasValue()) {
					var strokeStyle = new svg.Property('stroke', ctx.strokeStyle);
					strokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity'));
					ctx.strokeStyle = strokeStyle.value;
				}
				if (this.style('stroke-width').hasValue()) {
					var newLineWidth = this.style('stroke-width').toPixels();
					ctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0
			    }
				if (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;
				if (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;
				if (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;
				if (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {
					var gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);
					if (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }
					else if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }
					else if (typeof(ctx.mozDash) != 'undefined' && !(gaps.length==1 && gaps[0]==0)) { ctx.mozDash = gaps; }

					var offset = this.style('stroke-dashoffset').numValueOrDefault(1);
					if (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }
					else if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }
					else if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }
				}

				// font
				if (typeof(ctx.font) != 'undefined') {
					ctx.font = svg.Font.CreateFont(
						this.style('font-style').value,
						this.style('font-variant').value,
						this.style('font-weight').value,
						this.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',
						this.style('font-family').value).toString();
				}

				// transform
				if (this.style('transform', false, true).hasValue()) {
					var transform = new svg.Transform(this.style('transform', false, true).value);
					transform.apply(ctx);
				}

				// clip
				if (this.attribute('clip-path', false, true).hasValue()) {
					var clip = this.attribute('clip-path', false, true).getDefinition();
					if (clip != null) clip.apply(ctx);
				}

				// opacity
				if (this.style('opacity').hasValue()) {
					ctx.globalAlpha = this.style('opacity').numValue();
				}
			}
		}
		svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;

		svg.Element.PathElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.path = function(ctx) {
				if (ctx != null) ctx.beginPath();
				return new svg.BoundingBox();
			}

			this.renderChildren = function(ctx) {
				this.path(ctx);
				svg.Mouse.checkPath(this, ctx);
				if (ctx.fillStyle != '') {
					if (this.style('fill-rule').valueOrDefault('inherit') != 'inherit') { ctx.fill(this.style('fill-rule').value); }
					else { ctx.fill(); }
				}
				if (ctx.strokeStyle != '') ctx.stroke();

				var markers = this.getMarkers();
				if (markers != null) {
					if (this.style('marker-start').isUrlDefinition()) {
						var marker = this.style('marker-start').getDefinition();
						marker.render(ctx, markers[0][0], markers[0][1]);
					}
					if (this.style('marker-mid').isUrlDefinition()) {
						var marker = this.style('marker-mid').getDefinition();
						for (var i=1;i<markers.length-1;i++) {
							marker.render(ctx, markers[i][0], markers[i][1]);
						}
					}
					if (this.style('marker-end').isUrlDefinition()) {
						var marker = this.style('marker-end').getDefinition();
						marker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);
					}
				}
			}

			this.getBoundingBox = function() {
				return this.path();
			}

			this.getMarkers = function() {
				return null;
			}
		}
		svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;

		// svg element
		svg.Element.svg = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseClearContext = this.clearContext;
			this.clearContext = function(ctx) {
				this.baseClearContext(ctx);
				svg.ViewPort.RemoveCurrent();
			}

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				// initial values and defaults
				ctx.strokeStyle = 'rgba(0,0,0,0)';
				ctx.lineCap = 'butt';
				ctx.lineJoin = 'miter';
				ctx.miterLimit = 4;
				if (typeof(ctx.font) != 'undefined' && typeof(window.getComputedStyle) != 'undefined') {
					ctx.font = window.getComputedStyle(ctx.canvas).getPropertyValue('font');
				}

				this.baseSetContext(ctx);

				// create new view port
				if (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;
				if (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;
				ctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));

				var width = svg.ViewPort.width();
				var height = svg.ViewPort.height();

				if (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';
				if (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';
				if (typeof(this.root) == 'undefined') {
					width = this.attribute('width').toPixels('x');
					height = this.attribute('height').toPixels('y');

					var x = 0;
					var y = 0;
					if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {
						x = -this.attribute('refX').toPixels('x');
						y = -this.attribute('refY').toPixels('y');
					}

					if (this.attribute('overflow').valueOrDefault('hidden') != 'visible') {
						ctx.beginPath();
						ctx.moveTo(x, y);
						ctx.lineTo(width, y);
						ctx.lineTo(width, height);
						ctx.lineTo(x, height);
						ctx.closePath();
						ctx.clip();
					}
				}
				svg.ViewPort.SetCurrent(width, height);

				// viewbox
				if (this.attribute('viewBox').hasValue()) {
					var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
					var minX = viewBox[0];
					var minY = viewBox[1];
					width = viewBox[2];
					height = viewBox[3];

					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									svg.ViewPort.width(),
									width,
									svg.ViewPort.height(),
									height,
									minX,
									minY,
									this.attribute('refX').value,
									this.attribute('refY').value);

					svg.ViewPort.RemoveCurrent();
					svg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);
				}
			}
		}
		svg.Element.svg.prototype = new svg.Element.RenderedElementBase;

		// rect element
		svg.Element.rect = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;
				if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;
				rx = Math.min(rx, width / 2.0);
				ry = Math.min(ry, height / 2.0);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(x + rx, y);
					ctx.lineTo(x + width - rx, y);
					ctx.quadraticCurveTo(x + width, y, x + width, y + ry)
					ctx.lineTo(x + width, y + height - ry);
					ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)
					ctx.lineTo(x + rx, y + height);
					ctx.quadraticCurveTo(x, y + height, x, y + height - ry)
					ctx.lineTo(x, y + ry);
					ctx.quadraticCurveTo(x, y, x + rx, y)
					ctx.closePath();
				}

				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.rect.prototype = new svg.Element.PathElementBase;

		// circle element
		svg.Element.circle = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');
				var r = this.attribute('r').toPixels();

				if (ctx != null) {
					ctx.beginPath();
					ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);
			}
		}
		svg.Element.circle.prototype = new svg.Element.PathElementBase;

		// ellipse element
		svg.Element.ellipse = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.path = function(ctx) {
				var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
				var rx = this.attribute('rx').toPixels('x');
				var ry = this.attribute('ry').toPixels('y');
				var cx = this.attribute('cx').toPixels('x');
				var cy = this.attribute('cy').toPixels('y');

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(cx, cy - ry);
					ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);
					ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
					ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
					ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
					ctx.closePath();
				}

				return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
			}
		}
		svg.Element.ellipse.prototype = new svg.Element.PathElementBase;

		// line element
		svg.Element.line = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.getPoints = function() {
				return [
					new svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),
					new svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];
			}

			this.path = function(ctx) {
				var points = this.getPoints();

				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(points[0].x, points[0].y);
					ctx.lineTo(points[1].x, points[1].y);
				}

				return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);
			}

			this.getMarkers = function() {
				var points = this.getPoints();
				var a = points[0].angleTo(points[1]);
				return [[points[0], a], [points[1], a]];
			}
		}
		svg.Element.line.prototype = new svg.Element.PathElementBase;

		// polyline element
		svg.Element.polyline = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			this.points = svg.CreatePath(this.attribute('points').value);
			this.path = function(ctx) {
				var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
				if (ctx != null) {
					ctx.beginPath();
					ctx.moveTo(this.points[0].x, this.points[0].y);
				}
				for (var i=1; i<this.points.length; i++) {
					bb.addPoint(this.points[i].x, this.points[i].y);
					if (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);
				}
				return bb;
			}

			this.getMarkers = function() {
				var markers = [];
				for (var i=0; i<this.points.length - 1; i++) {
					markers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);
				}
				markers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);
				return markers;
			}
		}
		svg.Element.polyline.prototype = new svg.Element.PathElementBase;

		// polygon element
		svg.Element.polygon = function(node) {
			this.base = svg.Element.polyline;
			this.base(node);

			this.basePath = this.path;
			this.path = function(ctx) {
				var bb = this.basePath(ctx);
				if (ctx != null) {
					ctx.lineTo(this.points[0].x, this.points[0].y);
					ctx.closePath();
				}
				return bb;
			}
		}
		svg.Element.polygon.prototype = new svg.Element.polyline;

		// path element
		svg.Element.path = function(node) {
			this.base = svg.Element.PathElementBase;
			this.base(node);

			var d = this.attribute('d').value;
			// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF
			d = d.replace(/,/gm,' '); // get rid of all commas
			// As the end of a match can also be the start of the next match, we need to run this replace twice.
			for(var i=0; i<2; i++)
				d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm,'$1 $2'); // suffix commands with spaces
			d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // prefix commands with spaces
			d = d.replace(/([0-9])([+\-])/gm,'$1 $2'); // separate digits on +- signs
			// Again, we need to run this twice to find all occurances
			for(var i=0; i<2; i++)
				d = d.replace(/(\.[0-9]*)(\.)/gm,'$1 $2'); // separate digits when they start with a comma
			d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax
			d = svg.compressSpaces(d); // compress multiple spaces
			d = svg.trim(d);
			this.PathParser = new (function(d) {
				this.tokens = d.split(' ');

				this.reset = function() {
					this.i = -1;
					this.command = '';
					this.previousCommand = '';
					this.start = new svg.Point(0, 0);
					this.control = new svg.Point(0, 0);
					this.current = new svg.Point(0, 0);
					this.points = [];
					this.angles = [];
				}

				this.isEnd = function() {
					return this.i >= this.tokens.length - 1;
				}

				this.isCommandOrEnd = function() {
					if (this.isEnd()) return true;
					return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;
				}

				this.isRelativeCommand = function() {
					switch(this.command)
					{
						case 'm':
						case 'l':
						case 'h':
						case 'v':
						case 'c':
						case 's':
						case 'q':
						case 't':
						case 'a':
						case 'z':
							return true;
							break;
					}
					return false;
				}

				this.getToken = function() {
					this.i++;
					return this.tokens[this.i];
				}

				this.getScalar = function() {
					return parseFloat(this.getToken());
				}

				this.nextCommand = function() {
					this.previousCommand = this.command;
					this.command = this.getToken();
				}

				this.getPoint = function() {
					var p = new svg.Point(this.getScalar(), this.getScalar());
					return this.makeAbsolute(p);
				}

				this.getAsControlPoint = function() {
					var p = this.getPoint();
					this.control = p;
					return p;
				}

				this.getAsCurrentPoint = function() {
					var p = this.getPoint();
					this.current = p;
					return p;
				}

				this.getReflectedControlPoint = function() {
					if (this.previousCommand.toLowerCase() != 'c' &&
					    this.previousCommand.toLowerCase() != 's' &&
						this.previousCommand.toLowerCase() != 'q' &&
						this.previousCommand.toLowerCase() != 't' ){
						return this.current;
					}

					// reflect point
					var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
					return p;
				}

				this.makeAbsolute = function(p) {
					if (this.isRelativeCommand()) {
						p.x += this.current.x;
						p.y += this.current.y;
					}
					return p;
				}

				this.addMarker = function(p, from, priorTo) {
					// if the last angle isn't filled in because we didn't have this point yet ...
					if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {
						this.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);
					}
					this.addMarkerAngle(p, from == null ? null : from.angleTo(p));
				}

				this.addMarkerAngle = function(p, a) {
					this.points.push(p);
					this.angles.push(a);
				}

				this.getMarkerPoints = function() { return this.points; }
				this.getMarkerAngles = function() {
					for (var i=0; i<this.angles.length; i++) {
						if (this.angles[i] == null) {
							for (var j=i+1; j<this.angles.length; j++) {
								if (this.angles[j] != null) {
									this.angles[i] = this.angles[j];
									break;
								}
							}
						}
					}
					return this.angles;
				}
			})(d);

			this.path = function(ctx) {
				var pp = this.PathParser;
				pp.reset();

				var bb = new svg.BoundingBox();
				if (ctx != null) ctx.beginPath();
				while (!pp.isEnd()) {
					pp.nextCommand();
					switch (pp.command) {
					case 'M':
					case 'm':
						var p = pp.getAsCurrentPoint();
						pp.addMarker(p);
						bb.addPoint(p.x, p.y);
						if (ctx != null) ctx.moveTo(p.x, p.y);
						pp.start = pp.current;
						while (!pp.isCommandOrEnd()) {
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, pp.start);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'L':
					case 'l':
						while (!pp.isCommandOrEnd()) {
							var c = pp.current;
							var p = pp.getAsCurrentPoint();
							pp.addMarker(p, c);
							bb.addPoint(p.x, p.y);
							if (ctx != null) ctx.lineTo(p.x, p.y);
						}
						break;
					case 'H':
					case 'h':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'V':
					case 'v':
						while (!pp.isCommandOrEnd()) {
							var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
							pp.addMarker(newP, pp.current);
							pp.current = newP;
							bb.addPoint(pp.current.x, pp.current.y);
							if (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);
						}
						break;
					case 'C':
					case 'c':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'S':
					case 's':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var p1 = pp.getReflectedControlPoint();
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, p1);
							bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'Q':
					case 'q':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getAsControlPoint();
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'T':
					case 't':
						while (!pp.isCommandOrEnd()) {
							var curr = pp.current;
							var cntrl = pp.getReflectedControlPoint();
							pp.control = cntrl;
							var cp = pp.getAsCurrentPoint();
							pp.addMarker(cp, cntrl, cntrl);
							bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
							if (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);
						}
						break;
					case 'A':
					case 'a':
						while (!pp.isCommandOrEnd()) {
						    var curr = pp.current;
							var rx = pp.getScalar();
							var ry = pp.getScalar();
							var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
							var largeArcFlag = pp.getScalar();
							var sweepFlag = pp.getScalar();
							var cp = pp.getAsCurrentPoint();

							// Conversion from endpoint to center parameterization
							// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
							// x1', y1'
							var currp = new svg.Point(
								Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,
								-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0
							);
							// adjust radii
							var l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);
							if (l > 1) {
								rx *= Math.sqrt(l);
								ry *= Math.sqrt(l);
							}
							// cx', cy'
							var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(
								((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /
								(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))
							);
							if (isNaN(s)) s = 0;
							var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
							// cx, cy
							var centp = new svg.Point(
								(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,
								(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y
							);
							// vector magnitude
							var m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }
							// ratio between two vectors
							var r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }
							// angle between two vectors
							var a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }
							// initial angle
							var a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);
							// angle delta
							var u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];
							var v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];
							var ad = a(u, v);
							if (r(u,v) <= -1) ad = Math.PI;
							if (r(u,v) >= 1) ad = 0;

							// for markers
							var dir = 1 - sweepFlag ? 1.0 : -1.0;
							var ah = a1 + dir * (ad / 2.0);
							var halfWay = new svg.Point(
								centp.x + rx * Math.cos(ah),
								centp.y + ry * Math.sin(ah)
							);
							pp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
							pp.addMarkerAngle(cp, ah - dir * Math.PI);

							bb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better
							if (ctx != null) {
								var r = rx > ry ? rx : ry;
								var sx = rx > ry ? 1 : rx / ry;
								var sy = rx > ry ? ry / rx : 1;

								ctx.translate(centp.x, centp.y);
								ctx.rotate(xAxisRotation);
								ctx.scale(sx, sy);
								ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
								ctx.scale(1/sx, 1/sy);
								ctx.rotate(-xAxisRotation);
								ctx.translate(-centp.x, -centp.y);
							}
						}
						break;
					case 'Z':
					case 'z':
						if (ctx != null) ctx.closePath();
						pp.current = pp.start;
					}
				}

				return bb;
			}

			this.getMarkers = function() {
				var points = this.PathParser.getMarkerPoints();
				var angles = this.PathParser.getMarkerAngles();

				var markers = [];
				for (var i=0; i<points.length; i++) {
					markers.push([points[i], angles[i]]);
				}
				return markers;
			}
		}
		svg.Element.path.prototype = new svg.Element.PathElementBase;

		// pattern element
		svg.Element.pattern = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.createPattern = function(ctx, element) {
				var width = this.attribute('width').toPixels('x', true);
				var height = this.attribute('height').toPixels('y', true);

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['width'] = new svg.Property('width', width + 'px');
				tempSvg.attributes['height'] = new svg.Property('height', height + 'px');
				tempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);
				tempSvg.children = this.children;

				var c = document.createElement('canvas');
				c.width = width;
				c.height = height;
				var cctx = c.getContext('2d');
				if (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {
					cctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));
				}
				// render 3x3 grid so when we transform there's no white space on edges
				for (var x=-1; x<=1; x++) {
					for (var y=-1; y<=1; y++) {
						cctx.save();
						tempSvg.attributes['x'] = new svg.Property('x', x * c.width);
						tempSvg.attributes['y'] = new svg.Property('y', y * c.height);
						tempSvg.render(cctx);
						cctx.restore();
					}
				}
				var pattern = ctx.createPattern(c, 'repeat');
				return pattern;
			}
		}
		svg.Element.pattern.prototype = new svg.Element.ElementBase;

		// marker element
		svg.Element.marker = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.baseRender = this.render;
			this.render = function(ctx, point, angle) {
				ctx.translate(point.x, point.y);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);
				ctx.save();

				// render me using a temporary svg element
				var tempSvg = new svg.Element.svg();
				tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
				tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
				tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
				tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
				tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
				tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
				tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
				tempSvg.children = this.children;
				tempSvg.render(ctx);

				ctx.restore();
				if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);
				if (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);
				ctx.translate(-point.x, -point.y);
			}
		}
		svg.Element.marker.prototype = new svg.Element.ElementBase;

		// definitions element
		svg.Element.defs = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NOOP
			}
		}
		svg.Element.defs.prototype = new svg.Element.ElementBase;

		// base for gradients
		svg.Element.GradientBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.stops = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'stop') this.stops.push(child);
			}

			this.getGradient = function() {
				// OVERRIDE ME!
			}
			
			this.gradientUnits = function () {
				return this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
			}
			
			this.attributesToInherit = ['gradientUnits'];
			
			this.inheritStopContainer = function (stopsContainer) {
				for (var i=0; i<this.attributesToInherit.length; i++) {
					var attributeToInherit = this.attributesToInherit[i];
					if (!this.attribute(attributeToInherit).hasValue() && stopsContainer.attribute(attributeToInherit).hasValue()) {
						this.attribute(attributeToInherit, true).value = stopsContainer.attribute(attributeToInherit).value;
					}
				}
			}

			this.createGradient = function(ctx, element, parentOpacityProp) {
				var stopsContainer = this;
				if (this.getHrefAttribute().hasValue()) {
					stopsContainer = this.getHrefAttribute().getDefinition();
					this.inheritStopContainer(stopsContainer);
				}

				var addParentOpacity = function (color) {
					if (parentOpacityProp.hasValue()) {
						var p = new svg.Property('color', color);
						return p.addOpacity(parentOpacityProp).value;
					}
					return color;
				};

				var g = this.getGradient(ctx, element);
				if (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);
				for (var i=0; i<stopsContainer.stops.length; i++) {
					g.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));
				}

				if (this.attribute('gradientTransform').hasValue()) {
					// render as transformed pattern on temporary canvas
					var rootView = svg.ViewPort.viewPorts[0];

					var rect = new svg.Element.rect();
					rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);
					rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
					rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);

					var group = new svg.Element.g();
					group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
					group.children = [ rect ];

					var tempSvg = new svg.Element.svg();
					tempSvg.attributes['x'] = new svg.Property('x', 0);
					tempSvg.attributes['y'] = new svg.Property('y', 0);
					tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
					tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
					tempSvg.children = [ group ];

					var c = document.createElement('canvas');
					c.width = rootView.width;
					c.height = rootView.height;
					c.className = "screenShotTempCanvas";
					var tempCtx = c.getContext('2d');
					tempCtx.fillStyle = g;
					tempSvg.render(tempCtx);
					return tempCtx.createPattern(c, 'no-repeat');
				}

				return g;
			}
		}
		svg.Element.GradientBase.prototype = new svg.Element.ElementBase;

		// linear gradient element
		svg.Element.linearGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('x1');
			this.attributesToInherit.push('y1');
			this.attributesToInherit.push('x2');
			this.attributesToInherit.push('y2');

			this.getGradient = function(ctx, element) {
				var bb = this.gradientUnits() == 'objectBoundingBox' ? element.getBoundingBox() : null;

				if (!this.attribute('x1').hasValue()
				 && !this.attribute('y1').hasValue()
				 && !this.attribute('x2').hasValue()
				 && !this.attribute('y2').hasValue()) {
					this.attribute('x1', true).value = 0;
					this.attribute('y1', true).value = 0;
					this.attribute('x2', true).value = 1;
					this.attribute('y2', true).value = 0;
				 }

				var x1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x1').numValue()
					: this.attribute('x1').toPixels('x'));
				var y1 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y1').numValue()
					: this.attribute('y1').toPixels('y'));
				var x2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('x2').numValue()
					: this.attribute('x2').toPixels('x'));
				var y2 = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('y2').numValue()
					: this.attribute('y2').toPixels('y'));

				if (x1 == x2 && y1 == y2) return null;
				return ctx.createLinearGradient(x1, y1, x2, y2);
			}
		}
		svg.Element.linearGradient.prototype = new svg.Element.GradientBase;

		// radial gradient element
		svg.Element.radialGradient = function(node) {
			this.base = svg.Element.GradientBase;
			this.base(node);
			
			this.attributesToInherit.push('cx');
			this.attributesToInherit.push('cy');
			this.attributesToInherit.push('r');
			this.attributesToInherit.push('fx');
			this.attributesToInherit.push('fy');

			this.getGradient = function(ctx, element) {
				var bb = element.getBoundingBox();

				if (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';
				if (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';
				if (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';

				var cx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('cx').numValue()
					: this.attribute('cx').toPixels('x'));
				var cy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('cy').numValue()
					: this.attribute('cy').toPixels('y'));

				var fx = cx;
				var fy = cy;
				if (this.attribute('fx').hasValue()) {
					fx = (this.gradientUnits() == 'objectBoundingBox'
					? bb.x() + bb.width() * this.attribute('fx').numValue()
					: this.attribute('fx').toPixels('x'));
				}
				if (this.attribute('fy').hasValue()) {
					fy = (this.gradientUnits() == 'objectBoundingBox'
					? bb.y() + bb.height() * this.attribute('fy').numValue()
					: this.attribute('fy').toPixels('y'));
				}

				var r = (this.gradientUnits() == 'objectBoundingBox'
					? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()
					: this.attribute('r').toPixels());

				return ctx.createRadialGradient(fx, fy, 0, cx, cy, r);
			}
		}
		svg.Element.radialGradient.prototype = new svg.Element.GradientBase;

		// gradient stop element
		svg.Element.stop = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.offset = this.attribute('offset').numValue();
			if (this.offset < 0) this.offset = 0;
			if (this.offset > 1) this.offset = 1;

			var stopColor = this.style('stop-color', true);
			if (stopColor.value === '') stopColor.value = '#000';
			if (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity'));
			this.color = stopColor.value;
		}
		svg.Element.stop.prototype = new svg.Element.ElementBase;

		// animation base element
		svg.Element.AnimateBase = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			svg.Animations.push(this);

			this.duration = 0.0;
			this.begin = this.attribute('begin').toMilliseconds();
			this.maxDuration = this.begin + this.attribute('dur').toMilliseconds();

			this.getProperty = function() {
				var attributeType = this.attribute('attributeType').value;
				var attributeName = this.attribute('attributeName').value;

				if (attributeType == 'CSS') {
					return this.parent.style(attributeName, true);
				}
				return this.parent.attribute(attributeName, true);
			};

			this.initialValue = null;
			this.initialUnits = '';
			this.removed = false;

			this.calcValue = function() {
				// OVERRIDE ME!
				return '';
			}

			this.update = function(delta) {
				// set initial value
				if (this.initialValue == null) {
					this.initialValue = this.getProperty().value;
					this.initialUnits = this.getProperty().getUnits();
				}

				// if we're past the end time
				if (this.duration > this.maxDuration) {
					// loop for indefinitely repeating animations
					if (this.attribute('repeatCount').value == 'indefinite'
					 || this.attribute('repeatDur').value == 'indefinite') {
						this.duration = 0.0
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'freeze' && !this.frozen) {
						this.frozen = true;
						this.parent.animationFrozen = true;
						this.parent.animationFrozenValue = this.getProperty().value;
					}
					else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {
						this.removed = true;
						this.getProperty().value = this.parent.animationFrozen ? this.parent.animationFrozenValue : this.initialValue;
						return true;
					}
					return false;
				}
				this.duration = this.duration + delta;

				// if we're past the begin time
				var updated = false;
				if (this.begin < this.duration) {
					var newValue = this.calcValue(); // tween

					if (this.attribute('type').hasValue()) {
						// for transform, etc.
						var type = this.attribute('type').value;
						newValue = type + '(' + newValue + ')';
					}

					this.getProperty().value = newValue;
					updated = true;
				}

				return updated;
			}

			this.from = this.attribute('from');
			this.to = this.attribute('to');
			this.values = this.attribute('values');
			if (this.values.hasValue()) this.values.value = this.values.value.split(';');

			// fraction of duration we've covered
			this.progress = function() {
				var ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };
				if (this.values.hasValue()) {
					var p = ret.progress * (this.values.value.length - 1);
					var lb = Math.floor(p), ub = Math.ceil(p);
					ret.from = new svg.Property('from', parseFloat(this.values.value[lb]));
					ret.to = new svg.Property('to', parseFloat(this.values.value[ub]));
					ret.progress = (p - lb) / (ub - lb);
				}
				else {
					ret.from = this.from;
					ret.to = this.to;
				}
				return ret;
			}
		}
		svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;

		// animate element
		svg.Element.animate = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;
				return newValue + this.initialUnits;
			};
		}
		svg.Element.animate.prototype = new svg.Element.AnimateBase;

		// animate color element
		svg.Element.animateColor = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();
				var from = new RGBColor(p.from.value);
				var to = new RGBColor(p.to.value);

				if (from.ok && to.ok) {
					// tween color linearly
					var r = from.r + (to.r - from.r) * p.progress;
					var g = from.g + (to.g - from.g) * p.progress;
					var b = from.b + (to.b - from.b) * p.progress;
					return 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';
				}
				return this.attribute('from').value;
			};
		}
		svg.Element.animateColor.prototype = new svg.Element.AnimateBase;

		// animate transform element
		svg.Element.animateTransform = function(node) {
			this.base = svg.Element.AnimateBase;
			this.base(node);

			this.calcValue = function() {
				var p = this.progress();

				// tween value linearly
				var from = svg.ToNumberArray(p.from.value);
				var to = svg.ToNumberArray(p.to.value);
				var newValue = '';
				for (var i=0; i<from.length; i++) {
					newValue += from[i] + (to[i] - from[i]) * p.progress + ' ';
				}
				return newValue;
			};
		}
		svg.Element.animateTransform.prototype = new svg.Element.animate;

		// font element
		svg.Element.font = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();

			this.isRTL = false;
			this.isArabic = false;
			this.fontFace = null;
			this.missingGlyph = null;
			this.glyphs = [];
			for (var i=0; i<this.children.length; i++) {
				var child = this.children[i];
				if (child.type == 'font-face') {
					this.fontFace = child;
					if (child.style('font-family').hasValue()) {
						svg.Definitions[child.style('font-family').value] = this;
					}
				}
				else if (child.type == 'missing-glyph') this.missingGlyph = child;
				else if (child.type == 'glyph') {
					if (child.arabicForm != '') {
						this.isRTL = true;
						this.isArabic = true;
						if (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];
						this.glyphs[child.unicode][child.arabicForm] = child;
					}
					else {
						this.glyphs[child.unicode] = child;
					}
				}
			}
		}
		svg.Element.font.prototype = new svg.Element.ElementBase;

		// font-face element
		svg.Element.fontface = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.ascent = this.attribute('ascent').value;
			this.descent = this.attribute('descent').value;
			this.unitsPerEm = this.attribute('units-per-em').numValue();
		}
		svg.Element.fontface.prototype = new svg.Element.ElementBase;

		// missing-glyph element
		svg.Element.missingglyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = 0;
		}
		svg.Element.missingglyph.prototype = new svg.Element.path;

		// glyph element
		svg.Element.glyph = function(node) {
			this.base = svg.Element.path;
			this.base(node);

			this.horizAdvX = this.attribute('horiz-adv-x').numValue();
			this.unicode = this.attribute('unicode').value;
			this.arabicForm = this.attribute('arabic-form').value;
		}
		svg.Element.glyph.prototype = new svg.Element.path;

		// text element
		svg.Element.text = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);

				var textBaseline = this.style('dominant-baseline').toTextBaseline();
				if (textBaseline == null) textBaseline = this.style('alignment-baseline').toTextBaseline();
				if (textBaseline != null) ctx.textBaseline = textBaseline;
			}

			this.getBoundingBox = function () {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
				return new svg.BoundingBox(x, y - fontSize, x + Math.floor(fontSize * 2.0 / 3.0) * this.children[0].getText().length, y);
			}

			this.renderChildren = function(ctx) {
				this.x = this.attribute('x').toPixels('x');
				this.y = this.attribute('y').toPixels('y');
				if (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');
				if (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');
				this.x += this.getAnchorDelta(ctx, this, 0);
				for (var i=0; i<this.children.length; i++) {
					this.renderChild(ctx, this, i);
				}
			}

			this.getAnchorDelta = function (ctx, parent, startI) {
				var textAnchor = this.style('text-anchor').valueOrDefault('start');
				if (textAnchor != 'start') {
					var width = 0;
					for (var i=startI; i<parent.children.length; i++) {
						var child = parent.children[i];
						if (i > startI && child.attribute('x').hasValue()) break; // new group
						width += child.measureTextRecursive(ctx);
					}
					return -1 * (textAnchor == 'end' ? width : width / 2.0);
				}
				return 0;
			}

			this.renderChild = function(ctx, parent, i) {
				var child = parent.children[i];
				if (child.attribute('x').hasValue()) {
					child.x = child.attribute('x').toPixels('x') + parent.getAnchorDelta(ctx, parent, i);
					if (child.attribute('dx').hasValue()) child.x += child.attribute('dx').toPixels('x');
				}
				else {
					if (child.attribute('dx').hasValue()) parent.x += child.attribute('dx').toPixels('x');
					child.x = parent.x;
				}
				parent.x = child.x + child.measureText(ctx);

				if (child.attribute('y').hasValue()) {
					child.y = child.attribute('y').toPixels('y');
					if (child.attribute('dy').hasValue()) child.y += child.attribute('dy').toPixels('y');
				}
				else {
					if (child.attribute('dy').hasValue()) parent.y += child.attribute('dy').toPixels('y');
					child.y = parent.y;
				}
				parent.y = child.y;

				child.render(ctx);

				for (var i=0; i<child.children.length; i++) {
					parent.renderChild(ctx, child, i);
				}
			}
		}
		svg.Element.text.prototype = new svg.Element.RenderedElementBase;

		// text base
		svg.Element.TextElementBase = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getGlyph = function(font, text, i) {
				var c = text[i];
				var glyph = null;
				if (font.isArabic) {
					var arabicForm = 'isolated';
					if ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';
					if (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';
					if (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';
					if (typeof(font.glyphs[c]) != 'undefined') {
						glyph = font.glyphs[c][arabicForm];
						if (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];
					}
				}
				else {
					glyph = font.glyphs[c];
				}
				if (glyph == null) glyph = font.missingGlyph;
				return glyph;
			}

			this.renderChildren = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");

					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						var scale = fontSize / customFont.fontFace.unitsPerEm;
						ctx.translate(this.x, this.y);
						ctx.scale(scale, -scale);
						var lw = ctx.lineWidth;
						ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
						if (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);
						glyph.render(ctx);
						if (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);
						ctx.lineWidth = lw;
						ctx.scale(1/scale, -1/scale);
						ctx.translate(-this.x, -this.y);

						this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							this.x += dx[i];
						}
					}
					return;
				}

				if (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);
				if (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
			}

			this.getText = function() {
				// OVERRIDE ME
			}

			this.measureTextRecursive = function(ctx) {
				var width = this.measureText(ctx);
				for (var i=0; i<this.children.length; i++) {
					width += this.children[i].measureTextRecursive(ctx);
				}
				return width;
			}

			this.measureText = function(ctx) {
				var customFont = this.parent.style('font-family').getDefinition();
				if (customFont != null) {
					var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
					var measure = 0;
					var text = this.getText();
					if (customFont.isRTL) text = text.split("").reverse().join("");
					var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
					for (var i=0; i<text.length; i++) {
						var glyph = this.getGlyph(customFont, text, i);
						measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
						if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {
							measure += dx[i];
						}
					}
					return measure;
				}

				var textToMeasure = svg.compressSpaces(this.getText());
				if (!ctx.measureText) return textToMeasure.length * 10;

				ctx.save();
				this.setContext(ctx);
				var width = ctx.measureText(textToMeasure).width;
				ctx.restore();
				return width;
			}
		}
		svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;

		// tspan
		svg.Element.tspan = function(node) {
			this.captureTextNodes = true;
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.text = svg.compressSpaces(node.value || node.text || node.textContent || '');
			this.getText = function() {
				// if this node has children, then they own the text
				if (this.children.length > 0) { return ''; }
				return this.text;
			}
		}
		svg.Element.tspan.prototype = new svg.Element.TextElementBase;

		// tref
		svg.Element.tref = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.getText = function() {
				var element = this.getHrefAttribute().getDefinition();
				if (element != null) return element.children[0].getText();
			}
		}
		svg.Element.tref.prototype = new svg.Element.TextElementBase;

		// a element
		svg.Element.a = function(node) {
			this.base = svg.Element.TextElementBase;
			this.base(node);

			this.hasText = node.childNodes.length > 0;
			for (var i=0; i<node.childNodes.length; i++) {
				if (node.childNodes[i].nodeType != 3) this.hasText = false;
			}

			// this might contain text
			this.text = this.hasText ? node.childNodes[0].value : '';
			this.getText = function() {
				return this.text;
			}

			this.baseRenderChildren = this.renderChildren;
			this.renderChildren = function(ctx) {
				if (this.hasText) {
					// render as text element
					this.baseRenderChildren(ctx);
					var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
					svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));
				}
				else if (this.children.length > 0) {
					// render as temporary group
					var g = new svg.Element.g();
					g.children = this.children;
					g.parent = this;
					g.render(ctx);
				}
			}

			this.onclick = function() {
				window.open(this.getHrefAttribute().value);
			}

			this.onmousemove = function() {
				svg.ctx.canvas.style.cursor = 'pointer';
			}
		}
		svg.Element.a.prototype = new svg.Element.TextElementBase;

		// image element
		svg.Element.image = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			var href = this.getHrefAttribute().value;
			if (href == '') { return; }
			var isSvg = href.match(/\.svg$/)

			svg.Images.push(this);
			this.loaded = false;
			if (!isSvg) {
				this.img = document.createElement('img');
				if (svg.opts['useCORS'] == true) { this.img.crossOrigin = 'Anonymous'; }
				var self = this;
				this.img.onload = function() { self.loaded = true; }
				this.img.onerror = function() { svg.log('ERROR: image "' + href + '" not found'); self.loaded = true; }
				this.img.src = href;
			}
			else {
				this.img = svg.ajax(href);
				this.loaded = true;
			}

			this.renderChildren = function(ctx) {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');

				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				if (width == 0 || height == 0) return;

				ctx.save();
				if (isSvg) {
					ctx.drawSvg(this.img, x, y, width, height);
				}
				else {
					ctx.translate(x, y);
					svg.AspectRatio(ctx,
									this.attribute('preserveAspectRatio').value,
									width,
									this.img.width,
									height,
									this.img.height,
									0,
									0);
					ctx.drawImage(this.img, 0, 0);
				}
				ctx.restore();
			}

			this.getBoundingBox = function() {
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');
				return new svg.BoundingBox(x, y, x + width, y + height);
			}
		}
		svg.Element.image.prototype = new svg.Element.RenderedElementBase;

		// group element
		svg.Element.g = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.getBoundingBox = function() {
				var bb = new svg.BoundingBox();
				for (var i=0; i<this.children.length; i++) {
					bb.addBoundingBox(this.children[i].getBoundingBox());
				}
				return bb;
			};
		}
		svg.Element.g.prototype = new svg.Element.RenderedElementBase;

		// symbol element
		svg.Element.symbol = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.render = function(ctx) {
				// NO RENDER
			};
		}
		svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;

		// style element
		svg.Element.style = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			// text, or spaces then CDATA
			var css = ''
			for (var i=0; i<node.childNodes.length; i++) {
			  css += node.childNodes[i].data;
			}
			css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, ''); // remove comments
			css = svg.compressSpaces(css); // replace whitespace
			var cssDefs = css.split('}');
			for (var i=0; i<cssDefs.length; i++) {
				if (svg.trim(cssDefs[i]) != '') {
					var cssDef = cssDefs[i].split('{');
					var cssClasses = cssDef[0].split(',');
					var cssProps = cssDef[1].split(';');
					for (var j=0; j<cssClasses.length; j++) {
						var cssClass = svg.trim(cssClasses[j]);
						if (cssClass != '') {
							var props = {};
							for (var k=0; k<cssProps.length; k++) {
								var prop = cssProps[k].indexOf(':');
								var name = cssProps[k].substr(0, prop);
								var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
								if (name != null && value != null) {
									props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));
								}
							}
							svg.Styles[cssClass] = props;
							svg.StylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
							if (cssClass == '@font-face') {
								var fontFamily = props['font-family'].value.replace(/"/g,'');
								var srcs = props['src'].value.split(',');
								for (var s=0; s<srcs.length; s++) {
									if (srcs[s].indexOf('format("svg")') > 0) {
										var urlStart = srcs[s].indexOf('url');
										var urlEnd = srcs[s].indexOf(')', urlStart);
										var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
										var doc = svg.parseXml(svg.ajax(url));
										var fonts = doc.getElementsByTagName('font');
										for (var f=0; f<fonts.length; f++) {
											var font = svg.CreateElement(fonts[f]);
											svg.Definitions[fontFamily] = font;
										}
									}
								}
							}
						}
					}
				}
			}
		}
		svg.Element.style.prototype = new svg.Element.ElementBase;

		// use element
		svg.Element.use = function(node) {
			this.base = svg.Element.RenderedElementBase;
			this.base(node);

			this.baseSetContext = this.setContext;
			this.setContext = function(ctx) {
				this.baseSetContext(ctx);
				if (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);
				if (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));
			}

			var element = this.getHrefAttribute().getDefinition();

			this.path = function(ctx) {
				if (element != null) element.path(ctx);
			}

			this.getBoundingBox = function() {
				if (element != null) return element.getBoundingBox();
			}

			this.renderChildren = function(ctx) {
				if (element != null) {
					var tempSvg = element;
					if (element.type == 'symbol') {
						// render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)
						tempSvg = new svg.Element.svg();
						tempSvg.type = 'svg';
						tempSvg.attributes['viewBox'] = new svg.Property('viewBox', element.attribute('viewBox').value);
						tempSvg.attributes['preserveAspectRatio'] = new svg.Property('preserveAspectRatio', element.attribute('preserveAspectRatio').value);
						tempSvg.attributes['overflow'] = new svg.Property('overflow', element.attribute('overflow').value);
						tempSvg.children = element.children;
					}
					if (tempSvg.type == 'svg') {
						// if symbol or svg, inherit width/height from me
						if (this.attribute('width').hasValue()) tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
						if (this.attribute('height').hasValue()) tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
					}
					var oldParent = tempSvg.parent;
					tempSvg.parent = null;
					tempSvg.render(ctx);
					tempSvg.parent = oldParent;
				}
			}
		}
		svg.Element.use.prototype = new svg.Element.RenderedElementBase;

		// mask element
		svg.Element.mask = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var x = this.attribute('x').toPixels('x');
				var y = this.attribute('y').toPixels('y');
				var width = this.attribute('width').toPixels('x');
				var height = this.attribute('height').toPixels('y');

				if (width == 0 && height == 0) {
					var bb = new svg.BoundingBox();
					for (var i=0; i<this.children.length; i++) {
						bb.addBoundingBox(this.children[i].getBoundingBox());
					}
					var x = Math.floor(bb.x1);
					var y = Math.floor(bb.y1);
					var width = Math.floor(bb.width());
					var	height = Math.floor(bb.height());
				}

				// temporarily remove mask to avoid recursion
				var mask = element.attribute('mask').value;
				element.attribute('mask').value = '';

					var cMask = document.createElement('canvas');
					cMask.width = x + width;
					cMask.height = y + height;
					var maskCtx = cMask.getContext('2d');
					this.renderChildren(maskCtx);

					var c = document.createElement('canvas');
					c.width = x + width;
					c.height = y + height;
					var tempCtx = c.getContext('2d');
					element.render(tempCtx);
					tempCtx.globalCompositeOperation = 'destination-in';
					tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
					tempCtx.fillRect(0, 0, x + width, y + height);

					ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
					ctx.fillRect(0, 0, x + width, y + height);

				// reassign mask
				element.attribute('mask').value = mask;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.mask.prototype = new svg.Element.ElementBase;

		// clip element
		svg.Element.clipPath = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx) {
				var oldBeginPath = CanvasRenderingContext2D.prototype.beginPath;
				CanvasRenderingContext2D.prototype.beginPath = function () { };

				var oldClosePath = CanvasRenderingContext2D.prototype.closePath;
				CanvasRenderingContext2D.prototype.closePath = function () { };

				oldBeginPath.call(ctx);
				for (var i=0; i<this.children.length; i++) {
					var child = this.children[i];
					if (typeof(child.path) != 'undefined') {
						var transform = null;
						if (child.style('transform', false, true).hasValue()) {
							transform = new svg.Transform(child.style('transform', false, true).value);
							transform.apply(ctx);
						}
						child.path(ctx);
						CanvasRenderingContext2D.prototype.closePath = oldClosePath;
						if (transform) { transform.unapply(ctx); }
					}
				}
				oldClosePath.call(ctx);
				ctx.clip();

				CanvasRenderingContext2D.prototype.beginPath = oldBeginPath;
				CanvasRenderingContext2D.prototype.closePath = oldClosePath;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.clipPath.prototype = new svg.Element.ElementBase;

		// filters
		svg.Element.filter = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, element) {
				// render as temp svg
				var bb = element.getBoundingBox();
				var x = Math.floor(bb.x1);
				var y = Math.floor(bb.y1);
				var width = Math.floor(bb.width());
				var	height = Math.floor(bb.height());

				// temporarily remove filter to avoid recursion
				var filter = element.style('filter').value;
				element.style('filter').value = '';

				var px = 0, py = 0;
				for (var i=0; i<this.children.length; i++) {
					var efd = this.children[i].extraFilterDistance || 0;
					px = Math.max(px, efd);
					py = Math.max(py, efd);
				}

				var c = document.createElement('canvas');
				c.width = width + 2*1;
				c.height = height + 2*1;
				var tempCtx = c.getContext('2d');
				tempCtx.translate(-x + 1, -y + 1);
				element.render(tempCtx);

				// apply filters
				for (var i=0; i<this.children.length; i++) {
					if (typeof(this.children[i].apply) === 'function') {
						this.children[i].apply(tempCtx, 0, 0, width + 2*1, height + 2*1);
					}
				}

				// render on me
				//c.width = width+ 2*1;
				//c.height = height+ 2*1;
				ctx.drawImage(c, 0, 0, width+ 2*1, height+ 2*1, Math.abs(x -1), Math.abs(y-1), width+ 2*1, height+ 2*1);

				// reassign filter
				element.style('filter', true).value = filter;
			}

			this.render = function(ctx) {
				// NO RENDER
			}
		}
		svg.Element.filter.prototype = new svg.Element.ElementBase;

		svg.Element.feMorphology = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feMorphology.prototype = new svg.Element.ElementBase;

		svg.Element.feComposite = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.apply = function(ctx, x, y, width, height) {
				// TODO: implement
			}
		}
		svg.Element.feComposite.prototype = new svg.Element.ElementBase;

		svg.Element.feColorMatrix = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			var matrix = svg.ToNumberArray(this.attribute('values').value);
			switch (this.attribute('type').valueOrDefault('matrix')) { // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
				case 'saturate':
					var s = matrix[0];
					matrix = [0.213+0.787*s,0.715-0.715*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715+0.285*s,0.072-0.072*s,0,0,
							  0.213-0.213*s,0.715-0.715*s,0.072+0.928*s,0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'hueRotate':
					var a = matrix[0] * Math.PI / 180.0;
					var c = function (m1,m2,m3) { return m1 + Math.cos(a)*m2 + Math.sin(a)*m3; };
					matrix = [c(0.213,0.787,-0.213),c(0.715,-0.715,-0.715),c(0.072,-0.072,0.928),0,0,
							  c(0.213,-0.213,0.143),c(0.715,0.285,0.140),c(0.072,-0.072,-0.283),0,0,
							  c(0.213,-0.213,-0.787),c(0.715,-0.715,0.715),c(0.072,0.928,0.072),0,0,
							  0,0,0,1,0,
							  0,0,0,0,1];
					break;
				case 'luminanceToAlpha':
					matrix = [0,0,0,0,0,
							  0,0,0,0,0,
							  0,0,0,0,0,
							  0.2125,0.7154,0.0721,0,0,
							  0,0,0,0,1];
					break;
			}

			function imGet(img, x, y, width, height, rgba) {
				return img[y*width*4 + x*4 + rgba];
			}

			function imSet(img, x, y, width, height, rgba, val) {
				img[y*width*4 + x*4 + rgba] = val;
			}

			function m(i, v) {
				var mi = matrix[i];
				return mi * (mi < 0 ? v - 255 : v);
			}

			this.apply = function(ctx, x, y, width, height) {
				// assuming x==0 && y==0 for now
				var srcData = ctx.getImageData(0, 0, width, height);
				for (var y = 0; y < height; y++) {
					for (var x = 0; x < width; x++) {
						var r = imGet(srcData.data, x, y, width, height, 0);
						var g = imGet(srcData.data, x, y, width, height, 1);
						var b = imGet(srcData.data, x, y, width, height, 2);
						var a = imGet(srcData.data, x, y, width, height, 3);
						imSet(srcData.data, x, y, width, height, 0, m(0,r)+m(1,g)+m(2,b)+m(3,a)+m(4,1));
						imSet(srcData.data, x, y, width, height, 1, m(5,r)+m(6,g)+m(7,b)+m(8,a)+m(9,1));
						imSet(srcData.data, x, y, width, height, 2, m(10,r)+m(11,g)+m(12,b)+m(13,a)+m(14,1));
						imSet(srcData.data, x, y, width, height, 3, m(15,r)+m(16,g)+m(17,b)+m(18,a)+m(19,1));
					}
				}
				ctx.clearRect(0, 0, width, height);
				ctx.putImageData(srcData, 0, 0);
			}
		}
		svg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;

		svg.Element.feGaussianBlur = function(node) {
			this.base = svg.Element.ElementBase;
			this.base(node);

			this.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());
			this.extraFilterDistance = this.blurRadius;

			this.apply = function(ctx, x, y, width, height) {
				if (typeof(stackBlurCanvasRGBA) == 'undefined') {
					svg.log('ERROR: StackBlur.js must be included for blur to work');
					return;
				}

				// StackBlur requires canvas be on document
				ctx.canvas.id = svg.UniqueId();
				ctx.canvas.style.display = 'none';
				document.body.appendChild(ctx.canvas);
				stackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);
				document.body.removeChild(ctx.canvas);
			}
		}
		svg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;

		// title element, do nothing
		svg.Element.title = function(node) {
		}
		svg.Element.title.prototype = new svg.Element.ElementBase;

		// desc element, do nothing
		svg.Element.desc = function(node) {
		}
		svg.Element.desc.prototype = new svg.Element.ElementBase;

		svg.Element.MISSING = function(node) {
			svg.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.');
		}
		svg.Element.MISSING.prototype = new svg.Element.ElementBase;

		// element factory
		svg.CreateElement = function(node) {
			var className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace
			className = className.replace(/\-/g,''); // remove dashes
			var e = null;
			if (typeof(svg.Element[className]) != 'undefined') {
				e = new svg.Element[className](node);
			}
			else {
				e = new svg.Element.MISSING(node);
			}

			e.type = node.nodeName;
			return e;
		}

		// load from url
		svg.load = function(ctx, url) {
			svg.loadXml(ctx, svg.ajax(url));
		}

		// load from xml
		svg.loadXml = function(ctx, xml) {
			svg.loadXmlDoc(ctx, svg.parseXml(xml));
		}

		svg.loadXmlDoc = function(ctx, dom) {
			svg.init(ctx);

			var mapXY = function(p) {
				var e = ctx.canvas;
				while (e) {
					p.x -= e.offsetLeft;
					p.y -= e.offsetTop;
					e = e.offsetParent;
				}
				if (window.scrollX) p.x += window.scrollX;
				if (window.scrollY) p.y += window.scrollY;
				return p;
			}

			// bind mouse
			if (svg.opts['ignoreMouse'] != true) {
				ctx.context.canvas.onclick = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onclick(p.x, p.y);
				};
				ctx.context.canvas.onmousemove = function(e) {
					var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
					svg.Mouse.onmousemove(p.x, p.y);
				};
			}

			var e = svg.CreateElement(dom.documentElement);
			e.root = true;
			e.addStylesFromStyleDefinition();

			// render loop
			var isFirstRender = true;
			var draw = function() {
				svg.ViewPort.Clear();
				if (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);

				if (svg.opts['ignoreDimensions'] != true) {
					// set canvas size
					if (e.style('width').hasValue() && e.style('width').value.indexOf('%') < 0) {
						ctx.canvas.width = e.style('width').toPixels('x');
						ctx.canvas.style.width = ctx.canvas.width + 'px';
					}
					if (e.style('height').hasValue() && e.style('height').value.indexOf('%') < 0) {
						ctx.canvas.height = e.style('height').toPixels('y');
						ctx.canvas.style.height = ctx.canvas.height + 'px';
					}
				}
				var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
				var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
				if (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {
					cWidth = e.style('width').toPixels('x');
					cHeight = e.style('height').toPixels('y');
				}
				svg.ViewPort.SetCurrent(cWidth, cHeight);

				if (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];
				if (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];
				if (svg.opts['scaleWidth'] != null || svg.opts['scaleHeight'] != null) {
					var xRatio = null, yRatio = null, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);

					if (svg.opts['scaleWidth'] != null) {
						if (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];
						else if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];
					}

					if (svg.opts['scaleHeight'] != null) {
						if (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];
						else if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];
					}

					if (xRatio == null) { xRatio = yRatio; }
					if (yRatio == null) { yRatio = xRatio; }

					e.attribute('width', true).value = svg.opts['scaleWidth'];
					e.attribute('height', true).value = svg.opts['scaleHeight'];
					e.style('transform', true, true).value += ' scale('+(1.0/xRatio)+','+(1.0/yRatio)+')';
				}

				// clear and render
				if (svg.opts['ignoreClear'] != true) {
					ctx.clearRect(0, 0, cWidth, cHeight);
				}
				e.render(ctx);
				if (isFirstRender) {
					isFirstRender = false;
					if (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);
				}
			}

			var waitingForImages = true;
			if (svg.ImagesLoaded()) {
				waitingForImages = false;
				draw();
			}
			svg.intervalID = setInterval(function() {
				var needUpdate = false;

				if (waitingForImages && svg.ImagesLoaded()) {
					waitingForImages = false;
					needUpdate = true;
				}

				// need update from mouse events?
				if (svg.opts['ignoreMouse'] != true) {
					needUpdate = needUpdate | svg.Mouse.hasEvents();
				}

				// need update from animations?
				if (svg.opts['ignoreAnimation'] != true) {
					for (var i=0; i<svg.Animations.length; i++) {
						needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);
					}
				}

				// need update from redraw?
				if (typeof(svg.opts['forceRedraw']) == 'function') {
					if (svg.opts['forceRedraw']() == true) needUpdate = true;
				}

				// render if needed
				if (needUpdate) {
					draw();
					svg.Mouse.runEvents(); // run and clear our events
				}
			}, 1000 / svg.FRAMERATE);
		}

		svg.stop = function() {
			if (svg.intervalID) {
				clearInterval(svg.intervalID);
			}
		}

		svg.Mouse = new (function() {
			this.events = [];
			this.hasEvents = function() { return this.events.length != 0; }

			this.onclick = function(x, y) {
				this.events.push({ type: 'onclick', x: x, y: y,
					run: function(e) { if (e.onclick) e.onclick(); }
				});
			}

			this.onmousemove = function(x, y) {
				this.events.push({ type: 'onmousemove', x: x, y: y,
					run: function(e) { if (e.onmousemove) e.onmousemove(); }
				});
			}

			this.eventElements = [];

			this.checkPath = function(element, ctx) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.checkBoundingBox = function(element, bb) {
				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					if (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;
				}
			}

			this.runEvents = function() {
				svg.ctx.canvas.style.cursor = '';

				for (var i=0; i<this.events.length; i++) {
					var e = this.events[i];
					var element = this.eventElements[i];
					while (element) {
						e.run(element);
						element = element.parent;
					}
				}

				// done running, clear
				this.events = [];
				this.eventElements = [];
			}
		});

		return svg;
	}
})();

if (typeof(CanvasRenderingContext2D) != 'undefined') {
	CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {
		canvg(this.canvas, s, {
			ignoreMouse: true,
			ignoreAnimation: true,
			ignoreDimensions: true,
			ignoreClear: true,
			offsetX: dx,
			offsetY: dy,
			scaleWidth: dw,
			scaleHeight: dh
		});
	}
}
//------------------------------- End of canvg.js library -------------------------------
//# sourceURL=ExportPlugin.js
//------------------------------- Start of Raphael.js library -------------------------------
//â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”� \\
//â”‚ RaphaÃ«l 2.1.2 - JavaScript Vector Library                          â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ Copyright Â© 2008-2012 Dmitry Baranovskiy (http://raphaeljs.com)    â”‚ \\
//â”‚ Copyright Â© 2008-2012 Sencha Labs (http://sencha.com)              â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ Licensed under the MIT (http://raphaeljs.com/license.html) license.â”‚ \\
//â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ \\
//Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.
//
//Licensed under the Apache License, Version 2.0 (the "License");
//you may not use this file except in compliance with the License.
//You may obtain a copy of the License at
//
//http://www.apache.org/licenses/LICENSE-2.0
//
//Unless required by applicable law or agreed to in writing, software
//distributed under the License is distributed on an "AS IS" BASIS,
//WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//See the License for the specific language governing permissions and
//limitations under the License.
//â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”� \\
//â”‚ Eve 0.4.2 - JavaScript Events Library                      â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ Author Dmitry Baranovskiy (http://dmitry.baranovskiy.com/) â”‚ \\
//â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ \\

(function (glob) {
 var version = "0.4.2",
     has = "hasOwnProperty",
     separator = /[\.\/]/,
     wildcard = "*",
     fun = function () {},
     numsort = function (a, b) {
         return a - b;
     },
     current_event,
     stop,
     events = {n: {}},
 /*\
  * eve
  [ method ]

  * Fires event with given `name`, given scope and other parameters.

  > Arguments

  - name (string) name of the *event*, dot (`.`) or slash (`/`) separated
  - scope (object) context for the event handlers
  - varargs (...) the rest of arguments will be sent to event handlers

  = (object) array of returned values from the listeners
 \*/
     eve = function (name, scope) {
			name = String(name);
         var e = events,
             oldstop = stop,
             args = Array.prototype.slice.call(arguments, 2),
             listeners = eve.listeners(name),
             z = 0,
             f = false,
             l,
             indexed = [],
             queue = {},
             out = [],
             ce = current_event,
             errors = [];
         current_event = name;
         stop = 0;
         for (var i = 0, ii = listeners.length; i < ii; i++) if ("zIndex" in listeners[i]) {
             indexed.push(listeners[i].zIndex);
             if (listeners[i].zIndex < 0) {
                 queue[listeners[i].zIndex] = listeners[i];
             }
         }
         indexed.sort(numsort);
         while (indexed[z] < 0) {
             l = queue[indexed[z++]];
             out.push(l.apply(scope, args));
             if (stop) {
                 stop = oldstop;
                 return out;
             }
         }
         for (i = 0; i < ii; i++) {
             l = listeners[i];
             if ("zIndex" in l) {
                 if (l.zIndex == indexed[z]) {
                     out.push(l.apply(scope, args));
                     if (stop) {
                         break;
                     }
                     do {
                         z++;
                         l = queue[indexed[z]];
                         l && out.push(l.apply(scope, args));
                         if (stop) {
                             break;
                         }
                     } while (l)
                 } else {
                     queue[l.zIndex] = l;
                 }
             } else {
                 out.push(l.apply(scope, args));
                 if (stop) {
                     break;
                 }
             }
         }
         stop = oldstop;
         current_event = ce;
         return out.length ? out : null;
     };
		// Undocumented. Debug only.
		eve._events = events;
 /*\
  * eve.listeners
  [ method ]

  * Internal method which gives you array of all event handlers that will be triggered by the given `name`.

  > Arguments

  - name (string) name of the event, dot (`.`) or slash (`/`) separated

  = (array) array of event handlers
 \*/
 eve.listeners = function (name) {
     var names = name.split(separator),
         e = events,
         item,
         items,
         k,
         i,
         ii,
         j,
         jj,
         nes,
         es = [e],
         out = [];
     for (i = 0, ii = names.length; i < ii; i++) {
         nes = [];
         for (j = 0, jj = es.length; j < jj; j++) {
             e = es[j].n;
             items = [e[names[i]], e[wildcard]];
             k = 2;
             while (k--) {
                 item = items[k];
                 if (item) {
                     nes.push(item);
                     out = out.concat(item.f || []);
                 }
             }
         }
         es = nes;
     }
     return out;
 };
 
 /*\
  * eve.on
  [ method ]
  **
  * Binds given event handler with a given name. You can use wildcards â€œ`*`â€� for the names:
  | eve.on("*.under.*", f);
  | eve("mouse.under.floor"); // triggers f
  * Use @eve to trigger the listener.
  **
  > Arguments
  **
  - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
  - f (function) event handler function
  **
  = (function) returned function accepts a single numeric parameter that represents z-index of the handler. It is an optional feature and only used when you need to ensure that some subset of handlers will be invoked in a given order, despite of the order of assignment. 
  > Example:
  | eve.on("mouse", eatIt)(2);
  | eve.on("mouse", scream);
  | eve.on("mouse", catchIt)(1);
  * This will ensure that `catchIt()` function will be called before `eatIt()`.
	 *
  * If you want to put your handler before non-indexed handlers, specify a negative value.
  * Note: I assume most of the time you donâ€™t need to worry about z-index, but itâ€™s nice to have this feature â€œjust in caseâ€�.
 \*/
 eve.on = function (name, f) {
		name = String(name);
		if (typeof f != "function") {
			return function () {};
		}
     var names = name.split(separator),
         e = events;
     for (var i = 0, ii = names.length; i < ii; i++) {
         e = e.n;
         e = e.hasOwnProperty(names[i]) && e[names[i]] || (e[names[i]] = {n: {}});
     }
     e.f = e.f || [];
     for (i = 0, ii = e.f.length; i < ii; i++) if (e.f[i] == f) {
         return fun;
     }
     e.f.push(f);
     return function (zIndex) {
         if (+zIndex == +zIndex) {
             f.zIndex = +zIndex;
         }
     };
 };
 /*\
  * eve.f
  [ method ]
  **
  * Returns function that will fire given event with optional arguments.
	 * Arguments that will be passed to the result function will be also
	 * concated to the list of final arguments.
	 | el.onclick = eve.f("click", 1, 2);
	 | eve.on("click", function (a, b, c) {
	 |     console.log(a, b, c); // 1, 2, [event object]
	 | });
  > Arguments
	 - event (string) event name
	 - varargs (â€¦) and any other arguments
	 = (function) possible event handler function
 \*/
	eve.f = function (event) {
		var attrs = [].slice.call(arguments, 1);
		return function () {
			eve.apply(null, [event, null].concat(attrs).concat([].slice.call(arguments, 0)));
		};
	};
 /*\
  * eve.stop
  [ method ]
  **
  * Is used inside an event handler to stop the event, preventing any subsequent listeners from firing.
 \*/
 eve.stop = function () {
     stop = 1;
 };
 /*\
  * eve.nt
  [ method ]
  **
  * Could be used inside event handler to figure out actual name of the event.
  **
  > Arguments
  **
  - subname (string) #optional subname of the event
  **
  = (string) name of the event, if `subname` is not specified
  * or
  = (boolean) `true`, if current eventâ€™s name contains `subname`
 \*/
 eve.nt = function (subname) {
     if (subname) {
         return new RegExp("(?:\\.|\\/|^)" + subname + "(?:\\.|\\/|$)").test(current_event);
     }
     return current_event;
 };
 /*\
  * eve.nts
  [ method ]
  **
  * Could be used inside event handler to figure out actual name of the event.
  **
  **
  = (array) names of the event
 \*/
 eve.nts = function () {
     return current_event.split(separator);
 };
 /*\
  * eve.off
  [ method ]
  **
  * Removes given function from the list of event listeners assigned to given name.
	 * If no arguments specified all the events will be cleared.
  **
  > Arguments
  **
  - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
  - f (function) event handler function
 \*/
 /*\
  * eve.unbind
  [ method ]
  **
  * See @eve.off
 \*/
 eve.off = eve.unbind = function (name, f) {
		if (!name) {
		    eve._events = events = {n: {}};
			return;
		}
     var names = name.split(separator),
         e,
         key,
         splice,
         i, ii, j, jj,
         cur = [events];
     for (i = 0, ii = names.length; i < ii; i++) {
         for (j = 0; j < cur.length; j += splice.length - 2) {
             splice = [j, 1];
             e = cur[j].n;
             if (names[i] != wildcard) {
                 if (e[names[i]]) {
                     splice.push(e[names[i]]);
                 }
             } else {
                 for (key in e) if (e[has](key)) {
                     splice.push(e[key]);
                 }
             }
             cur.splice.apply(cur, splice);
         }
     }
     for (i = 0, ii = cur.length; i < ii; i++) {
         e = cur[i];
         while (e.n) {
             if (f) {
                 if (e.f) {
                     for (j = 0, jj = e.f.length; j < jj; j++) if (e.f[j] == f) {
                         e.f.splice(j, 1);
                         break;
                     }
                     !e.f.length && delete e.f;
                 }
                 for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                     var funcs = e.n[key].f;
                     for (j = 0, jj = funcs.length; j < jj; j++) if (funcs[j] == f) {
                         funcs.splice(j, 1);
                         break;
                     }
                     !funcs.length && delete e.n[key].f;
                 }
             } else {
                 delete e.f;
                 for (key in e.n) if (e.n[has](key) && e.n[key].f) {
                     delete e.n[key].f;
                 }
             }
             e = e.n;
         }
     }
 };
 /*\
  * eve.once
  [ method ]
  **
  * Binds given event handler with a given name to only run once then unbind itself.
  | eve.once("login", f);
  | eve("login"); // triggers f
  | eve("login"); // no listeners
  * Use @eve to trigger the listener.
  **
  > Arguments
  **
  - name (string) name of the event, dot (`.`) or slash (`/`) separated, with optional wildcards
  - f (function) event handler function
  **
  = (function) same return function as @eve.on
 \*/
 eve.once = function (name, f) {
     var f2 = function () {
         eve.unbind(name, f2);
         return f.apply(this, arguments);
     };
     return eve.on(name, f2);
 };
 /*\
  * eve.version
  [ property (string) ]
  **
  * Current version of the library.
 \*/
 eve.version = version;
 eve.toString = function () {
     return "You are running Eve " + version;
 };
 (typeof module != "undefined" && module.exports) ? (module.exports = eve) : (typeof define != "undefined" ? (define("eve", [], function() { return eve; })) : (glob.eve = eve));
})(this);
//â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”� \\
//â”‚ "RaphaÃ«l 2.1.2" - JavaScript Vector Library                         â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   â”‚ \\
//â”‚ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             â”‚ \\
//â”‚ Licensed under the MIT (http://raphaeljs.com/license.html) license. â”‚ \\
//â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ \\

(function (glob, factory) {
 // AMD support
 if (typeof define === "function" && define.amd) {
     // Define as an anonymous module
     define(["eve"], function( eve ) {
         return factory(glob, eve);
     });
 } else {
     // Browser globals (glob is window)
     // Raphael adds itself to window
     factory(glob, glob.eve);
 }
}(this, function (window, eve) {
 /*\
  * Raphael
  [ method ]
  **
  * Creates a canvas object on which to draw.
  * You must do this first, as all future calls to drawing methods
  * from this instance will be bound to this canvas.
  > Parameters
  **
  - container (HTMLElement|string) DOM element or its ID which is going to be a parent for drawing surface
  - width (number)
  - height (number)
  - callback (function) #optional callback function which is going to be executed in the context of newly created paper
  * or
  - x (number)
  - y (number)
  - width (number)
  - height (number)
  - callback (function) #optional callback function which is going to be executed in the context of newly created paper
  * or
  - all (array) (first 3 or 4 elements in the array are equal to [containerID, width, height] or [x, y, width, height]. The rest are element descriptions in format {type: type, <attributes>}). See @Paper.add.
  - callback (function) #optional callback function which is going to be executed in the context of newly created paper
  * or
  - onReadyCallback (function) function that is going to be called on DOM ready event. You can also subscribe to this event via Eveâ€™s â€œDOMLoadâ€� event. In this case method returns `undefined`.
  = (object) @Paper
  > Usage
  | // Each of the following examples create a canvas
  | // that is 320px wide by 200px high.
  | // Canvas is created at the viewportâ€™s 10,50 coordinate.
  | var paper = Raphael(10, 50, 320, 200);
  | // Canvas is created at the top left corner of the #notepad element
  | // (or its top right corner in dir="rtl" elements)
  | var paper = Raphael(document.getElementById("notepad"), 320, 200);
  | // Same as above
  | var paper = Raphael("notepad", 320, 200);
  | // Image dump
  | var set = Raphael(["notepad", 320, 200, {
  |     type: "rect",
  |     x: 10,
  |     y: 10,
  |     width: 25,
  |     height: 25,
  |     stroke: "#f00"
  | }, {
  |     type: "text",
  |     x: 30,
  |     y: 40,
  |     text: "Dump"
  | }]);
 \*/
 function R(first) {
     if (R.is(first, "function")) {
         return loaded ? first() : eve.on("raphael.DOMload", first);
     } else if (R.is(first, array)) {
         return R._engine.create[apply](R, first.splice(0, 3 + R.is(first[0], nu))).add(first);
     } else {
         var args = Array.prototype.slice.call(arguments, 0);
         if (R.is(args[args.length - 1], "function")) {
             var f = args.pop();
             return loaded ? f.call(R._engine.create[apply](R, args)) : eve.on("raphael.DOMload", function () {
                 f.call(R._engine.create[apply](R, args));
             });
         } else {
             return R._engine.create[apply](R, arguments);
         }
     }
 }
 R.version = "2.1.2";
 R.eve = eve;
 var loaded,
     separator = /[, ]+/,
     elements = {circle: 1, rect: 1, path: 1, ellipse: 1, text: 1, image: 1},
     formatrg = /\{(\d+)\}/g,
     proto = "prototype",
     has = "hasOwnProperty",
     g = {
         doc: document,
         win: window
     },
     oldRaphael = {
         was: Object.prototype[has].call(g.win, "Raphael"),
         is: g.win.Raphael
     },
     Paper = function () {
         /*\
          * Paper.ca
          [ property (object) ]
          **
          * Shortcut for @Paper.customAttributes
         \*/
         /*\
          * Paper.customAttributes
          [ property (object) ]
          **
          * If you have a set of attributes that you would like to represent
          * as a function of some number you can do it easily with custom attributes:
          > Usage
          | paper.customAttributes.hue = function (num) {
          |     num = num % 1;
          |     return {fill: "hsb(" + num + ", 0.75, 1)"};
          | };
          | // Custom attribute â€œhueâ€� will change fill
          | // to be given hue with fixed saturation and brightness.
          | // Now you can use it like this:
          | var c = paper.circle(10, 10, 10).attr({hue: .45});
          | // or even like this:
          | c.animate({hue: 1}, 1e3);
          | 
          | // You could also create custom attribute
          | // with multiple parameters:
          | paper.customAttributes.hsb = function (h, s, b) {
          |     return {fill: "hsb(" + [h, s, b].join(",") + ")"};
          | };
          | c.attr({hsb: "0.5 .8 1"});
          | c.animate({hsb: [1, 0, 0.5]}, 1e3);
         \*/
         this.ca = this.customAttributes = {};
     },
     paperproto,
     appendChild = "appendChild",
     apply = "apply",
     concat = "concat",
     supportsTouch = ('ontouchstart' in g.win) || g.win.DocumentTouch && g.doc instanceof DocumentTouch, //taken from Modernizr touch test
     E = "",
     S = " ",
     Str = String,
     split = "split",
     events = "click dblclick mousedown mousemove mouseout mouseover mouseup touchstart touchmove touchend touchcancel"[split](S),
     touchMap = {
         mousedown: "touchstart",
         mousemove: "touchmove",
         mouseup: "touchend"
     },
     lowerCase = Str.prototype.toLowerCase,
     math = Math,
     mmax = math.max,
     mmin = math.min,
     abs = math.abs,
     pow = math.pow,
     PI = math.PI,
     nu = "number",
     string = "string",
     array = "array",
     toString = "toString",
     fillString = "fill",
     objectToString = Object.prototype.toString,
     paper = {},
     push = "push",
     ISURL = R._ISURL = /^url\(['"]?([^\)]+?)['"]?\)$/i,
     colourRegExp = /^\s*((#[a-f\d]{6})|(#[a-f\d]{3})|rgba?\(\s*([\d\.]+%?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+%?(?:\s*,\s*[\d\.]+%?)?)\s*\)|hsba?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\)|hsla?\(\s*([\d\.]+(?:deg|\xb0|%)?\s*,\s*[\d\.]+%?\s*,\s*[\d\.]+(?:%?\s*,\s*[\d\.]+)?)%?\s*\))\s*$/i,
     isnan = {"NaN": 1, "Infinity": 1, "-Infinity": 1},
     bezierrg = /^(?:cubic-)?bezier\(([^,]+),([^,]+),([^,]+),([^\)]+)\)/,
     round = math.round,
     setAttribute = "setAttribute",
     toFloat = parseFloat,
     toInt = parseInt,
     upperCase = Str.prototype.toUpperCase,
     availableAttrs = R._availableAttrs = {
         "arrow-end": "none",
         "arrow-start": "none",
         blur: 0,
         "clip-rect": "0 0 1e9 1e9",
         cursor: "default",
         cx: 0,
         cy: 0,
         fill: "#fff",
         "fill-opacity": 1,
         font: '10px "Arial"',
         "font-family": '"Arial"',
         "font-size": "10",
         "font-style": "normal",
         "font-weight": 400,
         gradient: 0,
         height: 0,
         href: "http://raphaeljs.com/",
         "letter-spacing": 0,
         opacity: 1,
         path: "M0,0",
         r: 0,
         rx: 0,
         ry: 0,
         src: "",
         stroke: "#000",
         "stroke-dasharray": "",
         "stroke-linecap": "butt",
         "stroke-linejoin": "butt",
         "stroke-miterlimit": 0,
         "stroke-opacity": 1,
         "stroke-width": 1,
         target: "_blank",
         "text-anchor": "middle",
         title: "Raphael",
         transform: "",
         width: 0,
         x: 0,
         y: 0
     },
     availableAnimAttrs = R._availableAnimAttrs = {
         blur: nu,
         "clip-rect": "csv",
         cx: nu,
         cy: nu,
         fill: "colour",
         "fill-opacity": nu,
         "font-size": nu,
         height: nu,
         opacity: nu,
         path: "path",
         r: nu,
         rx: nu,
         ry: nu,
         stroke: "colour",
         "stroke-opacity": nu,
         "stroke-width": nu,
         transform: "transform",
         width: nu,
         x: nu,
         y: nu
     },
     whitespace = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]/g,
     commaSpaces = /[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/,
     hsrg = {hs: 1, rg: 1},
     p2s = /,?([achlmqrstvxz]),?/gi,
     pathCommand = /([achlmrqstvz])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
     tCommand = /([rstm])[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029,]*((-?\d*\.?\d*(?:e[\-+]?\d+)?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*)+)/ig,
     pathValues = /(-?\d*\.?\d*(?:e[\-+]?\d+)?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,?[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*/ig,
     radial_gradient = R._radial_gradient = /^r(?:\(([^,]+?)[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*,[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028\u2029]*([^\)]+?)\))?/,
     eldata = {},
     sortByKey = function (a, b) {
         return a.key - b.key;
     },
     sortByNumber = function (a, b) {
         return toFloat(a) - toFloat(b);
     },
     fun = function () {},
     pipe = function (x) {
         return x;
     },
     rectPath = R._rectPath = function (x, y, w, h, r) {
         if (r) {
             return [["M", x + r, y], ["l", w - r * 2, 0], ["a", r, r, 0, 0, 1, r, r], ["l", 0, h - r * 2], ["a", r, r, 0, 0, 1, -r, r], ["l", r * 2 - w, 0], ["a", r, r, 0, 0, 1, -r, -r], ["l", 0, r * 2 - h], ["a", r, r, 0, 0, 1, r, -r], ["z"]];
         }
         return [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
     },
     ellipsePath = function (x, y, rx, ry) {
         if (ry == null) {
             ry = rx;
         }
         return [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
     },
     getPath = R._getPath = {
         path: function (el) {
             return el.attr("path");
         },
         circle: function (el) {
             var a = el.attrs;
             return ellipsePath(a.cx, a.cy, a.r);
         },
         ellipse: function (el) {
             var a = el.attrs;
             return ellipsePath(a.cx, a.cy, a.rx, a.ry);
         },
         rect: function (el) {
             var a = el.attrs;
             return rectPath(a.x, a.y, a.width, a.height, a.r);
         },
         image: function (el) {
             var a = el.attrs;
             return rectPath(a.x, a.y, a.width, a.height);
         },
         text: function (el) {
             var bbox = el._getBBox();
             return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
         },
         set : function(el) {
             var bbox = el._getBBox();
             return rectPath(bbox.x, bbox.y, bbox.width, bbox.height);
         }
     },
     /*\
      * Raphael.mapPath
      [ method ]
      **
      * Transform the path string with given matrix.
      > Parameters
      - path (string) path string
      - matrix (object) see @Matrix
      = (string) transformed path string
     \*/
     mapPath = R.mapPath = function (path, matrix) {
         if (!matrix) {
             return path;
         }
         var x, y, i, j, ii, jj, pathi;
         path = path2curve(path);
         for (i = 0, ii = path.length; i < ii; i++) {
             pathi = path[i];
             for (j = 1, jj = pathi.length; j < jj; j += 2) {
                 x = matrix.x(pathi[j], pathi[j + 1]);
                 y = matrix.y(pathi[j], pathi[j + 1]);
                 pathi[j] = x;
                 pathi[j + 1] = y;
             }
         }
         return path;
     };

 R._g = g;
 /*\
  * Raphael.type
  [ property (string) ]
  **
  * Can be â€œSVGâ€�, â€œVMLâ€� or empty, depending on browser support.
 \*/
 R.type = (g.win.SVGAngle || g.doc.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML");
 if (R.type == "VML") {
     var d = g.doc.createElement("div"),
         b;
     d.innerHTML = '<v:shape adj="1"/>';
     b = d.firstChild;
     b.style.behavior = "url(#default#VML)";
     if (!(b && typeof b.adj == "object")) {
         return (R.type = E);
     }
     d = null;
 }
 /*\
  * Raphael.svg
  [ property (boolean) ]
  **
  * `true` if browser supports SVG.
 \*/
 /*\
  * Raphael.vml
  [ property (boolean) ]
  **
  * `true` if browser supports VML.
 \*/
 R.svg = !(R.vml = R.type == "VML");
 R._Paper = Paper;
 /*\
  * Raphael.fn
  [ property (object) ]
  **
  * You can add your own method to the canvas. For example if you want to draw a pie chart,
  * you can create your own pie chart function and ship it as a RaphaÃ«l plugin. To do this
  * you need to extend the `Raphael.fn` object. You should modify the `fn` object before a
  * RaphaÃ«l instance is created, otherwise it will take no effect. Please note that the
  * ability for namespaced plugins was removed in Raphael 2.0. It is up to the plugin to
  * ensure any namespacing ensures proper context.
  > Usage
  | Raphael.fn.arrow = function (x1, y1, x2, y2, size) {
  |     return this.path( ... );
  | };
  | // or create namespace
  | Raphael.fn.mystuff = {
  |     arrow: function () {â€¦},
  |     star: function () {â€¦},
  |     // etcâ€¦
  | };
  | var paper = Raphael(10, 10, 630, 480);
  | // then use it
  | paper.arrow(10, 10, 30, 30, 5).attr({fill: "#f00"});
  | paper.mystuff.arrow();
  | paper.mystuff.star();
 \*/
 R.fn = paperproto = Paper.prototype = R.prototype;
 R._id = 0;
 R._oid = 0;
 /*\
  * Raphael.is
  [ method ]
  **
  * Handfull replacement for `typeof` operator.
  > Parameters
  - o (â€¦) any object or primitive
  - type (string) name of the type, i.e. â€œstringâ€�, â€œfunctionâ€�, â€œnumberâ€�, etc.
  = (boolean) is given value is of given type
 \*/
 R.is = function (o, type) {
     type = lowerCase.call(type);
     if (type == "finite") {
         return !isnan[has](+o);
     }
     if (type == "array") {
         return o instanceof Array;
     }
     return  (type == "null" && o === null) ||
             (type == typeof o && o !== null) ||
             (type == "object" && o === Object(o)) ||
             (type == "array" && Array.isArray && Array.isArray(o)) ||
             objectToString.call(o).slice(8, -1).toLowerCase() == type;
 };

 function clone(obj) {
     if (typeof obj == "function" || Object(obj) !== obj) {
         return obj;
     }
     var res = new obj.constructor;
     for (var key in obj) if (obj[has](key)) {
         res[key] = clone(obj[key]);
     }
     return res;
 }

 /*\
  * Raphael.angle
  [ method ]
  **
  * Returns angle between two or three points
  > Parameters
  - x1 (number) x coord of first point
  - y1 (number) y coord of first point
  - x2 (number) x coord of second point
  - y2 (number) y coord of second point
  - x3 (number) #optional x coord of third point
  - y3 (number) #optional y coord of third point
  = (number) angle in degrees.
 \*/
 R.angle = function (x1, y1, x2, y2, x3, y3) {
     if (x3 == null) {
         var x = x1 - x2,
             y = y1 - y2;
         if (!x && !y) {
             return 0;
         }
         return (180 + math.atan2(-y, -x) * 180 / PI + 360) % 360;
     } else {
         return R.angle(x1, y1, x3, y3) - R.angle(x2, y2, x3, y3);
     }
 };
 /*\
  * Raphael.rad
  [ method ]
  **
  * Transform angle to radians
  > Parameters
  - deg (number) angle in degrees
  = (number) angle in radians.
 \*/
 R.rad = function (deg) {
     return deg % 360 * PI / 180;
 };
 /*\
  * Raphael.deg
  [ method ]
  **
  * Transform angle to degrees
  > Parameters
  - deg (number) angle in radians
  = (number) angle in degrees.
 \*/
 R.deg = function (rad) {
     return rad * 180 / PI % 360;
 };
 /*\
  * Raphael.snapTo
  [ method ]
  **
  * Snaps given value to given grid.
  > Parameters
  - values (array|number) given array of values or step of the grid
  - value (number) value to adjust
  - tolerance (number) #optional tolerance for snapping. Default is `10`.
  = (number) adjusted value.
 \*/
 R.snapTo = function (values, value, tolerance) {
     tolerance = R.is(tolerance, "finite") ? tolerance : 10;
     if (R.is(values, array)) {
         var i = values.length;
         while (i--) if (abs(values[i] - value) <= tolerance) {
             return values[i];
         }
     } else {
         values = +values;
         var rem = value % values;
         if (rem < tolerance) {
             return value - rem;
         }
         if (rem > values - tolerance) {
             return value - rem + values;
         }
     }
     return value;
 };

 /*\
  * Raphael.createUUID
  [ method ]
  **
  * Returns RFC4122, version 4 ID
 \*/
 var createUUID = R.createUUID = (function (uuidRegEx, uuidReplacer) {
     return function () {
         return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(uuidRegEx, uuidReplacer).toUpperCase();
     };
 })(/[xy]/g, function (c) {
     var r = math.random() * 16 | 0,
         v = c == "x" ? r : (r & 3 | 8);
     return v.toString(16);
 });

 /*\
  * Raphael.setWindow
  [ method ]
  **
  * Used when you need to draw in `&lt;iframe>`. Switched window to the iframe one.
  > Parameters
  - newwin (window) new window object
 \*/
 R.setWindow = function (newwin) {
     eve("raphael.setWindow", R, g.win, newwin);
     g.win = newwin;
     g.doc = g.win.document;
     if (R._engine.initWin) {
         R._engine.initWin(g.win);
     }
 };
 var toHex = function (color) {
     if (R.vml) {
         // http://dean.edwards.name/weblog/2009/10/convert-any-colour-value-to-hex-in-msie/
         var trim = /^\s+|\s+$/g;
         var bod;
         try {
             var docum = new ActiveXObject("htmlfile");
             docum.write("<body>");
             docum.close();
             bod = docum.body;
         } catch(e) {
             bod = createPopup().document.body;
         }
         var range = bod.createTextRange();
         toHex = cacher(function (color) {
             try {
                 bod.style.color = Str(color).replace(trim, E);
                 var value = range.queryCommandValue("ForeColor");
                 value = ((value & 255) << 16) | (value & 65280) | ((value & 16711680) >>> 16);
                 return "#" + ("000000" + value.toString(16)).slice(-6);
             } catch(e) {
                 return "none";
             }
         });
     } else {
         var i = g.doc.createElement("i");
         i.title = "Rapha\xebl Colour Picker";
         i.style.display = "none";
         g.doc.body.appendChild(i);
         toHex = cacher(function (color) {
             i.style.color = color;
             return g.doc.defaultView.getComputedStyle(i, E).getPropertyValue("color");
         });
     }
     return toHex(color);
 },
 hsbtoString = function () {
     return "hsb(" + [this.h, this.s, this.b] + ")";
 },
 hsltoString = function () {
     return "hsl(" + [this.h, this.s, this.l] + ")";
 },
 rgbtoString = function () {
     return this.hex;
 },
 prepareRGB = function (r, g, b) {
     if (g == null && R.is(r, "object") && "r" in r && "g" in r && "b" in r) {
         b = r.b;
         g = r.g;
         r = r.r;
     }
     if (g == null && R.is(r, string)) {
         var clr = R.getRGB(r);
         r = clr.r;
         g = clr.g;
         b = clr.b;
     }
     if (r > 1 || g > 1 || b > 1) {
         r /= 255;
         g /= 255;
         b /= 255;
     }

     return [r, g, b];
 },
 packageRGB = function (r, g, b, o) {
     r *= 255;
     g *= 255;
     b *= 255;
     var rgb = {
         r: r,
         g: g,
         b: b,
         hex: R.rgb(r, g, b),
         toString: rgbtoString
     };
     R.is(o, "finite") && (rgb.opacity = o);
     return rgb;
 };

 /*\
  * Raphael.color
  [ method ]
  **
  * Parses the color string and returns object with all values for the given color.
  > Parameters
  - clr (string) color string in one of the supported formats (see @Raphael.getRGB)
  = (object) Combined RGB & HSB object in format:
  o {
  o     r (number) red,
  o     g (number) green,
  o     b (number) blue,
  o     hex (string) color in HTML/CSS format: #â€¢â€¢â€¢â€¢â€¢â€¢,
  o     error (boolean) `true` if string canâ€™t be parsed,
  o     h (number) hue,
  o     s (number) saturation,
  o     v (number) value (brightness),
  o     l (number) lightness
  o }
 \*/
 R.color = function (clr) {
     var rgb;
     if (R.is(clr, "object") && "h" in clr && "s" in clr && "b" in clr) {
         rgb = R.hsb2rgb(clr);
         clr.r = rgb.r;
         clr.g = rgb.g;
         clr.b = rgb.b;
         clr.hex = rgb.hex;
     } else if (R.is(clr, "object") && "h" in clr && "s" in clr && "l" in clr) {
         rgb = R.hsl2rgb(clr);
         clr.r = rgb.r;
         clr.g = rgb.g;
         clr.b = rgb.b;
         clr.hex = rgb.hex;
     } else {
         if (R.is(clr, "string")) {
             clr = R.getRGB(clr);
         }
         if (R.is(clr, "object") && "r" in clr && "g" in clr && "b" in clr) {
             rgb = R.rgb2hsl(clr);
             clr.h = rgb.h;
             clr.s = rgb.s;
             clr.l = rgb.l;
             rgb = R.rgb2hsb(clr);
             clr.v = rgb.b;
         } else {
             clr = {hex: "none"};
             clr.r = clr.g = clr.b = clr.h = clr.s = clr.v = clr.l = -1;
         }
     }
     clr.toString = rgbtoString;
     return clr;
 };
 /*\
  * Raphael.hsb2rgb
  [ method ]
  **
  * Converts HSB values to RGB object.
  > Parameters
  - h (number) hue
  - s (number) saturation
  - v (number) value or brightness
  = (object) RGB object in format:
  o {
  o     r (number) red,
  o     g (number) green,
  o     b (number) blue,
  o     hex (string) color in HTML/CSS format: #â€¢â€¢â€¢â€¢â€¢â€¢
  o }
 \*/
 R.hsb2rgb = function (h, s, v, o) {
     if (this.is(h, "object") && "h" in h && "s" in h && "b" in h) {
         v = h.b;
         s = h.s;
         h = h.h;
         o = h.o;
     }
     h *= 360;
     var R, G, B, X, C;
     h = (h % 360) / 60;
     C = v * s;
     X = C * (1 - abs(h % 2 - 1));
     R = G = B = v - C;

     h = ~~h;
     R += [C, X, 0, 0, X, C][h];
     G += [X, C, C, X, 0, 0][h];
     B += [0, 0, X, C, C, X][h];
     return packageRGB(R, G, B, o);
 };
 /*\
  * Raphael.hsl2rgb
  [ method ]
  **
  * Converts HSL values to RGB object.
  > Parameters
  - h (number) hue
  - s (number) saturation
  - l (number) luminosity
  = (object) RGB object in format:
  o {
  o     r (number) red,
  o     g (number) green,
  o     b (number) blue,
  o     hex (string) color in HTML/CSS format: #â€¢â€¢â€¢â€¢â€¢â€¢
  o }
 \*/
 R.hsl2rgb = function (h, s, l, o) {
     if (this.is(h, "object") && "h" in h && "s" in h && "l" in h) {
         l = h.l;
         s = h.s;
         h = h.h;
     }
     if (h > 1 || s > 1 || l > 1) {
         h /= 360;
         s /= 100;
         l /= 100;
     }
     h *= 360;
     var R, G, B, X, C;
     h = (h % 360) / 60;
     C = 2 * s * (l < .5 ? l : 1 - l);
     X = C * (1 - abs(h % 2 - 1));
     R = G = B = l - C / 2;

     h = ~~h;
     R += [C, X, 0, 0, X, C][h];
     G += [X, C, C, X, 0, 0][h];
     B += [0, 0, X, C, C, X][h];
     return packageRGB(R, G, B, o);
 };
 /*\
  * Raphael.rgb2hsb
  [ method ]
  **
  * Converts RGB values to HSB object.
  > Parameters
  - r (number) red
  - g (number) green
  - b (number) blue
  = (object) HSB object in format:
  o {
  o     h (number) hue
  o     s (number) saturation
  o     b (number) brightness
  o }
 \*/
 R.rgb2hsb = function (r, g, b) {
     b = prepareRGB(r, g, b);
     r = b[0];
     g = b[1];
     b = b[2];

     var H, S, V, C;
     V = mmax(r, g, b);
     C = V - mmin(r, g, b);
     H = (C == 0 ? null :
          V == r ? (g - b) / C :
          V == g ? (b - r) / C + 2 :
                   (r - g) / C + 4
         );
     H = ((H + 360) % 6) * 60 / 360;
     S = C == 0 ? 0 : C / V;
     return {h: H, s: S, b: V, toString: hsbtoString};
 };
 /*\
  * Raphael.rgb2hsl
  [ method ]
  **
  * Converts RGB values to HSL object.
  > Parameters
  - r (number) red
  - g (number) green
  - b (number) blue
  = (object) HSL object in format:
  o {
  o     h (number) hue
  o     s (number) saturation
  o     l (number) luminosity
  o }
 \*/
 R.rgb2hsl = function (r, g, b) {
     b = prepareRGB(r, g, b);
     r = b[0];
     g = b[1];
     b = b[2];

     var H, S, L, M, m, C;
     M = mmax(r, g, b);
     m = mmin(r, g, b);
     C = M - m;
     H = (C == 0 ? null :
          M == r ? (g - b) / C :
          M == g ? (b - r) / C + 2 :
                   (r - g) / C + 4);
     H = ((H + 360) % 6) * 60 / 360;
     L = (M + m) / 2;
     S = (C == 0 ? 0 :
          L < .5 ? C / (2 * L) :
                   C / (2 - 2 * L));
     return {h: H, s: S, l: L, toString: hsltoString};
 };
 R._path2string = function () {
     return this.join(",").replace(p2s, "$1");
 };
 function repush(array, item) {
     for (var i = 0, ii = array.length; i < ii; i++) if (array[i] === item) {
         return array.push(array.splice(i, 1)[0]);
     }
 }
 function cacher(f, scope, postprocessor) {
     function newf() {
         var arg = Array.prototype.slice.call(arguments, 0),
             args = arg.join("\u2400"),
             cache = newf.cache = newf.cache || {},
             count = newf.count = newf.count || [];
         if (cache[has](args)) {
             repush(count, args);
             return postprocessor ? postprocessor(cache[args]) : cache[args];
         }
         count.length >= 1e3 && delete cache[count.shift()];
         count.push(args);
         cache[args] = f[apply](scope, arg);
         return postprocessor ? postprocessor(cache[args]) : cache[args];
     }
     return newf;
 }

 var preload = R._preload = function (src, f) {
     var img = g.doc.createElement("img");
     img.style.cssText = "position:absolute;left:-9999em;top:-9999em";
     img.onload = function () {
         f.call(this);
         this.onload = null;
         g.doc.body.removeChild(this);
     };
     img.onerror = function () {
         g.doc.body.removeChild(this);
     };
     g.doc.body.appendChild(img);
     img.src = src;
 };

 function clrToString() {
     return this.hex;
 }

 /*\
  * Raphael.getRGB
  [ method ]
  **
  * Parses colour string as RGB object
  > Parameters
  - colour (string) colour string in one of formats:
  # <ul>
  #     <li>Colour name (â€œ<code>red</code>â€�, â€œ<code>green</code>â€�, â€œ<code>cornflowerblue</code>â€�, etc)</li>
  #     <li>#â€¢â€¢â€¢ â€” shortened HTML colour: (â€œ<code>#000</code>â€�, â€œ<code>#fc0</code>â€�, etc)</li>
  #     <li>#â€¢â€¢â€¢â€¢â€¢â€¢ â€” full length HTML colour: (â€œ<code>#000000</code>â€�, â€œ<code>#bd2300</code>â€�)</li>
  #     <li>rgb(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” red, green and blue channelsâ€™ values: (â€œ<code>rgb(200,&nbsp;100,&nbsp;0)</code>â€�)</li>
  #     <li>rgb(â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%) â€” same as above, but in %: (â€œ<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>â€�)</li>
  #     <li>hsb(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” hue, saturation and brightness values: (â€œ<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>â€�)</li>
  #     <li>hsb(â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%) â€” same as above, but in %</li>
  #     <li>hsl(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” same as hsb</li>
  #     <li>hsl(â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%) â€” same as hsb</li>
  # </ul>
  = (object) RGB object in format:
  o {
  o     r (number) red,
  o     g (number) green,
  o     b (number) blue
  o     hex (string) color in HTML/CSS format: #â€¢â€¢â€¢â€¢â€¢â€¢,
  o     error (boolean) true if string canâ€™t be parsed
  o }
 \*/
 R.getRGB = cacher(function (colour) {
     if (!colour || !!((colour = Str(colour)).indexOf("-") + 1)) {
         return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
     }
     if (colour == "none") {
         return {r: -1, g: -1, b: -1, hex: "none", toString: clrToString};
     }
     !(hsrg[has](colour.toLowerCase().substring(0, 2)) || colour.charAt() == "#") && (colour = toHex(colour));
     var res,
         red,
         green,
         blue,
         opacity,
         t,
         values,
         rgb = colour.match(colourRegExp);
     if (rgb) {
         if (rgb[2]) {
             blue = toInt(rgb[2].substring(5), 16);
             green = toInt(rgb[2].substring(3, 5), 16);
             red = toInt(rgb[2].substring(1, 3), 16);
         }
         if (rgb[3]) {
             blue = toInt((t = rgb[3].charAt(3)) + t, 16);
             green = toInt((t = rgb[3].charAt(2)) + t, 16);
             red = toInt((t = rgb[3].charAt(1)) + t, 16);
         }
         if (rgb[4]) {
             values = rgb[4][split](commaSpaces);
             red = toFloat(values[0]);
             values[0].slice(-1) == "%" && (red *= 2.55);
             green = toFloat(values[1]);
             values[1].slice(-1) == "%" && (green *= 2.55);
             blue = toFloat(values[2]);
             values[2].slice(-1) == "%" && (blue *= 2.55);
             rgb[1].toLowerCase().slice(0, 4) == "rgba" && (opacity = toFloat(values[3]));
             values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
         }
         if (rgb[5]) {
             values = rgb[5][split](commaSpaces);
             red = toFloat(values[0]);
             values[0].slice(-1) == "%" && (red *= 2.55);
             green = toFloat(values[1]);
             values[1].slice(-1) == "%" && (green *= 2.55);
             blue = toFloat(values[2]);
             values[2].slice(-1) == "%" && (blue *= 2.55);
             (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
             rgb[1].toLowerCase().slice(0, 4) == "hsba" && (opacity = toFloat(values[3]));
             values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
             return R.hsb2rgb(red, green, blue, opacity);
         }
         if (rgb[6]) {
             values = rgb[6][split](commaSpaces);
             red = toFloat(values[0]);
             values[0].slice(-1) == "%" && (red *= 2.55);
             green = toFloat(values[1]);
             values[1].slice(-1) == "%" && (green *= 2.55);
             blue = toFloat(values[2]);
             values[2].slice(-1) == "%" && (blue *= 2.55);
             (values[0].slice(-3) == "deg" || values[0].slice(-1) == "\xb0") && (red /= 360);
             rgb[1].toLowerCase().slice(0, 4) == "hsla" && (opacity = toFloat(values[3]));
             values[3] && values[3].slice(-1) == "%" && (opacity /= 100);
             return R.hsl2rgb(red, green, blue, opacity);
         }
         rgb = {r: red, g: green, b: blue, toString: clrToString};
         rgb.hex = "#" + (16777216 | blue | (green << 8) | (red << 16)).toString(16).slice(1);
         R.is(opacity, "finite") && (rgb.opacity = opacity);
         return rgb;
     }
     return {r: -1, g: -1, b: -1, hex: "none", error: 1, toString: clrToString};
 }, R);
 /*\
  * Raphael.hsb
  [ method ]
  **
  * Converts HSB values to hex representation of the colour.
  > Parameters
  - h (number) hue
  - s (number) saturation
  - b (number) value or brightness
  = (string) hex representation of the colour.
 \*/
 R.hsb = cacher(function (h, s, b) {
     return R.hsb2rgb(h, s, b).hex;
 });
 /*\
  * Raphael.hsl
  [ method ]
  **
  * Converts HSL values to hex representation of the colour.
  > Parameters
  - h (number) hue
  - s (number) saturation
  - l (number) luminosity
  = (string) hex representation of the colour.
 \*/
 R.hsl = cacher(function (h, s, l) {
     return R.hsl2rgb(h, s, l).hex;
 });
 /*\
  * Raphael.rgb
  [ method ]
  **
  * Converts RGB values to hex representation of the colour.
  > Parameters
  - r (number) red
  - g (number) green
  - b (number) blue
  = (string) hex representation of the colour.
 \*/
 R.rgb = cacher(function (r, g, b) {
     return "#" + (16777216 | b | (g << 8) | (r << 16)).toString(16).slice(1);
 });
 /*\
  * Raphael.getColor
  [ method ]
  **
  * On each call returns next colour in the spectrum. To reset it back to red call @Raphael.getColor.reset
  > Parameters
  - value (number) #optional brightness, default is `0.75`
  = (string) hex representation of the colour.
 \*/
 R.getColor = function (value) {
     var start = this.getColor.start = this.getColor.start || {h: 0, s: 1, b: value || .75},
         rgb = this.hsb2rgb(start.h, start.s, start.b);
     start.h += .075;
     if (start.h > 1) {
         start.h = 0;
         start.s -= .2;
         start.s <= 0 && (this.getColor.start = {h: 0, s: 1, b: start.b});
     }
     return rgb.hex;
 };
 /*\
  * Raphael.getColor.reset
  [ method ]
  **
  * Resets spectrum position for @Raphael.getColor back to red.
 \*/
 R.getColor.reset = function () {
     delete this.start;
 };

 // http://schepers.cc/getting-to-the-point
 function catmullRom2bezier(crp, z) {
     var d = [];
     for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
         var p = [
                     {x: +crp[i - 2], y: +crp[i - 1]},
                     {x: +crp[i],     y: +crp[i + 1]},
                     {x: +crp[i + 2], y: +crp[i + 3]},
                     {x: +crp[i + 4], y: +crp[i + 5]}
                 ];
         if (z) {
             if (!i) {
                 p[0] = {x: +crp[iLen - 2], y: +crp[iLen - 1]};
             } else if (iLen - 4 == i) {
                 p[3] = {x: +crp[0], y: +crp[1]};
             } else if (iLen - 2 == i) {
                 p[2] = {x: +crp[0], y: +crp[1]};
                 p[3] = {x: +crp[2], y: +crp[3]};
             }
         } else {
             if (iLen - 4 == i) {
                 p[3] = p[2];
             } else if (!i) {
                 p[0] = {x: +crp[i], y: +crp[i + 1]};
             }
         }
         d.push(["C",
               (-p[0].x + 6 * p[1].x + p[2].x) / 6,
               (-p[0].y + 6 * p[1].y + p[2].y) / 6,
               (p[1].x + 6 * p[2].x - p[3].x) / 6,
               (p[1].y + 6*p[2].y - p[3].y) / 6,
               p[2].x,
               p[2].y
         ]);
     }

     return d;
 }
 /*\
  * Raphael.parsePathString
  [ method ]
  **
  * Utility method
  **
  * Parses given path string into an array of arrays of path segments.
  > Parameters
  - pathString (string|array) path string or array of segments (in the last case it will be returned straight away)
  = (array) array of segments.
 \*/
 R.parsePathString = function (pathString) {
     if (!pathString) {
         return null;
     }
     var pth = paths(pathString);
     if (pth.arr) {
         return pathClone(pth.arr);
     }

     var paramCounts = {a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0},
         data = [];
     if (R.is(pathString, array) && R.is(pathString[0], array)) { // rough assumption
         data = pathClone(pathString);
     }
     if (!data.length) {
         Str(pathString).replace(pathCommand, function (a, b, c) {
             var params = [],
                 name = b.toLowerCase();
             c.replace(pathValues, function (a, b) {
                 b && params.push(+b);
             });
             if (name == "m" && params.length > 2) {
                 data.push([b][concat](params.splice(0, 2)));
                 name = "l";
                 b = b == "m" ? "l" : "L";
             }
             if (name == "r") {
                 data.push([b][concat](params));
             } else while (params.length >= paramCounts[name]) {
                 data.push([b][concat](params.splice(0, paramCounts[name])));
                 if (!paramCounts[name]) {
                     break;
                 }
             }
         });
     }
     data.toString = R._path2string;
     pth.arr = pathClone(data);
     return data;
 };
 /*\
  * Raphael.parseTransformString
  [ method ]
  **
  * Utility method
  **
  * Parses given path string into an array of transformations.
  > Parameters
  - TString (string|array) transform string or array of transformations (in the last case it will be returned straight away)
  = (array) array of transformations.
 \*/
 R.parseTransformString = cacher(function (TString) {
     if (!TString) {
         return null;
     }
     var paramCounts = {r: 3, s: 4, t: 2, m: 6},
         data = [];
     if (R.is(TString, array) && R.is(TString[0], array)) { // rough assumption
         data = pathClone(TString);
     }
     if (!data.length) {
         Str(TString).replace(tCommand, function (a, b, c) {
             var params = [],
                 name = lowerCase.call(b);
             c.replace(pathValues, function (a, b) {
                 b && params.push(+b);
             });
             data.push([b][concat](params));
         });
     }
     data.toString = R._path2string;
     return data;
 });
 // PATHS
 var paths = function (ps) {
     var p = paths.ps = paths.ps || {};
     if (p[ps]) {
         p[ps].sleep = 100;
     } else {
         p[ps] = {
             sleep: 100
         };
     }
     setTimeout(function () {
         for (var key in p) if (p[has](key) && key != ps) {
             p[key].sleep--;
             !p[key].sleep && delete p[key];
         }
     });
     return p[ps];
 };
 /*\
  * Raphael.findDotsAtSegment
  [ method ]
  **
  * Utility method
  **
  * Find dot coordinates on the given cubic bezier curve at the given t.
  > Parameters
  - p1x (number) x of the first point of the curve
  - p1y (number) y of the first point of the curve
  - c1x (number) x of the first anchor of the curve
  - c1y (number) y of the first anchor of the curve
  - c2x (number) x of the second anchor of the curve
  - c2y (number) y of the second anchor of the curve
  - p2x (number) x of the second point of the curve
  - p2y (number) y of the second point of the curve
  - t (number) position on the curve (0..1)
  = (object) point information in format:
  o {
  o     x: (number) x coordinate of the point
  o     y: (number) y coordinate of the point
  o     m: {
  o         x: (number) x coordinate of the left anchor
  o         y: (number) y coordinate of the left anchor
  o     }
  o     n: {
  o         x: (number) x coordinate of the right anchor
  o         y: (number) y coordinate of the right anchor
  o     }
  o     start: {
  o         x: (number) x coordinate of the start of the curve
  o         y: (number) y coordinate of the start of the curve
  o     }
  o     end: {
  o         x: (number) x coordinate of the end of the curve
  o         y: (number) y coordinate of the end of the curve
  o     }
  o     alpha: (number) angle of the curve derivative at the point
  o }
 \*/
 R.findDotsAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
     var t1 = 1 - t,
         t13 = pow(t1, 3),
         t12 = pow(t1, 2),
         t2 = t * t,
         t3 = t2 * t,
         x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x,
         y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y,
         mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x),
         my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y),
         nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x),
         ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y),
         ax = t1 * p1x + t * c1x,
         ay = t1 * p1y + t * c1y,
         cx = t1 * c2x + t * p2x,
         cy = t1 * c2y + t * p2y,
         alpha = (90 - math.atan2(mx - nx, my - ny) * 180 / PI);
     (mx > nx || my < ny) && (alpha += 180);
     return {
         x: x,
         y: y,
         m: {x: mx, y: my},
         n: {x: nx, y: ny},
         start: {x: ax, y: ay},
         end: {x: cx, y: cy},
         alpha: alpha
     };
 };
 /*\
  * Raphael.bezierBBox
  [ method ]
  **
  * Utility method
  **
  * Return bounding box of a given cubic bezier curve
  > Parameters
  - p1x (number) x of the first point of the curve
  - p1y (number) y of the first point of the curve
  - c1x (number) x of the first anchor of the curve
  - c1y (number) y of the first anchor of the curve
  - c2x (number) x of the second anchor of the curve
  - c2y (number) y of the second anchor of the curve
  - p2x (number) x of the second point of the curve
  - p2y (number) y of the second point of the curve
  * or
  - bez (array) array of six points for bezier curve
  = (object) point information in format:
  o {
  o     min: {
  o         x: (number) x coordinate of the left point
  o         y: (number) y coordinate of the top point
  o     }
  o     max: {
  o         x: (number) x coordinate of the right point
  o         y: (number) y coordinate of the bottom point
  o     }
  o }
 \*/
 R.bezierBBox = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
     if (!R.is(p1x, "array")) {
         p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
     }
     var bbox = curveDim.apply(null, p1x);
     return {
         x: bbox.min.x,
         y: bbox.min.y,
         x2: bbox.max.x,
         y2: bbox.max.y,
         width: bbox.max.x - bbox.min.x,
         height: bbox.max.y - bbox.min.y
     };
 };
 /*\
  * Raphael.isPointInsideBBox
  [ method ]
  **
  * Utility method
  **
  * Returns `true` if given point is inside bounding boxes.
  > Parameters
  - bbox (string) bounding box
  - x (string) x coordinate of the point
  - y (string) y coordinate of the point
  = (boolean) `true` if point inside
 \*/
 R.isPointInsideBBox = function (bbox, x, y) {
     return x >= bbox.x && x <= bbox.x2 && y >= bbox.y && y <= bbox.y2;
 };
 /*\
  * Raphael.isBBoxIntersect
  [ method ]
  **
  * Utility method
  **
  * Returns `true` if two bounding boxes intersect
  > Parameters
  - bbox1 (string) first bounding box
  - bbox2 (string) second bounding box
  = (boolean) `true` if they intersect
 \*/
 R.isBBoxIntersect = function (bbox1, bbox2) {
     var i = R.isPointInsideBBox;
     return i(bbox2, bbox1.x, bbox1.y)
         || i(bbox2, bbox1.x2, bbox1.y)
         || i(bbox2, bbox1.x, bbox1.y2)
         || i(bbox2, bbox1.x2, bbox1.y2)
         || i(bbox1, bbox2.x, bbox2.y)
         || i(bbox1, bbox2.x2, bbox2.y)
         || i(bbox1, bbox2.x, bbox2.y2)
         || i(bbox1, bbox2.x2, bbox2.y2)
         || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x)
         && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
 };
 function base3(t, p1, p2, p3, p4) {
     var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4,
         t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
     return t * t2 - 3 * p1 + 3 * p2;
 }
 function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z) {
     if (z == null) {
         z = 1;
     }
     z = z > 1 ? 1 : z < 0 ? 0 : z;
     var z2 = z / 2,
         n = 12,
         Tvalues = [-0.1252,0.1252,-0.3678,0.3678,-0.5873,0.5873,-0.7699,0.7699,-0.9041,0.9041,-0.9816,0.9816],
         Cvalues = [0.2491,0.2491,0.2335,0.2335,0.2032,0.2032,0.1601,0.1601,0.1069,0.1069,0.0472,0.0472],
         sum = 0;
     for (var i = 0; i < n; i++) {
         var ct = z2 * Tvalues[i] + z2,
             xbase = base3(ct, x1, x2, x3, x4),
             ybase = base3(ct, y1, y2, y3, y4),
             comb = xbase * xbase + ybase * ybase;
         sum += Cvalues[i] * math.sqrt(comb);
     }
     return z2 * sum;
 }
 function getTatLen(x1, y1, x2, y2, x3, y3, x4, y4, ll) {
     if (ll < 0 || bezlen(x1, y1, x2, y2, x3, y3, x4, y4) < ll) {
         return;
     }
     var t = 1,
         step = t / 2,
         t2 = t - step,
         l,
         e = .01;
     l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
     while (abs(l - ll) > e) {
         step /= 2;
         t2 += (l < ll ? 1 : -1) * step;
         l = bezlen(x1, y1, x2, y2, x3, y3, x4, y4, t2);
     }
     return t2;
 }
 function intersect(x1, y1, x2, y2, x3, y3, x4, y4) {
     if (
         mmax(x1, x2) < mmin(x3, x4) ||
         mmin(x1, x2) > mmax(x3, x4) ||
         mmax(y1, y2) < mmin(y3, y4) ||
         mmin(y1, y2) > mmax(y3, y4)
     ) {
         return;
     }
     var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),
         ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),
         denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

     if (!denominator) {
         return;
     }
     var px = nx / denominator,
         py = ny / denominator,
         px2 = +px.toFixed(2),
         py2 = +py.toFixed(2);
     if (
         px2 < +mmin(x1, x2).toFixed(2) ||
         px2 > +mmax(x1, x2).toFixed(2) ||
         px2 < +mmin(x3, x4).toFixed(2) ||
         px2 > +mmax(x3, x4).toFixed(2) ||
         py2 < +mmin(y1, y2).toFixed(2) ||
         py2 > +mmax(y1, y2).toFixed(2) ||
         py2 < +mmin(y3, y4).toFixed(2) ||
         py2 > +mmax(y3, y4).toFixed(2)
     ) {
         return;
     }
     return {x: px, y: py};
 }
 function inter(bez1, bez2) {
     return interHelper(bez1, bez2);
 }
 function interCount(bez1, bez2) {
     return interHelper(bez1, bez2, 1);
 }
 function interHelper(bez1, bez2, justCount) {
     var bbox1 = R.bezierBBox(bez1),
         bbox2 = R.bezierBBox(bez2);
     if (!R.isBBoxIntersect(bbox1, bbox2)) {
         return justCount ? 0 : [];
     }
     var l1 = bezlen.apply(0, bez1),
         l2 = bezlen.apply(0, bez2),
         n1 = mmax(~~(l1 / 5), 1),
         n2 = mmax(~~(l2 / 5), 1),
         dots1 = [],
         dots2 = [],
         xy = {},
         res = justCount ? 0 : [];
     for (var i = 0; i < n1 + 1; i++) {
         var p = R.findDotsAtSegment.apply(R, bez1.concat(i / n1));
         dots1.push({x: p.x, y: p.y, t: i / n1});
     }
     for (i = 0; i < n2 + 1; i++) {
         p = R.findDotsAtSegment.apply(R, bez2.concat(i / n2));
         dots2.push({x: p.x, y: p.y, t: i / n2});
     }
     for (i = 0; i < n1; i++) {
         for (var j = 0; j < n2; j++) {
             var di = dots1[i],
                 di1 = dots1[i + 1],
                 dj = dots2[j],
                 dj1 = dots2[j + 1],
                 ci = abs(di1.x - di.x) < .001 ? "y" : "x",
                 cj = abs(dj1.x - dj.x) < .001 ? "y" : "x",
                 is = intersect(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
             if (is) {
                 if (xy[is.x.toFixed(4)] == is.y.toFixed(4)) {
                     continue;
                 }
                 xy[is.x.toFixed(4)] = is.y.toFixed(4);
                 var t1 = di.t + abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t),
                     t2 = dj.t + abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
                 if (t1 >= 0 && t1 <= 1.001 && t2 >= 0 && t2 <= 1.001) {
                     if (justCount) {
                         res++;
                     } else {
                         res.push({
                             x: is.x,
                             y: is.y,
                             t1: mmin(t1, 1),
                             t2: mmin(t2, 1)
                         });
                     }
                 }
             }
         }
     }
     return res;
 }
 /*\
  * Raphael.pathIntersection
  [ method ]
  **
  * Utility method
  **
  * Finds intersections of two paths
  > Parameters
  - path1 (string) path string
  - path2 (string) path string
  = (array) dots of intersection
  o [
  o     {
  o         x: (number) x coordinate of the point
  o         y: (number) y coordinate of the point
  o         t1: (number) t value for segment of path1
  o         t2: (number) t value for segment of path2
  o         segment1: (number) order number for segment of path1
  o         segment2: (number) order number for segment of path2
  o         bez1: (array) eight coordinates representing beziÃ©r curve for the segment of path1
  o         bez2: (array) eight coordinates representing beziÃ©r curve for the segment of path2
  o     }
  o ]
 \*/
 R.pathIntersection = function (path1, path2) {
     return interPathHelper(path1, path2);
 };
 R.pathIntersectionNumber = function (path1, path2) {
     return interPathHelper(path1, path2, 1);
 };
 function interPathHelper(path1, path2, justCount) {
     path1 = R._path2curve(path1);
     path2 = R._path2curve(path2);
     var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2,
         res = justCount ? 0 : [];
     for (var i = 0, ii = path1.length; i < ii; i++) {
         var pi = path1[i];
         if (pi[0] == "M") {
             x1 = x1m = pi[1];
             y1 = y1m = pi[2];
         } else {
             if (pi[0] == "C") {
                 bez1 = [x1, y1].concat(pi.slice(1));
                 x1 = bez1[6];
                 y1 = bez1[7];
             } else {
                 bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
                 x1 = x1m;
                 y1 = y1m;
             }
             for (var j = 0, jj = path2.length; j < jj; j++) {
                 var pj = path2[j];
                 if (pj[0] == "M") {
                     x2 = x2m = pj[1];
                     y2 = y2m = pj[2];
                 } else {
                     if (pj[0] == "C") {
                         bez2 = [x2, y2].concat(pj.slice(1));
                         x2 = bez2[6];
                         y2 = bez2[7];
                     } else {
                         bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
                         x2 = x2m;
                         y2 = y2m;
                     }
                     var intr = interHelper(bez1, bez2, justCount);
                     if (justCount) {
                         res += intr;
                     } else {
                         for (var k = 0, kk = intr.length; k < kk; k++) {
                             intr[k].segment1 = i;
                             intr[k].segment2 = j;
                             intr[k].bez1 = bez1;
                             intr[k].bez2 = bez2;
                         }
                         res = res.concat(intr);
                     }
                 }
             }
         }
     }
     return res;
 }
 /*\
  * Raphael.isPointInsidePath
  [ method ]
  **
  * Utility method
  **
  * Returns `true` if given point is inside a given closed path.
  > Parameters
  - path (string) path string
  - x (number) x of the point
  - y (number) y of the point
  = (boolean) true, if point is inside the path
 \*/
 R.isPointInsidePath = function (path, x, y) {
     var bbox = R.pathBBox(path);
     return R.isPointInsideBBox(bbox, x, y) &&
            interPathHelper(path, [["M", x, y], ["H", bbox.x2 + 10]], 1) % 2 == 1;
 };
 R._removedFactory = function (methodname) {
     return function () {
         eve("raphael.log", null, "Rapha\xebl: you are calling to method \u201c" + methodname + "\u201d of removed object", methodname);
     };
 };
 /*\
  * Raphael.pathBBox
  [ method ]
  **
  * Utility method
  **
  * Return bounding box of a given path
  > Parameters
  - path (string) path string
  = (object) bounding box
  o {
  o     x: (number) x coordinate of the left top point of the box
  o     y: (number) y coordinate of the left top point of the box
  o     x2: (number) x coordinate of the right bottom point of the box
  o     y2: (number) y coordinate of the right bottom point of the box
  o     width: (number) width of the box
  o     height: (number) height of the box
  o     cx: (number) x coordinate of the center of the box
  o     cy: (number) y coordinate of the center of the box
  o }
 \*/
 var pathDimensions = R.pathBBox = function (path) {
     var pth = paths(path);
     if (pth.bbox) {
         return clone(pth.bbox);
     }
     if (!path) {
         return {x: 0, y: 0, width: 0, height: 0, x2: 0, y2: 0};
     }
     path = path2curve(path);
     var x = 0,
         y = 0,
         X = [],
         Y = [],
         p;
     for (var i = 0, ii = path.length; i < ii; i++) {
         p = path[i];
         if (p[0] == "M") {
             x = p[1];
             y = p[2];
             X.push(x);
             Y.push(y);
         } else {
             var dim = curveDim(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
             X = X[concat](dim.min.x, dim.max.x);
             Y = Y[concat](dim.min.y, dim.max.y);
             x = p[5];
             y = p[6];
         }
     }
     var xmin = mmin[apply](0, X),
         ymin = mmin[apply](0, Y),
         xmax = mmax[apply](0, X),
         ymax = mmax[apply](0, Y),
         width = xmax - xmin,
         height = ymax - ymin,
             bb = {
             x: xmin,
             y: ymin,
             x2: xmax,
             y2: ymax,
             width: width,
             height: height,
             cx: xmin + width / 2,
             cy: ymin + height / 2
         };
     pth.bbox = clone(bb);
     return bb;
 },
     pathClone = function (pathArray) {
         var res = clone(pathArray);
         res.toString = R._path2string;
         return res;
     },
     pathToRelative = R._pathToRelative = function (pathArray) {
         var pth = paths(pathArray);
         if (pth.rel) {
             return pathClone(pth.rel);
         }
         if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
             pathArray = R.parsePathString(pathArray);
         }
         var res = [],
             x = 0,
             y = 0,
             mx = 0,
             my = 0,
             start = 0;
         if (pathArray[0][0] == "M") {
             x = pathArray[0][1];
             y = pathArray[0][2];
             mx = x;
             my = y;
             start++;
             res.push(["M", x, y]);
         }
         for (var i = start, ii = pathArray.length; i < ii; i++) {
             var r = res[i] = [],
                 pa = pathArray[i];
             if (pa[0] != lowerCase.call(pa[0])) {
                 r[0] = lowerCase.call(pa[0]);
                 switch (r[0]) {
                     case "a":
                         r[1] = pa[1];
                         r[2] = pa[2];
                         r[3] = pa[3];
                         r[4] = pa[4];
                         r[5] = pa[5];
                         r[6] = +(pa[6] - x).toFixed(3);
                         r[7] = +(pa[7] - y).toFixed(3);
                         break;
                     case "v":
                         r[1] = +(pa[1] - y).toFixed(3);
                         break;
                     case "m":
                         mx = pa[1];
                         my = pa[2];
                     default:
                         for (var j = 1, jj = pa.length; j < jj; j++) {
                             r[j] = +(pa[j] - ((j % 2) ? x : y)).toFixed(3);
                         }
                 }
             } else {
                 r = res[i] = [];
                 if (pa[0] == "m") {
                     mx = pa[1] + x;
                     my = pa[2] + y;
                 }
                 for (var k = 0, kk = pa.length; k < kk; k++) {
                     res[i][k] = pa[k];
                 }
             }
             var len = res[i].length;
             switch (res[i][0]) {
                 case "z":
                     x = mx;
                     y = my;
                     break;
                 case "h":
                     x += +res[i][len - 1];
                     break;
                 case "v":
                     y += +res[i][len - 1];
                     break;
                 default:
                     x += +res[i][len - 2];
                     y += +res[i][len - 1];
             }
         }
         res.toString = R._path2string;
         pth.rel = pathClone(res);
         return res;
     },
     pathToAbsolute = R._pathToAbsolute = function (pathArray) {
         var pth = paths(pathArray);
         if (pth.abs) {
             return pathClone(pth.abs);
         }
         if (!R.is(pathArray, array) || !R.is(pathArray && pathArray[0], array)) { // rough assumption
             pathArray = R.parsePathString(pathArray);
         }
         if (!pathArray || !pathArray.length) {
             return [["M", 0, 0]];
         }
         var res = [],
             x = 0,
             y = 0,
             mx = 0,
             my = 0,
             start = 0;
         if (pathArray[0][0] == "M") {
             x = +pathArray[0][1];
             y = +pathArray[0][2];
             mx = x;
             my = y;
             start++;
             res[0] = ["M", x, y];
         }
         var crz = pathArray.length == 3 && pathArray[0][0] == "M" && pathArray[1][0].toUpperCase() == "R" && pathArray[2][0].toUpperCase() == "Z";
         for (var r, pa, i = start, ii = pathArray.length; i < ii; i++) {
             res.push(r = []);
             pa = pathArray[i];
             if (pa[0] != upperCase.call(pa[0])) {
                 r[0] = upperCase.call(pa[0]);
                 switch (r[0]) {
                     case "A":
                         r[1] = pa[1];
                         r[2] = pa[2];
                         r[3] = pa[3];
                         r[4] = pa[4];
                         r[5] = pa[5];
                         r[6] = +(pa[6] + x);
                         r[7] = +(pa[7] + y);
                         break;
                     case "V":
                         r[1] = +pa[1] + y;
                         break;
                     case "H":
                         r[1] = +pa[1] + x;
                         break;
                     case "R":
                         var dots = [x, y][concat](pa.slice(1));
                         for (var j = 2, jj = dots.length; j < jj; j++) {
                             dots[j] = +dots[j] + x;
                             dots[++j] = +dots[j] + y;
                         }
                         res.pop();
                         res = res[concat](catmullRom2bezier(dots, crz));
                         break;
                     case "M":
                         mx = +pa[1] + x;
                         my = +pa[2] + y;
                     default:
                         for (j = 1, jj = pa.length; j < jj; j++) {
                             r[j] = +pa[j] + ((j % 2) ? x : y);
                         }
                 }
             } else if (pa[0] == "R") {
                 dots = [x, y][concat](pa.slice(1));
                 res.pop();
                 res = res[concat](catmullRom2bezier(dots, crz));
                 r = ["R"][concat](pa.slice(-2));
             } else {
                 for (var k = 0, kk = pa.length; k < kk; k++) {
                     r[k] = pa[k];
                 }
             }
             switch (r[0]) {
                 case "Z":
                     x = mx;
                     y = my;
                     break;
                 case "H":
                     x = r[1];
                     break;
                 case "V":
                     y = r[1];
                     break;
                 case "M":
                     mx = r[r.length - 2];
                     my = r[r.length - 1];
                 default:
                     x = r[r.length - 2];
                     y = r[r.length - 1];
             }
         }
         res.toString = R._path2string;
         pth.abs = pathClone(res);
         return res;
     },
     l2c = function (x1, y1, x2, y2) {
         return [x1, y1, x2, y2, x2, y2];
     },
     q2c = function (x1, y1, ax, ay, x2, y2) {
         var _13 = 1 / 3,
             _23 = 2 / 3;
         return [
                 _13 * x1 + _23 * ax,
                 _13 * y1 + _23 * ay,
                 _13 * x2 + _23 * ax,
                 _13 * y2 + _23 * ay,
                 x2,
                 y2
             ];
     },
     a2c = function (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
         // for more information of where this math came from visit:
         // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
         var _120 = PI * 120 / 180,
             rad = PI / 180 * (+angle || 0),
             res = [],
             xy,
             rotate = cacher(function (x, y, rad) {
                 var X = x * math.cos(rad) - y * math.sin(rad),
                     Y = x * math.sin(rad) + y * math.cos(rad);
                 return {x: X, y: Y};
             });
         if (!recursive) {
             xy = rotate(x1, y1, -rad);
             x1 = xy.x;
             y1 = xy.y;
             xy = rotate(x2, y2, -rad);
             x2 = xy.x;
             y2 = xy.y;
             var cos = math.cos(PI / 180 * angle),
                 sin = math.sin(PI / 180 * angle),
                 x = (x1 - x2) / 2,
                 y = (y1 - y2) / 2;
             var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
             if (h > 1) {
                 h = math.sqrt(h);
                 rx = h * rx;
                 ry = h * ry;
             }
             var rx2 = rx * rx,
                 ry2 = ry * ry,
                 k = (large_arc_flag == sweep_flag ? -1 : 1) *
                     math.sqrt(abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
                 cx = k * rx * y / ry + (x1 + x2) / 2,
                 cy = k * -ry * x / rx + (y1 + y2) / 2,
                 f1 = math.asin(((y1 - cy) / ry).toFixed(9)),
                 f2 = math.asin(((y2 - cy) / ry).toFixed(9));

             f1 = x1 < cx ? PI - f1 : f1;
             f2 = x2 < cx ? PI - f2 : f2;
             f1 < 0 && (f1 = PI * 2 + f1);
             f2 < 0 && (f2 = PI * 2 + f2);
             if (sweep_flag && f1 > f2) {
                 f1 = f1 - PI * 2;
             }
             if (!sweep_flag && f2 > f1) {
                 f2 = f2 - PI * 2;
             }
         } else {
             f1 = recursive[0];
             f2 = recursive[1];
             cx = recursive[2];
             cy = recursive[3];
         }
         var df = f2 - f1;
         if (abs(df) > _120) {
             var f2old = f2,
                 x2old = x2,
                 y2old = y2;
             f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
             x2 = cx + rx * math.cos(f2);
             y2 = cy + ry * math.sin(f2);
             res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
         }
         df = f2 - f1;
         var c1 = math.cos(f1),
             s1 = math.sin(f1),
             c2 = math.cos(f2),
             s2 = math.sin(f2),
             t = math.tan(df / 4),
             hx = 4 / 3 * rx * t,
             hy = 4 / 3 * ry * t,
             m1 = [x1, y1],
             m2 = [x1 + hx * s1, y1 - hy * c1],
             m3 = [x2 + hx * s2, y2 - hy * c2],
             m4 = [x2, y2];
         m2[0] = 2 * m1[0] - m2[0];
         m2[1] = 2 * m1[1] - m2[1];
         if (recursive) {
             return [m2, m3, m4][concat](res);
         } else {
             res = [m2, m3, m4][concat](res).join()[split](",");
             var newres = [];
             for (var i = 0, ii = res.length; i < ii; i++) {
                 newres[i] = i % 2 ? rotate(res[i - 1], res[i], rad).y : rotate(res[i], res[i + 1], rad).x;
             }
             return newres;
         }
     },
     findDotAtSegment = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
         var t1 = 1 - t;
         return {
             x: pow(t1, 3) * p1x + pow(t1, 2) * 3 * t * c1x + t1 * 3 * t * t * c2x + pow(t, 3) * p2x,
             y: pow(t1, 3) * p1y + pow(t1, 2) * 3 * t * c1y + t1 * 3 * t * t * c2y + pow(t, 3) * p2y
         };
     },
     curveDim = cacher(function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
         var a = (c2x - 2 * c1x + p1x) - (p2x - 2 * c2x + c1x),
             b = 2 * (c1x - p1x) - 2 * (c2x - c1x),
             c = p1x - c1x,
             t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a,
             t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a,
             y = [p1y, p2y],
             x = [p1x, p2x],
             dot;
         abs(t1) > "1e12" && (t1 = .5);
         abs(t2) > "1e12" && (t2 = .5);
         if (t1 > 0 && t1 < 1) {
             dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
             x.push(dot.x);
             y.push(dot.y);
         }
         if (t2 > 0 && t2 < 1) {
             dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
             x.push(dot.x);
             y.push(dot.y);
         }
         a = (c2y - 2 * c1y + p1y) - (p2y - 2 * c2y + c1y);
         b = 2 * (c1y - p1y) - 2 * (c2y - c1y);
         c = p1y - c1y;
         t1 = (-b + math.sqrt(b * b - 4 * a * c)) / 2 / a;
         t2 = (-b - math.sqrt(b * b - 4 * a * c)) / 2 / a;
         abs(t1) > "1e12" && (t1 = .5);
         abs(t2) > "1e12" && (t2 = .5);
         if (t1 > 0 && t1 < 1) {
             dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t1);
             x.push(dot.x);
             y.push(dot.y);
         }
         if (t2 > 0 && t2 < 1) {
             dot = findDotAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2);
             x.push(dot.x);
             y.push(dot.y);
         }
         return {
             min: {x: mmin[apply](0, x), y: mmin[apply](0, y)},
             max: {x: mmax[apply](0, x), y: mmax[apply](0, y)}
         };
     }),
     path2curve = R._path2curve = cacher(function (path, path2) {
         var pth = !path2 && paths(path);
         if (!path2 && pth.curve) {
             return pathClone(pth.curve);
         }
         var p = pathToAbsolute(path),
             p2 = path2 && pathToAbsolute(path2),
             attrs = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
             attrs2 = {x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null},
             processPath = function (path, d, pcom) {
                 var nx, ny;
                 if (!path) {
                     return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
                 }
                 !(path[0] in {T:1, Q:1}) && (d.qx = d.qy = null);
                 switch (path[0]) {
                     case "M":
                         d.X = path[1];
                         d.Y = path[2];
                         break;
                     case "A":
                         path = ["C"][concat](a2c[apply](0, [d.x, d.y][concat](path.slice(1))));
                         break;
                     case "S":
                         if (pcom == "C" || pcom == "S") { // In "S" case we have to take into account, if the previous command is C/S.
                             nx = d.x * 2 - d.bx;          // And reflect the previous
                             ny = d.y * 2 - d.by;          // command's control point relative to the current point.
                         }
                         else {                            // or some else or nothing
                             nx = d.x;
                             ny = d.y;
                         }
                         path = ["C", nx, ny][concat](path.slice(1));
                         break;
                     case "T":
                         if (pcom == "Q" || pcom == "T") { // In "T" case we have to take into account, if the previous command is Q/T.
                             d.qx = d.x * 2 - d.qx;        // And make a reflection similar
                             d.qy = d.y * 2 - d.qy;        // to case "S".
                         }
                         else {                            // or something else or nothing
                             d.qx = d.x;
                             d.qy = d.y;
                         }
                         path = ["C"][concat](q2c(d.x, d.y, d.qx, d.qy, path[1], path[2]));
                         break;
                     case "Q":
                         d.qx = path[1];
                         d.qy = path[2];
                         path = ["C"][concat](q2c(d.x, d.y, path[1], path[2], path[3], path[4]));
                         break;
                     case "L":
                         path = ["C"][concat](l2c(d.x, d.y, path[1], path[2]));
                         break;
                     case "H":
                         path = ["C"][concat](l2c(d.x, d.y, path[1], d.y));
                         break;
                     case "V":
                         path = ["C"][concat](l2c(d.x, d.y, d.x, path[1]));
                         break;
                     case "Z":
                         path = ["C"][concat](l2c(d.x, d.y, d.X, d.Y));
                         break;
                 }
                 return path;
             },
             fixArc = function (pp, i) {
                 if (pp[i].length > 7) {
                     pp[i].shift();
                     var pi = pp[i];
                     while (pi.length) {
                         pp.splice(i++, 0, ["C"][concat](pi.splice(0, 6)));
                     }
                     pp.splice(i, 1);
                     ii = mmax(p.length, p2 && p2.length || 0);
                 }
             },
             fixM = function (path1, path2, a1, a2, i) {
                 if (path1 && path2 && path1[i][0] == "M" && path2[i][0] != "M") {
                     path2.splice(i, 0, ["M", a2.x, a2.y]);
                     a1.bx = 0;
                     a1.by = 0;
                     a1.x = path1[i][1];
                     a1.y = path1[i][2];
                     ii = mmax(p.length, p2 && p2.length || 0);
                 }
             };
         for (var i = 0, ii = mmax(p.length, p2 && p2.length || 0); i < ii; i++) {
             p[i] = processPath(p[i], attrs);
             fixArc(p, i);
             p2 && (p2[i] = processPath(p2[i], attrs2));
             p2 && fixArc(p2, i);
             fixM(p, p2, attrs, attrs2, i);
             fixM(p2, p, attrs2, attrs, i);
             var seg = p[i],
                 seg2 = p2 && p2[i],
                 seglen = seg.length,
                 seg2len = p2 && seg2.length;
             attrs.x = seg[seglen - 2];
             attrs.y = seg[seglen - 1];
             attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
             attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
             attrs2.bx = p2 && (toFloat(seg2[seg2len - 4]) || attrs2.x);
             attrs2.by = p2 && (toFloat(seg2[seg2len - 3]) || attrs2.y);
             attrs2.x = p2 && seg2[seg2len - 2];
             attrs2.y = p2 && seg2[seg2len - 1];
         }
         if (!p2) {
             pth.curve = pathClone(p);
         }
         return p2 ? [p, p2] : p;
     }, null, pathClone),
     parseDots = R._parseDots = cacher(function (gradient) {
         var dots = [];
         for (var i = 0, ii = gradient.length; i < ii; i++) {
             var dot = {},
                 par = gradient[i].match(/^([^:]*):?([\d\.]*)/);
             dot.color = R.getRGB(par[1]);
             if (dot.color.error) {
                 return null;
             }
             dot.color = dot.color.hex;
             par[2] && (dot.offset = par[2] + "%");
             dots.push(dot);
         }
         for (i = 1, ii = dots.length - 1; i < ii; i++) {
             if (!dots[i].offset) {
                 var start = toFloat(dots[i - 1].offset || 0),
                     end = 0;
                 for (var j = i + 1; j < ii; j++) {
                     if (dots[j].offset) {
                         end = dots[j].offset;
                         break;
                     }
                 }
                 if (!end) {
                     end = 100;
                     j = ii;
                 }
                 end = toFloat(end);
                 var d = (end - start) / (j - i + 1);
                 for (; i < j; i++) {
                     start += d;
                     dots[i].offset = start + "%";
                 }
             }
         }
         return dots;
     }),
     tear = R._tear = function (el, paper) {
         el == paper.top && (paper.top = el.prev);
         el == paper.bottom && (paper.bottom = el.next);
         el.next && (el.next.prev = el.prev);
         el.prev && (el.prev.next = el.next);
     },
     tofront = R._tofront = function (el, paper) {
         if (paper.top === el) {
             return;
         }
         tear(el, paper);
         el.next = null;
         el.prev = paper.top;
         paper.top.next = el;
         paper.top = el;
     },
     toback = R._toback = function (el, paper) {
         if (paper.bottom === el) {
             return;
         }
         tear(el, paper);
         el.next = paper.bottom;
         el.prev = null;
         paper.bottom.prev = el;
         paper.bottom = el;
     },
     insertafter = R._insertafter = function (el, el2, paper) {
         tear(el, paper);
         el2 == paper.top && (paper.top = el);
         el2.next && (el2.next.prev = el);
         el.next = el2.next;
         el.prev = el2;
         el2.next = el;
     },
     insertbefore = R._insertbefore = function (el, el2, paper) {
         tear(el, paper);
         el2 == paper.bottom && (paper.bottom = el);
         el2.prev && (el2.prev.next = el);
         el.prev = el2.prev;
         el2.prev = el;
         el.next = el2;
     },
     /*\
      * Raphael.toMatrix
      [ method ]
      **
      * Utility method
      **
      * Returns matrix of transformations applied to a given path
      > Parameters
      - path (string) path string
      - transform (string|array) transformation string
      = (object) @Matrix
     \*/
     toMatrix = R.toMatrix = function (path, transform) {
         var bb = pathDimensions(path),
             el = {
                 _: {
                     transform: E
                 },
                 getBBox: function () {
                     return bb;
                 }
             };
         extractTransform(el, transform);
         return el.matrix;
     },
     /*\
      * Raphael.transformPath
      [ method ]
      **
      * Utility method
      **
      * Returns path transformed by a given transformation
      > Parameters
      - path (string) path string
      - transform (string|array) transformation string
      = (string) path
     \*/
     transformPath = R.transformPath = function (path, transform) {
         return mapPath(path, toMatrix(path, transform));
     },
     extractTransform = R._extractTransform = function (el, tstr) {
         if (tstr == null) {
             return el._.transform;
         }
         tstr = Str(tstr).replace(/\.{3}|\u2026/g, el._.transform || E);
         var tdata = R.parseTransformString(tstr),
             deg = 0,
             dx = 0,
             dy = 0,
             sx = 1,
             sy = 1,
             _ = el._,
             m = new Matrix;
         _.transform = tdata || [];
         if (tdata) {
             for (var i = 0, ii = tdata.length; i < ii; i++) {
                 var t = tdata[i],
                     tlen = t.length,
                     command = Str(t[0]).toLowerCase(),
                     absolute = t[0] != command,
                     inver = absolute ? m.invert() : 0,
                     x1,
                     y1,
                     x2,
                     y2,
                     bb;
                 if (command == "t" && tlen == 3) {
                     if (absolute) {
                         x1 = inver.x(0, 0);
                         y1 = inver.y(0, 0);
                         x2 = inver.x(t[1], t[2]);
                         y2 = inver.y(t[1], t[2]);
                         m.translate(x2 - x1, y2 - y1);
                     } else {
                         m.translate(t[1], t[2]);
                     }
                 } else if (command == "r") {
                     if (tlen == 2) {
                         bb = bb || el.getBBox(1);
                         m.rotate(t[1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                         deg += t[1];
                     } else if (tlen == 4) {
                         if (absolute) {
                             x2 = inver.x(t[2], t[3]);
                             y2 = inver.y(t[2], t[3]);
                             m.rotate(t[1], x2, y2);
                         } else {
                             m.rotate(t[1], t[2], t[3]);
                         }
                         deg += t[1];
                     }
                 } else if (command == "s") {
                     if (tlen == 2 || tlen == 3) {
                         bb = bb || el.getBBox(1);
                         m.scale(t[1], t[tlen - 1], bb.x + bb.width / 2, bb.y + bb.height / 2);
                         sx *= t[1];
                         sy *= t[tlen - 1];
                     } else if (tlen == 5) {
                         if (absolute) {
                             x2 = inver.x(t[3], t[4]);
                             y2 = inver.y(t[3], t[4]);
                             m.scale(t[1], t[2], x2, y2);
                         } else {
                             m.scale(t[1], t[2], t[3], t[4]);
                         }
                         sx *= t[1];
                         sy *= t[2];
                     }
                 } else if (command == "m" && tlen == 7) {
                     m.add(t[1], t[2], t[3], t[4], t[5], t[6]);
                 }
                 _.dirtyT = 1;
                 el.matrix = m;
             }
         }

         /*\
          * Element.matrix
          [ property (object) ]
          **
          * Keeps @Matrix object, which represents element transformation
         \*/
         el.matrix = m;

         _.sx = sx;
         _.sy = sy;
         _.deg = deg;
         _.dx = dx = m.e;
         _.dy = dy = m.f;

         if (sx == 1 && sy == 1 && !deg && _.bbox) {
             _.bbox.x += +dx;
             _.bbox.y += +dy;
         } else {
             _.dirtyT = 1;
         }
     },
     getEmpty = function (item) {
         var l = item[0];
         switch (l.toLowerCase()) {
             case "t": return [l, 0, 0];
             case "m": return [l, 1, 0, 0, 1, 0, 0];
             case "r": if (item.length == 4) {
                 return [l, 0, item[2], item[3]];
             } else {
                 return [l, 0];
             }
             case "s": if (item.length == 5) {
                 return [l, 1, 1, item[3], item[4]];
             } else if (item.length == 3) {
                 return [l, 1, 1];
             } else {
                 return [l, 1];
             }
         }
     },
     equaliseTransform = R._equaliseTransform = function (t1, t2) {
         t2 = Str(t2).replace(/\.{3}|\u2026/g, t1);
         t1 = R.parseTransformString(t1) || [];
         t2 = R.parseTransformString(t2) || [];
         var maxlength = mmax(t1.length, t2.length),
             from = [],
             to = [],
             i = 0, j, jj,
             tt1, tt2;
         for (; i < maxlength; i++) {
             tt1 = t1[i] || getEmpty(t2[i]);
             tt2 = t2[i] || getEmpty(tt1);
             if ((tt1[0] != tt2[0]) ||
                 (tt1[0].toLowerCase() == "r" && (tt1[2] != tt2[2] || tt1[3] != tt2[3])) ||
                 (tt1[0].toLowerCase() == "s" && (tt1[3] != tt2[3] || tt1[4] != tt2[4]))
                 ) {
                 return;
             }
             from[i] = [];
             to[i] = [];
             for (j = 0, jj = mmax(tt1.length, tt2.length); j < jj; j++) {
                 j in tt1 && (from[i][j] = tt1[j]);
                 j in tt2 && (to[i][j] = tt2[j]);
             }
         }
         return {
             from: from,
             to: to
         };
     };
 R._getContainer = function (x, y, w, h) {
     var container;
     container = h == null && !R.is(x, "object") ? g.doc.getElementById(x) : x;
     if (container == null) {
         return;
     }
     if (container.tagName) {
         if (y == null) {
             return {
                 container: container,
                 width: container.style.pixelWidth || container.offsetWidth,
                 height: container.style.pixelHeight || container.offsetHeight
             };
         } else {
             return {
                 container: container,
                 width: y,
                 height: w
             };
         }
     }
     return {
         container: 1,
         x: x,
         y: y,
         width: w,
         height: h
     };
 };
 /*\
  * Raphael.pathToRelative
  [ method ]
  **
  * Utility method
  **
  * Converts path to relative form
  > Parameters
  - pathString (string|array) path string or array of segments
  = (array) array of segments.
 \*/
 R.pathToRelative = pathToRelative;
 R._engine = {};
 /*\
  * Raphael.path2curve
  [ method ]
  **
  * Utility method
  **
  * Converts path to a new path where all segments are cubic bezier curves.
  > Parameters
  - pathString (string|array) path string or array of segments
  = (array) array of segments.
 \*/
 R.path2curve = path2curve;
 /*\
  * Raphael.matrix
  [ method ]
  **
  * Utility method
  **
  * Returns matrix based on given parameters.
  > Parameters
  - a (number)
  - b (number)
  - c (number)
  - d (number)
  - e (number)
  - f (number)
  = (object) @Matrix
 \*/
 R.matrix = function (a, b, c, d, e, f) {
     return new Matrix(a, b, c, d, e, f);
 };
 function Matrix(a, b, c, d, e, f) {
     if (a != null) {
         this.a = +a;
         this.b = +b;
         this.c = +c;
         this.d = +d;
         this.e = +e;
         this.f = +f;
     } else {
         this.a = 1;
         this.b = 0;
         this.c = 0;
         this.d = 1;
         this.e = 0;
         this.f = 0;
     }
 }
 (function (matrixproto) {
     /*\
      * Matrix.add
      [ method ]
      **
      * Adds given matrix to existing one.
      > Parameters
      - a (number)
      - b (number)
      - c (number)
      - d (number)
      - e (number)
      - f (number)
      or
      - matrix (object) @Matrix
     \*/
     matrixproto.add = function (a, b, c, d, e, f) {
         var out = [[], [], []],
             m = [[this.a, this.c, this.e], [this.b, this.d, this.f], [0, 0, 1]],
             matrix = [[a, c, e], [b, d, f], [0, 0, 1]],
             x, y, z, res;

         if (a && a instanceof Matrix) {
             matrix = [[a.a, a.c, a.e], [a.b, a.d, a.f], [0, 0, 1]];
         }

         for (x = 0; x < 3; x++) {
             for (y = 0; y < 3; y++) {
                 res = 0;
                 for (z = 0; z < 3; z++) {
                     res += m[x][z] * matrix[z][y];
                 }
                 out[x][y] = res;
             }
         }
         this.a = out[0][0];
         this.b = out[1][0];
         this.c = out[0][1];
         this.d = out[1][1];
         this.e = out[0][2];
         this.f = out[1][2];
     };
     /*\
      * Matrix.invert
      [ method ]
      **
      * Returns inverted version of the matrix
      = (object) @Matrix
     \*/
     matrixproto.invert = function () {
         var me = this,
             x = me.a * me.d - me.b * me.c;
         return new Matrix(me.d / x, -me.b / x, -me.c / x, me.a / x, (me.c * me.f - me.d * me.e) / x, (me.b * me.e - me.a * me.f) / x);
     };
     /*\
      * Matrix.clone
      [ method ]
      **
      * Returns copy of the matrix
      = (object) @Matrix
     \*/
     matrixproto.clone = function () {
         return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
     };
     /*\
      * Matrix.translate
      [ method ]
      **
      * Translate the matrix
      > Parameters
      - x (number)
      - y (number)
     \*/
     matrixproto.translate = function (x, y) {
         this.add(1, 0, 0, 1, x, y);
     };
     /*\
      * Matrix.scale
      [ method ]
      **
      * Scales the matrix
      > Parameters
      - x (number)
      - y (number) #optional
      - cx (number) #optional
      - cy (number) #optional
     \*/
     matrixproto.scale = function (x, y, cx, cy) {
         y == null && (y = x);
         (cx || cy) && this.add(1, 0, 0, 1, cx, cy);
         this.add(x, 0, 0, y, 0, 0);
         (cx || cy) && this.add(1, 0, 0, 1, -cx, -cy);
     };
     /*\
      * Matrix.rotate
      [ method ]
      **
      * Rotates the matrix
      > Parameters
      - a (number)
      - x (number)
      - y (number)
     \*/
     matrixproto.rotate = function (a, x, y) {
         a = R.rad(a);
         x = x || 0;
         y = y || 0;
         var cos = +math.cos(a).toFixed(9),
             sin = +math.sin(a).toFixed(9);
         this.add(cos, sin, -sin, cos, x, y);
         this.add(1, 0, 0, 1, -x, -y);
     };
     /*\
      * Matrix.x
      [ method ]
      **
      * Return x coordinate for given point after transformation described by the matrix. See also @Matrix.y
      > Parameters
      - x (number)
      - y (number)
      = (number) x
     \*/
     matrixproto.x = function (x, y) {
         return x * this.a + y * this.c + this.e;
     };
     /*\
      * Matrix.y
      [ method ]
      **
      * Return y coordinate for given point after transformation described by the matrix. See also @Matrix.x
      > Parameters
      - x (number)
      - y (number)
      = (number) y
     \*/
     matrixproto.y = function (x, y) {
         return x * this.b + y * this.d + this.f;
     };
     matrixproto.get = function (i) {
         return +this[Str.fromCharCode(97 + i)].toFixed(4);
     };
     matrixproto.toString = function () {
         return R.svg ?
             "matrix(" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)].join() + ")" :
             [this.get(0), this.get(2), this.get(1), this.get(3), 0, 0].join();
     };
     matrixproto.toFilter = function () {
         return "progid:DXImageTransform.Microsoft.Matrix(M11=" + this.get(0) +
             ", M12=" + this.get(2) + ", M21=" + this.get(1) + ", M22=" + this.get(3) +
             ", Dx=" + this.get(4) + ", Dy=" + this.get(5) + ", sizingmethod='auto expand')";
     };
     matrixproto.offset = function () {
         return [this.e.toFixed(4), this.f.toFixed(4)];
     };
     function norm(a) {
         return a[0] * a[0] + a[1] * a[1];
     }
     function normalize(a) {
         var mag = math.sqrt(norm(a));
         a[0] && (a[0] /= mag);
         a[1] && (a[1] /= mag);
     }
     /*\
      * Matrix.split
      [ method ]
      **
      * Splits matrix into primitive transformations
      = (object) in format:
      o dx (number) translation by x
      o dy (number) translation by y
      o scalex (number) scale by x
      o scaley (number) scale by y
      o shear (number) shear
      o rotate (number) rotation in deg
      o isSimple (boolean) could it be represented via simple transformations
     \*/
     matrixproto.split = function () {
         var out = {};
         // translation
         out.dx = this.e;
         out.dy = this.f;

         // scale and shear
         var row = [[this.a, this.c], [this.b, this.d]];
         out.scalex = math.sqrt(norm(row[0]));
         normalize(row[0]);

         out.shear = row[0][0] * row[1][0] + row[0][1] * row[1][1];
         row[1] = [row[1][0] - row[0][0] * out.shear, row[1][1] - row[0][1] * out.shear];

         out.scaley = math.sqrt(norm(row[1]));
         normalize(row[1]);
         out.shear /= out.scaley;

         // rotation
         var sin = -row[0][1],
             cos = row[1][1];
         if (cos < 0) {
             out.rotate = R.deg(math.acos(cos));
             if (sin < 0) {
                 out.rotate = 360 - out.rotate;
             }
         } else {
             out.rotate = R.deg(math.asin(sin));
         }

         out.isSimple = !+out.shear.toFixed(9) && (out.scalex.toFixed(9) == out.scaley.toFixed(9) || !out.rotate);
         out.isSuperSimple = !+out.shear.toFixed(9) && out.scalex.toFixed(9) == out.scaley.toFixed(9) && !out.rotate;
         out.noRotation = !+out.shear.toFixed(9) && !out.rotate;
         return out;
     };
     /*\
      * Matrix.toTransformString
      [ method ]
      **
      * Return transform string that represents given matrix
      = (string) transform string
     \*/
     matrixproto.toTransformString = function (shorter) {
         var s = shorter || this[split]();
         if (s.isSimple) {
             s.scalex = +s.scalex.toFixed(4);
             s.scaley = +s.scaley.toFixed(4);
             s.rotate = +s.rotate.toFixed(4);
             return  (s.dx || s.dy ? "t" + [s.dx, s.dy] : E) +
                     (s.scalex != 1 || s.scaley != 1 ? "s" + [s.scalex, s.scaley, 0, 0] : E) +
                     (s.rotate ? "r" + [s.rotate, 0, 0] : E);
         } else {
             return "m" + [this.get(0), this.get(1), this.get(2), this.get(3), this.get(4), this.get(5)];
         }
     };
 })(Matrix.prototype);

 // WebKit rendering bug workaround method
 var version = navigator.userAgent.match(/Version\/(.*?)\s/) || navigator.userAgent.match(/Chrome\/(\d+)/);
 if ((navigator.vendor == "Apple Computer, Inc.") && (version && version[1] < 4 || navigator.platform.slice(0, 2) == "iP") ||
     (navigator.vendor == "Google Inc." && version && version[1] < 8)) {
     /*\
      * Paper.safari
      [ method ]
      **
      * There is an inconvenient rendering bug in Safari (WebKit):
      * sometimes the rendering should be forced.
      * This method should help with dealing with this bug.
     \*/
     paperproto.safari = function () {
         var rect = this.rect(-99, -99, this.width + 99, this.height + 99).attr({stroke: "none"});
         setTimeout(function () {rect.remove();});
     };
 } else {
     paperproto.safari = fun;
 }

 var preventDefault = function () {
     this.returnValue = false;
 },
 preventTouch = function () {
     return this.originalEvent.preventDefault();
 },
 stopPropagation = function () {
     this.cancelBubble = true;
 },
 stopTouch = function () {
     return this.originalEvent.stopPropagation();
 },
 getEventPosition = function (e) {
     var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
         scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;

     return {
         x: e.clientX + scrollX,
         y: e.clientY + scrollY
     };
 },
 addEvent = (function () {
     if (g.doc.addEventListener) {
         return function (obj, type, fn, element) {
             var f = function (e) {
                 var pos = getEventPosition(e);
                 return fn.call(element, e, pos.x, pos.y);
             };
             obj.addEventListener(type, f, false);

             if (supportsTouch && touchMap[type]) {
                 var _f = function (e) {
                     var pos = getEventPosition(e),
                         olde = e;

                     for (var i = 0, ii = e.targetTouches && e.targetTouches.length; i < ii; i++) {
                         if (e.targetTouches[i].target == obj) {
                             e = e.targetTouches[i];
                             e.originalEvent = olde;
                             e.preventDefault = preventTouch;
                             e.stopPropagation = stopTouch;
                             break;
                         }
                     }

                     return fn.call(element, e, pos.x, pos.y);
                 };
                 obj.addEventListener(touchMap[type], _f, false);
             }

             return function () {
                 obj.removeEventListener(type, f, false);

                 if (supportsTouch && touchMap[type])
                     obj.removeEventListener(touchMap[type], f, false);

                 return true;
             };
         };
     } else if (g.doc.attachEvent) {
         return function (obj, type, fn, element) {
             var f = function (e) {
                 e = e || g.win.event;
                 var scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
                     scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
                     x = e.clientX + scrollX,
                     y = e.clientY + scrollY;
                 e.preventDefault = e.preventDefault || preventDefault;
                 e.stopPropagation = e.stopPropagation || stopPropagation;
                 return fn.call(element, e, x, y);
             };
             obj.attachEvent("on" + type, f);
             var detacher = function () {
                 obj.detachEvent("on" + type, f);
                 return true;
             };
             return detacher;
         };
     }
 })(),
 drag = [],
 dragMove = function (e) {
     var x = e.clientX,
         y = e.clientY,
         scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
         scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft,
         dragi,
         j = drag.length;
     while (j--) {
         dragi = drag[j];
         if (supportsTouch && e.touches) {
             var i = e.touches.length,
                 touch;
             while (i--) {
                 touch = e.touches[i];
                 if (touch.identifier == dragi.el._drag.id) {
                     x = touch.clientX;
                     y = touch.clientY;
                     (e.originalEvent ? e.originalEvent : e).preventDefault();
                     break;
                 }
             }
         } else {
             e.preventDefault();
         }
         var node = dragi.el.node,
             o,
             next = node.nextSibling,
             parent = node.parentNode,
             display = node.style.display;
         g.win.opera && parent.removeChild(node);
         node.style.display = "none";
         o = dragi.el.paper.getElementByPoint(x, y);
         node.style.display = display;
         g.win.opera && (next ? parent.insertBefore(node, next) : parent.appendChild(node));
         o && eve("raphael.drag.over." + dragi.el.id, dragi.el, o);
         x += scrollX;
         y += scrollY;
         eve("raphael.drag.move." + dragi.el.id, dragi.move_scope || dragi.el, x - dragi.el._drag.x, y - dragi.el._drag.y, x, y, e);
     }
 },
 dragUp = function (e) {
     R.unmousemove(dragMove).unmouseup(dragUp);
     var i = drag.length,
         dragi;
     while (i--) {
         dragi = drag[i];
         dragi.el._drag = {};
         eve("raphael.drag.end." + dragi.el.id, dragi.end_scope || dragi.start_scope || dragi.move_scope || dragi.el, e);
     }
     drag = [];
 },
 /*\
  * Raphael.el
  [ property (object) ]
  **
  * You can add your own method to elements. This is usefull when you want to hack default functionality or
  * want to wrap some common transformation or attributes in one method. In difference to canvas methods,
  * you can redefine element method at any time. Expending element methods wouldnâ€™t affect set.
  > Usage
  | Raphael.el.red = function () {
  |     this.attr({fill: "#f00"});
  | };
  | // then use it
  | paper.circle(100, 100, 20).red();
 \*/
 elproto = R.el = {};
 /*\
  * Element.click
  [ method ]
  **
  * Adds event handler for click for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.unclick
  [ method ]
  **
  * Removes event handler for click for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.dblclick
  [ method ]
  **
  * Adds event handler for double click for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.undblclick
  [ method ]
  **
  * Removes event handler for double click for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.mousedown
  [ method ]
  **
  * Adds event handler for mousedown for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.unmousedown
  [ method ]
  **
  * Removes event handler for mousedown for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.mousemove
  [ method ]
  **
  * Adds event handler for mousemove for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.unmousemove
  [ method ]
  **
  * Removes event handler for mousemove for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.mouseout
  [ method ]
  **
  * Adds event handler for mouseout for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.unmouseout
  [ method ]
  **
  * Removes event handler for mouseout for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.mouseover
  [ method ]
  **
  * Adds event handler for mouseover for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.unmouseover
  [ method ]
  **
  * Removes event handler for mouseover for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.mouseup
  [ method ]
  **
  * Adds event handler for mouseup for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.unmouseup
  [ method ]
  **
  * Removes event handler for mouseup for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.touchstart
  [ method ]
  **
  * Adds event handler for touchstart for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.untouchstart
  [ method ]
  **
  * Removes event handler for touchstart for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.touchmove
  [ method ]
  **
  * Adds event handler for touchmove for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.untouchmove
  [ method ]
  **
  * Removes event handler for touchmove for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.touchend
  [ method ]
  **
  * Adds event handler for touchend for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.untouchend
  [ method ]
  **
  * Removes event handler for touchend for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/

 /*\
  * Element.touchcancel
  [ method ]
  **
  * Adds event handler for touchcancel for the element.
  > Parameters
  - handler (function) handler for the event
  = (object) @Element
 \*/
 /*\
  * Element.untouchcancel
  [ method ]
  **
  * Removes event handler for touchcancel for the element.
  > Parameters
  - handler (function) #optional handler for the event
  = (object) @Element
 \*/
 for (var i = events.length; i--;) {
     (function (eventName) {
         R[eventName] = elproto[eventName] = function (fn, scope) {
             if (R.is(fn, "function")) {
                 this.events = this.events || [];
                 this.events.push({name: eventName, f: fn, unbind: addEvent(this.shape || this.node || g.doc, eventName, fn, scope || this)});
             }
             return this;
         };
         R["un" + eventName] = elproto["un" + eventName] = function (fn) {
             var events = this.events || [],
                 l = events.length;
             while (l--){
                 if (events[l].name == eventName && (R.is(fn, "undefined") || events[l].f == fn)) {
                     events[l].unbind();
                     events.splice(l, 1);
                     !events.length && delete this.events;
                 }
             }
             return this;
         };
     })(events[i]);
 }

 /*\
  * Element.data
  [ method ]
  **
  * Adds or retrieves given value asociated with given key.
  ** 
  * See also @Element.removeData
  > Parameters
  - key (string) key to store data
  - value (any) #optional value to store
  = (object) @Element
  * or, if value is not specified:
  = (any) value
  * or, if key and value are not specified:
  = (object) Key/value pairs for all the data associated with the element.
  > Usage
  | for (var i = 0, i < 5, i++) {
  |     paper.circle(10 + 15 * i, 10, 10)
  |          .attr({fill: "#000"})
  |          .data("i", i)
  |          .click(function () {
  |             alert(this.data("i"));
  |          });
  | }
 \*/
 elproto.data = function (key, value) {
     var data = eldata[this.id] = eldata[this.id] || {};
     if (arguments.length == 0) {
         return data;
     }
     if (arguments.length == 1) {
         if (R.is(key, "object")) {
             for (var i in key) if (key[has](i)) {
                 this.data(i, key[i]);
             }
             return this;
         }
         eve("raphael.data.get." + this.id, this, data[key], key);
         return data[key];
     }
     data[key] = value;
     eve("raphael.data.set." + this.id, this, value, key);
     return this;
 };
 /*\
  * Element.removeData
  [ method ]
  **
  * Removes value associated with an element by given key.
  * If key is not provided, removes all the data of the element.
  > Parameters
  - key (string) #optional key
  = (object) @Element
 \*/
 elproto.removeData = function (key) {
     if (key == null) {
         eldata[this.id] = {};
     } else {
         eldata[this.id] && delete eldata[this.id][key];
     }
     return this;
 };
  /*\
  * Element.getData
  [ method ]
  **
  * Retrieves the element data
  = (object) data
 \*/
 elproto.getData = function () {
     return clone(eldata[this.id] || {});
 };
 /*\
  * Element.hover
  [ method ]
  **
  * Adds event handlers for hover for the element.
  > Parameters
  - f_in (function) handler for hover in
  - f_out (function) handler for hover out
  - icontext (object) #optional context for hover in handler
  - ocontext (object) #optional context for hover out handler
  = (object) @Element
 \*/
 elproto.hover = function (f_in, f_out, scope_in, scope_out) {
     return this.mouseover(f_in, scope_in).mouseout(f_out, scope_out || scope_in);
 };
 /*\
  * Element.unhover
  [ method ]
  **
  * Removes event handlers for hover for the element.
  > Parameters
  - f_in (function) handler for hover in
  - f_out (function) handler for hover out
  = (object) @Element
 \*/
 elproto.unhover = function (f_in, f_out) {
     return this.unmouseover(f_in).unmouseout(f_out);
 };
 var draggable = [];
 /*\
  * Element.drag
  [ method ]
  **
  * Adds event handlers for drag of the element.
  > Parameters
  - onmove (function) handler for moving
  - onstart (function) handler for drag start
  - onend (function) handler for drag end
  - mcontext (object) #optional context for moving handler
  - scontext (object) #optional context for drag start handler
  - econtext (object) #optional context for drag end handler
  * Additionaly following `drag` events will be triggered: `drag.start.<id>` on start, 
  * `drag.end.<id>` on end and `drag.move.<id>` on every move. When element will be dragged over another element 
  * `drag.over.<id>` will be fired as well.
  *
  * Start event and start handler will be called in specified context or in context of the element with following parameters:
  o x (number) x position of the mouse
  o y (number) y position of the mouse
  o event (object) DOM event object
  * Move event and move handler will be called in specified context or in context of the element with following parameters:
  o dx (number) shift by x from the start point
  o dy (number) shift by y from the start point
  o x (number) x position of the mouse
  o y (number) y position of the mouse
  o event (object) DOM event object
  * End event and end handler will be called in specified context or in context of the element with following parameters:
  o event (object) DOM event object
  = (object) @Element
 \*/
 elproto.drag = function (onmove, onstart, onend, move_scope, start_scope, end_scope) {
     function start(e) {
         (e.originalEvent || e).preventDefault();
         var x = e.clientX,
             y = e.clientY,
             scrollY = g.doc.documentElement.scrollTop || g.doc.body.scrollTop,
             scrollX = g.doc.documentElement.scrollLeft || g.doc.body.scrollLeft;
         this._drag.id = e.identifier;
         if (supportsTouch && e.touches) {
             var i = e.touches.length, touch;
             while (i--) {
                 touch = e.touches[i];
                 this._drag.id = touch.identifier;
                 if (touch.identifier == this._drag.id) {
                     x = touch.clientX;
                     y = touch.clientY;
                     break;
                 }
             }
         }
         this._drag.x = x + scrollX;
         this._drag.y = y + scrollY;
         !drag.length && R.mousemove(dragMove).mouseup(dragUp);
         drag.push({el: this, move_scope: move_scope, start_scope: start_scope, end_scope: end_scope});
         onstart && eve.on("raphael.drag.start." + this.id, onstart);
         onmove && eve.on("raphael.drag.move." + this.id, onmove);
         onend && eve.on("raphael.drag.end." + this.id, onend);
         eve("raphael.drag.start." + this.id, start_scope || move_scope || this, e.clientX + scrollX, e.clientY + scrollY, e);
     }
     this._drag = {};
     draggable.push({el: this, start: start});
     this.mousedown(start);
     return this;
 };
 /*\
  * Element.onDragOver
  [ method ]
  **
  * Shortcut for assigning event handler for `drag.over.<id>` event, where id is id of the element (see @Element.id).
  > Parameters
  - f (function) handler for event, first argument would be the element you are dragging over
 \*/
 elproto.onDragOver = function (f) {
     f ? eve.on("raphael.drag.over." + this.id, f) : eve.unbind("raphael.drag.over." + this.id);
 };
 /*\
  * Element.undrag
  [ method ]
  **
  * Removes all drag event handlers from given element.
 \*/
 elproto.undrag = function () {
     var i = draggable.length;
     while (i--) if (draggable[i].el == this) {
         this.unmousedown(draggable[i].start);
         draggable.splice(i, 1);
         eve.unbind("raphael.drag.*." + this.id);
     }
     !draggable.length && R.unmousemove(dragMove).unmouseup(dragUp);
     drag = [];
 };
 /*\
  * Paper.circle
  [ method ]
  **
  * Draws a circle.
  **
  > Parameters
  **
  - x (number) x coordinate of the centre
  - y (number) y coordinate of the centre
  - r (number) radius
  = (object) RaphaÃ«l element object with type â€œcircleâ€�
  **
  > Usage
  | var c = paper.circle(50, 50, 40);
 \*/
 paperproto.circle = function (x, y, r) {
     var out = R._engine.circle(this, x || 0, y || 0, r || 0);
     this.__set__ && this.__set__.push(out);
     return out;
 };
 /*\
  * Paper.rect
  [ method ]
  *
  * Draws a rectangle.
  **
  > Parameters
  **
  - x (number) x coordinate of the top left corner
  - y (number) y coordinate of the top left corner
  - width (number) width
  - height (number) height
  - r (number) #optional radius for rounded corners, default is 0
  = (object) RaphaÃ«l element object with type â€œrectâ€�
  **
  > Usage
  | // regular rectangle
  | var c = paper.rect(10, 10, 50, 50);
  | // rectangle with rounded corners
  | var c = paper.rect(40, 40, 50, 50, 10);
 \*/
 paperproto.rect = function (x, y, w, h, r) {
     var out = R._engine.rect(this, x || 0, y || 0, w || 0, h || 0, r || 0);
     this.__set__ && this.__set__.push(out);
     return out;
 };
 /*\
  * Paper.ellipse
  [ method ]
  **
  * Draws an ellipse.
  **
  > Parameters
  **
  - x (number) x coordinate of the centre
  - y (number) y coordinate of the centre
  - rx (number) horizontal radius
  - ry (number) vertical radius
  = (object) RaphaÃ«l element object with type â€œellipseâ€�
  **
  > Usage
  | var c = paper.ellipse(50, 50, 40, 20);
 \*/
 paperproto.ellipse = function (x, y, rx, ry) {
     var out = R._engine.ellipse(this, x || 0, y || 0, rx || 0, ry || 0);
     this.__set__ && this.__set__.push(out);
     return out;
 };
 /*\
  * Paper.path
  [ method ]
  **
  * Creates a path element by given path data string.
  > Parameters
  - pathString (string) #optional path string in SVG format.
  * Path string consists of one-letter commands, followed by comma seprarated arguments in numercal form. Example:
  | "M10,20L30,40"
  * Here we can see two commands: â€œMâ€�, with arguments `(10, 20)` and â€œLâ€� with arguments `(30, 40)`. Upper case letter mean command is absolute, lower caseâ€”relative.
  *
  # <p>Here is short list of commands available, for more details see <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a path's data attribute's format are described in the SVG specification.">SVG path string format</a>.</p>
  # <table><thead><tr><th>Command</th><th>Name</th><th>Parameters</th></tr></thead><tbody>
  # <tr><td>M</td><td>moveto</td><td>(x y)+</td></tr>
  # <tr><td>Z</td><td>closepath</td><td>(none)</td></tr>
  # <tr><td>L</td><td>lineto</td><td>(x y)+</td></tr>
  # <tr><td>H</td><td>horizontal lineto</td><td>x+</td></tr>
  # <tr><td>V</td><td>vertical lineto</td><td>y+</td></tr>
  # <tr><td>C</td><td>curveto</td><td>(x1 y1 x2 y2 x y)+</td></tr>
  # <tr><td>S</td><td>smooth curveto</td><td>(x2 y2 x y)+</td></tr>
  # <tr><td>Q</td><td>quadratic BÃ©zier curveto</td><td>(x1 y1 x y)+</td></tr>
  # <tr><td>T</td><td>smooth quadratic BÃ©zier curveto</td><td>(x y)+</td></tr>
  # <tr><td>A</td><td>elliptical arc</td><td>(rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</td></tr>
  # <tr><td>R</td><td><a href="http://en.wikipedia.org/wiki/Catmullâ€“Rom_spline#Catmull.E2.80.93Rom_spline">Catmull-Rom curveto</a>*</td><td>x1 y1 (x y)+</td></tr></tbody></table>
  * * â€œCatmull-Rom curvetoâ€� is a not standard SVG command and added in 2.0 to make life easier.
  * Note: there is a special case when path consist of just three commands: â€œM10,10Râ€¦zâ€�. In this case path will smoothly connects to its beginning.
  > Usage
  | var c = paper.path("M10 10L90 90");
  | // draw a diagonal line:
  | // move to 10,10, line to 90,90
  * For example of path strings, check out these icons: http://raphaeljs.com/icons/
 \*/
 paperproto.path = function (pathString) {
     pathString && !R.is(pathString, string) && !R.is(pathString[0], array) && (pathString += E);
     var out = R._engine.path(R.format[apply](R, arguments), this);
     this.__set__ && this.__set__.push(out);
     return out;
 };
 /*\
  * Paper.image
  [ method ]
  **
  * Embeds an image into the surface.
  **
  > Parameters
  **
  - src (string) URI of the source image
  - x (number) x coordinate position
  - y (number) y coordinate position
  - width (number) width of the image
  - height (number) height of the image
  = (object) RaphaÃ«l element object with type â€œimageâ€�
  **
  > Usage
  | var c = paper.image("apple.png", 10, 10, 80, 80);
 \*/
 paperproto.image = function (src, x, y, w, h) {
     var out = R._engine.image(this, src || "about:blank", x || 0, y || 0, w || 0, h || 0);
     this.__set__ && this.__set__.push(out);
     return out;
 };
 /*\
  * Paper.text
  [ method ]
  **
  * Draws a text string. If you need line breaks, put â€œ\nâ€� in the string.
  **
  > Parameters
  **
  - x (number) x coordinate position
  - y (number) y coordinate position
  - text (string) The text string to draw
  = (object) RaphaÃ«l element object with type â€œtextâ€�
  **
  > Usage
  | var t = paper.text(50, 50, "RaphaÃ«l\nkicks\nbutt!");
 \*/
 paperproto.text = function (x, y, text) {
     var out = R._engine.text(this, x || 0, y || 0, Str(text));
     this.__set__ && this.__set__.push(out);
     return out;
 };
 /*\
  * Paper.set
  [ method ]
  **
  * Creates array-like object to keep and operate several elements at once.
  * Warning: it doesnâ€™t create any elements for itself in the page, it just groups existing elements.
  * Sets act as pseudo elements â€” all methods available to an element can be used on a set.
  = (object) array-like object that represents set of elements
  **
  > Usage
  | var st = paper.set();
  | st.push(
  |     paper.circle(10, 10, 5),
  |     paper.circle(30, 10, 5)
  | );
  | st.attr({fill: "red"}); // changes the fill of both circles
 \*/
 paperproto.set = function (itemsArray) {
     !R.is(itemsArray, "array") && (itemsArray = Array.prototype.splice.call(arguments, 0, arguments.length));
     var out = new Set(itemsArray);
     this.__set__ && this.__set__.push(out);
     out["paper"] = this;
     out["type"] = "set";
     return out;
 };
 /*\
  * Paper.setStart
  [ method ]
  **
  * Creates @Paper.set. All elements that will be created after calling this method and before calling
  * @Paper.setFinish will be added to the set.
  **
  > Usage
  | paper.setStart();
  | paper.circle(10, 10, 5),
  | paper.circle(30, 10, 5)
  | var st = paper.setFinish();
  | st.attr({fill: "red"}); // changes the fill of both circles
 \*/
 paperproto.setStart = function (set) {
     this.__set__ = set || this.set();
 };
 /*\
  * Paper.setFinish
  [ method ]
  **
  * See @Paper.setStart. This method finishes catching and returns resulting set.
  **
  = (object) set
 \*/
 paperproto.setFinish = function (set) {
     var out = this.__set__;
     delete this.__set__;
     return out;
 };
 /*\
  * Paper.setSize
  [ method ]
  **
  * If you need to change dimensions of the canvas call this method
  **
  > Parameters
  **
  - width (number) new width of the canvas
  - height (number) new height of the canvas
 \*/
 paperproto.setSize = function (width, height) {
     return R._engine.setSize.call(this, width, height);
 };
 /*\
  * Paper.setViewBox
  [ method ]
  **
  * Sets the view box of the paper. Practically it gives you ability to zoom and pan whole paper surface by 
  * specifying new boundaries.
  **
  > Parameters
  **
  - x (number) new x position, default is `0`
  - y (number) new y position, default is `0`
  - w (number) new width of the canvas
  - h (number) new height of the canvas
  - fit (boolean) `true` if you want graphics to fit into new boundary box
 \*/
 paperproto.setViewBox = function (x, y, w, h, fit) {
     return R._engine.setViewBox.call(this, x, y, w, h, fit);
 };
 /*\
  * Paper.top
  [ property ]
  **
  * Points to the topmost element on the paper
 \*/
 /*\
  * Paper.bottom
  [ property ]
  **
  * Points to the bottom element on the paper
 \*/
 paperproto.top = paperproto.bottom = null;
 /*\
  * Paper.raphael
  [ property ]
  **
  * Points to the @Raphael object/function
 \*/
 paperproto.raphael = R;
 var getOffset = function (elem) {
     var box = elem.getBoundingClientRect(),
         doc = elem.ownerDocument,
         body = doc.body,
         docElem = doc.documentElement,
         clientTop = docElem.clientTop || body.clientTop || 0, clientLeft = docElem.clientLeft || body.clientLeft || 0,
         top  = box.top  + (g.win.pageYOffset || docElem.scrollTop || body.scrollTop ) - clientTop,
         left = box.left + (g.win.pageXOffset || docElem.scrollLeft || body.scrollLeft) - clientLeft;
     return {
         y: top,
         x: left
     };
 };
 /*\
  * Paper.getElementByPoint
  [ method ]
  **
  * Returns you topmost element under given point.
  **
  = (object) RaphaÃ«l element object
  > Parameters
  **
  - x (number) x coordinate from the top left corner of the window
  - y (number) y coordinate from the top left corner of the window
  > Usage
  | paper.getElementByPoint(mouseX, mouseY).attr({stroke: "#f00"});
 \*/
 paperproto.getElementByPoint = function (x, y) {
     var paper = this,
         svg = paper.canvas,
         target = g.doc.elementFromPoint(x, y);
     if (g.win.opera && target.tagName == "svg") {
         var so = getOffset(svg),
             sr = svg.createSVGRect();
         sr.x = x - so.x;
         sr.y = y - so.y;
         sr.width = sr.height = 1;
         var hits = svg.getIntersectionList(sr, null);
         if (hits.length) {
             target = hits[hits.length - 1];
         }
     }
     if (!target) {
         return null;
     }
     while (target.parentNode && target != svg.parentNode && !target.raphael) {
         target = target.parentNode;
     }
     target == paper.canvas.parentNode && (target = svg);
     target = target && target.raphael ? paper.getById(target.raphaelid) : null;
     return target;
 };

 /*\
  * Paper.getElementsByBBox
  [ method ]
  **
  * Returns set of elements that have an intersecting bounding box
  **
  > Parameters
  **
  - bbox (object) bbox to check with
  = (object) @Set
  \*/
 paperproto.getElementsByBBox = function (bbox) {
     var set = this.set();
     this.forEach(function (el) {
         if (R.isBBoxIntersect(el.getBBox(), bbox)) {
             set.push(el);
         }
     });
     return set;
 };

 /*\
  * Paper.getById
  [ method ]
  **
  * Returns you element by its internal ID.
  **
  > Parameters
  **
  - id (number) id
  = (object) RaphaÃ«l element object
 \*/
 paperproto.getById = function (id) {
     var bot = this.bottom;
     while (bot) {
         if (bot.id == id) {
             return bot;
         }
         bot = bot.next;
     }
     return null;
 };
 /*\
  * Paper.forEach
  [ method ]
  **
  * Executes given function for each element on the paper
  *
  * If callback function returns `false` it will stop loop running.
  **
  > Parameters
  **
  - callback (function) function to run
  - thisArg (object) context object for the callback
  = (object) Paper object
  > Usage
  | paper.forEach(function (el) {
  |     el.attr({ stroke: "blue" });
  | });
 \*/
 paperproto.forEach = function (callback, thisArg) {
     var bot = this.bottom;
     while (bot) {
         if (callback.call(thisArg, bot) === false) {
             return this;
         }
         bot = bot.next;
     }
     return this;
 };
 /*\
  * Paper.getElementsByPoint
  [ method ]
  **
  * Returns set of elements that have common point inside
  **
  > Parameters
  **
  - x (number) x coordinate of the point
  - y (number) y coordinate of the point
  = (object) @Set
 \*/
 paperproto.getElementsByPoint = function (x, y) {
     var set = this.set();
     this.forEach(function (el) {
         if (el.isPointInside(x, y)) {
             set.push(el);
         }
     });
     return set;
 };
 function x_y() {
     return this.x + S + this.y;
 }
 function x_y_w_h() {
     return this.x + S + this.y + S + this.width + " \xd7 " + this.height;
 }
 /*\
  * Element.isPointInside
  [ method ]
  **
  * Determine if given point is inside this elementâ€™s shape
  **
  > Parameters
  **
  - x (number) x coordinate of the point
  - y (number) y coordinate of the point
  = (boolean) `true` if point inside the shape
 \*/
 elproto.isPointInside = function (x, y) {
     var rp = this.realPath = getPath[this.type](this);
     if (this.attr('transform') && this.attr('transform').length) {
         rp = R.transformPath(rp, this.attr('transform'));
     }
     return R.isPointInsidePath(rp, x, y);
 };
 /*\
  * Element.getBBox
  [ method ]
  **
  * Return bounding box for a given element
  **
  > Parameters
  **
  - isWithoutTransform (boolean) flag, `true` if you want to have bounding box before transformations. Default is `false`.
  = (object) Bounding box object:
  o {
  o     x: (number) top left corner x
  o     y: (number) top left corner y
  o     x2: (number) bottom right corner x
  o     y2: (number) bottom right corner y
  o     width: (number) width
  o     height: (number) height
  o }
 \*/
 elproto.getBBox = function (isWithoutTransform) {
     if (this.removed) {
         return {};
     }
     var _ = this._;
     if (isWithoutTransform) {
         if (_.dirty || !_.bboxwt) {
             this.realPath = getPath[this.type](this);
             _.bboxwt = pathDimensions(this.realPath);
             _.bboxwt.toString = x_y_w_h;
             _.dirty = 0;
         }
         return _.bboxwt;
     }
     if (_.dirty || _.dirtyT || !_.bbox) {
         if (_.dirty || !this.realPath) {
             _.bboxwt = 0;
             this.realPath = getPath[this.type](this);
         }
         _.bbox = pathDimensions(mapPath(this.realPath, this.matrix));
         _.bbox.toString = x_y_w_h;
         _.dirty = _.dirtyT = 0;
     }
     return _.bbox;
 };
 /*\
  * Element.clone
  [ method ]
  **
  = (object) clone of a given element
  **
 \*/
 elproto.clone = function () {
     if (this.removed) {
         return null;
     }
     var out = this.paper[this.type]().attr(this.attr());
     this.__set__ && this.__set__.push(out);
     return out;
 };
 /*\
  * Element.glow
  [ method ]
  **
  * Return set of elements that create glow-like effect around given element. See @Paper.set.
  *
  * Note: Glow is not connected to the element. If you change element attributes it wonâ€™t adjust itself.
  **
  > Parameters
  **
  - glow (object) #optional parameters object with all properties optional:
  o {
  o     width (number) size of the glow, default is `10`
  o     fill (boolean) will it be filled, default is `false`
  o     opacity (number) opacity, default is `0.5`
  o     offsetx (number) horizontal offset, default is `0`
  o     offsety (number) vertical offset, default is `0`
  o     color (string) glow colour, default is `black`
  o }
  = (object) @Paper.set of elements that represents glow
 \*/
 elproto.glow = function (glow) {
     if (this.type == "text") {
         return null;
     }
     glow = glow || {};
     var s = {
         width: (glow.width || 10) + (+this.attr("stroke-width") || 1),
         fill: glow.fill || false,
         opacity: glow.opacity || .5,
         offsetx: glow.offsetx || 0,
         offsety: glow.offsety || 0,
         color: glow.color || "#000"
     },
         c = s.width / 2,
         r = this.paper,
         out = r.set(),
         path = this.realPath || getPath[this.type](this);
     path = this.matrix ? mapPath(path, this.matrix) : path;
     for (var i = 1; i < c + 1; i++) {
         out.push(r.path(path).attr({
             stroke: s.color,
             fill: s.fill ? s.color : "none",
             "stroke-linejoin": "round",
             "stroke-linecap": "round",
             "stroke-width": +(s.width / c * i).toFixed(3),
             opacity: +(s.opacity / c).toFixed(3)
         }));
     }
     return out.insertBefore(this).translate(s.offsetx, s.offsety);
 };
 var curveslengths = {},
 getPointAtSegmentLength = function (p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length) {
     if (length == null) {
         return bezlen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);
     } else {
         return R.findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, getTatLen(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, length));
     }
 },
 getLengthFactory = function (istotal, subpath) {
     return function (path, length, onlystart) {
         path = path2curve(path);
         var x, y, p, l, sp = "", subpaths = {}, point,
             len = 0;
         for (var i = 0, ii = path.length; i < ii; i++) {
             p = path[i];
             if (p[0] == "M") {
                 x = +p[1];
                 y = +p[2];
             } else {
                 l = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6]);
                 if (len + l > length) {
                     if (subpath && !subpaths.start) {
                         point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                         sp += ["C" + point.start.x, point.start.y, point.m.x, point.m.y, point.x, point.y];
                         if (onlystart) {return sp;}
                         subpaths.start = sp;
                         sp = ["M" + point.x, point.y + "C" + point.n.x, point.n.y, point.end.x, point.end.y, p[5], p[6]].join();
                         len += l;
                         x = +p[5];
                         y = +p[6];
                         continue;
                     }
                     if (!istotal && !subpath) {
                         point = getPointAtSegmentLength(x, y, p[1], p[2], p[3], p[4], p[5], p[6], length - len);
                         return {x: point.x, y: point.y, alpha: point.alpha};
                     }
                 }
                 len += l;
                 x = +p[5];
                 y = +p[6];
             }
             sp += p.shift() + p;
         }
         subpaths.end = sp;
         point = istotal ? len : subpath ? subpaths : R.findDotsAtSegment(x, y, p[0], p[1], p[2], p[3], p[4], p[5], 1);
         point.alpha && (point = {x: point.x, y: point.y, alpha: point.alpha});
         return point;
     };
 };
 var getTotalLength = getLengthFactory(1),
     getPointAtLength = getLengthFactory(),
     getSubpathsAtLength = getLengthFactory(0, 1);
 /*\
  * Raphael.getTotalLength
  [ method ]
  **
  * Returns length of the given path in pixels.
  **
  > Parameters
  **
  - path (string) SVG path string.
  **
  = (number) length.
 \*/
 R.getTotalLength = getTotalLength;
 /*\
  * Raphael.getPointAtLength
  [ method ]
  **
  * Return coordinates of the point located at the given length on the given path.
  **
  > Parameters
  **
  - path (string) SVG path string
  - length (number)
  **
  = (object) representation of the point:
  o {
  o     x: (number) x coordinate
  o     y: (number) y coordinate
  o     alpha: (number) angle of derivative
  o }
 \*/
 R.getPointAtLength = getPointAtLength;
 /*\
  * Raphael.getSubpath
  [ method ]
  **
  * Return subpath of a given path from given length to given length.
  **
  > Parameters
  **
  - path (string) SVG path string
  - from (number) position of the start of the segment
  - to (number) position of the end of the segment
  **
  = (string) pathstring for the segment
 \*/
 R.getSubpath = function (path, from, to) {
     if (this.getTotalLength(path) - to < 1e-6) {
         return getSubpathsAtLength(path, from).end;
     }
     var a = getSubpathsAtLength(path, to, 1);
     return from ? getSubpathsAtLength(a, from).end : a;
 };
 /*\
  * Element.getTotalLength
  [ method ]
  **
  * Returns length of the path in pixels. Only works for element of â€œpathâ€� type.
  = (number) length.
 \*/
 elproto.getTotalLength = function () {
     var path = this.getPath();
     if (!path) {
         return;
     }

     if (this.node.getTotalLength) {
         return this.node.getTotalLength();
     }

     return getTotalLength(path);
 };
 /*\
  * Element.getPointAtLength
  [ method ]
  **
  * Return coordinates of the point located at the given length on the given path. Only works for element of â€œpathâ€� type.
  **
  > Parameters
  **
  - length (number)
  **
  = (object) representation of the point:
  o {
  o     x: (number) x coordinate
  o     y: (number) y coordinate
  o     alpha: (number) angle of derivative
  o }
 \*/
 elproto.getPointAtLength = function (length) {
     var path = this.getPath();
     if (!path) {
         return;
     }

     return getPointAtLength(path, length);
 };
 /*\
  * Element.getPath
  [ method ]
  **
  * Returns path of the element. Only works for elements of â€œpathâ€� type and simple elements like circle.
  = (object) path
  **
 \*/
 elproto.getPath = function () {
     var path,
         getPath = R._getPath[this.type];
     
     if (this.type == "text" || this.type == "set") {
         return;
     }

     if (getPath) {
         path = getPath(this);
     }

     return path;
 };
 /*\
  * Element.getSubpath
  [ method ]
  **
  * Return subpath of a given element from given length to given length. Only works for element of â€œpathâ€� type.
  **
  > Parameters
  **
  - from (number) position of the start of the segment
  - to (number) position of the end of the segment
  **
  = (string) pathstring for the segment
 \*/
 elproto.getSubpath = function (from, to) {
     var path = this.getPath();
     if (!path) {
         return;
     }

     return R.getSubpath(path, from, to);
 };
 /*\
  * Raphael.easing_formulas
  [ property ]
  **
  * Object that contains easing formulas for animation. You could extend it with your own. By default it has following list of easing:
  # <ul>
  #     <li>â€œlinearâ€�</li>
  #     <li>â€œ&lt;â€� or â€œeaseInâ€� or â€œease-inâ€�</li>
  #     <li>â€œ>â€� or â€œeaseOutâ€� or â€œease-outâ€�</li>
  #     <li>â€œ&lt;>â€� or â€œeaseInOutâ€� or â€œease-in-outâ€�</li>
  #     <li>â€œbackInâ€� or â€œback-inâ€�</li>
  #     <li>â€œbackOutâ€� or â€œback-outâ€�</li>
  #     <li>â€œelasticâ€�</li>
  #     <li>â€œbounceâ€�</li>
  # </ul>
  # <p>See also <a href="http://raphaeljs.com/easing.html">Easing demo</a>.</p>
 \*/
 var ef = R.easing_formulas = {
     linear: function (n) {
         return n;
     },
     "<": function (n) {
         return pow(n, 1.7);
     },
     ">": function (n) {
         return pow(n, .48);
     },
     "<>": function (n) {
         var q = .48 - n / 1.04,
             Q = math.sqrt(.1734 + q * q),
             x = Q - q,
             X = pow(abs(x), 1 / 3) * (x < 0 ? -1 : 1),
             y = -Q - q,
             Y = pow(abs(y), 1 / 3) * (y < 0 ? -1 : 1),
             t = X + Y + .5;
         return (1 - t) * 3 * t * t + t * t * t;
     },
     backIn: function (n) {
         var s = 1.70158;
         return n * n * ((s + 1) * n - s);
     },
     backOut: function (n) {
         n = n - 1;
         var s = 1.70158;
         return n * n * ((s + 1) * n + s) + 1;
     },
     elastic: function (n) {
         if (n == !!n) {
             return n;
         }
         return pow(2, -10 * n) * math.sin((n - .075) * (2 * PI) / .3) + 1;
     },
     bounce: function (n) {
         var s = 7.5625,
             p = 2.75,
             l;
         if (n < (1 / p)) {
             l = s * n * n;
         } else {
             if (n < (2 / p)) {
                 n -= (1.5 / p);
                 l = s * n * n + .75;
             } else {
                 if (n < (2.5 / p)) {
                     n -= (2.25 / p);
                     l = s * n * n + .9375;
                 } else {
                     n -= (2.625 / p);
                     l = s * n * n + .984375;
                 }
             }
         }
         return l;
     }
 };
 ef.easeIn = ef["ease-in"] = ef["<"];
 ef.easeOut = ef["ease-out"] = ef[">"];
 ef.easeInOut = ef["ease-in-out"] = ef["<>"];
 ef["back-in"] = ef.backIn;
 ef["back-out"] = ef.backOut;

 var animationElements = [],
     requestAnimFrame = window.requestAnimationFrame       ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame    ||
                        window.oRequestAnimationFrame      ||
                        window.msRequestAnimationFrame     ||
                        function (callback) {
                            setTimeout(callback, 16);
                        },
     animation = function () {
         var Now = +new Date,
             l = 0;
         for (; l < animationElements.length; l++) {
             var e = animationElements[l];
             if (e.el.removed || e.paused) {
                 continue;
             }
             var time = Now - e.start,
                 ms = e.ms,
                 easing = e.easing,
                 from = e.from,
                 diff = e.diff,
                 to = e.to,
                 t = e.t,
                 that = e.el,
                 set = {},
                 now,
                 init = {},
                 key;
             if (e.initstatus) {
                 time = (e.initstatus * e.anim.top - e.prev) / (e.percent - e.prev) * ms;
                 e.status = e.initstatus;
                 delete e.initstatus;
                 e.stop && animationElements.splice(l--, 1);
             } else {
                 e.status = (e.prev + (e.percent - e.prev) * (time / ms)) / e.anim.top;
             }
             if (time < 0) {
                 continue;
             }
             if (time < ms) {
                 var pos = easing(time / ms);
                 for (var attr in from) if (from[has](attr)) {
                     switch (availableAnimAttrs[attr]) {
                         case nu:
                             now = +from[attr] + pos * ms * diff[attr];
                             break;
                         case "colour":
                             now = "rgb(" + [
                                 upto255(round(from[attr].r + pos * ms * diff[attr].r)),
                                 upto255(round(from[attr].g + pos * ms * diff[attr].g)),
                                 upto255(round(from[attr].b + pos * ms * diff[attr].b))
                             ].join(",") + ")";
                             break;
                         case "path":
                             now = [];
                             for (var i = 0, ii = from[attr].length; i < ii; i++) {
                                 now[i] = [from[attr][i][0]];
                                 for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                     now[i][j] = +from[attr][i][j] + pos * ms * diff[attr][i][j];
                                 }
                                 now[i] = now[i].join(S);
                             }
                             now = now.join(S);
                             break;
                         case "transform":
                             if (diff[attr].real) {
                                 now = [];
                                 for (i = 0, ii = from[attr].length; i < ii; i++) {
                                     now[i] = [from[attr][i][0]];
                                     for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                         now[i][j] = from[attr][i][j] + pos * ms * diff[attr][i][j];
                                     }
                                 }
                             } else {
                                 var get = function (i) {
                                     return +from[attr][i] + pos * ms * diff[attr][i];
                                 };
                                 // now = [["r", get(2), 0, 0], ["t", get(3), get(4)], ["s", get(0), get(1), 0, 0]];
                                 now = [["m", get(0), get(1), get(2), get(3), get(4), get(5)]];
                             }
                             break;
                         case "csv":
                             if (attr == "clip-rect") {
                                 now = [];
                                 i = 4;
                                 while (i--) {
                                     now[i] = +from[attr][i] + pos * ms * diff[attr][i];
                                 }
                             }
                             break;
                         default:
                             var from2 = [][concat](from[attr]);
                             now = [];
                             i = that.paper.customAttributes[attr].length;
                             while (i--) {
                                 now[i] = +from2[i] + pos * ms * diff[attr][i];
                             }
                             break;
                     }
                     set[attr] = now;
                 }
                 that.attr(set);
                 (function (id, that, anim) {
                     setTimeout(function () {
                         eve("raphael.anim.frame." + id, that, anim);
                     });
                 })(that.id, that, e.anim);
             } else {
                 (function(f, el, a) {
                     setTimeout(function() {
                         eve("raphael.anim.frame." + el.id, el, a);
                         eve("raphael.anim.finish." + el.id, el, a);
                         R.is(f, "function") && f.call(el);
                     });
                 })(e.callback, that, e.anim);
                 that.attr(to);
                 animationElements.splice(l--, 1);
                 if (e.repeat > 1 && !e.next) {
                     for (key in to) if (to[has](key)) {
                         init[key] = e.totalOrigin[key];
                     }
                     e.el.attr(init);
                     runAnimation(e.anim, e.el, e.anim.percents[0], null, e.totalOrigin, e.repeat - 1);
                 }
                 if (e.next && !e.stop) {
                     runAnimation(e.anim, e.el, e.next, null, e.totalOrigin, e.repeat);
                 }
             }
         }
         R.svg && that && that.paper && that.paper.safari();
         animationElements.length && requestAnimFrame(animation);
     },
     upto255 = function (color) {
         return color > 255 ? 255 : color < 0 ? 0 : color;
     };
 /*\
  * Element.animateWith
  [ method ]
  **
  * Acts similar to @Element.animate, but ensure that given animation runs in sync with another given element.
  **
  > Parameters
  **
  - el (object) element to sync with
  - anim (object) animation to sync with
  - params (object) #optional final attributes for the element, see also @Element.attr
  - ms (number) #optional number of milliseconds for animation to run
  - easing (string) #optional easing type. Accept on of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
  - callback (function) #optional callback function. Will be called at the end of animation.
  * or
  - element (object) element to sync with
  - anim (object) animation to sync with
  - animation (object) #optional animation object, see @Raphael.animation
  **
  = (object) original element
 \*/
 elproto.animateWith = function (el, anim, params, ms, easing, callback) {
     var element = this;
     if (element.removed) {
         callback && callback.call(element);
         return element;
     }
     var a = params instanceof Animation ? params : R.animation(params, ms, easing, callback),
         x, y;
     runAnimation(a, element, a.percents[0], null, element.attr());
     for (var i = 0, ii = animationElements.length; i < ii; i++) {
         if (animationElements[i].anim == anim && animationElements[i].el == el) {
             animationElements[ii - 1].start = animationElements[i].start;
             break;
         }
     }
     return element;
     // 
     // 
     // var a = params ? R.animation(params, ms, easing, callback) : anim,
     //     status = element.status(anim);
     // return this.animate(a).status(a, status * anim.ms / a.ms);
 };
 function CubicBezierAtTime(t, p1x, p1y, p2x, p2y, duration) {
     var cx = 3 * p1x,
         bx = 3 * (p2x - p1x) - cx,
         ax = 1 - cx - bx,
         cy = 3 * p1y,
         by = 3 * (p2y - p1y) - cy,
         ay = 1 - cy - by;
     function sampleCurveX(t) {
         return ((ax * t + bx) * t + cx) * t;
     }
     function solve(x, epsilon) {
         var t = solveCurveX(x, epsilon);
         return ((ay * t + by) * t + cy) * t;
     }
     function solveCurveX(x, epsilon) {
         var t0, t1, t2, x2, d2, i;
         for(t2 = x, i = 0; i < 8; i++) {
             x2 = sampleCurveX(t2) - x;
             if (abs(x2) < epsilon) {
                 return t2;
             }
             d2 = (3 * ax * t2 + 2 * bx) * t2 + cx;
             if (abs(d2) < 1e-6) {
                 break;
             }
             t2 = t2 - x2 / d2;
         }
         t0 = 0;
         t1 = 1;
         t2 = x;
         if (t2 < t0) {
             return t0;
         }
         if (t2 > t1) {
             return t1;
         }
         while (t0 < t1) {
             x2 = sampleCurveX(t2);
             if (abs(x2 - x) < epsilon) {
                 return t2;
             }
             if (x > x2) {
                 t0 = t2;
             } else {
                 t1 = t2;
             }
             t2 = (t1 - t0) / 2 + t0;
         }
         return t2;
     }
     return solve(t, 1 / (200 * duration));
 }
 elproto.onAnimation = function (f) {
     f ? eve.on("raphael.anim.frame." + this.id, f) : eve.unbind("raphael.anim.frame." + this.id);
     return this;
 };
 function Animation(anim, ms) {
     var percents = [],
         newAnim = {};
     this.ms = ms;
     this.times = 1;
     if (anim) {
         for (var attr in anim) if (anim[has](attr)) {
             newAnim[toFloat(attr)] = anim[attr];
             percents.push(toFloat(attr));
         }
         percents.sort(sortByNumber);
     }
     this.anim = newAnim;
     this.top = percents[percents.length - 1];
     this.percents = percents;
 }
 /*\
  * Animation.delay
  [ method ]
  **
  * Creates a copy of existing animation object with given delay.
  **
  > Parameters
  **
  - delay (number) number of ms to pass between animation start and actual animation
  **
  = (object) new altered Animation object
  | var anim = Raphael.animation({cx: 10, cy: 20}, 2e3);
  | circle1.animate(anim); // run the given animation immediately
  | circle2.animate(anim.delay(500)); // run the given animation after 500 ms
 \*/
 Animation.prototype.delay = function (delay) {
     var a = new Animation(this.anim, this.ms);
     a.times = this.times;
     a.del = +delay || 0;
     return a;
 };
 /*\
  * Animation.repeat
  [ method ]
  **
  * Creates a copy of existing animation object with given repetition.
  **
  > Parameters
  **
  - repeat (number) number iterations of animation. For infinite animation pass `Infinity`
  **
  = (object) new altered Animation object
 \*/
 Animation.prototype.repeat = function (times) {
     var a = new Animation(this.anim, this.ms);
     a.del = this.del;
     a.times = math.floor(mmax(times, 0)) || 1;
     return a;
 };
 function runAnimation(anim, element, percent, status, totalOrigin, times) {
     percent = toFloat(percent);
     var params,
         isInAnim,
         isInAnimSet,
         percents = [],
         next,
         prev,
         timestamp,
         ms = anim.ms,
         from = {},
         to = {},
         diff = {};
     if (status) {
         for (i = 0, ii = animationElements.length; i < ii; i++) {
             var e = animationElements[i];
             if (e.el.id == element.id && e.anim == anim) {
                 if (e.percent != percent) {
                     animationElements.splice(i, 1);
                     isInAnimSet = 1;
                 } else {
                     isInAnim = e;
                 }
                 element.attr(e.totalOrigin);
                 break;
             }
         }
     } else {
         status = +to; // NaN
     }
     for (var i = 0, ii = anim.percents.length; i < ii; i++) {
         if (anim.percents[i] == percent || anim.percents[i] > status * anim.top) {
             percent = anim.percents[i];
             prev = anim.percents[i - 1] || 0;
             ms = ms / anim.top * (percent - prev);
             next = anim.percents[i + 1];
             params = anim.anim[percent];
             break;
         } else if (status) {
             element.attr(anim.anim[anim.percents[i]]);
         }
     }
     if (!params) {
         return;
     }
     if (!isInAnim) {
         for (var attr in params) if (params[has](attr)) {
             if (availableAnimAttrs[has](attr) || element.paper.customAttributes[has](attr)) {
                 from[attr] = element.attr(attr);
                 (from[attr] == null) && (from[attr] = availableAttrs[attr]);
                 to[attr] = params[attr];
                 switch (availableAnimAttrs[attr]) {
                     case nu:
                         diff[attr] = (to[attr] - from[attr]) / ms;
                         break;
                     case "colour":
                         from[attr] = R.getRGB(from[attr]);
                         var toColour = R.getRGB(to[attr]);
                         diff[attr] = {
                             r: (toColour.r - from[attr].r) / ms,
                             g: (toColour.g - from[attr].g) / ms,
                             b: (toColour.b - from[attr].b) / ms
                         };
                         break;
                     case "path":
                         var pathes = path2curve(from[attr], to[attr]),
                             toPath = pathes[1];
                         from[attr] = pathes[0];
                         diff[attr] = [];
                         for (i = 0, ii = from[attr].length; i < ii; i++) {
                             diff[attr][i] = [0];
                             for (var j = 1, jj = from[attr][i].length; j < jj; j++) {
                                 diff[attr][i][j] = (toPath[i][j] - from[attr][i][j]) / ms;
                             }
                         }
                         break;
                     case "transform":
                         var _ = element._,
                             eq = equaliseTransform(_[attr], to[attr]);
                         if (eq) {
                             from[attr] = eq.from;
                             to[attr] = eq.to;
                             diff[attr] = [];
                             diff[attr].real = true;
                             for (i = 0, ii = from[attr].length; i < ii; i++) {
                                 diff[attr][i] = [from[attr][i][0]];
                                 for (j = 1, jj = from[attr][i].length; j < jj; j++) {
                                     diff[attr][i][j] = (to[attr][i][j] - from[attr][i][j]) / ms;
                                 }
                             }
                         } else {
                             var m = (element.matrix || new Matrix),
                                 to2 = {
                                     _: {transform: _.transform},
                                     getBBox: function () {
                                         return element.getBBox(1);
                                     }
                                 };
                             from[attr] = [
                                 m.a,
                                 m.b,
                                 m.c,
                                 m.d,
                                 m.e,
                                 m.f
                             ];
                             extractTransform(to2, to[attr]);
                             to[attr] = to2._.transform;
                             diff[attr] = [
                                 (to2.matrix.a - m.a) / ms,
                                 (to2.matrix.b - m.b) / ms,
                                 (to2.matrix.c - m.c) / ms,
                                 (to2.matrix.d - m.d) / ms,
                                 (to2.matrix.e - m.e) / ms,
                                 (to2.matrix.f - m.f) / ms
                             ];
                             // from[attr] = [_.sx, _.sy, _.deg, _.dx, _.dy];
                             // var to2 = {_:{}, getBBox: function () { return element.getBBox(); }};
                             // extractTransform(to2, to[attr]);
                             // diff[attr] = [
                             //     (to2._.sx - _.sx) / ms,
                             //     (to2._.sy - _.sy) / ms,
                             //     (to2._.deg - _.deg) / ms,
                             //     (to2._.dx - _.dx) / ms,
                             //     (to2._.dy - _.dy) / ms
                             // ];
                         }
                         break;
                     case "csv":
                         var values = Str(params[attr])[split](separator),
                             from2 = Str(from[attr])[split](separator);
                         if (attr == "clip-rect") {
                             from[attr] = from2;
                             diff[attr] = [];
                             i = from2.length;
                             while (i--) {
                                 diff[attr][i] = (values[i] - from[attr][i]) / ms;
                             }
                         }
                         to[attr] = values;
                         break;
                     default:
                         values = [][concat](params[attr]);
                         from2 = [][concat](from[attr]);
                         diff[attr] = [];
                         i = element.paper.customAttributes[attr].length;
                         while (i--) {
                             diff[attr][i] = ((values[i] || 0) - (from2[i] || 0)) / ms;
                         }
                         break;
                 }
             }
         }
         var easing = params.easing,
             easyeasy = R.easing_formulas[easing];
         if (!easyeasy) {
             easyeasy = Str(easing).match(bezierrg);
             if (easyeasy && easyeasy.length == 5) {
                 var curve = easyeasy;
                 easyeasy = function (t) {
                     return CubicBezierAtTime(t, +curve[1], +curve[2], +curve[3], +curve[4], ms);
                 };
             } else {
                 easyeasy = pipe;
             }
         }
         timestamp = params.start || anim.start || +new Date;
         e = {
             anim: anim,
             percent: percent,
             timestamp: timestamp,
             start: timestamp + (anim.del || 0),
             status: 0,
             initstatus: status || 0,
             stop: false,
             ms: ms,
             easing: easyeasy,
             from: from,
             diff: diff,
             to: to,
             el: element,
             callback: params.callback,
             prev: prev,
             next: next,
             repeat: times || anim.times,
             origin: element.attr(),
             totalOrigin: totalOrigin
         };
         animationElements.push(e);
         if (status && !isInAnim && !isInAnimSet) {
             e.stop = true;
             e.start = new Date - ms * status;
             if (animationElements.length == 1) {
                 return animation();
             }
         }
         if (isInAnimSet) {
             e.start = new Date - e.ms * status;
         }
         animationElements.length == 1 && requestAnimFrame(animation);
     } else {
         isInAnim.initstatus = status;
         isInAnim.start = new Date - isInAnim.ms * status;
     }
     eve("raphael.anim.start." + element.id, element, anim);
 }
 /*\
  * Raphael.animation
  [ method ]
  **
  * Creates an animation object that can be passed to the @Element.animate or @Element.animateWith methods.
  * See also @Animation.delay and @Animation.repeat methods.
  **
  > Parameters
  **
  - params (object) final attributes for the element, see also @Element.attr
  - ms (number) number of milliseconds for animation to run
  - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
  - callback (function) #optional callback function. Will be called at the end of animation.
  **
  = (object) @Animation
 \*/
 R.animation = function (params, ms, easing, callback) {
     if (params instanceof Animation) {
         return params;
     }
     if (R.is(easing, "function") || !easing) {
         callback = callback || easing || null;
         easing = null;
     }
     params = Object(params);
     ms = +ms || 0;
     var p = {},
         json,
         attr;
     for (attr in params) if (params[has](attr) && toFloat(attr) != attr && toFloat(attr) + "%" != attr) {
         json = true;
         p[attr] = params[attr];
     }
     if (!json) {
         return new Animation(params, ms);
     } else {
         easing && (p.easing = easing);
         callback && (p.callback = callback);
         return new Animation({100: p}, ms);
     }
 };
 /*\
  * Element.animate
  [ method ]
  **
  * Creates and starts animation for given element.
  **
  > Parameters
  **
  - params (object) final attributes for the element, see also @Element.attr
  - ms (number) number of milliseconds for animation to run
  - easing (string) #optional easing type. Accept one of @Raphael.easing_formulas or CSS format: `cubic&#x2010;bezier(XX,&#160;XX,&#160;XX,&#160;XX)`
  - callback (function) #optional callback function. Will be called at the end of animation.
  * or
  - animation (object) animation object, see @Raphael.animation
  **
  = (object) original element
 \*/
 elproto.animate = function (params, ms, easing, callback) {
     var element = this;
     if (element.removed) {
         callback && callback.call(element);
         return element;
     }
     var anim = params instanceof Animation ? params : R.animation(params, ms, easing, callback);
     runAnimation(anim, element, anim.percents[0], null, element.attr());
     return element;
 };
 /*\
  * Element.setTime
  [ method ]
  **
  * Sets the status of animation of the element in milliseconds. Similar to @Element.status method.
  **
  > Parameters
  **
  - anim (object) animation object
  - value (number) number of milliseconds from the beginning of the animation
  **
  = (object) original element if `value` is specified
  * Note, that during animation following events are triggered:
  *
  * On each animation frame event `anim.frame.<id>`, on start `anim.start.<id>` and on end `anim.finish.<id>`.
 \*/
 elproto.setTime = function (anim, value) {
     if (anim && value != null) {
         this.status(anim, mmin(value, anim.ms) / anim.ms);
     }
     return this;
 };
 /*\
  * Element.status
  [ method ]
  **
  * Gets or sets the status of animation of the element.
  **
  > Parameters
  **
  - anim (object) #optional animation object
  - value (number) #optional 0 â€“ 1. If specified, method works like a setter and sets the status of a given animation to the value. This will cause animation to jump to the given position.
  **
  = (number) status
  * or
  = (array) status if `anim` is not specified. Array of objects in format:
  o {
  o     anim: (object) animation object
  o     status: (number) status
  o }
  * or
  = (object) original element if `value` is specified
 \*/
 elproto.status = function (anim, value) {
     var out = [],
         i = 0,
         len,
         e;
     if (value != null) {
         runAnimation(anim, this, -1, mmin(value, 1));
         return this;
     } else {
         len = animationElements.length;
         for (; i < len; i++) {
             e = animationElements[i];
             if (e.el.id == this.id && (!anim || e.anim == anim)) {
                 if (anim) {
                     return e.status;
                 }
                 out.push({
                     anim: e.anim,
                     status: e.status
                 });
             }
         }
         if (anim) {
             return 0;
         }
         return out;
     }
 };
 /*\
  * Element.pause
  [ method ]
  **
  * Stops animation of the element with ability to resume it later on.
  **
  > Parameters
  **
  - anim (object) #optional animation object
  **
  = (object) original element
 \*/
 elproto.pause = function (anim) {
     for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
         if (eve("raphael.anim.pause." + this.id, this, animationElements[i].anim) !== false) {
             animationElements[i].paused = true;
         }
     }
     return this;
 };
 /*\
  * Element.resume
  [ method ]
  **
  * Resumes animation if it was paused with @Element.pause method.
  **
  > Parameters
  **
  - anim (object) #optional animation object
  **
  = (object) original element
 \*/
 elproto.resume = function (anim) {
     for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
         var e = animationElements[i];
         if (eve("raphael.anim.resume." + this.id, this, e.anim) !== false) {
             delete e.paused;
             this.status(e.anim, e.status);
         }
     }
     return this;
 };
 /*\
  * Element.stop
  [ method ]
  **
  * Stops animation of the element.
  **
  > Parameters
  **
  - anim (object) #optional animation object
  **
  = (object) original element
 \*/
 elproto.stop = function (anim) {
     for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.id == this.id && (!anim || animationElements[i].anim == anim)) {
         if (eve("raphael.anim.stop." + this.id, this, animationElements[i].anim) !== false) {
             animationElements.splice(i--, 1);
         }
     }
     return this;
 };
 function stopAnimation(paper) {
     for (var i = 0; i < animationElements.length; i++) if (animationElements[i].el.paper == paper) {
         animationElements.splice(i--, 1);
     }
 }
 eve.on("raphael.remove", stopAnimation);
 eve.on("raphael.clear", stopAnimation);
 elproto.toString = function () {
     return "Rapha\xebl\u2019s object";
 };

 // Set
 var Set = function (items) {
     this.items = [];
     this.length = 0;
     this.type = "set";
     if (items) {
         for (var i = 0, ii = items.length; i < ii; i++) {
             if (items[i] && (items[i].constructor == elproto.constructor || items[i].constructor == Set)) {
                 this[this.items.length] = this.items[this.items.length] = items[i];
                 this.length++;
             }
         }
     }
 },
 setproto = Set.prototype;
 /*\
  * Set.push
  [ method ]
  **
  * Adds each argument to the current set.
  = (object) original element
 \*/
 setproto.push = function () {
     var item,
         len;
     for (var i = 0, ii = arguments.length; i < ii; i++) {
         item = arguments[i];
         if (item && (item.constructor == elproto.constructor || item.constructor == Set)) {
             len = this.items.length;
             this[len] = this.items[len] = item;
             this.length++;
         }
     }
     return this;
 };
 /*\
  * Set.pop
  [ method ]
  **
  * Removes last element and returns it.
  = (object) element
 \*/
 setproto.pop = function () {
     this.length && delete this[this.length--];
     return this.items.pop();
 };
 /*\
  * Set.forEach
  [ method ]
  **
  * Executes given function for each element in the set.
  *
  * If function returns `false` it will stop loop running.
  **
  > Parameters
  **
  - callback (function) function to run
  - thisArg (object) context object for the callback
  = (object) Set object
 \*/
 setproto.forEach = function (callback, thisArg) {
     for (var i = 0, ii = this.items.length; i < ii; i++) {
         if (callback.call(thisArg, this.items[i], i) === false) {
             return this;
         }
     }
     return this;
 };
 for (var method in elproto) if (elproto[has](method)) {
     setproto[method] = (function (methodname) {
         return function () {
             var arg = arguments;
             return this.forEach(function (el) {
                 el[methodname][apply](el, arg);
             });
         };
     })(method);
 }
 setproto.attr = function (name, value) {
     if (name && R.is(name, array) && R.is(name[0], "object")) {
         for (var j = 0, jj = name.length; j < jj; j++) {
             this.items[j].attr(name[j]);
         }
     } else {
         for (var i = 0, ii = this.items.length; i < ii; i++) {
             this.items[i].attr(name, value);
         }
     }
     return this;
 };
 /*\
  * Set.clear
  [ method ]
  **
  * Removeds all elements from the set
 \*/
 setproto.clear = function () {
     while (this.length) {
         this.pop();
     }
 };
 /*\
  * Set.splice
  [ method ]
  **
  * Removes given element from the set
  **
  > Parameters
  **
  - index (number) position of the deletion
  - count (number) number of element to remove
  - insertionâ€¦ (object) #optional elements to insert
  = (object) set elements that were deleted
 \*/
 setproto.splice = function (index, count, insertion) {
     index = index < 0 ? mmax(this.length + index, 0) : index;
     count = mmax(0, mmin(this.length - index, count));
     var tail = [],
         todel = [],
         args = [],
         i;
     for (i = 2; i < arguments.length; i++) {
         args.push(arguments[i]);
     }
     for (i = 0; i < count; i++) {
         todel.push(this[index + i]);
     }
     for (; i < this.length - index; i++) {
         tail.push(this[index + i]);
     }
     var arglen = args.length;
     for (i = 0; i < arglen + tail.length; i++) {
         this.items[index + i] = this[index + i] = i < arglen ? args[i] : tail[i - arglen];
     }
     i = this.items.length = this.length -= count - arglen;
     while (this[i]) {
         delete this[i++];
     }
     return new Set(todel);
 };
 /*\
  * Set.exclude
  [ method ]
  **
  * Removes given element from the set
  **
  > Parameters
  **
  - element (object) element to remove
  = (boolean) `true` if object was found & removed from the set
 \*/
 setproto.exclude = function (el) {
     for (var i = 0, ii = this.length; i < ii; i++) if (this[i] == el) {
         this.splice(i, 1);
         return true;
     }
 };
 setproto.animate = function (params, ms, easing, callback) {
     (R.is(easing, "function") || !easing) && (callback = easing || null);
     var len = this.items.length,
         i = len,
         item,
         set = this,
         collector;
     if (!len) {
         return this;
     }
     callback && (collector = function () {
         !--len && callback.call(set);
     });
     easing = R.is(easing, string) ? easing : collector;
     var anim = R.animation(params, ms, easing, collector);
     item = this.items[--i].animate(anim);
     while (i--) {
         this.items[i] && !this.items[i].removed && this.items[i].animateWith(item, anim, anim);
         (this.items[i] && !this.items[i].removed) || len--;
     }
     return this;
 };
 setproto.insertAfter = function (el) {
     var i = this.items.length;
     while (i--) {
         this.items[i].insertAfter(el);
     }
     return this;
 };
 setproto.getBBox = function () {
     var x = [],
         y = [],
         x2 = [],
         y2 = [];
     for (var i = this.items.length; i--;) if (!this.items[i].removed) {
         var box = this.items[i].getBBox();
         x.push(box.x);
         y.push(box.y);
         x2.push(box.x + box.width);
         y2.push(box.y + box.height);
     }
     x = mmin[apply](0, x);
     y = mmin[apply](0, y);
     x2 = mmax[apply](0, x2);
     y2 = mmax[apply](0, y2);
     return {
         x: x,
         y: y,
         x2: x2,
         y2: y2,
         width: x2 - x,
         height: y2 - y
     };
 };
 setproto.clone = function (s) {
     s = this.paper.set();
     for (var i = 0, ii = this.items.length; i < ii; i++) {
         s.push(this.items[i].clone());
     }
     return s;
 };
 setproto.toString = function () {
     return "Rapha\xebl\u2018s set";
 };

 setproto.glow = function(glowConfig) {
     var ret = this.paper.set();
     this.forEach(function(shape, index){
         var g = shape.glow(glowConfig);
         if(g != null){
             g.forEach(function(shape2, index2){
                 ret.push(shape2);
             });
         }
     });
     return ret;
 };


 /*\
  * Set.isPointInside
  [ method ]
  **
  * Determine if given point is inside this setâ€™s elements
  **
  > Parameters
  **
  - x (number) x coordinate of the point
  - y (number) y coordinate of the point
  = (boolean) `true` if point is inside any of the set's elements
  \*/
 setproto.isPointInside = function (x, y) {
     var isPointInside = false;
     this.forEach(function (el) {
         if (el.isPointInside(x, y)) {
             console.log('runned');
             isPointInside = true;
             return false; // stop loop
         }
     });
     return isPointInside;
 };

 /*\
  * Raphael.registerFont
  [ method ]
  **
  * Adds given font to the registered set of fonts for RaphaÃ«l. Should be used as an internal call from within CufÃ³nâ€™s font file.
  * Returns original parameter, so it could be used with chaining.
  # <a href="http://wiki.github.com/sorccu/cufon/about">More about CufÃ³n and how to convert your font form TTF, OTF, etc to JavaScript file.</a>
  **
  > Parameters
  **
  - font (object) the font to register
  = (object) the font you passed in
  > Usage
  | Cufon.registerFont(Raphael.registerFont({â€¦}));
 \*/
 R.registerFont = function (font) {
     if (!font.face) {
         return font;
     }
     this.fonts = this.fonts || {};
     var fontcopy = {
             w: font.w,
             face: {},
             glyphs: {}
         },
         family = font.face["font-family"];
     for (var prop in font.face) if (font.face[has](prop)) {
         fontcopy.face[prop] = font.face[prop];
     }
     if (this.fonts[family]) {
         this.fonts[family].push(fontcopy);
     } else {
         this.fonts[family] = [fontcopy];
     }
     if (!font.svg) {
         fontcopy.face["units-per-em"] = toInt(font.face["units-per-em"], 10);
         for (var glyph in font.glyphs) if (font.glyphs[has](glyph)) {
             var path = font.glyphs[glyph];
             fontcopy.glyphs[glyph] = {
                 w: path.w,
                 k: {},
                 d: path.d && "M" + path.d.replace(/[mlcxtrv]/g, function (command) {
                         return {l: "L", c: "C", x: "z", t: "m", r: "l", v: "c"}[command] || "M";
                     }) + "z"
             };
             if (path.k) {
                 for (var k in path.k) if (path[has](k)) {
                     fontcopy.glyphs[glyph].k[k] = path.k[k];
                 }
             }
         }
     }
     return font;
 };
 /*\
  * Paper.getFont
  [ method ]
  **
  * Finds font object in the registered fonts by given parameters. You could specify only one word from the font name, like â€œMyriadâ€� for â€œMyriad Proâ€�.
  **
  > Parameters
  **
  - family (string) font family name or any word from it
  - weight (string) #optional font weight
  - style (string) #optional font style
  - stretch (string) #optional font stretch
  = (object) the font object
  > Usage
  | paper.print(100, 100, "Test string", paper.getFont("Times", 800), 30);
 \*/
 paperproto.getFont = function (family, weight, style, stretch) {
     stretch = stretch || "normal";
     style = style || "normal";
     weight = +weight || {normal: 400, bold: 700, lighter: 300, bolder: 800}[weight] || 400;
     if (!R.fonts) {
         return;
     }
     var font = R.fonts[family];
     if (!font) {
         var name = new RegExp("(^|\\s)" + family.replace(/[^\w\d\s+!~.:_-]/g, E) + "(\\s|$)", "i");
         for (var fontName in R.fonts) if (R.fonts[has](fontName)) {
             if (name.test(fontName)) {
                 font = R.fonts[fontName];
                 break;
             }
         }
     }
     var thefont;
     if (font) {
         for (var i = 0, ii = font.length; i < ii; i++) {
             thefont = font[i];
             if (thefont.face["font-weight"] == weight && (thefont.face["font-style"] == style || !thefont.face["font-style"]) && thefont.face["font-stretch"] == stretch) {
                 break;
             }
         }
     }
     return thefont;
 };
 /*\
  * Paper.print
  [ method ]
  **
  * Creates path that represent given text written using given font at given position with given size.
  * Result of the method is path element that contains whole text as a separate path.
  **
  > Parameters
  **
  - x (number) x position of the text
  - y (number) y position of the text
  - string (string) text to print
  - font (object) font object, see @Paper.getFont
  - size (number) #optional size of the font, default is `16`
  - origin (string) #optional could be `"baseline"` or `"middle"`, default is `"middle"`
  - letter_spacing (number) #optional number in range `-1..1`, default is `0`
  - line_spacing (number) #optional number in range `1..3`, default is `1`
  = (object) resulting path element, which consist of all letters
  > Usage
  | var txt = r.print(10, 50, "print", r.getFont("Museo"), 30).attr({fill: "#fff"});
 \*/
 paperproto.print = function (x, y, string, font, size, origin, letter_spacing, line_spacing) {
     origin = origin || "middle"; // baseline|middle
     letter_spacing = mmax(mmin(letter_spacing || 0, 1), -1);
     line_spacing = mmax(mmin(line_spacing || 1, 3), 1);
     var letters = Str(string)[split](E),
         shift = 0,
         notfirst = 0,
         path = E,
         scale;
     R.is(font, "string") && (font = this.getFont(font));
     if (font) {
         scale = (size || 16) / font.face["units-per-em"];
         var bb = font.face.bbox[split](separator),
             top = +bb[0],
             lineHeight = bb[3] - bb[1],
             shifty = 0,
             height = +bb[1] + (origin == "baseline" ? lineHeight + (+font.face.descent) : lineHeight / 2);
         for (var i = 0, ii = letters.length; i < ii; i++) {
             if (letters[i] == "\n") {
                 shift = 0;
                 curr = 0;
                 notfirst = 0;
                 shifty += lineHeight * line_spacing;
             } else {
                 var prev = notfirst && font.glyphs[letters[i - 1]] || {},
                     curr = font.glyphs[letters[i]];
                 shift += notfirst ? (prev.w || font.w) + (prev.k && prev.k[letters[i]] || 0) + (font.w * letter_spacing) : 0;
                 notfirst = 1;
             }
             if (curr && curr.d) {
                 path += R.transformPath(curr.d, ["t", shift * scale, shifty * scale, "s", scale, scale, top, height, "t", (x - top) / scale, (y - height) / scale]);
             }
         }
     }
     return this.path(path).attr({
         fill: "#000",
         stroke: "none"
     });
 };

 /*\
  * Paper.add
  [ method ]
  **
  * Imports elements in JSON array in format `{type: type, <attributes>}`
  **
  > Parameters
  **
  - json (array)
  = (object) resulting set of imported elements
  > Usage
  | paper.add([
  |     {
  |         type: "circle",
  |         cx: 10,
  |         cy: 10,
  |         r: 5
  |     },
  |     {
  |         type: "rect",
  |         x: 10,
  |         y: 10,
  |         width: 10,
  |         height: 10,
  |         fill: "#fc0"
  |     }
  | ]);
 \*/
 paperproto.add = function (json) {
     if (R.is(json, "array")) {
         var res = this.set(),
             i = 0,
             ii = json.length,
             j;
         for (; i < ii; i++) {
             j = json[i] || {};
             elements[has](j.type) && res.push(this[j.type]().attr(j));
         }
     }
     return res;
 };

 /*\
  * Raphael.format
  [ method ]
  **
  * Simple format function. Replaces construction of type â€œ`{<number>}`â€� to the corresponding argument.
  **
  > Parameters
  **
  - token (string) string to format
  - â€¦ (string) rest of arguments will be treated as parameters for replacement
  = (string) formated string
  > Usage
  | var x = 10,
  |     y = 20,
  |     width = 40,
  |     height = 50;
  | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
  | paper.path(Raphael.format("M{0},{1}h{2}v{3}h{4}z", x, y, width, height, -width));
 \*/
 R.format = function (token, params) {
     var args = R.is(params, array) ? [0][concat](params) : arguments;
     token && R.is(token, string) && args.length - 1 && (token = token.replace(formatrg, function (str, i) {
         return args[++i] == null ? E : args[i];
     }));
     return token || E;
 };
 /*\
  * Raphael.fullfill
  [ method ]
  **
  * A little bit more advanced format function than @Raphael.format. Replaces construction of type â€œ`{<name>}`â€� to the corresponding argument.
  **
  > Parameters
  **
  - token (string) string to format
  - json (object) object which properties will be used as a replacement
  = (string) formated string
  > Usage
  | // this will draw a rectangular shape equivalent to "M10,20h40v50h-40z"
  | paper.path(Raphael.fullfill("M{x},{y}h{dim.width}v{dim.height}h{dim['negative width']}z", {
  |     x: 10,
  |     y: 20,
  |     dim: {
  |         width: 40,
  |         height: 50,
  |         "negative width": -40
  |     }
  | }));
 \*/
 R.fullfill = (function () {
     var tokenRegex = /\{([^\}]+)\}/g,
         objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g, // matches .xxxxx or ["xxxxx"] to run over object properties
         replacer = function (all, key, obj) {
             var res = obj;
             key.replace(objNotationRegex, function (all, name, quote, quotedName, isFunc) {
                 name = name || quotedName;
                 if (res) {
                     if (name in res) {
                         res = res[name];
                     }
                     typeof res == "function" && isFunc && (res = res());
                 }
             });
             res = (res == null || res == obj ? all : res) + "";
             return res;
         };
     return function (str, obj) {
         return String(str).replace(tokenRegex, function (all, key) {
             return replacer(all, key, obj);
         });
     };
 })();
 /*\
  * Raphael.ninja
  [ method ]
  **
  * If you want to leave no trace of RaphaÃ«l (Well, RaphaÃ«l creates only one global variable `Raphael`, but anyway.) You can use `ninja` method.
  * Beware, that in this case plugins could stop working, because they are depending on global variable existance.
  **
  = (object) Raphael object
  > Usage
  | (function (local_raphael) {
  |     var paper = local_raphael(10, 10, 320, 200);
  |     â€¦
  | })(Raphael.ninja());
 \*/
 R.ninja = function () {
     oldRaphael.was ? (g.win.Raphael = oldRaphael.is) : delete Raphael;
     return R;
 };
 /*\
  * Raphael.st
  [ property (object) ]
  **
  * You can add your own method to elements and sets. It is wise to add a set method for each element method
  * you added, so you will be able to call the same method on sets too.
  **
  * See also @Raphael.el.
  > Usage
  | Raphael.el.red = function () {
  |     this.attr({fill: "#f00"});
  | };
  | Raphael.st.red = function () {
  |     this.forEach(function (el) {
  |         el.red();
  |     });
  | };
  | // then use it
  | paper.set(paper.circle(100, 100, 20), paper.circle(110, 100, 20)).red();
 \*/
 R.st = setproto;
 // Firefox <3.6 fix: http://webreflection.blogspot.com/2009/11/195-chars-to-help-lazy-loading.html
 (function (doc, loaded, f) {
     if (doc.readyState == null && doc.addEventListener){
         doc.addEventListener(loaded, f = function () {
             doc.removeEventListener(loaded, f, false);
             doc.readyState = "complete";
         }, false);
         doc.readyState = "loading";
     }
     function isLoaded() {
         (/in/).test(doc.readyState) ? setTimeout(isLoaded, 9) : R.eve("raphael.DOMload");
     }
     isLoaded();
 })(document, "DOMContentLoaded");

 eve.on("raphael.DOMload", function () {
     loaded = true;
 });

//â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”� \\
//â”‚ RaphaÃ«l - JavaScript Vector Library                                 â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ SVG Module                                                          â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   â”‚ \\
//â”‚ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             â”‚ \\
//â”‚ Licensed under the MIT (http://raphaeljs.com/license.html) license. â”‚ \\
//â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ \\

(function(){
 if (!R.svg) {
     return;
 }
 var has = "hasOwnProperty",
     Str = String,
     toFloat = parseFloat,
     toInt = parseInt,
     math = Math,
     mmax = math.max,
     abs = math.abs,
     pow = math.pow,
     separator = /[, ]+/,
     eve = R.eve,
     E = "",
     S = " ";
 var xlink = "http://www.w3.org/1999/xlink",
     markers = {
         block: "M5,0 0,2.5 5,5z",
         classic: "M5,0 0,2.5 5,5 3.5,3 3.5,2z",
         diamond: "M2.5,0 5,2.5 2.5,5 0,2.5z",
         open: "M6,1 1,3.5 6,6",
         oval: "M2.5,0A2.5,2.5,0,0,1,2.5,5 2.5,2.5,0,0,1,2.5,0z"
     },
     markerCounter = {};
 R.toString = function () {
     return  "Your browser supports SVG.\nYou are running Rapha\xebl " + this.version;
 };
 var $ = function (el, attr) {
     if (attr) {
         if (typeof el == "string") {
             el = $(el);
         }
         for (var key in attr) if (attr[has](key)) {
             if (key.substring(0, 6) == "xlink:") {
                 el.setAttributeNS(xlink, key.substring(6), Str(attr[key]));
             } else {
                 el.setAttribute(key, Str(attr[key]));
             }
         }
     } else {
         el = R._g.doc.createElementNS("http://www.w3.org/2000/svg", el);
         el.style && (el.style.webkitTapHighlightColor = "rgba(0,0,0,0)");
     }
     return el;
 },
 addGradientFill = function (element, gradient) {
     var type = "linear",
         id = element.id + gradient,
         fx = .5, fy = .5,
         o = element.node,
         SVG = element.paper,
         s = o.style,
         el = R._g.doc.getElementById(id);
     if (!el) {
         gradient = Str(gradient).replace(R._radial_gradient, function (all, _fx, _fy) {
             type = "radial";
             if (_fx && _fy) {
                 fx = toFloat(_fx);
                 fy = toFloat(_fy);
                 var dir = ((fy > .5) * 2 - 1);
                 pow(fx - .5, 2) + pow(fy - .5, 2) > .25 &&
                     (fy = math.sqrt(.25 - pow(fx - .5, 2)) * dir + .5) &&
                     fy != .5 &&
                     (fy = fy.toFixed(5) - 1e-5 * dir);
             }
             return E;
         });
         gradient = gradient.split(/\s*\-\s*/);
         if (type == "linear") {
             var angle = gradient.shift();
             angle = -toFloat(angle);
             if (isNaN(angle)) {
                 return null;
             }
             var vector = [0, 0, math.cos(R.rad(angle)), math.sin(R.rad(angle))],
                 max = 1 / (mmax(abs(vector[2]), abs(vector[3])) || 1);
             vector[2] *= max;
             vector[3] *= max;
             if (vector[2] < 0) {
                 vector[0] = -vector[2];
                 vector[2] = 0;
             }
             if (vector[3] < 0) {
                 vector[1] = -vector[3];
                 vector[3] = 0;
             }
         }
         var dots = R._parseDots(gradient);
         if (!dots) {
             return null;
         }
         id = id.replace(/[\(\)\s,\xb0#]/g, "_");
         
         if (element.gradient && id != element.gradient.id) {
             SVG.defs.removeChild(element.gradient);
             delete element.gradient;
         }

         if (!element.gradient) {
             el = $(type + "Gradient", {id: id});
             element.gradient = el;
             $(el, type == "radial" ? {
                 fx: fx,
                 fy: fy
             } : {
                 x1: vector[0],
                 y1: vector[1],
                 x2: vector[2],
                 y2: vector[3],
                 gradientTransform: element.matrix.invert()
             });
             SVG.defs.appendChild(el);
             for (var i = 0, ii = dots.length; i < ii; i++) {
                 el.appendChild($("stop", {
                     offset: dots[i].offset ? dots[i].offset : i ? "100%" : "0%",
                     "stop-color": dots[i].color || "#fff"
                 }));
             }
         }
     }
     $(o, {
         fill: "url(#" + id + ")",
         opacity: 1,
         "fill-opacity": 1
     });
     s.fill = E;
     s.opacity = 1;
     s.fillOpacity = 1;
     return 1;
 },
 updatePosition = function (o) {
     var bbox = o.getBBox(1);
     $(o.pattern, {patternTransform: o.matrix.invert() + " translate(" + bbox.x + "," + bbox.y + ")"});
 },
 addArrow = function (o, value, isEnd) {
     if (o.type == "path") {
         var values = Str(value).toLowerCase().split("-"),
             p = o.paper,
             se = isEnd ? "end" : "start",
             node = o.node,
             attrs = o.attrs,
             stroke = attrs["stroke-width"],
             i = values.length,
             type = "classic",
             from,
             to,
             dx,
             refX,
             attr,
             w = 3,
             h = 3,
             t = 5;
         while (i--) {
             switch (values[i]) {
                 case "block":
                 case "classic":
                 case "oval":
                 case "diamond":
                 case "open":
                 case "none":
                     type = values[i];
                     break;
                 case "wide": h = 5; break;
                 case "narrow": h = 2; break;
                 case "long": w = 5; break;
                 case "short": w = 2; break;
             }
         }
         if (type == "open") {
             w += 2;
             h += 2;
             t += 2;
             dx = 1;
             refX = isEnd ? 4 : 1;
             attr = {
                 fill: "none",
                 stroke: attrs.stroke
             };
         } else {
             refX = dx = w / 2;
             attr = {
                 fill: attrs.stroke,
                 stroke: "none"
             };
         }
         if (o._.arrows) {
             if (isEnd) {
                 o._.arrows.endPath && markerCounter[o._.arrows.endPath]--;
                 o._.arrows.endMarker && markerCounter[o._.arrows.endMarker]--;
             } else {
                 o._.arrows.startPath && markerCounter[o._.arrows.startPath]--;
                 o._.arrows.startMarker && markerCounter[o._.arrows.startMarker]--;
             }
         } else {
             o._.arrows = {};
         }
         if (type != "none") {
             var pathId = "raphael-marker-" + type,
                 markerId = "raphael-marker-" + se + type + w + h;
             if (!R._g.doc.getElementById(pathId)) {
                 p.defs.appendChild($($("path"), {
                     "stroke-linecap": "round",
                     d: markers[type],
                     id: pathId
                 }));
                 markerCounter[pathId] = 1;
             } else {
                 markerCounter[pathId]++;
             }
             var marker = R._g.doc.getElementById(markerId),
                 use;
             if (!marker) {
                 marker = $($("marker"), {
                     id: markerId,
                     markerHeight: h,
                     markerWidth: w,
                     orient: "auto",
                     refX: refX,
                     refY: h / 2
                 });
                 use = $($("use"), {
                     "xlink:href": "#" + pathId,
                     transform: (isEnd ? "rotate(180 " + w / 2 + " " + h / 2 + ") " : E) + "scale(" + w / t + "," + h / t + ")",
                     "stroke-width": (1 / ((w / t + h / t) / 2)).toFixed(4)
                 });
                 marker.appendChild(use);
                 p.defs.appendChild(marker);
                 markerCounter[markerId] = 1;
             } else {
                 markerCounter[markerId]++;
                 use = marker.getElementsByTagName("use")[0];
             }
             $(use, attr);
             var delta = dx * (type != "diamond" && type != "oval");
             if (isEnd) {
                 from = o._.arrows.startdx * stroke || 0;
                 to = R.getTotalLength(attrs.path) - delta * stroke;
             } else {
                 from = delta * stroke;
                 to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
             }
             attr = {};
             attr["marker-" + se] = "url(#" + markerId + ")";
             if (to || from) {
                 attr.d = R.getSubpath(attrs.path, from, to);
             }
             $(node, attr);
             o._.arrows[se + "Path"] = pathId;
             o._.arrows[se + "Marker"] = markerId;
             o._.arrows[se + "dx"] = delta;
             o._.arrows[se + "Type"] = type;
             o._.arrows[se + "String"] = value;
         } else {
             if (isEnd) {
                 from = o._.arrows.startdx * stroke || 0;
                 to = R.getTotalLength(attrs.path) - from;
             } else {
                 from = 0;
                 to = R.getTotalLength(attrs.path) - (o._.arrows.enddx * stroke || 0);
             }
             o._.arrows[se + "Path"] && $(node, {d: R.getSubpath(attrs.path, from, to)});
             delete o._.arrows[se + "Path"];
             delete o._.arrows[se + "Marker"];
             delete o._.arrows[se + "dx"];
             delete o._.arrows[se + "Type"];
             delete o._.arrows[se + "String"];
         }
         for (attr in markerCounter) if (markerCounter[has](attr) && !markerCounter[attr]) {
             var item = R._g.doc.getElementById(attr);
             item && item.parentNode.removeChild(item);
         }
     }
 },
 dasharray = {
     "": [0],
     "none": [0],
     "-": [3, 1],
     ".": [1, 1],
     "-.": [3, 1, 1, 1],
     "-..": [3, 1, 1, 1, 1, 1],
     ". ": [1, 3],
     "- ": [4, 3],
     "--": [8, 3],
     "- .": [4, 3, 1, 3],
     "--.": [8, 3, 1, 3],
     "--..": [8, 3, 1, 3, 1, 3]
 },
 addDashes = function (o, value, params) {
     value = dasharray[Str(value).toLowerCase()];
     if (value) {
         var width = o.attrs["stroke-width"] || "1",
             butt = {round: width, square: width, butt: 0}[o.attrs["stroke-linecap"] || params["stroke-linecap"]] || 0,
             dashes = [],
             i = value.length;
         while (i--) {
             dashes[i] = value[i] * width + ((i % 2) ? 1 : -1) * butt;
         }
         $(o.node, {"stroke-dasharray": dashes.join(",")});
     }
 },
 setFillAndStroke = function (o, params) {
     var node = o.node,
         attrs = o.attrs,
         vis = node.style.visibility;
     node.style.visibility = "hidden";
     for (var att in params) {
         if (params[has](att)) {
             if (!R._availableAttrs[has](att)) {
                 continue;
             }
             var value = params[att];
             attrs[att] = value;
             switch (att) {
                 case "blur":
                     o.blur(value);
                     break;
                 case "href":
                 case "title":
                     var hl = $("title");
                     var val = R._g.doc.createTextNode(value);
                     hl.appendChild(val);
                     node.appendChild(hl);
                     break;
                 case "target":
                     var pn = node.parentNode;
                     if (pn.tagName.toLowerCase() != "a") {
                         var hl = $("a");
                         pn.insertBefore(hl, node);
                         hl.appendChild(node);
                         pn = hl;
                     }
                     if (att == "target") {
                         pn.setAttributeNS(xlink, "show", value == "blank" ? "new" : value);
                     } else {
                         pn.setAttributeNS(xlink, att, value);
                     }
                     break;
                 case "cursor":
                     node.style.cursor = value;
                     break;
                 case "transform":
                     o.transform(value);
                     break;
                 case "arrow-start":
                     addArrow(o, value);
                     break;
                 case "arrow-end":
                     addArrow(o, value, 1);
                     break;
                 case "clip-rect":
                     var rect = Str(value).split(separator);
                     if (rect.length == 4) {
                         o.clip && o.clip.parentNode.parentNode.removeChild(o.clip.parentNode);
                         var el = $("clipPath"),
                             rc = $("rect");
                         el.id = R.createUUID();
                         $(rc, {
                             x: rect[0],
                             y: rect[1],
                             width: rect[2],
                             height: rect[3]
                         });
                         el.appendChild(rc);
                         o.paper.defs.appendChild(el);
                         $(node, {"clip-path": "url(#" + el.id + ")"});
                         o.clip = rc;
                     }
                     if (!value) {
                         var path = node.getAttribute("clip-path");
                         if (path) {
                             var clip = R._g.doc.getElementById(path.replace(/(^url\(#|\)$)/g, E));
                             clip && clip.parentNode.removeChild(clip);
                             $(node, {"clip-path": E});
                             delete o.clip;
                         }
                     }
                 break;
                 case "path":
                     if (o.type == "path") {
                         $(node, {d: value ? attrs.path = R._pathToAbsolute(value) : "M0,0"});
                         o._.dirty = 1;
                         if (o._.arrows) {
                             "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                             "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                         }
                     }
                     break;
                 case "width":
                     node.setAttribute(att, value);
                     o._.dirty = 1;
                     if (attrs.fx) {
                         att = "x";
                         value = attrs.x;
                     } else {
                         break;
                     }
                 case "x":
                     if (attrs.fx) {
                         value = -attrs.x - (attrs.width || 0);
                     }
                 case "rx":
                     if (att == "rx" && o.type == "rect") {
                         break;
                     }
                 case "cx":
                     node.setAttribute(att, value);
                     o.pattern && updatePosition(o);
                     o._.dirty = 1;
                     break;
                 case "height":
                     node.setAttribute(att, value);
                     o._.dirty = 1;
                     if (attrs.fy) {
                         att = "y";
                         value = attrs.y;
                     } else {
                         break;
                     }
                 case "y":
                     if (attrs.fy) {
                         value = -attrs.y - (attrs.height || 0);
                     }
                 case "ry":
                     if (att == "ry" && o.type == "rect") {
                         break;
                     }
                 case "cy":
                     node.setAttribute(att, value);
                     o.pattern && updatePosition(o);
                     o._.dirty = 1;
                     break;
                 case "r":
                     if (o.type == "rect") {
                         $(node, {rx: value, ry: value});
                     } else {
                         node.setAttribute(att, value);
                     }
                     o._.dirty = 1;
                     break;
                 case "src":
                     if (o.type == "image") {
                         node.setAttributeNS(xlink, "href", value);
                     }
                     break;
                 case "stroke-width":
                     if (o._.sx != 1 || o._.sy != 1) {
                         value /= mmax(abs(o._.sx), abs(o._.sy)) || 1;
                     }
                     if (o.paper._vbSize) {
                         value *= o.paper._vbSize;
                     }
                     node.setAttribute(att, value);
                     if (attrs["stroke-dasharray"]) {
                         addDashes(o, attrs["stroke-dasharray"], params);
                     }
                     if (o._.arrows) {
                         "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                         "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                     }
                     break;
                 case "stroke-dasharray":
                     addDashes(o, value, params);
                     break;
                 case "fill":
                     var isURL = Str(value).match(R._ISURL);
                     if (isURL) {
                         el = $("pattern");
                         var ig = $("image");
                         el.id = R.createUUID();
                         $(el, {x: 0, y: 0, patternUnits: "userSpaceOnUse", height: 1, width: 1});
                         $(ig, {x: 0, y: 0, "xlink:href": isURL[1]});
                         el.appendChild(ig);

                         (function (el) {
                             R._preload(isURL[1], function () {
                                 var w = this.offsetWidth,
                                     h = this.offsetHeight;
                                 $(el, {width: w, height: h});
                                 $(ig, {width: w, height: h});
                                 o.paper.safari();
                             });
                         })(el);
                         o.paper.defs.appendChild(el);
                         $(node, {fill: "url(#" + el.id + ")"});
                         o.pattern = el;
                         o.pattern && updatePosition(o);
                         break;
                     }
                     var clr = R.getRGB(value);
                     if (!clr.error) {
                         delete params.gradient;
                         delete attrs.gradient;
                         !R.is(attrs.opacity, "undefined") &&
                             R.is(params.opacity, "undefined") &&
                             $(node, {opacity: attrs.opacity});
                         !R.is(attrs["fill-opacity"], "undefined") &&
                             R.is(params["fill-opacity"], "undefined") &&
                             $(node, {"fill-opacity": attrs["fill-opacity"]});
                     } else if ((o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value)) {
                         if ("opacity" in attrs || "fill-opacity" in attrs) {
                             var gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                             if (gradient) {
                                 var stops = gradient.getElementsByTagName("stop");
                                 $(stops[stops.length - 1], {"stop-opacity": ("opacity" in attrs ? attrs.opacity : 1) * ("fill-opacity" in attrs ? attrs["fill-opacity"] : 1)});
                             }
                         }
                         attrs.gradient = value;
                         attrs.fill = "none";
                         break;
                     }
                     clr[has]("opacity") && $(node, {"fill-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                 case "stroke":
                     clr = R.getRGB(value);
                     node.setAttribute(att, clr.hex);
                     att == "stroke" && clr[has]("opacity") && $(node, {"stroke-opacity": clr.opacity > 1 ? clr.opacity / 100 : clr.opacity});
                     if (att == "stroke" && o._.arrows) {
                         "startString" in o._.arrows && addArrow(o, o._.arrows.startString);
                         "endString" in o._.arrows && addArrow(o, o._.arrows.endString, 1);
                     }
                     break;
                 case "gradient":
                     (o.type == "circle" || o.type == "ellipse" || Str(value).charAt() != "r") && addGradientFill(o, value);
                     break;
                 case "opacity":
                     if (attrs.gradient && !attrs[has]("stroke-opacity")) {
                         $(node, {"stroke-opacity": value > 1 ? value / 100 : value});
                     }
                     // fall
                 case "fill-opacity":
                     if (attrs.gradient) {
                         gradient = R._g.doc.getElementById(node.getAttribute("fill").replace(/^url\(#|\)$/g, E));
                         if (gradient) {
                             stops = gradient.getElementsByTagName("stop");
                             $(stops[stops.length - 1], {"stop-opacity": value});
                         }
                         break;
                     }
                 default:
                     att == "font-size" && (value = toInt(value, 10) + "px");
                     var cssrule = att.replace(/(\-.)/g, function (w) {
                         return w.substring(1).toUpperCase();
                     });
                     node.style[cssrule] = value;
                     o._.dirty = 1;
                     node.setAttribute(att, value);
                     break;
             }
         }
     }

     tuneText(o, params);
     node.style.visibility = vis;
 },
 leading = 1.2,
 tuneText = function (el, params) {
     if (el.type != "text" || !(params[has]("text") || params[has]("font") || params[has]("font-size") || params[has]("x") || params[has]("y"))) {
         return;
     }
     var a = el.attrs,
         node = el.node,
         fontSize = node.firstChild ? toInt(R._g.doc.defaultView.getComputedStyle(node.firstChild, E).getPropertyValue("font-size"), 10) : 10;

     if (params[has]("text")) {
         a.text = params.text;
         while (node.firstChild) {
             node.removeChild(node.firstChild);
         }
         var texts = Str(params.text).split("\n"),
             tspans = [],
             tspan;
         for (var i = 0, ii = texts.length; i < ii; i++) {
             tspan = $("tspan");
             i && $(tspan, {dy: fontSize * leading, x: a.x});
             tspan.appendChild(R._g.doc.createTextNode(texts[i]));
             node.appendChild(tspan);
             tspans[i] = tspan;
         }
     } else {
         tspans = node.getElementsByTagName("tspan");
         for (i = 0, ii = tspans.length; i < ii; i++) if (i) {
             $(tspans[i], {dy: fontSize * leading, x: a.x});
         } else {
             $(tspans[0], {dy: 0});
         }
     }
     $(node, {x: a.x, y: a.y});
     el._.dirty = 1;
     var bb = el._getBBox(),
         dif = a.y - (bb.y + bb.height / 2);
         dif = (dif > 10) ? 4 : dif;
     dif && R.is(dif, "finite") && $(tspans[0], {dy: dif});
 },
 Element = function (node, svg) {
     var X = 0,
         Y = 0;
     /*\
      * Element.node
      [ property (object) ]
      **
      * Gives you a reference to the DOM object, so you can assign event handlers or just mess around.
      **
      * Note: Donâ€™t mess with it.
      > Usage
      | // draw a circle at coordinate 10,10 with radius of 10
      | var c = paper.circle(10, 10, 10);
      | c.node.onclick = function () {
      |     c.attr("fill", "red");
      | };
     \*/
     this[0] = this.node = node;
     /*\
      * Element.raphael
      [ property (object) ]
      **
      * Internal reference to @Raphael object. In case it is not available.
      > Usage
      | Raphael.el.red = function () {
      |     var hsb = this.paper.raphael.rgb2hsb(this.attr("fill"));
      |     hsb.h = 1;
      |     this.attr({fill: this.paper.raphael.hsb2rgb(hsb).hex});
      | }
     \*/
     node.raphael = true;
     /*\
      * Element.id
      [ property (number) ]
      **
      * Unique id of the element. Especially usesful when you want to listen to events of the element, 
      * because all events are fired in format `<module>.<action>.<id>`. Also useful for @Paper.getById method.
     \*/
     this.id = R._oid++;
     node.raphaelid = this.id;
     this.matrix = R.matrix();
     this.realPath = null;
     /*\
      * Element.paper
      [ property (object) ]
      **
      * Internal reference to â€œpaperâ€� where object drawn. Mainly for use in plugins and element extensions.
      > Usage
      | Raphael.el.cross = function () {
      |     this.attr({fill: "red"});
      |     this.paper.path("M10,10L50,50M50,10L10,50")
      |         .attr({stroke: "red"});
      | }
     \*/
     this.paper = svg;
     this.attrs = this.attrs || {};
     this._ = {
         transform: [],
         sx: 1,
         sy: 1,
         deg: 0,
         dx: 0,
         dy: 0,
         dirty: 1
     };
     !svg.bottom && (svg.bottom = this);
     /*\
      * Element.prev
      [ property (object) ]
      **
      * Reference to the previous element in the hierarchy.
     \*/
     this.prev = svg.top;
     svg.top && (svg.top.next = this);
     svg.top = this;
     /*\
      * Element.next
      [ property (object) ]
      **
      * Reference to the next element in the hierarchy.
     \*/
     this.next = null;
 },
 elproto = R.el;

 Element.prototype = elproto;
 elproto.constructor = Element;

 R._engine.path = function (pathString, SVG) {
     var el = $("path");
     SVG.canvas && SVG.canvas.appendChild(el);
     var p = new Element(el, SVG);
     p.type = "path";
     setFillAndStroke(p, {
         fill: "none",
         stroke: "#000",
         path: pathString
     });
     return p;
 };
 /*\
  * Element.rotate
  [ method ]
  **
  * Deprecated! Use @Element.transform instead.
  * Adds rotation by given angle around given point to the list of
  * transformations of the element.
  > Parameters
  - deg (number) angle in degrees
  - cx (number) #optional x coordinate of the centre of rotation
  - cy (number) #optional y coordinate of the centre of rotation
  * If cx & cy arenâ€™t specified centre of the shape is used as a point of rotation.
  = (object) @Element
 \*/
 elproto.rotate = function (deg, cx, cy) {
     if (this.removed) {
         return this;
     }
     deg = Str(deg).split(separator);
     if (deg.length - 1) {
         cx = toFloat(deg[1]);
         cy = toFloat(deg[2]);
     }
     deg = toFloat(deg[0]);
     (cy == null) && (cx = cy);
     if (cx == null || cy == null) {
         var bbox = this.getBBox(1);
         cx = bbox.x + bbox.width / 2;
         cy = bbox.y + bbox.height / 2;
     }
     this.transform(this._.transform.concat([["r", deg, cx, cy]]));
     return this;
 };
 /*\
  * Element.scale
  [ method ]
  **
  * Deprecated! Use @Element.transform instead.
  * Adds scale by given amount relative to given point to the list of
  * transformations of the element.
  > Parameters
  - sx (number) horisontal scale amount
  - sy (number) vertical scale amount
  - cx (number) #optional x coordinate of the centre of scale
  - cy (number) #optional y coordinate of the centre of scale
  * If cx & cy arenâ€™t specified centre of the shape is used instead.
  = (object) @Element
 \*/
 elproto.scale = function (sx, sy, cx, cy) {
     if (this.removed) {
         return this;
     }
     sx = Str(sx).split(separator);
     if (sx.length - 1) {
         sy = toFloat(sx[1]);
         cx = toFloat(sx[2]);
         cy = toFloat(sx[3]);
     }
     sx = toFloat(sx[0]);
     (sy == null) && (sy = sx);
     (cy == null) && (cx = cy);
     if (cx == null || cy == null) {
         var bbox = this.getBBox(1);
     }
     cx = cx == null ? bbox.x + bbox.width / 2 : cx;
     cy = cy == null ? bbox.y + bbox.height / 2 : cy;
     this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
     return this;
 };
 /*\
  * Element.translate
  [ method ]
  **
  * Deprecated! Use @Element.transform instead.
  * Adds translation by given amount to the list of transformations of the element.
  > Parameters
  - dx (number) horisontal shift
  - dy (number) vertical shift
  = (object) @Element
 \*/
 elproto.translate = function (dx, dy) {
     if (this.removed) {
         return this;
     }
     dx = Str(dx).split(separator);
     if (dx.length - 1) {
         dy = toFloat(dx[1]);
     }
     dx = toFloat(dx[0]) || 0;
     dy = +dy || 0;
     this.transform(this._.transform.concat([["t", dx, dy]]));
     return this;
 };
 /*\
  * Element.transform
  [ method ]
  **
  * Adds transformation to the element which is separate to other attributes,
  * i.e. translation doesnâ€™t change `x` or `y` of the rectange. The format
  * of transformation string is similar to the path string syntax:
  | "t100,100r30,100,100s2,2,100,100r45s1.5"
  * Each letter is a command. There are four commands: `t` is for translate, `r` is for rotate, `s` is for
  * scale and `m` is for matrix.
  *
  * There are also alternative â€œabsoluteâ€� translation, rotation and scale: `T`, `R` and `S`. They will not take previous transformation into account. For example, `...T100,0` will always move element 100 px horisontally, while `...t100,0` could move it vertically if there is `r90` before. Just compare results of `r90t100,0` and `r90T100,0`.
  *
  * So, the example line above could be read like â€œtranslate by 100, 100; rotate 30Â° around 100, 100; scale twice around 100, 100;
  * rotate 45Â° around centre; scale 1.5 times relative to centreâ€�. As you can see rotate and scale commands have origin
  * coordinates as optional parameters, the default is the centre point of the element.
  * Matrix accepts six parameters.
  > Usage
  | var el = paper.rect(10, 20, 300, 200);
  | // translate 100, 100, rotate 45Â°, translate -100, 0
  | el.transform("t100,100r45t-100,0");
  | // if you want you can append or prepend transformations
  | el.transform("...t50,50");
  | el.transform("s2...");
  | // or even wrap
  | el.transform("t50,50...t-50-50");
  | // to reset transformation call method with empty string
  | el.transform("");
  | // to get current value call it without parameters
  | console.log(el.transform());
  > Parameters
  - tstr (string) #optional transformation string
  * If tstr isnâ€™t specified
  = (string) current transformation string
  * else
  = (object) @Element
 \*/
 elproto.transform = function (tstr) {
     var _ = this._;
     if (tstr == null) {
         return _.transform;
     }
     R._extractTransform(this, tstr);

     this.clip && $(this.clip, {transform: this.matrix.invert()});
     this.pattern && updatePosition(this);
     this.node && $(this.node, {transform: this.matrix});
 
     if (_.sx != 1 || _.sy != 1) {
         var sw = this.attrs[has]("stroke-width") ? this.attrs["stroke-width"] : 1;
         this.attr({"stroke-width": sw});
     }

     return this;
 };
 /*\
  * Element.hide
  [ method ]
  **
  * Makes element invisible. See @Element.show.
  = (object) @Element
 \*/
 elproto.hide = function () {
     !this.removed && this.paper.safari(this.node.style.display = "none");
     return this;
 };
 /*\
  * Element.show
  [ method ]
  **
  * Makes element visible. See @Element.hide.
  = (object) @Element
 \*/
 elproto.show = function () {
     !this.removed && this.paper.safari(this.node.style.display = "");
     return this;
 };
 /*\
  * Element.remove
  [ method ]
  **
  * Removes element from the paper.
 \*/
 elproto.remove = function () {
     if (this.removed || !this.node.parentNode) {
         return;
     }
     var paper = this.paper;
     paper.__set__ && paper.__set__.exclude(this);
     eve.unbind("raphael.*.*." + this.id);
     if (this.gradient) {
         paper.defs.removeChild(this.gradient);
     }
     R._tear(this, paper);
     if (this.node.parentNode.tagName.toLowerCase() == "a") {
         this.node.parentNode.parentNode.removeChild(this.node.parentNode);
     } else {
         this.node.parentNode.removeChild(this.node);
     }
     for (var i in this) {
         this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
     }
     this.removed = true;
 };
 elproto._getBBox = function () {
     if (this.node.style.display == "none") {
         this.show();
         var hide = true;
     }
     var bbox = {};
     try {
         bbox = this.node.getBBox();
     } catch(e) {
         // Firefox 3.0.x plays badly here
     } finally {
         bbox = bbox || {};
     }
     hide && this.hide();
     return bbox;
 };
 /*\
  * Element.attr
  [ method ]
  **
  * Sets the attributes of the element.
  > Parameters
  - attrName (string) attributeâ€™s name
  - value (string) value
  * or
  - params (object) object of name/value pairs
  * or
  - attrName (string) attributeâ€™s name
  * or
  - attrNames (array) in this case method returns array of current values for given attribute names
  = (object) @Element if attrsName & value or params are passed in.
  = (...) value of the attribute if only attrsName is passed in.
  = (array) array of values of the attribute if attrsNames is passed in.
  = (object) object of attributes if nothing is passed in.
  > Possible parameters
  # <p>Please refer to the <a href="http://www.w3.org/TR/SVG/" title="The W3C Recommendation for the SVG language describes these properties in detail.">SVG specification</a> for an explanation of these parameters.</p>
  o arrow-end (string) arrowhead on the end of the path. The format for string is `<type>[-<width>[-<length>]]`. Possible types: `classic`, `block`, `open`, `oval`, `diamond`, `none`, width: `wide`, `narrow`, `medium`, length: `long`, `short`, `midium`.
  o clip-rect (string) comma or space separated values: x, y, width and height
  o cursor (string) CSS type of the cursor
  o cx (number) the x-axis coordinate of the center of the circle, or ellipse
  o cy (number) the y-axis coordinate of the center of the circle, or ellipse
  o fill (string) colour, gradient or image
  o fill-opacity (number)
  o font (string)
  o font-family (string)
  o font-size (number) font size in pixels
  o font-weight (string)
  o height (number)
  o href (string) URL, if specified element behaves as hyperlink
  o opacity (number)
  o path (string) SVG path string format
  o r (number) radius of the circle, ellipse or rounded corner on the rect
  o rx (number) horisontal radius of the ellipse
  o ry (number) vertical radius of the ellipse
  o src (string) image URL, only works for @Element.image element
  o stroke (string) stroke colour
  o stroke-dasharray (string) [â€œâ€�, â€œ`-`â€�, â€œ`.`â€�, â€œ`-.`â€�, â€œ`-..`â€�, â€œ`. `â€�, â€œ`- `â€�, â€œ`--`â€�, â€œ`- .`â€�, â€œ`--.`â€�, â€œ`--..`â€�]
  o stroke-linecap (string) [â€œ`butt`â€�, â€œ`square`â€�, â€œ`round`â€�]
  o stroke-linejoin (string) [â€œ`bevel`â€�, â€œ`round`â€�, â€œ`miter`â€�]
  o stroke-miterlimit (number)
  o stroke-opacity (number)
  o stroke-width (number) stroke width in pixels, default is '1'
  o target (string) used with href
  o text (string) contents of the text element. Use `\n` for multiline text
  o text-anchor (string) [â€œ`start`â€�, â€œ`middle`â€�, â€œ`end`â€�], default is â€œ`middle`â€�
  o title (string) will create tooltip with a given text
  o transform (string) see @Element.transform
  o width (number)
  o x (number)
  o y (number)
  > Gradients
  * Linear gradient format: â€œ`â€¹angleâ€º-â€¹colourâ€º[-â€¹colourâ€º[:â€¹offsetâ€º]]*-â€¹colourâ€º`â€�, example: â€œ`90-#fff-#000`â€� â€“ 90Â°
  * gradient from white to black or â€œ`0-#fff-#f00:20-#000`â€� â€“ 0Â° gradient from white via red (at 20%) to black.
  *
  * radial gradient: â€œ`r[(â€¹fxâ€º, â€¹fyâ€º)]â€¹colourâ€º[-â€¹colourâ€º[:â€¹offsetâ€º]]*-â€¹colourâ€º`â€�, example: â€œ`r#fff-#000`â€� â€“
  * gradient from white to black or â€œ`r(0.25, 0.75)#fff-#000`â€� â€“ gradient from white to black with focus point
  * at 0.25, 0.75. Focus point coordinates are in 0..1 range. Radial gradients can only be applied to circles and ellipses.
  > Path String
  # <p>Please refer to <a href="http://www.w3.org/TR/SVG/paths.html#PathData" title="Details of a pathâ€™s data attributeâ€™s format are described in the SVG specification.">SVG documentation regarding path string</a>. RaphaÃ«l fully supports it.</p>
  > Colour Parsing
  # <ul>
  #     <li>Colour name (â€œ<code>red</code>â€�, â€œ<code>green</code>â€�, â€œ<code>cornflowerblue</code>â€�, etc)</li>
  #     <li>#â€¢â€¢â€¢ â€” shortened HTML colour: (â€œ<code>#000</code>â€�, â€œ<code>#fc0</code>â€�, etc)</li>
  #     <li>#â€¢â€¢â€¢â€¢â€¢â€¢ â€” full length HTML colour: (â€œ<code>#000000</code>â€�, â€œ<code>#bd2300</code>â€�)</li>
  #     <li>rgb(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” red, green and blue channelsâ€™ values: (â€œ<code>rgb(200,&nbsp;100,&nbsp;0)</code>â€�)</li>
  #     <li>rgb(â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%) â€” same as above, but in %: (â€œ<code>rgb(100%,&nbsp;175%,&nbsp;0%)</code>â€�)</li>
  #     <li>rgba(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” red, green and blue channelsâ€™ values: (â€œ<code>rgba(200,&nbsp;100,&nbsp;0, .5)</code>â€�)</li>
  #     <li>rgba(â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%) â€” same as above, but in %: (â€œ<code>rgba(100%,&nbsp;175%,&nbsp;0%, 50%)</code>â€�)</li>
  #     <li>hsb(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” hue, saturation and brightness values: (â€œ<code>hsb(0.5,&nbsp;0.25,&nbsp;1)</code>â€�)</li>
  #     <li>hsb(â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%) â€” same as above, but in %</li>
  #     <li>hsba(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” same as above, but with opacity</li>
  #     <li>hsl(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” almost the same as hsb, see <a href="http://en.wikipedia.org/wiki/HSL_and_HSV" title="HSL and HSV - Wikipedia, the free encyclopedia">Wikipedia page</a></li>
  #     <li>hsl(â€¢â€¢â€¢%, â€¢â€¢â€¢%, â€¢â€¢â€¢%) â€” same as above, but in %</li>
  #     <li>hsla(â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢, â€¢â€¢â€¢) â€” same as above, but with opacity</li>
  #     <li>Optionally for hsb and hsl you could specify hue as a degree: â€œ<code>hsl(240deg,&nbsp;1,&nbsp;.5)</code>â€� or, if you want to go fancy, â€œ<code>hsl(240Â°,&nbsp;1,&nbsp;.5)</code>â€�</li>
  # </ul>
 \*/
 elproto.attr = function (name, value) {
     if (this.removed) {
         return this;
     }
     if (name == null) {
         var res = {};
         for (var a in this.attrs) if (this.attrs[has](a)) {
             res[a] = this.attrs[a];
         }
         res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
         res.transform = this._.transform;
         return res;
     }
     if (value == null && R.is(name, "string")) {
         if (name == "fill" && this.attrs.fill == "none" && this.attrs.gradient) {
             return this.attrs.gradient;
         }
         if (name == "transform") {
             return this._.transform;
         }
         var names = name.split(separator),
             out = {};
         for (var i = 0, ii = names.length; i < ii; i++) {
             name = names[i];
             if (name in this.attrs) {
                 out[name] = this.attrs[name];
             } else if (R.is(this.paper.customAttributes[name], "function")) {
                 out[name] = this.paper.customAttributes[name].def;
             } else {
                 out[name] = R._availableAttrs[name];
             }
         }
         return ii - 1 ? out : out[names[0]];
     }
     if (value == null && R.is(name, "array")) {
         out = {};
         for (i = 0, ii = name.length; i < ii; i++) {
             out[name[i]] = this.attr(name[i]);
         }
         return out;
     }
     if (value != null) {
         var params = {};
         params[name] = value;
     } else if (name != null && R.is(name, "object")) {
         params = name;
     }
     for (var key in params) {
         eve("raphael.attr." + key + "." + this.id, this, params[key]);
     }
     for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
         var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
         this.attrs[key] = params[key];
         for (var subkey in par) if (par[has](subkey)) {
             params[subkey] = par[subkey];
         }
     }
     setFillAndStroke(this, params);
     return this;
 };
 /*\
  * Element.toFront
  [ method ]
  **
  * Moves the element so it is the closest to the viewerâ€™s eyes, on top of other elements.
  = (object) @Element
 \*/
 elproto.toFront = function () {
     if (this.removed) {
         return this;
     }
     if (this.node.parentNode.tagName.toLowerCase() == "a") {
         this.node.parentNode.parentNode.appendChild(this.node.parentNode);
     } else {
         this.node.parentNode.appendChild(this.node);
     }
     var svg = this.paper;
     svg.top != this && R._tofront(this, svg);
     return this;
 };
 /*\
  * Element.toBack
  [ method ]
  **
  * Moves the element so it is the furthest from the viewerâ€™s eyes, behind other elements.
  = (object) @Element
 \*/
 elproto.toBack = function () {
     if (this.removed) {
         return this;
     }
     var parent = this.node.parentNode;
     if (parent.tagName.toLowerCase() == "a") {
         parent.parentNode.insertBefore(this.node.parentNode, this.node.parentNode.parentNode.firstChild); 
     } else if (parent.firstChild != this.node) {
         parent.insertBefore(this.node, this.node.parentNode.firstChild);
     }
     R._toback(this, this.paper);
     var svg = this.paper;
     return this;
 };
 /*\
  * Element.insertAfter
  [ method ]
  **
  * Inserts current object after the given one.
  = (object) @Element
 \*/
 elproto.insertAfter = function (element) {
     if (this.removed) {
         return this;
     }
     var node = element.node || element[element.length - 1].node;
     if (node.nextSibling) {
         node.parentNode.insertBefore(this.node, node.nextSibling);
     } else {
         node.parentNode.appendChild(this.node);
     }
     R._insertafter(this, element, this.paper);
     return this;
 };
 /*\
  * Element.insertBefore
  [ method ]
  **
  * Inserts current object before the given one.
  = (object) @Element
 \*/
 elproto.insertBefore = function (element) {
     if (this.removed) {
         return this;
     }
     var node = element.node || element[0].node;
     node.parentNode.insertBefore(this.node, node);
     R._insertbefore(this, element, this.paper);
     return this;
 };
 elproto.blur = function (size) {
     // Experimental. No Safari support. Use it on your own risk.
     var t = this;
     if (+size !== 0) {
         var fltr = $("filter"),
             blur = $("feGaussianBlur");
         t.attrs.blur = size;
         fltr.id = R.createUUID();
         $(blur, {stdDeviation: +size || 1.5});
         fltr.appendChild(blur);
         t.paper.defs.appendChild(fltr);
         t._blur = fltr;
         $(t.node, {filter: "url(#" + fltr.id + ")"});
     } else {
         if (t._blur) {
             t._blur.parentNode.removeChild(t._blur);
             delete t._blur;
             delete t.attrs.blur;
         }
         t.node.removeAttribute("filter");
     }
     return t;
 };
 R._engine.circle = function (svg, x, y, r) {
     var el = $("circle");
     svg.canvas && svg.canvas.appendChild(el);
     var res = new Element(el, svg);
     res.attrs = {cx: x, cy: y, r: r, fill: "none", stroke: "#000"};
     res.type = "circle";
     $(el, res.attrs);
     return res;
 };
 R._engine.rect = function (svg, x, y, w, h, r) {
     var el = $("rect");
     svg.canvas && svg.canvas.appendChild(el);
     var res = new Element(el, svg);
     res.attrs = {x: x, y: y, width: w, height: h, r: r || 0, rx: r || 0, ry: r || 0, fill: "none", stroke: "#000"};
     res.type = "rect";
     $(el, res.attrs);
     return res;
 };
 R._engine.ellipse = function (svg, x, y, rx, ry) {
     var el = $("ellipse");
     svg.canvas && svg.canvas.appendChild(el);
     var res = new Element(el, svg);
     res.attrs = {cx: x, cy: y, rx: rx, ry: ry, fill: "none", stroke: "#000"};
     res.type = "ellipse";
     $(el, res.attrs);
     return res;
 };
 R._engine.image = function (svg, src, x, y, w, h) {
     var el = $("image");
     $(el, {x: x, y: y, width: w, height: h, preserveAspectRatio: "none"});
     el.setAttributeNS(xlink, "href", src);
     svg.canvas && svg.canvas.appendChild(el);
     var res = new Element(el, svg);
     res.attrs = {x: x, y: y, width: w, height: h, src: src};
     res.type = "image";
     return res;
 };
 R._engine.text = function (svg, x, y, text) {
     var el = $("text");
     svg.canvas && svg.canvas.appendChild(el);
     var res = new Element(el, svg);
     res.attrs = {
         x: x,
         y: y,
         "text-anchor": "middle",
         text: text,
         font: R._availableAttrs.font,
         stroke: "none",
         fill: "#000"
     };
     res.type = "text";
     setFillAndStroke(res, res.attrs);
     return res;
 };
 R._engine.setSize = function (width, height) {
     this.width = width || this.width;
     this.height = height || this.height;
     this.canvas.setAttribute("width", this.width);
     this.canvas.setAttribute("height", this.height);
     if (this._viewBox) {
         this.setViewBox.apply(this, this._viewBox);
     }
     return this;
 };
 R._engine.create = function () {
     var con = R._getContainer.apply(0, arguments),
         container = con && con.container,
         x = con.x,
         y = con.y,
         width = con.width,
         height = con.height;
     if (!container) {
         throw new Error("SVG container not found.");
     }
     var cnvs = $("svg"),
         css = "overflow:hidden;",
         isFloating;
     x = x || 0;
     y = y || 0;
     width = width || 512;
     height = height || 342;
     $(cnvs, {
         height: height,
         version: 1.1,
         width: width,
         xmlns: "http://www.w3.org/2000/svg"
     });
     if (container == 1) {
         cnvs.style.cssText = css + "position:absolute;left:" + x + "px;top:" + y + "px";
         R._g.doc.body.appendChild(cnvs);
         isFloating = 1;
     } else {
         cnvs.style.cssText = css + "position:relative";
         if (container.firstChild) {
             container.insertBefore(cnvs, container.firstChild);
         } else {
             container.appendChild(cnvs);
         }
     }
     container = new R._Paper;
     container.width = width;
     container.height = height;
     container.canvas = cnvs;
     container.clear();
     container._left = container._top = 0;
     isFloating && (container.renderfix = function () {});
     container.renderfix();
     return container;
 };
 R._engine.setViewBox = function (x, y, w, h, fit) {
     eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
     var size = mmax(w / this.width, h / this.height),
         top = this.top,
         aspectRatio = fit ? "meet" : "xMinYMin",
         vb,
         sw;
     if (x == null) {
         if (this._vbSize) {
             size = 1;
         }
         delete this._vbSize;
         vb = "0 0 " + this.width + S + this.height;
     } else {
         this._vbSize = size;
         vb = x + S + y + S + w + S + h;
     }
     $(this.canvas, {
         viewBox: vb,
         preserveAspectRatio: aspectRatio
     });
     while (size && top) {
         sw = "stroke-width" in top.attrs ? top.attrs["stroke-width"] : 1;
         top.attr({"stroke-width": sw});
         top._.dirty = 1;
         top._.dirtyT = 1;
         top = top.prev;
     }
     this._viewBox = [x, y, w, h, !!fit];
     return this;
 };
 /*\
  * Paper.renderfix
  [ method ]
  **
  * Fixes the issue of Firefox and IE9 regarding subpixel rendering. If paper is dependant
  * on other elements after reflow it could shift half pixel which cause for lines to lost their crispness.
  * This method fixes the issue.
  **
    Special thanks to Mariusz Nowak (http://www.medikoo.com/) for this method.
 \*/
 R.prototype.renderfix = function () {
     var cnvs = this.canvas,
         s = cnvs.style,
         pos;
     try {
         pos = cnvs.getScreenCTM() || cnvs.createSVGMatrix();
     } catch (e) {
         pos = cnvs.createSVGMatrix();
     }
     var left = -pos.e % 1,
         top = -pos.f % 1;
     if (left || top) {
         if (left) {
             this._left = (this._left + left) % 1;
             s.left = this._left + "px";
         }
         if (top) {
             this._top = (this._top + top) % 1;
             s.top = this._top + "px";
         }
     }
 };
 /*\
  * Paper.clear
  [ method ]
  **
  * Clears the paper, i.e. removes all the elements.
 \*/
 R.prototype.clear = function () {
     R.eve("raphael.clear", this);
     var c = this.canvas;
     while (c.firstChild) {
         c.removeChild(c.firstChild);
     }
     this.bottom = this.top = null;
     (this.desc = $("desc")).appendChild(R._g.doc.createTextNode("Created with Rapha\xebl " + R.version));
     c.appendChild(this.desc);
     c.appendChild(this.defs = $("defs"));
 };
 /*\
  * Paper.remove
  [ method ]
  **
  * Removes the paper from the DOM.
 \*/
 R.prototype.remove = function () {
     eve("raphael.remove", this);
     this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas);
     for (var i in this) {
         this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
     }
 };
 var setproto = R.st;
 for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
     setproto[method] = (function (methodname) {
         return function () {
             var arg = arguments;
             return this.forEach(function (el) {
                 el[methodname].apply(el, arg);
             });
         };
     })(method);
 }
})();

//â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”� \\
//â”‚ RaphaÃ«l - JavaScript Vector Library                                 â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ VML Module                                                          â”‚ \\
//â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ \\
//â”‚ Copyright (c) 2008-2011 Dmitry Baranovskiy (http://raphaeljs.com)   â”‚ \\
//â”‚ Copyright (c) 2008-2011 Sencha Labs (http://sencha.com)             â”‚ \\
//â”‚ Licensed under the MIT (http://raphaeljs.com/license.html) license. â”‚ \\
//â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ \\

(function(){
 if (!R.vml) {
     return;
 }
 var has = "hasOwnProperty",
     Str = String,
     toFloat = parseFloat,
     math = Math,
     round = math.round,
     mmax = math.max,
     mmin = math.min,
     abs = math.abs,
     fillString = "fill",
     separator = /[, ]+/,
     eve = R.eve,
     ms = " progid:DXImageTransform.Microsoft",
     S = " ",
     E = "",
     map = {M: "m", L: "l", C: "c", Z: "x", m: "t", l: "r", c: "v", z: "x"},
     bites = /([clmz]),?([^clmz]*)/gi,
     blurregexp = / progid:\S+Blur\([^\)]+\)/g,
     val = /-?[^,\s-]+/g,
     cssDot = "position:absolute;left:0;top:0;width:1px;height:1px",
     zoom = 21600,
     pathTypes = {path: 1, rect: 1, image: 1},
     ovalTypes = {circle: 1, ellipse: 1},
     path2vml = function (path) {
         var total =  /[ahqstv]/ig,
             command = R._pathToAbsolute;
         Str(path).match(total) && (command = R._path2curve);
         total = /[clmz]/g;
         if (command == R._pathToAbsolute && !Str(path).match(total)) {
             var res = Str(path).replace(bites, function (all, command, args) {
                 var vals = [],
                     isMove = command.toLowerCase() == "m",
                     res = map[command];
                 args.replace(val, function (value) {
                     if (isMove && vals.length == 2) {
                         res += vals + map[command == "m" ? "l" : "L"];
                         vals = [];
                     }
                     vals.push(round(value * zoom));
                 });
                 return res + vals;
             });
             return res;
         }
         var pa = command(path), p, r;
         res = [];
         for (var i = 0, ii = pa.length; i < ii; i++) {
             p = pa[i];
             r = pa[i][0].toLowerCase();
             r == "z" && (r = "x");
             for (var j = 1, jj = p.length; j < jj; j++) {
                 r += round(p[j] * zoom) + (j != jj - 1 ? "," : E);
             }
             res.push(r);
         }
         return res.join(S);
     },
     compensation = function (deg, dx, dy) {
         var m = R.matrix();
         m.rotate(-deg, .5, .5);
         return {
             dx: m.x(dx, dy),
             dy: m.y(dx, dy)
         };
     },
     setCoords = function (p, sx, sy, dx, dy, deg) {
         var _ = p._,
             m = p.matrix,
             fillpos = _.fillpos,
             o = p.node,
             s = o.style,
             y = 1,
             flip = "",
             dxdy,
             kx = zoom / sx,
             ky = zoom / sy;
         s.visibility = "hidden";
         if (!sx || !sy) {
             return;
         }
         o.coordsize = abs(kx) + S + abs(ky);
         s.rotation = deg * (sx * sy < 0 ? -1 : 1);
         if (deg) {
             var c = compensation(deg, dx, dy);
             dx = c.dx;
             dy = c.dy;
         }
         sx < 0 && (flip += "x");
         sy < 0 && (flip += " y") && (y = -1);
         s.flip = flip;
         o.coordorigin = (dx * -kx) + S + (dy * -ky);
         if (fillpos || _.fillsize) {
             var fill = o.getElementsByTagName(fillString);
             fill = fill && fill[0];
             o.removeChild(fill);
             if (fillpos) {
                 c = compensation(deg, m.x(fillpos[0], fillpos[1]), m.y(fillpos[0], fillpos[1]));
                 fill.position = c.dx * y + S + c.dy * y;
             }
             if (_.fillsize) {
                 fill.size = _.fillsize[0] * abs(sx) + S + _.fillsize[1] * abs(sy);
             }
             o.appendChild(fill);
         }
         s.visibility = "visible";
     };
 R.toString = function () {
     return  "Your browser doesn\u2019t support SVG. Falling down to VML.\nYou are running Rapha\xebl " + this.version;
 };
 var addArrow = function (o, value, isEnd) {
     var values = Str(value).toLowerCase().split("-"),
         se = isEnd ? "end" : "start",
         i = values.length,
         type = "classic",
         w = "medium",
         h = "medium";
     while (i--) {
         switch (values[i]) {
             case "block":
             case "classic":
             case "oval":
             case "diamond":
             case "open":
             case "none":
                 type = values[i];
                 break;
             case "wide":
             case "narrow": h = values[i]; break;
             case "long":
             case "short": w = values[i]; break;
         }
     }
     var stroke = o.node.getElementsByTagName("stroke")[0];
     stroke[se + "arrow"] = type;
     stroke[se + "arrowlength"] = w;
     stroke[se + "arrowwidth"] = h;
 },
 setFillAndStroke = function (o, params) {
     // o.paper.canvas.style.display = "none";
     o.attrs = o.attrs || {};
     var node = o.node,
         a = o.attrs,
         s = node.style,
         xy,
         newpath = pathTypes[o.type] && (params.x != a.x || params.y != a.y || params.width != a.width || params.height != a.height || params.cx != a.cx || params.cy != a.cy || params.rx != a.rx || params.ry != a.ry || params.r != a.r),
         isOval = ovalTypes[o.type] && (a.cx != params.cx || a.cy != params.cy || a.r != params.r || a.rx != params.rx || a.ry != params.ry),
         res = o;


     for (var par in params) if (params[has](par)) {
         a[par] = params[par];
     }
     if (newpath) {
         a.path = R._getPath[o.type](o);
         o._.dirty = 1;
     }
     params.href && (node.href = params.href);
     params.title && (node.title = params.title);
     params.target && (node.target = params.target);
     params.cursor && (s.cursor = params.cursor);
     "blur" in params && o.blur(params.blur);
     if (params.path && o.type == "path" || newpath) {
         node.path = path2vml(~Str(a.path).toLowerCase().indexOf("r") ? R._pathToAbsolute(a.path) : a.path);
         if (o.type == "image") {
             o._.fillpos = [a.x, a.y];
             o._.fillsize = [a.width, a.height];
             setCoords(o, 1, 1, 0, 0, 0);
         }
     }
     "transform" in params && o.transform(params.transform);
     if (isOval) {
         var cx = +a.cx,
             cy = +a.cy,
             rx = +a.rx || +a.r || 0,
             ry = +a.ry || +a.r || 0;
         node.path = R.format("ar{0},{1},{2},{3},{4},{1},{4},{1}x", round((cx - rx) * zoom), round((cy - ry) * zoom), round((cx + rx) * zoom), round((cy + ry) * zoom), round(cx * zoom));
         o._.dirty = 1;
     }
     if ("clip-rect" in params) {
         var rect = Str(params["clip-rect"]).split(separator);
         if (rect.length == 4) {
             rect[2] = +rect[2] + (+rect[0]);
             rect[3] = +rect[3] + (+rect[1]);
             var div = node.clipRect || R._g.doc.createElement("div"),
                 dstyle = div.style;
             dstyle.clip = R.format("rect({1}px {2}px {3}px {0}px)", rect);
             if (!node.clipRect) {
                 dstyle.position = "absolute";
                 dstyle.top = 0;
                 dstyle.left = 0;
                 dstyle.width = o.paper.width + "px";
                 dstyle.height = o.paper.height + "px";
                 node.parentNode.insertBefore(div, node);
                 div.appendChild(node);
                 node.clipRect = div;
             }
         }
         if (!params["clip-rect"]) {
             node.clipRect && (node.clipRect.style.clip = "auto");
         }
     }
     if (o.textpath) {
         var textpathStyle = o.textpath.style;
         params.font && (textpathStyle.font = params.font);
         params["font-family"] && (textpathStyle.fontFamily = '"' + params["font-family"].split(",")[0].replace(/^['"]+|['"]+$/g, E) + '"');
         params["font-size"] && (textpathStyle.fontSize = params["font-size"]);
         params["font-weight"] && (textpathStyle.fontWeight = params["font-weight"]);
         params["font-style"] && (textpathStyle.fontStyle = params["font-style"]);
     }
     if ("arrow-start" in params) {
         addArrow(res, params["arrow-start"]);
     }
     if ("arrow-end" in params) {
         addArrow(res, params["arrow-end"], 1);
     }
     if (params.opacity != null || 
         params["stroke-width"] != null ||
         params.fill != null ||
         params.src != null ||
         params.stroke != null ||
         params["stroke-width"] != null ||
         params["stroke-opacity"] != null ||
         params["fill-opacity"] != null ||
         params["stroke-dasharray"] != null ||
         params["stroke-miterlimit"] != null ||
         params["stroke-linejoin"] != null ||
         params["stroke-linecap"] != null) {
         var fill = node.getElementsByTagName(fillString),
             newfill = false;
         fill = fill && fill[0];
         !fill && (newfill = fill = createNode(fillString));
         if (o.type == "image" && params.src) {
             fill.src = params.src;
         }
         params.fill && (fill.on = true);
         if (fill.on == null || params.fill == "none" || params.fill === null) {
             fill.on = false;
         }
         if (fill.on && params.fill) {
             var isURL = Str(params.fill).match(R._ISURL);
             if (isURL) {
                 fill.parentNode == node && node.removeChild(fill);
                 fill.rotate = true;
                 fill.src = isURL[1];
                 fill.type = "tile";
                 var bbox = o.getBBox(1);
                 fill.position = bbox.x + S + bbox.y;
                 o._.fillpos = [bbox.x, bbox.y];

                 R._preload(isURL[1], function () {
                     o._.fillsize = [this.offsetWidth, this.offsetHeight];
                 });
             } else {
                 fill.color = R.getRGB(params.fill).hex;
                 fill.src = E;
                 fill.type = "solid";
                 if (R.getRGB(params.fill).error && (res.type in {circle: 1, ellipse: 1} || Str(params.fill).charAt() != "r") && addGradientFill(res, params.fill, fill)) {
                     a.fill = "none";
                     a.gradient = params.fill;
                     fill.rotate = false;
                 }
             }
         }
         if ("fill-opacity" in params || "opacity" in params) {
             var opacity = ((+a["fill-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+R.getRGB(params.fill).o + 1 || 2) - 1);
             opacity = mmin(mmax(opacity, 0), 1);
             fill.opacity = opacity;
             if (fill.src) {
                 fill.color = "none";
             }
         }
         node.appendChild(fill);
         var stroke = (node.getElementsByTagName("stroke") && node.getElementsByTagName("stroke")[0]),
         newstroke = false;
         !stroke && (newstroke = stroke = createNode("stroke"));
         if ((params.stroke && params.stroke != "none") ||
             params["stroke-width"] ||
             params["stroke-opacity"] != null ||
             params["stroke-dasharray"] ||
             params["stroke-miterlimit"] ||
             params["stroke-linejoin"] ||
             params["stroke-linecap"]) {
             stroke.on = true;
         }
         (params.stroke == "none" || params.stroke === null || stroke.on == null || params.stroke == 0 || params["stroke-width"] == 0) && (stroke.on = false);
         var strokeColor = R.getRGB(params.stroke);
         stroke.on && params.stroke && (stroke.color = strokeColor.hex);
         opacity = ((+a["stroke-opacity"] + 1 || 2) - 1) * ((+a.opacity + 1 || 2) - 1) * ((+strokeColor.o + 1 || 2) - 1);
         var width = (toFloat(params["stroke-width"]) || 1) * .75;
         opacity = mmin(mmax(opacity, 0), 1);
         params["stroke-width"] == null && (width = a["stroke-width"]);
         params["stroke-width"] && (stroke.weight = width);
         width && width < 1 && (opacity *= width) && (stroke.weight = 1);
         stroke.opacity = opacity;
     
         params["stroke-linejoin"] && (stroke.joinstyle = params["stroke-linejoin"] || "miter");
         stroke.miterlimit = params["stroke-miterlimit"] || 8;
         params["stroke-linecap"] && (stroke.endcap = params["stroke-linecap"] == "butt" ? "flat" : params["stroke-linecap"] == "square" ? "square" : "round");
         if (params["stroke-dasharray"]) {
             var dasharray = {
                 "-": "shortdash",
                 ".": "shortdot",
                 "-.": "shortdashdot",
                 "-..": "shortdashdotdot",
                 ". ": "dot",
                 "- ": "dash",
                 "--": "longdash",
                 "- .": "dashdot",
                 "--.": "longdashdot",
                 "--..": "longdashdotdot"
             };
             stroke.dashstyle = dasharray[has](params["stroke-dasharray"]) ? dasharray[params["stroke-dasharray"]] : E;
         }
         newstroke && node.appendChild(stroke);
     }
     if (res.type == "text") {
         res.paper.canvas.style.display = E;
         var span = res.paper.span,
             m = 100,
             fontSize = a.font && a.font.match(/\d+(?:\.\d*)?(?=px)/);
         s = span.style;
         a.font && (s.font = a.font);
         a["font-family"] && (s.fontFamily = a["font-family"]);
         a["font-weight"] && (s.fontWeight = a["font-weight"]);
         a["font-style"] && (s.fontStyle = a["font-style"]);
         fontSize = toFloat(a["font-size"] || fontSize && fontSize[0]) || 10;
         s.fontSize = fontSize * m + "px";
         res.textpath.string && (span.innerHTML = Str(res.textpath.string).replace(/</g, "&#60;").replace(/&/g, "&#38;").replace(/\n/g, "<br>"));
         var brect = span.getBoundingClientRect();
         res.W = a.w = (brect.right - brect.left) / m;
         res.H = a.h = (brect.bottom - brect.top) / m;
         // res.paper.canvas.style.display = "none";
         res.X = a.x;
         res.Y = a.y + res.H / 2;

         ("x" in params || "y" in params) && (res.path.v = R.format("m{0},{1}l{2},{1}", round(a.x * zoom), round(a.y * zoom), round(a.x * zoom) + 1));
         var dirtyattrs = ["x", "y", "text", "font", "font-family", "font-weight", "font-style", "font-size"];
         for (var d = 0, dd = dirtyattrs.length; d < dd; d++) if (dirtyattrs[d] in params) {
             res._.dirty = 1;
             break;
         }
     
         // text-anchor emulation
         switch (a["text-anchor"]) {
             case "start":
                 res.textpath.style["v-text-align"] = "left";
                 res.bbx = res.W / 2;
             break;
             case "end":
                 res.textpath.style["v-text-align"] = "right";
                 res.bbx = -res.W / 2;
             break;
             default:
                 res.textpath.style["v-text-align"] = "center";
                 res.bbx = 0;
             break;
         }
         res.textpath.style["v-text-kern"] = true;
     }
     // res.paper.canvas.style.display = E;
 },
 addGradientFill = function (o, gradient, fill) {
     o.attrs = o.attrs || {};
     var attrs = o.attrs,
         pow = Math.pow,
         opacity,
         oindex,
         type = "linear",
         fxfy = ".5 .5";
     o.attrs.gradient = gradient;
     gradient = Str(gradient).replace(R._radial_gradient, function (all, fx, fy) {
         type = "radial";
         if (fx && fy) {
             fx = toFloat(fx);
             fy = toFloat(fy);
             pow(fx - .5, 2) + pow(fy - .5, 2) > .25 && (fy = math.sqrt(.25 - pow(fx - .5, 2)) * ((fy > .5) * 2 - 1) + .5);
             fxfy = fx + S + fy;
         }
         return E;
     });
     gradient = gradient.split(/\s*\-\s*/);
     if (type == "linear") {
         var angle = gradient.shift();
         angle = -toFloat(angle);
         if (isNaN(angle)) {
             return null;
         }
     }
     var dots = R._parseDots(gradient);
     if (!dots) {
         return null;
     }
     o = o.shape || o.node;
     if (dots.length) {
         o.removeChild(fill);
         fill.on = true;
         fill.method = "none";
         fill.color = dots[0].color;
         fill.color2 = dots[dots.length - 1].color;
         var clrs = [];
         for (var i = 0, ii = dots.length; i < ii; i++) {
             dots[i].offset && clrs.push(dots[i].offset + S + dots[i].color);
         }
         fill.colors = clrs.length ? clrs.join() : "0% " + fill.color;
         if (type == "radial") {
             fill.type = "gradientTitle";
             fill.focus = "100%";
             fill.focussize = "0 0";
             fill.focusposition = fxfy;
             fill.angle = 0;
         } else {
             // fill.rotate= true;
             fill.type = "gradient";
             fill.angle = (270 - angle) % 360;
         }
         o.appendChild(fill);
     }
     return 1;
 },
 Element = function (node, vml) {
     this[0] = this.node = node;
     node.raphael = true;
     this.id = R._oid++;
     node.raphaelid = this.id;
     this.X = 0;
     this.Y = 0;
     this.attrs = {};
     this.paper = vml;
     this.matrix = R.matrix();
     this._ = {
         transform: [],
         sx: 1,
         sy: 1,
         dx: 0,
         dy: 0,
         deg: 0,
         dirty: 1,
         dirtyT: 1
     };
     !vml.bottom && (vml.bottom = this);
     this.prev = vml.top;
     vml.top && (vml.top.next = this);
     vml.top = this;
     this.next = null;
 };
 var elproto = R.el;

 Element.prototype = elproto;
 elproto.constructor = Element;
 elproto.transform = function (tstr) {
     if (tstr == null) {
         return this._.transform;
     }
     var vbs = this.paper._viewBoxShift,
         vbt = vbs ? "s" + [vbs.scale, vbs.scale] + "-1-1t" + [vbs.dx, vbs.dy] : E,
         oldt;
     if (vbs) {
         oldt = tstr = Str(tstr).replace(/\.{3}|\u2026/g, this._.transform || E);
     }
     R._extractTransform(this, vbt + tstr);
     var matrix = this.matrix.clone(),
         skew = this.skew,
         o = this.node,
         split,
         isGrad = ~Str(this.attrs.fill).indexOf("-"),
         isPatt = !Str(this.attrs.fill).indexOf("url(");
     matrix.translate(1, 1);
     if (isPatt || isGrad || this.type == "image") {
         skew.matrix = "1 0 0 1";
         skew.offset = "0 0";
         split = matrix.split();
         if ((isGrad && split.noRotation) || !split.isSimple) {
             o.style.filter = matrix.toFilter();
             var bb = this.getBBox(),
                 bbt = this.getBBox(1),
                 dx = bb.x - bbt.x,
                 dy = bb.y - bbt.y;
             o.coordorigin = (dx * -zoom) + S + (dy * -zoom);
             setCoords(this, 1, 1, dx, dy, 0);
         } else {
             o.style.filter = E;
             setCoords(this, split.scalex, split.scaley, split.dx, split.dy, split.rotate);
         }
     } else {
         o.style.filter = E;
         skew.matrix = Str(matrix);
         skew.offset = matrix.offset();
     }
     oldt && (this._.transform = oldt);
     return this;
 };
 elproto.rotate = function (deg, cx, cy) {
     if (this.removed) {
         return this;
     }
     if (deg == null) {
         return;
     }
     deg = Str(deg).split(separator);
     if (deg.length - 1) {
         cx = toFloat(deg[1]);
         cy = toFloat(deg[2]);
     }
     deg = toFloat(deg[0]);
     (cy == null) && (cx = cy);
     if (cx == null || cy == null) {
         var bbox = this.getBBox(1);
         cx = bbox.x + bbox.width / 2;
         cy = bbox.y + bbox.height / 2;
     }
     this._.dirtyT = 1;
     this.transform(this._.transform.concat([["r", deg, cx, cy]]));
     return this;
 };
 elproto.translate = function (dx, dy) {
     if (this.removed) {
         return this;
     }
     dx = Str(dx).split(separator);
     if (dx.length - 1) {
         dy = toFloat(dx[1]);
     }
     dx = toFloat(dx[0]) || 0;
     dy = +dy || 0;
     if (this._.bbox) {
         this._.bbox.x += dx;
         this._.bbox.y += dy;
     }
     this.transform(this._.transform.concat([["t", dx, dy]]));
     return this;
 };
 elproto.scale = function (sx, sy, cx, cy) {
     if (this.removed) {
         return this;
     }
     sx = Str(sx).split(separator);
     if (sx.length - 1) {
         sy = toFloat(sx[1]);
         cx = toFloat(sx[2]);
         cy = toFloat(sx[3]);
         isNaN(cx) && (cx = null);
         isNaN(cy) && (cy = null);
     }
     sx = toFloat(sx[0]);
     (sy == null) && (sy = sx);
     (cy == null) && (cx = cy);
     if (cx == null || cy == null) {
         var bbox = this.getBBox(1);
     }
     cx = cx == null ? bbox.x + bbox.width / 2 : cx;
     cy = cy == null ? bbox.y + bbox.height / 2 : cy;
 
     this.transform(this._.transform.concat([["s", sx, sy, cx, cy]]));
     this._.dirtyT = 1;
     return this;
 };
 elproto.hide = function () {
     !this.removed && (this.node.style.display = "none");
     return this;
 };
 elproto.show = function () {
     !this.removed && (this.node.style.display = E);
     return this;
 };
 elproto._getBBox = function () {
     if (this.removed) {
         return {};
     }
     return {
         x: this.X + (this.bbx || 0) - this.W / 2,
         y: this.Y - this.H,
         width: this.W,
         height: this.H
     };
 };
 elproto.remove = function () {
     if (this.removed || !this.node.parentNode) {
         return;
     }
     this.paper.__set__ && this.paper.__set__.exclude(this);
     R.eve.unbind("raphael.*.*." + this.id);
     R._tear(this, this.paper);
     this.node.parentNode.removeChild(this.node);
     this.shape && this.shape.parentNode.removeChild(this.shape);
     for (var i in this) {
         this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
     }
     this.removed = true;
 };
 elproto.attr = function (name, value) {
     if (this.removed) {
         return this;
     }
     if (name == null) {
         var res = {};
         for (var a in this.attrs) if (this.attrs[has](a)) {
             res[a] = this.attrs[a];
         }
         res.gradient && res.fill == "none" && (res.fill = res.gradient) && delete res.gradient;
         res.transform = this._.transform;
         return res;
     }
     if (value == null && R.is(name, "string")) {
         if (name == fillString && this.attrs.fill == "none" && this.attrs.gradient) {
             return this.attrs.gradient;
         }
         var names = name.split(separator),
             out = {};
         for (var i = 0, ii = names.length; i < ii; i++) {
             name = names[i];
             if (name in this.attrs) {
                 out[name] = this.attrs[name];
             } else if (R.is(this.paper.customAttributes[name], "function")) {
                 out[name] = this.paper.customAttributes[name].def;
             } else {
                 out[name] = R._availableAttrs[name];
             }
         }
         return ii - 1 ? out : out[names[0]];
     }
     if (this.attrs && value == null && R.is(name, "array")) {
         out = {};
         for (i = 0, ii = name.length; i < ii; i++) {
             out[name[i]] = this.attr(name[i]);
         }
         return out;
     }
     var params;
     if (value != null) {
         params = {};
         params[name] = value;
     }
     value == null && R.is(name, "object") && (params = name);
     for (var key in params) {
         eve("raphael.attr." + key + "." + this.id, this, params[key]);
     }
     if (params) {
         for (key in this.paper.customAttributes) if (this.paper.customAttributes[has](key) && params[has](key) && R.is(this.paper.customAttributes[key], "function")) {
             var par = this.paper.customAttributes[key].apply(this, [].concat(params[key]));
             this.attrs[key] = params[key];
             for (var subkey in par) if (par[has](subkey)) {
                 params[subkey] = par[subkey];
             }
         }
         // this.paper.canvas.style.display = "none";
         if (params.text && this.type == "text") {
             this.textpath.string = params.text;
         }
         setFillAndStroke(this, params);
         // this.paper.canvas.style.display = E;
     }
     return this;
 };
 elproto.toFront = function () {
     !this.removed && this.node.parentNode.appendChild(this.node);
     this.paper && this.paper.top != this && R._tofront(this, this.paper);
     return this;
 };
 elproto.toBack = function () {
     if (this.removed) {
         return this;
     }
     if (this.node.parentNode.firstChild != this.node) {
         this.node.parentNode.insertBefore(this.node, this.node.parentNode.firstChild);
         R._toback(this, this.paper);
     }
     return this;
 };
 elproto.insertAfter = function (element) {
     if (this.removed) {
         return this;
     }
     if (element.constructor == R.st.constructor) {
         element = element[element.length - 1];
     }
     if (element.node.nextSibling) {
         element.node.parentNode.insertBefore(this.node, element.node.nextSibling);
     } else {
         element.node.parentNode.appendChild(this.node);
     }
     R._insertafter(this, element, this.paper);
     return this;
 };
 elproto.insertBefore = function (element) {
     if (this.removed) {
         return this;
     }
     if (element.constructor == R.st.constructor) {
         element = element[0];
     }
     element.node.parentNode.insertBefore(this.node, element.node);
     R._insertbefore(this, element, this.paper);
     return this;
 };
 elproto.blur = function (size) {
     var s = this.node.runtimeStyle,
         f = s.filter;
     f = f.replace(blurregexp, E);
     if (+size !== 0) {
         this.attrs.blur = size;
         s.filter = f + S + ms + ".Blur(pixelradius=" + (+size || 1.5) + ")";
         s.margin = R.format("-{0}px 0 0 -{0}px", round(+size || 1.5));
     } else {
         s.filter = f;
         s.margin = 0;
         delete this.attrs.blur;
     }
     return this;
 };

 R._engine.path = function (pathString, vml) {
     var el = createNode("shape");
     el.style.cssText = cssDot;
     el.coordsize = zoom + S + zoom;
     el.coordorigin = vml.coordorigin;
     var p = new Element(el, vml),
         attr = {fill: "none", stroke: "#000"};
     pathString && (attr.path = pathString);
     p.type = "path";
     p.path = [];
     p.Path = E;
     setFillAndStroke(p, attr);
     vml.canvas.appendChild(el);
     var skew = createNode("skew");
     skew.on = true;
     el.appendChild(skew);
     p.skew = skew;
     p.transform(E);
     return p;
 };
 R._engine.rect = function (vml, x, y, w, h, r) {
     var path = R._rectPath(x, y, w, h, r),
         res = vml.path(path),
         a = res.attrs;
     res.X = a.x = x;
     res.Y = a.y = y;
     res.W = a.width = w;
     res.H = a.height = h;
     a.r = r;
     a.path = path;
     res.type = "rect";
     return res;
 };
 R._engine.ellipse = function (vml, x, y, rx, ry) {
     var res = vml.path(),
         a = res.attrs;
     res.X = x - rx;
     res.Y = y - ry;
     res.W = rx * 2;
     res.H = ry * 2;
     res.type = "ellipse";
     setFillAndStroke(res, {
         cx: x,
         cy: y,
         rx: rx,
         ry: ry
     });
     return res;
 };
 R._engine.circle = function (vml, x, y, r) {
     var res = vml.path(),
         a = res.attrs;
     res.X = x - r;
     res.Y = y - r;
     res.W = res.H = r * 2;
     res.type = "circle";
     setFillAndStroke(res, {
         cx: x,
         cy: y,
         r: r
     });
     return res;
 };
 R._engine.image = function (vml, src, x, y, w, h) {
     var path = R._rectPath(x, y, w, h),
         res = vml.path(path).attr({stroke: "none"}),
         a = res.attrs,
         node = res.node,
         fill = node.getElementsByTagName(fillString)[0];
     a.src = src;
     res.X = a.x = x;
     res.Y = a.y = y;
     res.W = a.width = w;
     res.H = a.height = h;
     a.path = path;
     res.type = "image";
     fill.parentNode == node && node.removeChild(fill);
     fill.rotate = true;
     fill.src = src;
     fill.type = "tile";
     res._.fillpos = [x, y];
     res._.fillsize = [w, h];
     node.appendChild(fill);
     setCoords(res, 1, 1, 0, 0, 0);
     return res;
 };
 R._engine.text = function (vml, x, y, text) {
     var el = createNode("shape"),
         path = createNode("path"),
         o = createNode("textpath");
     x = x || 0;
     y = y || 0;
     text = text || "";
     path.v = R.format("m{0},{1}l{2},{1}", round(x * zoom), round(y * zoom), round(x * zoom) + 1);
     path.textpathok = true;
     o.string = Str(text);
     o.on = true;
     el.style.cssText = cssDot;
     el.coordsize = zoom + S + zoom;
     el.coordorigin = "0 0";
     var p = new Element(el, vml),
         attr = {
             fill: "#000",
             stroke: "none",
             font: R._availableAttrs.font,
             text: text
         };
     p.shape = el;
     p.path = path;
     p.textpath = o;
     p.type = "text";
     p.attrs.text = Str(text);
     p.attrs.x = x;
     p.attrs.y = y;
     p.attrs.w = 1;
     p.attrs.h = 1;
     setFillAndStroke(p, attr);
     el.appendChild(o);
     el.appendChild(path);
     vml.canvas.appendChild(el);
     var skew = createNode("skew");
     skew.on = true;
     el.appendChild(skew);
     p.skew = skew;
     p.transform(E);
     return p;
 };
 R._engine.setSize = function (width, height) {
     var cs = this.canvas.style;
     this.width = width;
     this.height = height;
     width == +width && (width += "px");
     height == +height && (height += "px");
     cs.width = width;
     cs.height = height;
     cs.clip = "rect(0 " + width + " " + height + " 0)";
     if (this._viewBox) {
         R._engine.setViewBox.apply(this, this._viewBox);
     }
     return this;
 };
 R._engine.setViewBox = function (x, y, w, h, fit) {
     R.eve("raphael.setViewBox", this, this._viewBox, [x, y, w, h, fit]);
     var width = this.width,
         height = this.height,
         size = 1 / mmax(w / width, h / height),
         H, W;
     if (fit) {
         H = height / h;
         W = width / w;
         if (w * H < width) {
             x -= (width - w * H) / 2 / H;
         }
         if (h * W < height) {
             y -= (height - h * W) / 2 / W;
         }
     }
     this._viewBox = [x, y, w, h, !!fit];
     this._viewBoxShift = {
         dx: -x,
         dy: -y,
         scale: size
     };
     this.forEach(function (el) {
         el.transform("...");
     });
     return this;
 };
 var createNode;
 R._engine.initWin = function (win) {
         var doc = win.document;
         doc.createStyleSheet().addRule(".rvml", "behavior:url(#default#VML)");
         try {
             !doc.namespaces.rvml && doc.namespaces.add("rvml", "urn:schemas-microsoft-com:vml");
             createNode = function (tagName) {
                 return doc.createElement('<rvml:' + tagName + ' class="rvml">');
             };
         } catch (e) {
             createNode = function (tagName) {
                 return doc.createElement('<' + tagName + ' xmlns="urn:schemas-microsoft.com:vml" class="rvml">');
             };
         }
     };
 R._engine.initWin(R._g.win);
 R._engine.create = function () {
     var con = R._getContainer.apply(0, arguments),
         container = con.container,
         height = con.height,
         s,
         width = con.width,
         x = con.x,
         y = con.y;
     if (!container) {
         throw new Error("VML container not found.");
     }
     var res = new R._Paper,
         c = res.canvas = R._g.doc.createElement("div"),
         cs = c.style;
     x = x || 0;
     y = y || 0;
     width = width || 512;
     height = height || 342;
     res.width = width;
     res.height = height;
     width == +width && (width += "px");
     height == +height && (height += "px");
     res.coordsize = zoom * 1e3 + S + zoom * 1e3;
     res.coordorigin = "0 0";
     res.span = R._g.doc.createElement("span");
     res.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;";
     c.appendChild(res.span);
     cs.cssText = R.format("top:0;left:0;width:{0};height:{1};display:inline-block;position:relative;clip:rect(0 {0} {1} 0);overflow:hidden", width, height);
     if (container == 1) {
         R._g.doc.body.appendChild(c);
         cs.left = x + "px";
         cs.top = y + "px";
         cs.position = "absolute";
     } else {
         if (container.firstChild) {
             container.insertBefore(c, container.firstChild);
         } else {
             container.appendChild(c);
         }
     }
     res.renderfix = function () {};
     return res;
 };
 R.prototype.clear = function () {
     R.eve("raphael.clear", this);
     this.canvas.innerHTML = E;
     this.span = R._g.doc.createElement("span");
     this.span.style.cssText = "position:absolute;left:-9999em;top:-9999em;padding:0;margin:0;line-height:1;display:inline;";
     this.canvas.appendChild(this.span);
     this.bottom = this.top = null;
 };
 R.prototype.remove = function () {
     R.eve("raphael.remove", this);
     this.canvas.parentNode.removeChild(this.canvas);
     for (var i in this) {
         this[i] = typeof this[i] == "function" ? R._removedFactory(i) : null;
     }
     return true;
 };

 var setproto = R.st;
 for (var method in elproto) if (elproto[has](method) && !setproto[has](method)) {
     setproto[method] = (function (methodname) {
         return function () {
             var arg = arguments;
             return this.forEach(function (el) {
                 el[methodname].apply(el, arg);
             });
         };
     })(method);
 }
})();

 // EXPOSE
 // SVG and VML are appended just before the EXPOSE line
 // Even with AMD, Raphael should be defined globally
 oldRaphael.was ? (g.win.Raphael = R) : (Raphael = R);

 return R;
}));

//------------------------------- End of Raphael.js library -------------------------------
//------------------------------- Start of Autotable.js library ---------------------------
/*!
 * jsPDF AutoTable plugin v2.3.5
 * Copyright (c) 2014 Simon Bengtsson, https://github.com/simonbengtsson/jsPDF-AutoTable 
 * 
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * 
 * * /if (typeof window === 'object') window.jspdfAutoTableVersion = '2.3.5';/*
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("jspdf"));
	else if(typeof define === 'function' && define.amd)
		define(["jspdf"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("jspdf")) : factory(root["jsPDF"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE__18__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
/**
 * Ratio between font size and font height. The number comes from jspdf's source code
 */
exports.FONT_ROW_RATIO = 1.15;
var models_1 = __webpack_require__(4);
var table = null;
var assign = __webpack_require__(5);
var entries = __webpack_require__(19);
/**
 * Styles for the themes (overriding the default styles)
 */
exports.getTheme = function (name) {
    var themes = {
        'striped': {
            table: { fillColor: 255, textColor: 80, fontStyle: 'normal' },
            header: { textColor: 255, fillColor: [41, 128, 185], fontStyle: 'bold' },
            body: {},
            alternateRow: { fillColor: 245 }
        },
        'grid': {
            table: { fillColor: 255, textColor: 80, fontStyle: 'normal', lineWidth: 0.1 },
            header: { textColor: 255, fillColor: [26, 188, 156], fontStyle: 'bold', lineWidth: 0 },
            body: {},
            alternateRow: {}
        },
        'plain': {
            header: { fontStyle: 'bold' }
        }
    };
    return themes[name];
};
function getDefaults() {
    var scaleFactor = Config.scaleFactor();
    return {
        // Styling
        theme: 'striped',
        styles: {},
        headerStyles: {},
        bodyStyles: {},
        alternateRowStyles: {},
        columnStyles: {},
        // Properties
        startY: false,
        margin: 40 / scaleFactor,
        pageBreak: 'auto',
        tableWidth: 'auto',
        showHeader: 'everyPage',
        tableLineWidth: 0,
        tableLineColor: 200,
        // Hooks
        createdHeaderCell: function (cell, data) { },
        createdCell: function (cell, data) { },
        drawHeaderRow: function (row, data) { },
        drawRow: function (row, data) { },
        drawHeaderCell: function (cell, data) { },
        drawCell: function (cell, data) { },
        addPageContent: function (data) { }
    };
}
exports.getDefaults = getDefaults;
// Base style for all themes
function defaultStyles() {
    var scaleFactor = Config.scaleFactor();
    return {
        font: "helvetica",
        fontStyle: 'normal',
        overflow: 'ellipsize',
        fillColor: false,
        textColor: 20,
        halign: 'left',
        valign: 'top',
        fontSize: 10,
        cellPadding: 5 / scaleFactor,
        lineColor: 200,
        lineWidth: 0 / scaleFactor,
        columnWidth: 'auto'
    };
}
var Config = /** @class */ (function () {
    function Config() {
    }
    Config.pageSize = function () {
        var pageSize = table.doc.internal.pageSize;
        // JSPDF 1.4 uses get functions instead of properties on pageSize
        if (pageSize.width == null) {
            pageSize = {
                width: pageSize.getWidth(),
                height: pageSize.getHeight()
            };
        }
        return pageSize;
    };
    Config.applyUserStyles = function () {
        Config.applyStyles(table.userStyles);
    };
    Config.createTable = function (doc) {
        table = new models_1.Table(doc);
        return table;
    };
    Config.tableInstance = function () {
        return table;
    };
    Config.scaleFactor = function () {
        return table.doc.internal.scaleFactor;
    };
    Config.hooksData = function (additionalData) {
        if (additionalData === void 0) { additionalData = {}; }
        return assign({
            pageCount: table.pageCount,
            settings: table.settings,
            table: table,
            doc: table.doc,
            cursor: table.cursor
        }, additionalData || {});
    };
    Config.initSettings = function (table, allOptions) {
        var _loop_1 = function (styleProp) {
            var styles = allOptions.map(function (opts) { return opts[styleProp] || {}; });
            table.styles[styleProp] = assign.apply(void 0, [{}].concat(styles));
        };
        // Merge styles one level deeper
        for (var _i = 0, _a = Object.keys(table.styles); _i < _a.length; _i++) {
            var styleProp = _a[_i];
            _loop_1(styleProp);
        }
        // Append event handlers instead of replacing them
        for (var _b = 0, _c = entries(table.hooks); _b < _c.length; _b++) {
            var _d = _c[_b], hookName = _d[0], list = _d[1];
            for (var _e = 0, allOptions_1 = allOptions; _e < allOptions_1.length; _e++) {
                var opts = allOptions_1[_e];
                if (opts && opts[hookName]) {
                    list.push(opts[hookName]);
                }
            }
        }
        // Merge all other options one level
        table.settings = assign.apply(void 0, [getDefaults()].concat(allOptions));
    };
    // This is messy, only keep array and number format the next major version
    Config.marginOrPadding = function (value, defaultValue) {
        var newValue = {};
        if (Array.isArray(value)) {
            if (value.length >= 4) {
                newValue = { 'top': value[0], 'right': value[1], 'bottom': value[2], 'left': value[3] };
            }
            else if (value.length === 3) {
                newValue = { 'top': value[0], 'right': value[1], 'bottom': value[2], 'left': value[1] };
            }
            else if (value.length === 2) {
                newValue = { 'top': value[0], 'right': value[1], 'bottom': value[0], 'left': value[1] };
            }
            else if (value.length === 1) {
                value = value[0];
            }
            else {
                value = defaultValue;
            }
        }
        else if (typeof value === 'object') {
            if (value['vertical']) {
                value['top'] = value['vertical'];
                value['bottom'] = value['vertical'];
            }
            else if (value['horizontal']) {
                value['right'] = value['horizontal'];
                value['left'] = value['horizontal'];
            }
            for (var _i = 0, _a = ['top', 'right', 'bottom', 'left']; _i < _a.length; _i++) {
                var side = _a[_i];
                newValue[side] = value[side] || value[side] === 0 ? value[side] : defaultValue;
            }
        }
        if (typeof value === 'number') {
            newValue = { 'top': value, 'right': value, 'bottom': value, 'left': value };
        }
        return newValue;
    };
    Config.styles = function (styles) {
        styles = Array.isArray(styles) ? styles : [styles];
        return assign.apply(void 0, [defaultStyles()].concat(styles));
    };
    Config.applyStyles = function (styles) {
        var doc = table.doc;
        var styleModifiers = {
            fillColor: doc.setFillColor,
            textColor: doc.setTextColor,
            fontStyle: doc.setFontStyle,
            lineColor: doc.setDrawColor,
            lineWidth: doc.setLineWidth,
            font: doc.setFont,
            fontSize: doc.setFontSize
        };
        Object.keys(styleModifiers).forEach(function (name) {
            var style = styles[name];
            var modifier = styleModifiers[name];
            if (typeof style !== 'undefined') {
                if (Array.isArray(style)) {
                    modifier.apply(this, style);
                }
                else {
                    modifier(style);
                }
            }
        });
    };
    return Config;
}());
exports.Config = Config;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fnToStr = Function.prototype.toString;

var constructorRegex = /^\s*class /;
var isES6ClassFn = function isES6ClassFn(value) {
	try {
		var fnStr = fnToStr.call(value);
		var singleStripped = fnStr.replace(/\/\/.*\n/g, '');
		var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, '');
		var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' ');
		return constructorRegex.test(spaceStripped);
	} catch (e) {
		return false; // not a function
	}
};

var tryFunctionObject = function tryFunctionObject(value) {
	try {
		if (isES6ClassFn(value)) { return false; }
		fnToStr.call(value);
		return true;
	} catch (e) {
		return false;
	}
};
var toStr = Object.prototype.toString;
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isCallable(value) {
	if (!value) { return false; }
	if (typeof value !== 'function' && typeof value !== 'object') { return false; }
	if (hasToStringTag) { return tryFunctionObject(value); }
	if (isES6ClassFn(value)) { return false; }
	var strClass = toStr.call(value);
	return strClass === fnClass || strClass === genClass;
};


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

var implementation = __webpack_require__(29);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var config_1 = __webpack_require__(0);
var painter_1 = __webpack_require__(16);
function getStringWidth(text, styles) {
    var k = config_1.Config.scaleFactor();
    var fontSize = styles.fontSize / k;
    config_1.Config.applyStyles(styles);
    text = Array.isArray(text) ? text : [text];
    var maxWidth = 0;
    text.forEach(function (line) {
        var width = config_1.Config.tableInstance().doc.getStringUnitWidth(line);
        if (width > maxWidth) {
            maxWidth = width;
        }
    });
    var precision = 10000 * k;
    maxWidth = Math.floor(maxWidth * precision) / precision;
    return maxWidth * fontSize;
}
exports.getStringWidth = getStringWidth;
/**
 * Ellipsize the text to fit in the width
 */
function ellipsize(text, width, styles, ellipsizeStr) {
    if (ellipsizeStr === void 0) { ellipsizeStr = '...'; }
    if (Array.isArray(text)) {
        var value_1 = [];
        text.forEach(function (str, i) {
            value_1[i] = ellipsize(str, width, styles, ellipsizeStr);
        });
        return value_1;
    }
    var precision = 10000 * config_1.Config.scaleFactor();
    width = Math.ceil(width * precision) / precision;
    if (width >= getStringWidth(text, styles)) {
        return text;
    }
    while (width < getStringWidth(text + ellipsizeStr, styles)) {
        if (text.length <= 1) {
            break;
        }
        text = text.substring(0, text.length - 1);
    }
    return text.trim() + ellipsizeStr;
}
exports.ellipsize = ellipsize;
function addTableBorder() {
    var table = config_1.Config.tableInstance();
    var styles = { lineWidth: table.settings.tableLineWidth, lineColor: table.settings.tableLineColor };
    config_1.Config.applyStyles(styles);
    var fs = getFillStyle(styles);
    if (fs) {
        table.doc.rect(table.pageStartX, table.pageStartY, table.width, table.cursor.y - table.pageStartY, fs);
    }
}
exports.addTableBorder = addTableBorder;
function addPage() {
    var table = config_1.Config.tableInstance();
    table.finalY = table.cursor.y;
    // Add user content just before adding new page ensure it will 
    // be drawn above other things on the page
    addContentHooks();
    addTableBorder();
    nextPage(table.doc);
    table.pageCount++;
    table.cursor = { x: table.margin('left'), y: table.margin('top') };
    table.pageStartX = table.cursor.x;
    table.pageStartY = table.cursor.y;
    if (table.settings.showHeader === true || table.settings.showHeader === 'everyPage') {
        painter_1.printRow(table.headerRow, table.hooks.drawHeaderRow, table.hooks.drawHeaderCell);
    }
}
exports.addPage = addPage;
function addContentHooks() {
    for (var _i = 0, _a = config_1.Config.tableInstance().hooks.addPageContent; _i < _a.length; _i++) {
        var hook = _a[_i];
        config_1.Config.applyUserStyles();
        hook(config_1.Config.hooksData());
    }
    config_1.Config.applyUserStyles();
}
exports.addContentHooks = addContentHooks;
function getFillStyle(styles) {
    var drawLine = styles.lineWidth > 0;
    var drawBackground = styles.fillColor || styles.fillColor === 0;
    if (drawLine && drawBackground) {
        return 'DF'; // Fill then stroke
    }
    else if (drawLine) {
        return 'S'; // Only stroke (transparent background)
    }
    else if (drawBackground) {
        return 'F'; // Only fill, no stroke
    }
    else {
        return false;
    }
}
exports.getFillStyle = getFillStyle;
function nextPage(doc) {
    var current = doc.internal.getCurrentPageInfo().pageNumber;
    doc.setPage(current + 1);
    var newCurrent = doc.internal.getCurrentPageInfo().pageNumber;
    if (newCurrent === current) {
        doc.addPage();
    }
}
exports.nextPage = nextPage;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var config_1 = __webpack_require__(0);
exports.table = {};
var Table = /** @class */ (function () {
    function Table(doc) {
        this.height = 0;
        this.width = 0;
        this.contentWidth = 0;
        this.preferredWidth = 0;
        this.rows = [];
        this.columns = [];
        this.headerRow = null;
        this.pageCount = 1;
        this.hooks = {
            createdHeaderCell: [],
            createdCell: [],
            drawHeaderRow: [],
            drawRow: [],
            drawHeaderCell: [],
            drawCell: [],
            addPageContent: []
        };
        this.styles = {
            styles: {},
            headerStyles: {},
            bodyStyles: {},
            alternateRowStyles: {},
            columnStyles: {}
        };
        this.doc = doc;
        this.userStyles = {
            textColor: 30,
            fontSize: doc.internal.getFontSize(),
            fontStyle: doc.internal.getFont().fontStyle
        };
    }
    Table.prototype.margin = function (side) {
        return config_1.Config.marginOrPadding(this.settings.margin, config_1.getDefaults().margin)[side];
    };
    return Table;
}());
exports.Table = Table;
var Row = /** @class */ (function () {
    function Row(raw, index) {
        this.cells = {};
        this.spansMultiplePages = false;
        this.pageCount = 1;
        this.height = 0;
        this.y = 0;
        this.maxLineCount = 1;
        this.raw = raw;
        this.index = index;
    }
    return Row;
}());
exports.Row = Row;
var Cell = /** @class */ (function () {
    function Cell(raw) {
        this.styles = {};
        this.text = '';
        this.contentWidth = 0;
        this.textPos = {};
        this.height = 0;
        this.width = 0;
        this.x = 0;
        this.y = 0;
        this.raw = raw;
    }
    Cell.prototype.padding = function (name) {
        var padding = config_1.Config.marginOrPadding(this.styles.cellPadding, config_1.Config.styles([]).cellPadding);
        if (name === 'vertical') {
            return padding.top + padding.bottom;
        }
        else if (name === 'horizontal') {
            return padding.left + padding.right;
        }
        else {
            return padding[name];
        }
    };
    return Cell;
}());
exports.Cell = Cell;
var Column = /** @class */ (function () {
    function Column(dataKey, index) {
        this.options = {};
        this.contentWidth = 0;
        this.preferredWidth = 0;
        this.widthStyle = 'auto';
        this.width = 0;
        this.x = 0;
        this.dataKey = dataKey;
        this.index = index;
    }
    return Column;
}());
exports.Column = Column;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var keys = __webpack_require__(20);
var foreach = __webpack_require__(22);
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

var toStr = Object.prototype.toString;

var isFunction = function (fn) {
	return typeof fn === 'function' && toStr.call(fn) === '[object Function]';
};

var arePropertyDescriptorsSupported = function () {
	var obj = {};
	try {
		Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
        /* eslint-disable no-unused-vars, no-restricted-syntax */
        for (var _ in obj) { return false; }
        /* eslint-enable no-unused-vars, no-restricted-syntax */
		return obj.x === obj;
	} catch (e) { /* this is IE 8. */
		return false;
	}
};
var supportsDescriptors = Object.defineProperty && arePropertyDescriptorsSupported();

var defineProperty = function (object, name, value, predicate) {
	if (name in object && (!isFunction(predicate) || !predicate())) {
		return;
	}
	if (supportsDescriptors) {
		Object.defineProperty(object, name, {
			configurable: true,
			enumerable: false,
			value: value,
			writable: true
		});
	} else {
		object[name] = value;
	}
};

var defineProperties = function (object, map) {
	var predicates = arguments.length > 2 ? arguments[2] : {};
	var props = keys(map);
	if (hasSymbols) {
		props = props.concat(Object.getOwnPropertySymbols(map));
	}
	foreach(props, function (name) {
		defineProperty(object, name, map[name], predicates[name]);
	});
};

defineProperties.supportsDescriptors = !!supportsDescriptors;

module.exports = defineProperties;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ES = __webpack_require__(23);
var has = __webpack_require__(14);
var bind = __webpack_require__(2);
var isEnumerable = bind.call(Function.call, Object.prototype.propertyIsEnumerable);

module.exports = function entries(O) {
	var obj = ES.RequireObjectCoercible(O);
	var entrys = [];
	for (var key in obj) {
		if (has(obj, key) && isEnumerable(obj, key)) {
			entrys.push([key, obj[key]]);
		}
	}
	return entrys;
};


/***/ }),
/* 8 */
/***/ (function(module, exports) {

module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),
/* 9 */
/***/ (function(module, exports) {

var $isNaN = Number.isNaN || function (a) { return a !== a; };

module.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };


/***/ }),
/* 10 */
/***/ (function(module, exports) {

var has = Object.prototype.hasOwnProperty;
module.exports = Object.assign || function assign(target, source) {
	for (var key in source) {
		if (has.call(source, key)) {
			target[key] = source[key];
		}
	}
	return target;
};


/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = function sign(number) {
	return number >= 0 ? 1 : -1;
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = function mod(number, modulo) {
	var remain = number % modulo;
	return Math.floor(remain >= 0 ? remain : remain + modulo);
};


/***/ }),
/* 13 */
/***/ (function(module, exports) {

module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(2);

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var implementation = __webpack_require__(7);

module.exports = function getPolyfill() {
	return typeof Object.entries === 'function' ? Object.entries : implementation;
};


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var config_1 = __webpack_require__(0);
var common_1 = __webpack_require__(3);
function printFullRow(row, drawRowHooks, drawCellHooks) {
    var remainingRowHeight = 0;
    var remainingTexts = {};
    var table = config_1.Config.tableInstance();
    if (!canFitOnPage(row.height)) {
        if (row.maxLineCount <= 1) {
            common_1.addPage();
        }
        else {
            // Modify the row to fit the current page and calculate text and height of partial row
            row.spansMultiplePages = true;
            var pageHeight = config_1.Config.pageSize().height;
            var maxCellHeight = 0;
            for (var j = 0; j < table.columns.length; j++) {
                var col = table.columns[j];
                var cell = row.cells[col.dataKey];
                var fontHeight = cell.styles.fontSize / config_1.Config.scaleFactor() * config_1.FONT_ROW_RATIO;
                var vPadding = cell.padding('vertical');
                var remainingPageSpace = pageHeight - table.cursor.y - table.margin('bottom');
                var remainingLineCount = Math.floor((remainingPageSpace - vPadding) / fontHeight);
                // Splice with negative values results in unexpected results, therefore eliminate
                // scenarios where less than one line is remaining, but are shown
                if (remainingLineCount < 0) {
                    remainingLineCount = 0;
                }
                if (Array.isArray(cell.text) && cell.text.length > remainingLineCount) {
                    var remainingLines = cell.text.splice(remainingLineCount, cell.text.length);
                    remainingTexts[col.dataKey] = remainingLines;
                    var cellHeight = cell.text.length * fontHeight + vPadding;
                    if (cellHeight > maxCellHeight) {
                        maxCellHeight = cellHeight;
                    }
                    var rCellHeight = remainingLines.length * fontHeight + vPadding;
                    if (rCellHeight > remainingRowHeight) {
                        remainingRowHeight = rCellHeight;
                    }
                }
            }
            // Reset row height since text are now removed
            row.height = maxCellHeight;
        }
    }
    printRow(row, drawRowHooks, drawCellHooks);
    // Parts of the row is now printed. Time for adding a new page, prune 
    // the text and start over
    if (Object.keys(remainingTexts).length > 0) {
        for (var j = 0; j < table.columns.length; j++) {
            var col = table.columns[j];
            var cell = row.cells[col.dataKey];
            cell.text = remainingTexts[col.dataKey] || '';
        }
        common_1.addPage();
        row.pageCount++;
        row.height = remainingRowHeight;
        printFullRow(row, drawRowHooks, drawCellHooks);
    }
}
exports.printFullRow = printFullRow;
function printRow(row, drawRowHooks, drawCellHooks) {
    var table = config_1.Config.tableInstance();
    row.y = table.cursor.y;
    for (var _i = 0, drawRowHooks_1 = drawRowHooks; _i < drawRowHooks_1.length; _i++) {
        var hook = drawRowHooks_1[_i];
        if (hook(row, config_1.Config.hooksData({ row: row, addPage: common_1.addPage })) === false) {
            return;
        }
    }
    table.cursor.x = table.margin('left');
    for (var i = 0; i < table.columns.length; i++) {
        var column = table.columns[i];
        var cell = row.cells[column.dataKey];
        if (!cell) {
            continue;
        }
        config_1.Config.applyStyles(cell.styles);
        cell.x = table.cursor.x;
        cell.y = table.cursor.y;
        cell.height = row.height;
        cell.width = column.width;
        if (cell.styles.valign === 'top') {
            cell.textPos.y = table.cursor.y + cell.padding('top');
        }
        else if (cell.styles.valign === 'bottom') {
            cell.textPos.y = table.cursor.y + row.height - cell.padding('bottom');
        }
        else {
            cell.textPos.y = table.cursor.y + row.height / 2;
        }
        if (cell.styles.halign === 'right') {
            cell.textPos.x = cell.x + cell.width - cell.padding('right');
        }
        else if (cell.styles.halign === 'center') {
            cell.textPos.x = cell.x + cell.width / 2;
        }
        else {
            cell.textPos.x = cell.x + cell.padding('left');
        }
        var shouldDrawCell = true;
        var data = config_1.Config.hooksData({ column: column, row: row, addPage: common_1.addPage });
        for (var _a = 0, drawCellHooks_1 = drawCellHooks; _a < drawCellHooks_1.length; _a++) {
            var hook = drawCellHooks_1[_a];
            if (hook(cell, data) === false) {
                shouldDrawCell = false;
            }
        }
        if (shouldDrawCell) {
            var fillStyle = common_1.getFillStyle(cell.styles);
            if (fillStyle) {
                table.doc.rect(cell.x, cell.y, cell.width, cell.height, fillStyle);
            }
            table.doc.autoTableText(cell.text, cell.textPos.x, cell.textPos.y, {
                halign: cell.styles.halign,
                valign: cell.styles.valign
            });
        }
        table.cursor.x += cell.width;
    }
    table.cursor.y += row.height;
}
exports.printRow = printRow;
function canFitOnPage(rowHeight) {
    var table = config_1.Config.tableInstance();
    var pos = rowHeight + table.cursor.y + table.margin('bottom');
    return pos < config_1.Config.pageSize().height;
}


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var jsPDF = __webpack_require__(18);
var config_1 = __webpack_require__(0);
var common_1 = __webpack_require__(3);
var painter_1 = __webpack_require__(16);
var calculator_1 = __webpack_require__(34);
var creator_1 = __webpack_require__(35);
/**
 * Create a table from a set of rows and columns.
 *
 * @param {Object[]|String[]} headers Either as an array of objects or array of strings
 * @param {Object[][]|String[][]} data Either as an array of objects or array of strings
 * @param {Object} [tableOptions={}] Options that will override the default ones
 */
jsPDF.API.autoTable = function (headers, data, tableOptions) {
    if (tableOptions === void 0) { tableOptions = {}; }
    this.autoTableState = this.autoTableState || {};
    jsPDF.autoTableState = jsPDF.autoTableState || {};
    var allOptions = [jsPDF.autoTableState.defaults || {}, this.autoTableState.defaults || {}, tableOptions || {}];
    creator_1.validateInput(headers, data, allOptions);
    var table = config_1.Config.createTable(this);
    config_1.Config.initSettings(table, allOptions);
    var settings = table.settings;
    // Create the table model with its columns, rows and cells
    creator_1.createModels(headers, data);
    settings.margin = config_1.Config.marginOrPadding(settings.margin, config_1.getDefaults().margin);
    calculator_1.calculateWidths(this, config_1.Config.pageSize().width);
    table.cursor = {
        x: table.margin('left'),
        y: settings.startY === false ? table.margin('top') : settings.startY
    };
    var minTableBottomPos = settings.startY + table.margin('bottom') + table.headerRow.height;
    if (settings.pageBreak === 'avoid') {
        minTableBottomPos += table.height;
    }
    var pageHeight = config_1.Config.pageSize().height;
    if ((settings.pageBreak === 'always' && settings.startY !== false) ||
        (settings.startY !== false && minTableBottomPos > pageHeight)) {
        common_1.nextPage(table.doc);
        table.cursor.y = table.margin('top');
    }
    table.pageStartX = table.cursor.x;
    table.pageStartY = table.cursor.y;
    config_1.Config.applyUserStyles();
    if (settings.showHeader === true || settings.showHeader === 'firstPage' || settings.showHeader === 'everyPage') {
        painter_1.printRow(table.headerRow, table.hooks.drawHeaderRow, table.hooks.drawHeaderCell);
    }
    config_1.Config.applyUserStyles();
    table.rows.forEach(function (row) {
        painter_1.printFullRow(row, table.hooks.drawRow, table.hooks.drawCell);
    });
    common_1.addTableBorder();
    // Don't call global and document addPageContent more than once for each page
    var pageNumber = this.internal.getCurrentPageInfo().pageNumber;
    if (this.autoTableState.addPageHookPages && this.autoTableState.addPageHookPages[pageNumber]) {
        if (typeof tableOptions['addPageContent'] === 'function') {
            tableOptions['addPageContent'](config_1.Config.hooksData());
        }
    }
    else {
        if (!this.autoTableState.addPageHookPages)
            this.autoTableState.addPageHookPages = {};
        this.autoTableState.addPageHookPages[pageNumber] = true;
        common_1.addContentHooks();
    }
    table.finalY = table.cursor.y;
    this.autoTable.previous = table;
    config_1.Config.applyUserStyles();
    return this;
};
// Enables doc.autoTable.previous.finalY || 40;
jsPDF.API.autoTable.previous = false;
jsPDF.API.autoTableSetDefaults = function (defaults) {
    if (!this.autoTableState)
        this.autoTableState = {};
    if (defaults && typeof defaults === 'object') {
        this.autoTableState.defaults = defaults;
    }
    else {
        delete this.autoTableState.defaults;
    }
    return this;
};
jsPDF.autoTableSetDefaults = function (defaults) {
    if (!jsPDF.autoTableState)
        jsPDF.autoTableState = {};
    if (defaults && typeof defaults === 'object') {
        this.autoTableState.defaults = defaults;
    }
    else {
        delete this.autoTableState.defaults;
    }
    jsPDF.autoTableState.defaults = defaults;
};
/**
 * Parses an html table
 *
 * @param tableElem Html table element
 * @param includeHiddenElements If to include hidden rows and columns (defaults to false)
 * @returns Object Object with two properties, columns and rows
 */
jsPDF.API.autoTableHtmlToJson = function (tableElem, includeHiddenElements) {
    includeHiddenElements = includeHiddenElements || false;
    if (!tableElem || !(tableElem instanceof HTMLTableElement)) {
        console.error("A HTMLTableElement has to be sent to autoTableHtmlToJson");
        return null;
    }
    var columns = {}, rows = [];
    var header = tableElem.rows[0];
    for (var i = 0; i < header.cells.length; i++) {
        var cell = header.cells[i];
        var style = window.getComputedStyle(cell);
        if (includeHiddenElements || style.display !== 'none') {
            columns[i] = cell;
        }
    }
    var _loop_1 = function (i) {
        var tableRow = tableElem.rows[i];
        var style = window.getComputedStyle(tableRow);
        if (includeHiddenElements || style.display !== 'none') {
            var rowData_1 = [];
            Object.keys(columns).forEach(function (key) {
                var cell = tableRow.cells[key];
                rowData_1.push(cell);
            });
            rows.push(rowData_1);
        }
    };
    for (var i = 1; i < tableElem.rows.length; i++) {
        _loop_1(i);
    }
    var values = Object.keys(columns).map(function (key) { return columns[key]; });
    return { columns: values, rows: rows, data: rows };
};
/**
 * Improved text function with halign and valign support
 * Inspiration from: http://stackoverflow.com/questions/28327510/align-text-right-using-jspdf/28433113#28433113
 */
jsPDF.API.autoTableText = function (text, x, y, styles) {
    if (typeof x !== 'number' || typeof y !== 'number') {
        console.error('The x and y parameters are required. Missing for the text: ', text);
    }
    var k = this.internal.scaleFactor;
    var fontSize = this.internal.getFontSize() / k;
    var splitRegex = /\r\n|\r|\n/g;
    var splitText = null;
    var lineCount = 1;
    if (styles.valign === 'middle' || styles.valign === 'bottom' || styles.halign === 'center' || styles.halign === 'right') {
        splitText = typeof text === 'string' ? text.split(splitRegex) : text;
        lineCount = splitText.length || 1;
    }
    // Align the top
    y += fontSize * (2 - config_1.FONT_ROW_RATIO);
    if (styles.valign === 'middle')
        y -= (lineCount / 2) * fontSize * config_1.FONT_ROW_RATIO;
    else if (styles.valign === 'bottom')
        y -= lineCount * fontSize * config_1.FONT_ROW_RATIO;
    if (styles.halign === 'center' || styles.halign === 'right') {
        var alignSize = fontSize;
        if (styles.halign === 'center')
            alignSize *= 0.5;
        if (lineCount >= 1) {
            for (var iLine = 0; iLine < splitText.length; iLine++) {
                this.text(splitText[iLine], x - this.getStringUnitWidth(splitText[iLine]) * alignSize, y);
                y += fontSize;
            }
            return this;
        }
        x -= this.getStringUnitWidth(text) * alignSize;
    }
    this.text(text, x, y);
    return this;
};
/**
 * @deprecated Use doc.autoTable.previous.finalY instead
 */
jsPDF.API.autoTableEndPosY = function () {
    var prev = this.autoTable.previous;
    if (prev.cursor && typeof prev.cursor.y === 'number') {
        return prev.cursor.y;
    }
    else {
        return 0;
    }
};
/**
 * @deprecated Use jsPDF.autoTableSetDefaults({addPageContent: function() {}}) instead
 */
jsPDF.API.autoTableAddPageContent = function (hook) {
    if (!jsPDF.API.autoTable.globalDefaults) {
        jsPDF.API.autoTable.globalDefaults = {};
    }
    jsPDF.API.autoTable.globalDefaults.addPageContent = hook;
    return this;
};
/**
 * @deprecated Use data.addPage in hooks instead
 */
jsPDF.API.autoTableAddPage = function () {
    common_1.addPage();
    return this;
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__18__;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var define = __webpack_require__(6);

var implementation = __webpack_require__(7);
var getPolyfill = __webpack_require__(15);
var shim = __webpack_require__(33);

var polyfill = getPolyfill();

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// modified from https://github.com/es-shims/es5-shim
var has = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var slice = Array.prototype.slice;
var isArgs = __webpack_require__(21);
var isEnumerable = Object.prototype.propertyIsEnumerable;
var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
var dontEnums = [
	'toString',
	'toLocaleString',
	'valueOf',
	'hasOwnProperty',
	'isPrototypeOf',
	'propertyIsEnumerable',
	'constructor'
];
var equalsConstructorPrototype = function (o) {
	var ctor = o.constructor;
	return ctor && ctor.prototype === o;
};
var excludedKeys = {
	$console: true,
	$external: true,
	$frame: true,
	$frameElement: true,
	$frames: true,
	$innerHeight: true,
	$innerWidth: true,
	$outerHeight: true,
	$outerWidth: true,
	$pageXOffset: true,
	$pageYOffset: true,
	$parent: true,
	$scrollLeft: true,
	$scrollTop: true,
	$scrollX: true,
	$scrollY: true,
	$self: true,
	$webkitIndexedDB: true,
	$webkitStorageInfo: true,
	$window: true
};
var hasAutomationEqualityBug = (function () {
	/* global window */
	if (typeof window === 'undefined') { return false; }
	for (var k in window) {
		try {
			if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
				try {
					equalsConstructorPrototype(window[k]);
				} catch (e) {
					return true;
				}
			}
		} catch (e) {
			return true;
		}
	}
	return false;
}());
var equalsConstructorPrototypeIfNotBuggy = function (o) {
	/* global window */
	if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
		return equalsConstructorPrototype(o);
	}
	try {
		return equalsConstructorPrototype(o);
	} catch (e) {
		return false;
	}
};

var keysShim = function keys(object) {
	var isObject = object !== null && typeof object === 'object';
	var isFunction = toStr.call(object) === '[object Function]';
	var isArguments = isArgs(object);
	var isString = isObject && toStr.call(object) === '[object String]';
	var theKeys = [];

	if (!isObject && !isFunction && !isArguments) {
		throw new TypeError('Object.keys called on a non-object');
	}

	var skipProto = hasProtoEnumBug && isFunction;
	if (isString && object.length > 0 && !has.call(object, 0)) {
		for (var i = 0; i < object.length; ++i) {
			theKeys.push(String(i));
		}
	}

	if (isArguments && object.length > 0) {
		for (var j = 0; j < object.length; ++j) {
			theKeys.push(String(j));
		}
	} else {
		for (var name in object) {
			if (!(skipProto && name === 'prototype') && has.call(object, name)) {
				theKeys.push(String(name));
			}
		}
	}

	if (hasDontEnumBug) {
		var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

		for (var k = 0; k < dontEnums.length; ++k) {
			if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
				theKeys.push(dontEnums[k]);
			}
		}
	}
	return theKeys;
};

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			return (Object.keys(arguments) || '').length === 2;
		}(1, 2));
		if (!keysWorksWithArguments) {
			var originalKeys = Object.keys;
			Object.keys = function keys(object) {
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				} else {
					return originalKeys(object);
				}
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};


/***/ }),
/* 22 */
/***/ (function(module, exports) {


var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;

module.exports = function forEach (obj, fn, ctx) {
    if (toString.call(fn) !== '[object Function]') {
        throw new TypeError('iterator must be a function');
    }
    var l = obj.length;
    if (l === +l) {
        for (var i = 0; i < l; i++) {
            fn.call(ctx, obj[i], i, obj);
        }
    } else {
        for (var k in obj) {
            if (hasOwn.call(obj, k)) {
                fn.call(ctx, obj[k], k, obj);
            }
        }
    }
};



/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ES6 = __webpack_require__(24);
var assign = __webpack_require__(10);

var ES7 = assign(ES6, {
	// https://github.com/tc39/ecma262/pull/60
	SameValueNonNumber: function SameValueNonNumber(x, y) {
		if (typeof x === 'number' || typeof x !== typeof y) {
			throw new TypeError('SameValueNonNumber requires two non-number values of the same type.');
		}
		return this.SameValue(x, y);
	}
});

module.exports = ES7;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';
var symbolToStr = hasSymbols ? Symbol.prototype.toString : toStr;

var $isNaN = __webpack_require__(8);
var $isFinite = __webpack_require__(9);
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || Math.pow(2, 53) - 1;

var assign = __webpack_require__(10);
var sign = __webpack_require__(11);
var mod = __webpack_require__(12);
var isPrimitive = __webpack_require__(25);
var toPrimitive = __webpack_require__(26);
var parseInteger = parseInt;
var bind = __webpack_require__(2);
var strSlice = bind.call(Function.call, String.prototype.slice);
var isBinary = bind.call(Function.call, RegExp.prototype.test, /^0b[01]+$/i);
var isOctal = bind.call(Function.call, RegExp.prototype.test, /^0o[0-7]+$/i);
var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
var hasNonWS = bind.call(Function.call, RegExp.prototype.test, nonWSregex);
var invalidHexLiteral = /^[-+]0x[0-9a-f]+$/i;
var isInvalidHexLiteral = bind.call(Function.call, RegExp.prototype.test, invalidHexLiteral);

// whitespace from: http://es5.github.io/#x15.5.4.20
// implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
var ws = [
	'\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
	'\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
	'\u2029\uFEFF'
].join('');
var trimRegex = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
var replace = bind.call(Function.call, String.prototype.replace);
var trim = function (value) {
	return replace(value, trimRegex, '');
};

var ES5 = __webpack_require__(30);

var hasRegExpMatcher = __webpack_require__(32);

// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-abstract-operations
var ES6 = assign(assign({}, ES5), {

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
	Call: function Call(F, V) {
		var args = arguments.length > 2 ? arguments[2] : [];
		if (!this.IsCallable(F)) {
			throw new TypeError(F + ' is not a function');
		}
		return F.apply(V, args);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toprimitive
	ToPrimitive: toPrimitive,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toboolean
	// ToBoolean: ES5.ToBoolean,

	// http://www.ecma-international.org/ecma-262/6.0/#sec-tonumber
	ToNumber: function ToNumber(argument) {
		var value = isPrimitive(argument) ? argument : toPrimitive(argument, 'number');
		if (typeof value === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a number');
		}
		if (typeof value === 'string') {
			if (isBinary(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 2));
			} else if (isOctal(value)) {
				return this.ToNumber(parseInteger(strSlice(value, 2), 8));
			} else if (hasNonWS(value) || isInvalidHexLiteral(value)) {
				return NaN;
			} else {
				var trimmed = trim(value);
				if (trimmed !== value) {
					return this.ToNumber(trimmed);
				}
			}
		}
		return Number(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tointeger
	// ToInteger: ES5.ToNumber,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint32
	// ToInt32: ES5.ToInt32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint32
	// ToUint32: ES5.ToUint32,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint16
	ToInt16: function ToInt16(argument) {
		var int16bit = this.ToUint16(argument);
		return int16bit >= 0x8000 ? int16bit - 0x10000 : int16bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint16
	// ToUint16: ES5.ToUint16,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toint8
	ToInt8: function ToInt8(argument) {
		var int8bit = this.ToUint8(argument);
		return int8bit >= 0x80 ? int8bit - 0x100 : int8bit;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8
	ToUint8: function ToUint8(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x100);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-touint8clamp
	ToUint8Clamp: function ToUint8Clamp(argument) {
		var number = this.ToNumber(argument);
		if ($isNaN(number) || number <= 0) { return 0; }
		if (number >= 0xFF) { return 0xFF; }
		var f = Math.floor(argument);
		if (f + 0.5 < number) { return f + 1; }
		if (number < f + 0.5) { return f; }
		if (f % 2 !== 0) { return f + 1; }
		return f;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tostring
	ToString: function ToString(argument) {
		if (typeof argument === 'symbol') {
			throw new TypeError('Cannot convert a Symbol value to a string');
		}
		return String(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-toobject
	ToObject: function ToObject(value) {
		this.RequireObjectCoercible(value);
		return Object(value);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-topropertykey
	ToPropertyKey: function ToPropertyKey(argument) {
		var key = this.ToPrimitive(argument, String);
		return typeof key === 'symbol' ? symbolToStr.call(key) : this.ToString(key);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	ToLength: function ToLength(argument) {
		var len = this.ToInteger(argument);
		if (len <= 0) { return 0; } // includes converting -0 to +0
		if (len > MAX_SAFE_INTEGER) { return MAX_SAFE_INTEGER; }
		return len;
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring
	CanonicalNumericIndexString: function CanonicalNumericIndexString(argument) {
		if (toStr.call(argument) !== '[object String]') {
			throw new TypeError('must be a string');
		}
		if (argument === '-0') { return -0; }
		var n = this.ToNumber(argument);
		if (this.SameValue(this.ToString(n), argument)) { return n; }
		return void 0;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-requireobjectcoercible
	RequireObjectCoercible: ES5.CheckObjectCoercible,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isarray
	IsArray: Array.isArray || function IsArray(argument) {
		return toStr.call(argument) === '[object Array]';
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iscallable
	// IsCallable: ES5.IsCallable,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isconstructor
	IsConstructor: function IsConstructor(argument) {
		return typeof argument === 'function' && !!argument.prototype; // unfortunately there's no way to truly check this without try/catch `new argument`
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isextensible-o
	IsExtensible: function IsExtensible(obj) {
		if (!Object.preventExtensions) { return true; }
		if (isPrimitive(obj)) {
			return false;
		}
		return Object.isExtensible(obj);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-isinteger
	IsInteger: function IsInteger(argument) {
		if (typeof argument !== 'number' || $isNaN(argument) || !$isFinite(argument)) {
			return false;
		}
		var abs = Math.abs(argument);
		return Math.floor(abs) === abs;
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-ispropertykey
	IsPropertyKey: function IsPropertyKey(argument) {
		return typeof argument === 'string' || typeof argument === 'symbol';
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-isregexp
	IsRegExp: function IsRegExp(argument) {
		if (!argument || typeof argument !== 'object') {
			return false;
		}
		if (hasSymbols) {
			var isRegExp = argument[Symbol.match];
			if (typeof isRegExp !== 'undefined') {
				return ES5.ToBoolean(isRegExp);
			}
		}
		return hasRegExpMatcher(argument);
	},

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevalue
	// SameValue: ES5.SameValue,

	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero
	SameValueZero: function SameValueZero(x, y) {
		return (x === y) || ($isNaN(x) && $isNaN(y));
	},

	/**
	 * 7.3.2 GetV (V, P)
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let O be ToObject(V).
	 * 3. ReturnIfAbrupt(O).
	 * 4. Return O.[[Get]](P, V).
	 */
	GetV: function GetV(V, P) {
		// 7.3.2.1
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.2.2-3
		var O = this.ToObject(V);

		// 7.3.2.4
		return O[P];
	},

	/**
	 * 7.3.9 - http://www.ecma-international.org/ecma-262/6.0/#sec-getmethod
	 * 1. Assert: IsPropertyKey(P) is true.
	 * 2. Let func be GetV(O, P).
	 * 3. ReturnIfAbrupt(func).
	 * 4. If func is either undefined or null, return undefined.
	 * 5. If IsCallable(func) is false, throw a TypeError exception.
	 * 6. Return func.
	 */
	GetMethod: function GetMethod(O, P) {
		// 7.3.9.1
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}

		// 7.3.9.2
		var func = this.GetV(O, P);

		// 7.3.9.4
		if (func == null) {
			return undefined;
		}

		// 7.3.9.5
		if (!this.IsCallable(func)) {
			throw new TypeError(P + 'is not a function');
		}

		// 7.3.9.6
		return func;
	},

	/**
	 * 7.3.1 Get (O, P) - http://www.ecma-international.org/ecma-262/6.0/#sec-get-o-p
	 * 1. Assert: Type(O) is Object.
	 * 2. Assert: IsPropertyKey(P) is true.
	 * 3. Return O.[[Get]](P, O).
	 */
	Get: function Get(O, P) {
		// 7.3.1.1
		if (this.Type(O) !== 'Object') {
			throw new TypeError('Assertion failed: Type(O) is not Object');
		}
		// 7.3.1.2
		if (!this.IsPropertyKey(P)) {
			throw new TypeError('Assertion failed: IsPropertyKey(P) is not true');
		}
		// 7.3.1.3
		return O[P];
	},

	Type: function Type(x) {
		if (typeof x === 'symbol') {
			return 'Symbol';
		}
		return ES5.Type(x);
	},

	// http://www.ecma-international.org/ecma-262/6.0/#sec-speciesconstructor
	SpeciesConstructor: function SpeciesConstructor(O, defaultConstructor) {
		if (this.Type(O) !== 'Object') {
			throw new TypeError('Assertion failed: Type(O) is not Object');
		}
		var C = O.constructor;
		if (typeof C === 'undefined') {
			return defaultConstructor;
		}
		if (this.Type(C) !== 'Object') {
			throw new TypeError('O.constructor is not an Object');
		}
		var S = hasSymbols && Symbol.species ? C[Symbol.species] : undefined;
		if (S == null) {
			return defaultConstructor;
		}
		if (this.IsConstructor(S)) {
			return S;
		}
		throw new TypeError('no constructor found');
	}
});

delete ES6.CheckObjectCoercible; // renamed in ES6 to RequireObjectCoercible

module.exports = ES6;


/***/ }),
/* 25 */
/***/ (function(module, exports) {

module.exports = function isPrimitive(value) {
	return value === null || (typeof value !== 'function' && typeof value !== 'object');
};


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';

var isPrimitive = __webpack_require__(13);
var isCallable = __webpack_require__(1);
var isDate = __webpack_require__(27);
var isSymbol = __webpack_require__(28);

var ordinaryToPrimitive = function OrdinaryToPrimitive(O, hint) {
	if (typeof O === 'undefined' || O === null) {
		throw new TypeError('Cannot call method on ' + O);
	}
	if (typeof hint !== 'string' || (hint !== 'number' && hint !== 'string')) {
		throw new TypeError('hint must be "string" or "number"');
	}
	var methodNames = hint === 'string' ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
	var method, result, i;
	for (i = 0; i < methodNames.length; ++i) {
		method = O[methodNames[i]];
		if (isCallable(method)) {
			result = method.call(O);
			if (isPrimitive(result)) {
				return result;
			}
		}
	}
	throw new TypeError('No default value');
};

var GetMethod = function GetMethod(O, P) {
	var func = O[P];
	if (func !== null && typeof func !== 'undefined') {
		if (!isCallable(func)) {
			throw new TypeError(func + ' returned for property ' + P + ' of object ' + O + ' is not a function');
		}
		return func;
	}
};

// http://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	var hint = 'default';
	if (arguments.length > 1) {
		if (PreferredType === String) {
			hint = 'string';
		} else if (PreferredType === Number) {
			hint = 'number';
		}
	}

	var exoticToPrim;
	if (hasSymbols) {
		if (Symbol.toPrimitive) {
			exoticToPrim = GetMethod(input, Symbol.toPrimitive);
		} else if (isSymbol(input)) {
			exoticToPrim = Symbol.prototype.valueOf;
		}
	}
	if (typeof exoticToPrim !== 'undefined') {
		var result = exoticToPrim.call(input, hint);
		if (isPrimitive(result)) {
			return result;
		}
		throw new TypeError('unable to convert exotic object to primitive');
	}
	if (hint === 'default' && (isDate(input) || isSymbol(input))) {
		hint = 'string';
	}
	return ordinaryToPrimitive(input, hint === 'default' ? 'number' : hint);
};


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateObject(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) { return false; }
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;
var hasSymbols = typeof Symbol === 'function' && typeof Symbol() === 'symbol';

if (hasSymbols) {
	var symToStr = Symbol.prototype.toString;
	var symStringRegex = /^Symbol\(.*\)$/;
	var isSymbolObject = function isSymbolObject(value) {
		if (typeof value.valueOf() !== 'symbol') { return false; }
		return symStringRegex.test(symToStr.call(value));
	};
	module.exports = function isSymbol(value) {
		if (typeof value === 'symbol') { return true; }
		if (toStr.call(value) !== '[object Symbol]') { return false; }
		try {
			return isSymbolObject(value);
		} catch (e) {
			return false;
		}
	};
} else {
	module.exports = function isSymbol(value) {
		// this environment does not support Symbols.
		return false;
	};
}


/***/ }),
/* 29 */
/***/ (function(module, exports) {

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $isNaN = __webpack_require__(8);
var $isFinite = __webpack_require__(9);

var sign = __webpack_require__(11);
var mod = __webpack_require__(12);

var IsCallable = __webpack_require__(1);
var toPrimitive = __webpack_require__(31);

// https://es5.github.io/#x9
var ES5 = {
	ToPrimitive: toPrimitive,

	ToBoolean: function ToBoolean(value) {
		return Boolean(value);
	},
	ToNumber: function ToNumber(value) {
		return Number(value);
	},
	ToInteger: function ToInteger(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number)) { return 0; }
		if (number === 0 || !$isFinite(number)) { return number; }
		return sign(number) * Math.floor(Math.abs(number));
	},
	ToInt32: function ToInt32(x) {
		return this.ToNumber(x) >> 0;
	},
	ToUint32: function ToUint32(x) {
		return this.ToNumber(x) >>> 0;
	},
	ToUint16: function ToUint16(value) {
		var number = this.ToNumber(value);
		if ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }
		var posInt = sign(number) * Math.floor(Math.abs(number));
		return mod(posInt, 0x10000);
	},
	ToString: function ToString(value) {
		return String(value);
	},
	ToObject: function ToObject(value) {
		this.CheckObjectCoercible(value);
		return Object(value);
	},
	CheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {
		/* jshint eqnull:true */
		if (value == null) {
			throw new TypeError(optMessage || 'Cannot call method on ' + value);
		}
		return value;
	},
	IsCallable: IsCallable,
	SameValue: function SameValue(x, y) {
		if (x === y) { // 0 === -0, but they are not identical.
			if (x === 0) { return 1 / x === 1 / y; }
			return true;
		}
		return $isNaN(x) && $isNaN(y);
	},

	// http://www.ecma-international.org/ecma-262/5.1/#sec-8
	Type: function Type(x) {
		if (x === null) {
			return 'Null';
		}
		if (typeof x === 'undefined') {
			return 'Undefined';
		}
		if (typeof x === 'function' || typeof x === 'object') {
			return 'Object';
		}
		if (typeof x === 'number') {
			return 'Number';
		}
		if (typeof x === 'boolean') {
			return 'Boolean';
		}
		if (typeof x === 'string') {
			return 'String';
		}
	}
};

module.exports = ES5;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toStr = Object.prototype.toString;

var isPrimitive = __webpack_require__(13);

var isCallable = __webpack_require__(1);

// https://es5.github.io/#x8.12
var ES5internalSlots = {
	'[[DefaultValue]]': function (O, hint) {
		var actualHint = hint || (toStr.call(O) === '[object Date]' ? String : Number);

		if (actualHint === String || actualHint === Number) {
			var methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];
			var value, i;
			for (i = 0; i < methods.length; ++i) {
				if (isCallable(O[methods[i]])) {
					value = O[methods[i]]();
					if (isPrimitive(value)) {
						return value;
					}
				}
			}
			throw new TypeError('No default value');
		}
		throw new TypeError('invalid [[DefaultValue]] hint supplied');
	}
};

// https://es5.github.io/#x9
module.exports = function ToPrimitive(input, PreferredType) {
	if (isPrimitive(input)) {
		return input;
	}
	return ES5internalSlots['[[DefaultValue]]'](input, PreferredType);
};


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = __webpack_require__(14);
var regexExec = RegExp.prototype.exec;
var gOPD = Object.getOwnPropertyDescriptor;

var tryRegexExecCall = function tryRegexExec(value) {
	try {
		var lastIndex = value.lastIndex;
		value.lastIndex = 0;

		regexExec.call(value);
		return true;
	} catch (e) {
		return false;
	} finally {
		value.lastIndex = lastIndex;
	}
};
var toStr = Object.prototype.toString;
var regexClass = '[object RegExp]';
var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';

module.exports = function isRegex(value) {
	if (!value || typeof value !== 'object') {
		return false;
	}
	if (!hasToStringTag) {
		return toStr.call(value) === regexClass;
	}

	var descriptor = gOPD(value, 'lastIndex');
	var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
	if (!hasLastIndexDataProperty) {
		return false;
	}

	return tryRegexExecCall(value);
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var getPolyfill = __webpack_require__(15);
var define = __webpack_require__(6);

module.exports = function shimEntries() {
	var polyfill = getPolyfill();
	define(Object, { entries: polyfill }, {
		entries: function testEntries() {
			return Object.entries !== polyfill;
		}
	});
	return polyfill;
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var config_1 = __webpack_require__(0);
var common_1 = __webpack_require__(3);
/**
 * Calculate the column widths
 */
function calculateWidths(doc, pageWidth) {
    var table = config_1.Config.tableInstance();
    // Column and table content width
    var fixedWidth = 0;
    var autoWidth = 0;
    var dynamicColumns = [];
    table.columns.forEach(function (column) {
        column.contentWidth = 0;
        table.rows.concat(table.headerRow).forEach(function (row) {
            var cell = row.cells[column.dataKey];
            cell.contentWidth = cell.padding('horizontal') + common_1.getStringWidth(cell.text, cell.styles);
            if (cell.contentWidth > column.contentWidth) {
                column.contentWidth = cell.contentWidth;
            }
        });
        table.contentWidth += column.contentWidth;
        if (typeof column.widthStyle === 'number') {
            column.preferredWidth = column.widthStyle;
            fixedWidth += column.preferredWidth;
            column.width = column.preferredWidth;
        }
        else if (column.widthStyle === 'wrap') {
            column.preferredWidth = column.contentWidth;
            fixedWidth += column.preferredWidth;
            column.width = column.preferredWidth;
        }
        else {
            column.preferredWidth = column.contentWidth;
            autoWidth += column.contentWidth;
            dynamicColumns.push(column);
        }
        table.preferredWidth += column.preferredWidth;
    });
    if (typeof table.settings.tableWidth === 'number') {
        table.width = table.settings.tableWidth;
    }
    else if (table.settings.tableWidth === 'wrap') {
        table.width = table.preferredWidth;
    }
    else {
        table.width = pageWidth - table.margin('left') - table.margin('right');
    }
    distributeWidth(dynamicColumns, fixedWidth, autoWidth, 0);
    // Row height, table height and text overflow
    var all = table.rows.concat(table.headerRow);
    all.forEach(function (row) {
        table.columns.forEach(function (col) {
            var cell = row.cells[col.dataKey];
            config_1.Config.applyStyles(cell.styles);
            var textSpace = col.width - cell.padding('horizontal');
            var k = config_1.Config.scaleFactor();
            if (cell.styles.overflow === 'linebreak') {
                // Add one pt to textSpace to fix rounding error
                try {
                    cell.text = doc.splitTextToSize(cell.text, textSpace + 1 / k, { fontSize: cell.styles.fontSize });
                }
                catch (e) {
                    if (e instanceof TypeError && Array.isArray(cell.text)) {
                        cell.text = doc.splitTextToSize(cell.text.join(' '), textSpace + 1 / k, { fontSize: cell.styles.fontSize });
                    }
                    else {
                        throw e;
                    }
                }
            }
            else if (cell.styles.overflow === 'ellipsize') {
                cell.text = common_1.ellipsize(cell.text, textSpace, cell.styles);
            }
            else if (cell.styles.overflow === 'visible') {
                // Do nothing
            }
            else if (cell.styles.overflow === 'hidden') {
                cell.text = common_1.ellipsize(cell.text, textSpace, cell.styles, '');
            }
            else if (typeof cell.styles.overflow === 'function') {
                cell.text = cell.styles.overflow(cell.text, textSpace);
            }
            else {
                console.error("Unrecognized overflow type: " + cell.styles.overflow);
            }
            var lineCount = Array.isArray(cell.text) ? cell.text.length : 1;
            var fontHeight = cell.styles.fontSize / k * config_1.FONT_ROW_RATIO;
            cell.contentHeight = lineCount * fontHeight + cell.padding('vertical');
            if (cell.contentHeight > row.height) {
                row.height = cell.contentHeight;
                row.maxLineCount = lineCount;
            }
        });
        table.height += row.height;
    });
}
exports.calculateWidths = calculateWidths;
function distributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth) {
    var table = config_1.Config.tableInstance();
    var extraWidth = table.width - staticWidth - dynamicColumnsContentWidth;
    for (var i = 0; i < dynamicColumns.length; i++) {
        var col = dynamicColumns[i];
        var ratio = col.contentWidth / dynamicColumnsContentWidth;
        // A column turned out to be none dynamic, start over recursively
        var isNoneDynamic = col.contentWidth + extraWidth * ratio < fairWidth;
        if (extraWidth < 0 && isNoneDynamic) {
            dynamicColumns.splice(i, 1);
            dynamicColumnsContentWidth -= col.contentWidth;
            col.width = fairWidth;
            staticWidth += col.width;
            distributeWidth(dynamicColumns, staticWidth, dynamicColumnsContentWidth, fairWidth);
            break;
        }
        else {
            col.width = col.contentWidth + extraWidth * ratio;
        }
    }
}


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

exports.__esModule = true;
var models_1 = __webpack_require__(4);
var config_1 = __webpack_require__(0);
var assign = __webpack_require__(5);
function validateInput(headers, data, allOptions) {
    if (!headers || typeof headers !== 'object') {
        console.error("The headers should be an object or array, is: " + typeof headers);
    }
    if (!data || typeof data !== 'object') {
        console.error("The data should be an object or array, is: " + typeof data);
    }
    var _loop_1 = function (settings) {
        if (settings && typeof settings !== 'object') {
            console.error("The options parameter should be of type object, is: " + typeof settings);
        }
        if (typeof settings.extendWidth !== 'undefined') {
            settings.tableWidth = settings.extendWidth ? 'auto' : 'wrap';
            console.error("Use of deprecated option: extendWidth, use tableWidth instead.");
        }
        if (typeof settings.margins !== 'undefined') {
            if (typeof settings.margin === 'undefined')
                settings.margin = settings.margins;
            console.error("Use of deprecated option: margins, use margin instead.");
        }
        if (typeof settings.afterPageContent !== 'undefined' || typeof settings.beforePageContent !== 'undefined' || typeof settings.afterPageAdd !== 'undefined') {
            console.error("The afterPageContent, beforePageContent and afterPageAdd hooks are deprecated. Use addPageContent instead");
            if (typeof settings.addPageContent === 'undefined') {
                settings.addPageContent = function (data) {
                    config_1.Config.applyUserStyles();
                    if (settings.beforePageContent)
                        settings.beforePageContent(data);
                    config_1.Config.applyUserStyles();
                    if (settings.afterPageContent)
                        settings.afterPageContent(data);
                    config_1.Config.applyUserStyles();
                    if (settings.afterPageAdd && data.pageCount > 1) {
                        data.afterPageAdd(data);
                    }
                    config_1.Config.applyUserStyles();
                };
            }
        }
        [['padding', 'cellPadding'], ['lineHeight', 'rowHeight'], 'fontSize', 'overflow'].forEach(function (o) {
            var deprecatedOption = typeof o === 'string' ? o : o[0];
            var style = typeof o === 'string' ? o : o[1];
            if (typeof settings[deprecatedOption] !== 'undefined') {
                if (typeof settings.styles[style] === 'undefined') {
                    settings.styles[style] = settings[deprecatedOption];
                }
                console.error("Use of deprecated option: " + deprecatedOption + ", use the style " + style + " instead.");
            }
        });
        for (var _i = 0, _a = ['styles', 'bodyStyles', 'headerStyles', 'columnStyles']; _i < _a.length; _i++) {
            var styleProp = _a[_i];
            if (settings[styleProp] && typeof settings[styleProp] !== 'object') {
                console.error("The " + styleProp + " style should be of type object, is: " + typeof settings[styleProp]);
            }
            else if (settings[styleProp] && settings[styleProp].rowHeight) {
                console.error("Use of deprecated style: rowHeight, use vertical cell padding instead");
            }
        }
    };
    for (var _i = 0, allOptions_1 = allOptions; _i < allOptions_1.length; _i++) {
        var settings = allOptions_1[_i];
        _loop_1(settings);
    }
}
exports.validateInput = validateInput;
/**
 * Create models from the user input
 *
 * @param inputHeaders
 * @param inputData
 */
function createModels(inputHeaders, inputData) {
    var splitRegex = /\r\n|\r|\n/g;
    var table = config_1.Config.tableInstance();
    var settings = table.settings;
    var theme = config_1.getTheme(settings.theme);
    // Header row and columns
    var headerRow = new models_1.Row(inputHeaders, -1);
    headerRow.index = -1;
    // Columns and header row
    inputHeaders.forEach(function (rawColumn, index) {
        var dataKey = index;
        if (typeof rawColumn.dataKey !== 'undefined') {
            dataKey = rawColumn.dataKey;
        }
        else if (typeof rawColumn.key !== 'undefined') {
            console.error("Deprecation warning: Use dataKey instead of key");
            dataKey = rawColumn.key; // deprecated since 2.x
        }
        var col = new models_1.Column(dataKey, index);
        col.raw = rawColumn;
        col.widthStyle = config_1.Config.styles([theme.table, theme.header, table.styles.styles, table.styles.columnStyles[col.dataKey] || {}]).columnWidth;
        table.columns.push(col);
        var cell = new models_1.Cell(rawColumn);
        cell.styles = config_1.Config.styles([theme.table, theme.header, table.styles.styles, table.styles.headerStyles]);
        if (cell.raw instanceof HTMLElement) {
            cell.text = (cell.raw.innerText || '').trim();
        }
        else {
            var text = typeof cell.raw === 'object' ? cell.raw.title : cell.raw;
            // Stringify 0 and false, but not undefined
            cell.text = typeof cell.raw !== 'undefined' ? '' + text : '';
        }
        cell.text = cell.text.split(splitRegex);
        headerRow.cells[dataKey] = cell;
        for (var _i = 0, _a = table.hooks.createdHeaderCell; _i < _a.length; _i++) {
            var hook = _a[_i];
            hook(cell, { cell: cell, column: col, row: headerRow, settings: settings });
        }
    });
    table.headerRow = headerRow;
    // Rows och cells
    inputData.forEach(function (rawRow, i) {
        var row = new models_1.Row(rawRow, i);
        var rowStyles = i % 2 === 0 ? assign({}, theme.alternateRow, table.styles.alternateRowStyles) : {};
        table.columns.forEach(function (column) {
            var cell = new models_1.Cell(rawRow[column.dataKey]);
            var colStyles = table.styles.columnStyles[column.dataKey] || {};
            cell.styles = config_1.Config.styles([theme.table, theme.body, table.styles.styles, table.styles.bodyStyles, rowStyles, colStyles]);
            if (cell.raw && cell.raw instanceof HTMLElement) {
                cell.text = (cell.raw.innerText || '').trim();
            }
            else {
                // Stringify 0 and false, but not undefined
                cell.text = typeof cell.raw !== 'undefined' ? '' + cell.raw : '';
            }
            cell.text = cell.text.split(splitRegex);
            row.cells[column.dataKey] = cell;
            for (var _i = 0, _a = table.hooks.createdCell; _i < _a.length; _i++) {
                var hook = _a[_i];
                hook(cell, config_1.Config.hooksData({ cell: cell, column: column, row: row }));
            }
        });
        table.rows.push(row);
    });
}
exports.createModels = createModels;


/***/ })
/******/ ]);
});
//------------------------------- End of Autotable.js library -----------------------------

